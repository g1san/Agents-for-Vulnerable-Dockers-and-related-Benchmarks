import os
import time
from flask import Flask, request, render_template_string, g
import psycopg2
from psycopg2 import OperationalError

app = Flask(__name__)

DB_CONFIG = {
    "host": os.getenv('POSTGRES_HOST', 'db'),
    "database": os.getenv('POSTGRES_DB', 'testdb'),
    "user": os.getenv('POSTGRES_USER', 'testuser'),
    "password": os.getenv('POSTGRES_PASSWORD', 'testpass')
}

def get_db_connection():
    """Return a fresh PostgreSQL connection, retrying a few times if the DB is not ready."""
    attempts = 0
    while attempts < 5:
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            return conn
        except OperationalError:
            attempts += 1
            time.sleep(2)
    # If all retries fail, raise the last exception
    raise OperationalError("Unable to connect to PostgreSQL after multiple attempts")

@app.before_request
def before_request():
    # Attach a connection to the Flask global for the request lifecycle
    g.db_conn = get_db_connection()

@app.teardown_request
def teardown_request(exception):
    conn = getattr(g, 'db_conn', None)
    if conn is not None:
        conn.close()

@app.route('/')
def index():
    q = request.args.get('q', '')
    # Safe rendering: the variable is escaped by default in render_template_string
    tmpl = "<h1>Search results for: {{ q }}</h1>"
    return render_template_string(tmpl, q=q)

@app.route('/users')
def users():
    cur = g.db_conn.cursor()
    cur.execute('SELECT id, username FROM users')
    rows = cur.fetchall()
    cur.close()
    return {'users': [{"id": r[0], "username": r[1]} for r in rows]}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)