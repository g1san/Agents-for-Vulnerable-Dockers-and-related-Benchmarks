import os
import socket
from flask import Flask, request, jsonify
import psycopg2

app = Flask(__name__)

def get_db_connection():
    return psycopg2.connect(
        host=os.getenv('POSTGRES_HOST', 'postgres'),
        user=os.getenv('POSTGRES_USER', 'gitlab'),
        password=os.getenv('POSTGRES_PASSWORD', 'gitlab_pass'),
        dbname=os.getenv('POSTGRES_DB', 'gitlabhq_production')
    )

@app.route('/')
def index():
    return 'Vulnerable Flask App - CVE-2016-9086 demonstration'

# Endpoint that illustrates the Docker socket exposure (CVE-2016-9086)
# An attacker can POST a JSON with a "cmd" field that will be executed on the host via the Docker socket.
@app.route('/run', methods=['POST'])
def run_cmd():
    data = request.get_json(force=True)
    cmd = data.get('cmd')
    if not cmd:
        return jsonify({'error': 'No command provided'}), 400
    try:
        payload = f"{{\"Image\":\"alpine:latest\",\"Cmd\":[\"sh\",\"-c\",\"{cmd}\"]}}"
        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        client.connect('/var/run/docker.sock')
        request_line = (
            f'POST /containers/create?name=vuln_test HTTP/1.1\r\n'
            f'Host: localhost\r\n'
            f'Content-Type: application/json\r\n'
            f'Content-Length: {len(payload)}\r\n\r\n{payload}'
        )
        client.sendall(request_line.encode())
        response = client.recv(4096)
        client.close()
        return jsonify({'docker_response': response.decode()})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/data')
def get_data():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM users')
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
    columns = ['id', 'username', 'email']
    result = [dict(zip(columns, row)) for row in rows]
    return jsonify(result)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
