{
  "version": "15.0.6",
  "vulnerabilities": [
    {
      "id": "a2dbe763669d4317067e6d95d0e2eb743faed28e08fe0162495139218fbdde71",
      "category": "container_scanning",
      "message": "CVE-2023-53052 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cifs: fix use-after-free bug in refresh_cache_worker()  The UAF bug occurred because we were putting DFS root sessions in cifs_umount() while DFS cache refresher was being executed.  Make DFS root sessions have same lifetime as DFS tcons so we can avoid the use-after-free bug is DFS cache refresher and other places that require IPCs to get new DFS referrals on.  Also, get rid of mount group handling in DFS cache as we no longer need it.  This fixes below use-after-free bug catched by KASAN  [ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56 [ 379.948096] [ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23 [ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014 [ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs] [ 379.949942] Call Trace: [ 379.950113] <TASK> [ 379.950260] dump_stack_lvl+0x50/0x67 [ 379.950510] print_report+0x16a/0x48e [ 379.950759] ? __virt_addr_valid+0xd8/0x160 [ 379.951040] ? __phys_addr+0x41/0x80 [ 379.951285] kasan_report+0xdb/0x110 [ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs] [ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs] [ 379.953637] ? __pfx___mutex_lock+0x10/0x10 [ 379.953915] ? lock_release+0xb6/0x720 [ 379.954167] ? __pfx_lock_acquire+0x10/0x10 [ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs] [ 379.954960] ? __pfx_wb_workfn+0x10/0x10 [ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs] [ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs] [ 379.956323] ? __pfx_lock_acquired+0x10/0x10 [ 379.956615] ? read_word_at_a_time+0xe/0x20 [ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220 [ 379.957235] process_one_work+0x535/0x990 [ 379.957509] ? __pfx_process_one_work+0x10/0x10 [ 379.957812] ? lock_acquired+0xb7/0x5f0 [ 379.958069] ? __list_add_valid+0x37/0xd0 [ 379.958341] ? __list_add_valid+0x37/0xd0 [ 379.958611] worker_thread+0x8e/0x630 [ 379.958861] ? __pfx_worker_thread+0x10/0x10 [ 379.959148] kthread+0x17d/0x1b0 [ 379.959369] ? __pfx_kthread+0x10/0x10 [ 379.959630] ret_from_fork+0x2c/0x50 [ 379.959879] </TASK>",
      "cve": "CVE-2023-53052",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53052",
          "value": "CVE-2023-53052",
          "url": "https://scout.docker.com/v/CVE-2023-53052?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53052?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "185ffe85b358c3bdfc954678b9194888a63f66040e0113682cf23ee4015eaa83",
      "category": "container_scanning",
      "message": "CVE-2024-2236 on ubuntu/libgcrypt20@1.9.4-3ubuntu3",
      "description": "A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.",
      "cve": "CVE-2024-2236",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libgcrypt20@1.9.4-3ubuntu3?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.9.4-3ubuntu3"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-2236",
          "value": "CVE-2024-2236",
          "url": "https://scout.docker.com/v/CVE-2024-2236?s=ubuntu&n=libgcrypt20&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-2236?s=ubuntu&n=libgcrypt20&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "84c1ff582039d28dfcee3412bd25154a830effe6ff22451ec6f3164641a20d9f",
      "category": "container_scanning",
      "message": "CVE-2024-41996 on ubuntu/openssl@3.0.2-0ubuntu1.20",
      "description": "Validating the order of the public keys in the Diffie-Hellman Key Agreement Protocol, when an approved safe prime is used, allows remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations. The client may cause asymmetric resource consumption. The basic attack scenario is that the client must claim that it can only communicate with DHE, and the server must be configured to allow DHE and validate the order of the public key.",
      "cve": "CVE-2024-41996",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openssl@3.0.2-0ubuntu1.20?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.0.2-0ubuntu1.20"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41996",
          "value": "CVE-2024-41996",
          "url": "https://scout.docker.com/v/CVE-2024-41996?s=ubuntu&n=openssl&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41996?s=ubuntu&n=openssl&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6db286f66d34f89d62fd713daea7e23d1f95e68fc09b645d26b42a85ad096988",
      "category": "container_scanning",
      "message": "CVE-2024-52615 on ubuntu/avahi@0.8-5ubuntu5.2",
      "description": "A flaw was found in Avahi-daemon, which relies on fixed source ports for wide-area DNS queries. This issue simplifies attacks where malicious DNS responses are injected.",
      "cve": "CVE-2024-52615",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/avahi@0.8-5ubuntu5.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "0.8-5ubuntu5.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-52615",
          "value": "CVE-2024-52615",
          "url": "https://scout.docker.com/v/CVE-2024-52615?s=ubuntu&n=avahi&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-52615?s=ubuntu&n=avahi&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "29a331d92ea35e29eb6e8deab163ae552cebccd9c4f376c3a879a5c4196dc369",
      "category": "container_scanning",
      "message": "CVE-2024-52616 on ubuntu/avahi@0.8-5ubuntu5.2",
      "description": "A flaw was found in the Avahi-daemon, where it initializes DNS transaction IDs randomly only once at startup, incrementing them sequentially after that. This predictable behavior facilitates DNS spoofing attacks, allowing attackers to guess transaction IDs.",
      "cve": "CVE-2024-52616",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/avahi@0.8-5ubuntu5.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "0.8-5ubuntu5.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-52616",
          "value": "CVE-2024-52616",
          "url": "https://scout.docker.com/v/CVE-2024-52616?s=ubuntu&n=avahi&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-52616?s=ubuntu&n=avahi&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "464f3eaca14ee734e26bcc2396b2630f52f38ad6fe1a7f0ed77e82f8ba8194ae",
      "category": "container_scanning",
      "message": "CVE-2024-53218 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix race in concurrent f2fs_stop_gc_thread  In my test case, concurrent calls to f2fs shutdown report the following stack trace:  Oops: general protection fault, probably for non-canonical address 0xc6cfff63bb5513fc: 0000 [#1] PREEMPT SMP PTI CPU: 0 UID: 0 PID: 678 Comm: f2fs_rep_shutdo Not tainted 6.12.0-rc5-next-20241029-g6fb2fa9805c5-dirty #85 Call Trace: <TASK> ? show_regs+0x8b/0xa0 ? __die_body+0x26/0xa0 ? die_addr+0x54/0x90 ? exc_general_protection+0x24b/0x5c0 ? asm_exc_general_protection+0x26/0x30 ? kthread_stop+0x46/0x390 f2fs_stop_gc_thread+0x6c/0x110 f2fs_do_shutdown+0x309/0x3a0 f2fs_ioc_shutdown+0x150/0x1c0 __f2fs_ioctl+0xffd/0x2ac0 f2fs_ioctl+0x76/0xe0 vfs_ioctl+0x23/0x60 __x64_sys_ioctl+0xce/0xf0 x64_sys_call+0x2b1b/0x4540 do_syscall_64+0xa7/0x240 entry_SYSCALL_64_after_hwframe+0x76/0x7e  The root cause is a race condition in f2fs_stop_gc_thread() called from different f2fs shutdown paths:  [CPU0]                       [CPU1] ----------------------       ----------------------- f2fs_stop_gc_thread          f2fs_stop_gc_thread gc_th = sbi->gc_thread gc_th = sbi->gc_thread kfree(gc_th) sbi->gc_thread = NULL < gc_th != NULL > kthread_stop(gc_th->f2fs_gc_task) //UAF  The commit c7f114d864ac (\"f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()\") attempted to fix this issue by using a read semaphore to prevent races between shutdown and remount threads, but it fails to prevent all race conditions.  Fix it by converting to write lock of s_umount in f2fs_do_shutdown().",
      "cve": "CVE-2024-53218",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53218",
          "value": "CVE-2024-53218",
          "url": "https://scout.docker.com/v/CVE-2024-53218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0486fa0000b7ad22b6f306e7966083206d44736a99a57330ee6deefb5be00fc7",
      "category": "container_scanning",
      "message": "CVE-2024-56433 on ubuntu/shadow@1:4.8.1-2ubuntu2.2",
      "description": "shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g., uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks, potentially leading to account takeover, e.g., by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids, within local networks, that are within the range that can occur in /etc/subuid.",
      "cve": "CVE-2024-56433",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/shadow@1%3A4.8.1-2ubuntu2.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1:4.8.1-2ubuntu2.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56433",
          "value": "CVE-2024-56433",
          "url": "https://scout.docker.com/v/CVE-2024-56433?s=ubuntu&n=shadow&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56433?s=ubuntu&n=shadow&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "792cfda1402abe337b1b14977c722e838a41bd8f34db20274f50e64e97ac36db",
      "category": "container_scanning",
      "message": "CVE-2024-58237 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: consider that tail calls invalidate packet pointers  Tail-called programs could execute any of the helpers that invalidate packet pointers. Hence, conservatively assume that each tail call invalidates packet pointers.  Making the change in bpf_helper_changes_pkt_data() automatically makes use of check_cfg() logic that computes 'changes_pkt_data' effect for global sub-programs, such that the following program could be rejected:  int tail_call(struct __sk_buff *sk) { bpf_tail_call_static(sk, &jmp_table, 0); return 0; }  SEC(\"tc\") int not_safe(struct __sk_buff *sk) { int *p = (void *)(long)sk->data; ... make p valid ... tail_call(sk); *p = 42; /* this is unsafe */ ... }  The tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function that can invalidate packet pointers. Otherwise, it can't be freplaced with tailcall_freplace.c:entry_freplace() that does a tail call.",
      "cve": "CVE-2024-58237",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58237",
          "value": "CVE-2024-58237",
          "url": "https://scout.docker.com/v/CVE-2024-58237?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58237?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ad18edad8f8e87439ad449b9a3049360419063a905a45f1d7c5526cfcb13f446",
      "category": "container_scanning",
      "message": "CVE-2025-21714 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/mlx5: Fix implicit ODP use after free  Prevent double queueing of implicit ODP mr destroy work by using __xa_cmpxchg() to make sure this is the only time we are destroying this specific mr.  Without this change, we could try to invalidate this mr twice, which in turn could result in queuing a MR work destroy twice, and eventually the second work could execute after the MR was freed due to the first work, causing a user after free and trace below.  refcount_t: underflow; use-after-free. WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130 Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs] CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib] RIP: 0010:refcount_warn_saturate+0x12b/0x130 Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027 RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0 RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019 R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00 R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0 FS:  0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? refcount_warn_saturate+0x12b/0x130 free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib] process_one_work+0x1cc/0x3c0 worker_thread+0x218/0x3c0 kthread+0xc6/0xf0 ret_from_fork+0x1f/0x30 </TASK>",
      "cve": "CVE-2025-21714",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21714",
          "value": "CVE-2025-21714",
          "url": "https://scout.docker.com/v/CVE-2025-21714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d13dc8897d8ddf8750318e7b1f5870a2339745b5f06530ec75be20d7140dcc92",
      "category": "container_scanning",
      "message": "CVE-2025-5222 on ubuntu/icu@70.1-2",
      "description": "A stack buffer overflow was found in Internationl components for unicode (ICU ). While running the genrb binary, the 'subtag' struct overflowed at the SRBRoot::addTag function. This issue may lead to memory corruption and local arbitrary code execution.",
      "cve": "CVE-2025-5222",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/icu@70.1-2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "70.1-2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-5222",
          "value": "CVE-2025-5222",
          "url": "https://scout.docker.com/v/CVE-2025-5222?s=ubuntu&n=icu&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-5222?s=ubuntu&n=icu&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9594ac0e3933909c2b09e891991af9dbdb09af9c22cce1754856341180f49d64",
      "category": "container_scanning",
      "message": "CVE-2022-3219 on ubuntu/gnupg2@2.2.27-3ubuntu2.4",
      "description": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
      "cve": "CVE-2022-3219",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/gnupg2@2.2.27-3ubuntu2.4?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.2.27-3ubuntu2.4"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-3219",
          "value": "CVE-2022-3219",
          "url": "https://scout.docker.com/v/CVE-2022-3219?s=ubuntu&n=gnupg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-3219?s=ubuntu&n=gnupg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4015dc2c99095e1624427f56011b1b677e1771b4eda91eb6af65263eae453935",
      "category": "container_scanning",
      "message": "CVE-2023-29383 on ubuntu/shadow@1:4.8.1-2ubuntu2.2",
      "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
      "cve": "CVE-2023-29383",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/shadow@1%3A4.8.1-2ubuntu2.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1:4.8.1-2ubuntu2.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-29383",
          "value": "CVE-2023-29383",
          "url": "https://scout.docker.com/v/CVE-2023-29383?s=ubuntu&n=shadow&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-29383?s=ubuntu&n=shadow&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3b5bcbef9728e894340ae4b6fabd5e449333abd394a3da3ecf93273ab0b3516",
      "category": "container_scanning",
      "message": "CVE-2020-35501 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem",
      "cve": "CVE-2020-35501",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2020-35501",
          "value": "CVE-2020-35501",
          "url": "https://scout.docker.com/v/CVE-2020-35501?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2020-35501?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "045f7e55caa2fd61f2ea83fda5ff1b5f90d624266b60feefbfe8bfd0ab369a4e",
      "category": "container_scanning",
      "message": "CVE-2021-39212 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
      "cve": "CVE-2021-39212",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-39212",
          "value": "CVE-2021-39212",
          "url": "https://scout.docker.com/v/CVE-2021-39212?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-39212?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ed8ae7cf86cce7273aac2c552505fe1d883e6c993f02d1e3ca605d4d9fa41765",
      "category": "container_scanning",
      "message": "CVE-2022-41848 on ubuntu/linux@5.15.0-161.171",
      "description": "drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",
      "cve": "CVE-2022-41848",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-41848",
          "value": "CVE-2022-41848",
          "url": "https://scout.docker.com/v/CVE-2022-41848?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-41848?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2e6b1c0eb50c743263d54697c8040e1c685112f931f19e3dd5bf2148eab3cbba",
      "category": "container_scanning",
      "message": "CVE-2020-14304 on ubuntu/linux@5.15.0-161.171",
      "description": "A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.",
      "cve": "CVE-2020-14304",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2020-14304",
          "value": "CVE-2020-14304",
          "url": "https://scout.docker.com/v/CVE-2020-14304?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2020-14304?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "adc2035bd268a5e50520d1a60a3a610b53649690ae49888a70d35b6030b464bc",
      "category": "container_scanning",
      "message": "CVE-2019-15213 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.",
      "cve": "CVE-2019-15213",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-15213",
          "value": "CVE-2019-15213",
          "url": "https://scout.docker.com/v/CVE-2019-15213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-15213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1cbfba793a0ac97b0ea08ead2442fc2c2f2d34ac276f67fed76f1f8117060be7",
      "category": "container_scanning",
      "message": "CVE-2023-4010 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.",
      "cve": "CVE-2023-4010",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-4010",
          "value": "CVE-2023-4010",
          "url": "https://scout.docker.com/v/CVE-2023-4010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-4010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1650cf83aa4e61cc703db206f591b7f8a4bde3aee0732f34c9b67ee776b33b97",
      "category": "container_scanning",
      "message": "CVE-2017-0537 on ubuntu/linux@5.15.0-161.171",
      "description": "An information disclosure vulnerability in the kernel USB gadget driver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.18. Android ID: A-31614969.",
      "cve": "CVE-2017-0537",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-0537",
          "value": "CVE-2017-0537",
          "url": "https://scout.docker.com/v/CVE-2017-0537?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-0537?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ee900822c2e9efe0ce97b3cb62758b8e6ecd539ebd8305ef9374f43e236e5840",
      "category": "container_scanning",
      "message": "CVE-2023-52749 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: Fix null dereference on suspend  A race condition exists where a synchronous (noqueue) transfer can be active during a system suspend. This can cause a null pointer dereference exception to occur when the system resumes.  Example order of events leading to the exception: 1. spi_sync() calls __spi_transfer_message_noqueue() which sets ctlr->cur_msg 2. Spi transfer begins via spi_transfer_one_message() 3. System is suspended interrupting the transfer context 4. System is resumed 6. spi_controller_resume() calls spi_start_queue() which resets cur_msg to NULL 7. Spi transfer context resumes and spi_finalize_current_message() is called which dereferences cur_msg (which is now NULL)  Wait for synchronous transfers to complete before suspending by acquiring the bus mutex and setting/checking a suspend flag.",
      "cve": "CVE-2023-52749",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52749",
          "value": "CVE-2023-52749",
          "url": "https://scout.docker.com/v/CVE-2023-52749?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52749?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6ba44e8cff2ee98601284c58866abbcf35ce9f5246f4c8e97e167bb67c507b87",
      "category": "container_scanning",
      "message": "CVE-2024-50183 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Ensure DA_ID handling completion before deleting an NPIV instance  Deleting an NPIV instance requires all fabric ndlps to be released before an NPIV's resources can be torn down.  Failure to release fabric ndlps beforehand opens kref imbalance race conditions.  Fix by forcing the DA_ID to complete synchronously with usage of wait_queue.",
      "cve": "CVE-2024-50183",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50183",
          "value": "CVE-2024-50183",
          "url": "https://scout.docker.com/v/CVE-2024-50183?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50183?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9767a1a60c626a7dd9bee2309d7783814ae002ef3461b7f62cd4c9e5accce830",
      "category": "container_scanning",
      "message": "CVE-2017-13693 on ubuntu/linux@5.15.0-161.171",
      "description": "The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
      "cve": "CVE-2017-13693",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-13693",
          "value": "CVE-2017-13693",
          "url": "https://scout.docker.com/v/CVE-2017-13693?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-13693?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4e5daadb1420c1c3f87552ca4e87ce8099b8c45ffd08af178db384c966bee6c7",
      "category": "container_scanning",
      "message": "CVE-2017-13716 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
      "cve": "CVE-2017-13716",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-13716",
          "value": "CVE-2017-13716",
          "url": "https://scout.docker.com/v/CVE-2017-13716?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-13716?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c2d286aad971ad034c5ab53673948eeb4918a9c7498b0bb9c8385ed2f865e98f",
      "category": "container_scanning",
      "message": "CVE-2017-7475 on ubuntu/cairo@1.16.0-5ubuntu2",
      "description": "Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.",
      "cve": "CVE-2017-7475",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/cairo@1.16.0-5ubuntu2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.16.0-5ubuntu2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-7475",
          "value": "CVE-2017-7475",
          "url": "https://scout.docker.com/v/CVE-2017-7475?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-7475?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2cf6410e72301e6a94dad20ef400b1f2fba12a507067fa539bd09f6c00a57cad",
      "category": "container_scanning",
      "message": "CVE-2018-12928 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.",
      "cve": "CVE-2018-12928",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-12928",
          "value": "CVE-2018-12928",
          "url": "https://scout.docker.com/v/CVE-2018-12928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-12928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "22a2295b0f70b45636bc560755692855ab5180badc52b2a752fe2ce24c6e1845",
      "category": "container_scanning",
      "message": "CVE-2018-12929 on ubuntu/linux@5.15.0-161.171",
      "description": "ntfs_read_locked_inode in the ntfs.ko filesystem driver in the Linux kernel 4.15.0 allows attackers to trigger a use-after-free read and possibly cause a denial of service (kernel oops or panic) via a crafted ntfs filesystem.",
      "cve": "CVE-2018-12929",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-12929",
          "value": "CVE-2018-12929",
          "url": "https://scout.docker.com/v/CVE-2018-12929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-12929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1c0da7bc7c9abc62767b9089f2313fe703985c6126ff290704d0bf5762aabfd8",
      "category": "container_scanning",
      "message": "CVE-2019-1010204 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
      "cve": "CVE-2019-1010204",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-1010204",
          "value": "CVE-2019-1010204",
          "url": "https://scout.docker.com/v/CVE-2019-1010204?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-1010204?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bcb58188740debcef466237dabf10290cee5f0414bbe1231634f277b065ee9de",
      "category": "container_scanning",
      "message": "CVE-2021-20241 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in coders/jp2.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20241",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20241",
          "value": "CVE-2021-20241",
          "url": "https://scout.docker.com/v/CVE-2021-20241?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20241?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9b6f767291bfb0572ce3f7b5c271072d731a4e83384dd428b4f2a7584b67bcbc",
      "category": "container_scanning",
      "message": "CVE-2021-20243 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in MagickCore/resize.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20243",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20243",
          "value": "CVE-2021-20243",
          "url": "https://scout.docker.com/v/CVE-2021-20243?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20243?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d1124c64233e5d2a55cb494abcca406d32e2666b2eca8f2772e55817a3ca36b8",
      "category": "container_scanning",
      "message": "CVE-2021-20244 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in MagickCore/visual-effects.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20244",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20244",
          "value": "CVE-2021-20244",
          "url": "https://scout.docker.com/v/CVE-2021-20244?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20244?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "915e9736c3f1ad2bf325ce7a6f8340f5444849f32ab1f7bdad283e170398b3b1",
      "category": "container_scanning",
      "message": "CVE-2021-20245 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in coders/webp.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20245",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20245",
          "value": "CVE-2021-20245",
          "url": "https://scout.docker.com/v/CVE-2021-20245?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20245?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a0eafa08a7010529741dda95d9146f046b815731b49bdcf2378d1df1238bcfe1",
      "category": "container_scanning",
      "message": "CVE-2021-20246 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in MagickCore/resample.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20246",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20246",
          "value": "CVE-2021-20246",
          "url": "https://scout.docker.com/v/CVE-2021-20246?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20246?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7ddc510010393a9793730b251524109dbe79c51d4e879ffa77234f957cc2241c",
      "category": "container_scanning",
      "message": "CVE-2021-4219 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick. The vulnerability occurs due to improper use of open functions and leads to a denial of service. This flaw allows an attacker to crash the system.",
      "cve": "CVE-2021-4219",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-4219",
          "value": "CVE-2021-4219",
          "url": "https://scout.docker.com/v/CVE-2021-4219?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-4219?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6564a02e76c1e29800548fcf2c6778b5cf7143cc16379312889cea64594e1748",
      "category": "container_scanning",
      "message": "CVE-2021-45261 on ubuntu/patch@2.7.6-7build2",
      "description": "An Invalid Pointer vulnerability exists in GNU patch 2.7 via the another_hunk function, which causes a Denial of Service.",
      "cve": "CVE-2021-45261",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/patch@2.7.6-7build2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.7.6-7build2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-45261",
          "value": "CVE-2021-45261",
          "url": "https://scout.docker.com/v/CVE-2021-45261?s=ubuntu&n=patch&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-45261?s=ubuntu&n=patch&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ac06f6ef45077fe1be336247ce4a83d84bf53bffc87293b3b4aa124e64d5b283",
      "category": "container_scanning",
      "message": "CVE-2021-45942 on ubuntu/openexr@2.5.7-1",
      "description": "OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.",
      "cve": "CVE-2021-45942",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openexr@2.5.7-1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.5.7-1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-45942",
          "value": "CVE-2021-45942",
          "url": "https://scout.docker.com/v/CVE-2021-45942?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-45942?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "411fe2f62577517fd9b9e32a33b38de6b7f207ca16b25fce6c28b4445fba4b5d",
      "category": "container_scanning",
      "message": "CVE-2021-46195 on ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2",
      "description": "GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.",
      "cve": "CVE-2021-46195",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "11.4.0-1ubuntu1~22.04.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-46195",
          "value": "CVE-2021-46195",
          "url": "https://scout.docker.com/v/CVE-2021-46195?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-46195?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5ebdfd8c757d7f0844c1be6f56833aef9adb62fc7b1ce3b65c89441d844126b",
      "category": "container_scanning",
      "message": "CVE-2022-27943 on ubuntu/gcc-12@12.3.0-1ubuntu1~22.04.2",
      "description": "libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.",
      "cve": "CVE-2022-27943",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/gcc-12@12.3.0-1ubuntu1~22.04.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "12.3.0-1ubuntu1~22.04.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-27943",
          "value": "CVE-2022-27943",
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=gcc-12&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=gcc-12&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1ebf199b0c6a9f310d49a8f6802229f804e5307bded6a213ac2d8c87878fe4de",
      "category": "container_scanning",
      "message": "CVE-2022-27943 on ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2",
      "description": "libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.",
      "cve": "CVE-2022-27943",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "11.4.0-1ubuntu1~22.04.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-27943",
          "value": "CVE-2022-27943",
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a81b8e45b7e5ceb544f7d567fd2b38c8906f96262c8d650c83286161b00737c9",
      "category": "container_scanning",
      "message": "CVE-2022-27943 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.",
      "cve": "CVE-2022-27943",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-27943",
          "value": "CVE-2022-27943",
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-27943?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b5a601fd5c51838d4c32f3806c5189d31dfcb73b8efbf30f2a5fd8cfaf3e876d",
      "category": "container_scanning",
      "message": "CVE-2022-3114 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.",
      "cve": "CVE-2022-3114",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-3114",
          "value": "CVE-2022-3114",
          "url": "https://scout.docker.com/v/CVE-2022-3114?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-3114?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6478344e6c4491e6951711e3b050ec94ed6db5aa32e41da3cf525556c81ee43d",
      "category": "container_scanning",
      "message": "CVE-2022-48064 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
      "cve": "CVE-2022-48064",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48064",
          "value": "CVE-2022-48064",
          "url": "https://scout.docker.com/v/CVE-2022-48064?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48064?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7b19409adda44fe4fd82abefe8acd10fb77dc583b0d433feb0dbd23d95d37ddf",
      "category": "container_scanning",
      "message": "CVE-2023-1906 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A heap-based buffer overflow issue was discovered in ImageMagick's ImportMultiSpectralQuantum() function in MagickCore/quantum-import.c. An attacker could pass specially crafted file to convert, triggering an out-of-bounds read error, allowing an application to crash, resulting in a denial of service.",
      "cve": "CVE-2023-1906",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-1906",
          "value": "CVE-2023-1906",
          "url": "https://scout.docker.com/v/CVE-2023-1906?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-1906?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "55211ccd232d4532d0fd572befc66b8cddf7057b25d491fb89e2171c46bf7b3e",
      "category": "container_scanning",
      "message": "CVE-2023-4133 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",
      "cve": "CVE-2023-4133",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-4133",
          "value": "CVE-2023-4133",
          "url": "https://scout.docker.com/v/CVE-2023-4133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-4133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b2d5ac56a6d1c3506a6e9b8c82dea6171da33e6de3a12a9d631425e0dd5f55bb",
      "category": "container_scanning",
      "message": "CVE-2024-27010 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: Fix mirred deadlock on device recursion  When the mirred action is used on a classful egress qdisc and a packet is mirrored or redirected to self we hit a qdisc lock deadlock. See trace below.  [..... other info removed for brevity....] [   82.890906] [   82.890906] ============================================ [   82.890906] WARNING: possible recursive locking detected [   82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G        W [   82.890906] -------------------------------------------- [   82.890906] ping/418 is trying to acquire lock: [   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at: __dev_queue_xmit+0x1778/0x3550 [   82.890906] [   82.890906] but task is already holding lock: [   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at: __dev_queue_xmit+0x1778/0x3550 [   82.890906] [   82.890906] other info that might help us debug this: [   82.890906]  Possible unsafe locking scenario: [   82.890906] [   82.890906]        CPU0 [   82.890906]        ---- [   82.890906]   lock(&sch->q.lock); [   82.890906]   lock(&sch->q.lock); [   82.890906] [   82.890906]  *** DEADLOCK *** [   82.890906] [..... other info removed for brevity....]  Example setup (eth0->eth0) to recreate tc qdisc add dev eth0 root handle 1: htb default 30 tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth0  Another example(eth0->eth1->eth0) to recreate tc qdisc add dev eth0 root handle 1: htb default 30 tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth1  tc qdisc add dev eth1 root handle 1: htb default 30 tc filter add dev eth1 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth0  We fix this by adding an owner field (CPU id) to struct Qdisc set after root qdisc is entered. When the softirq enters it a second time, if the qdisc owner is the same CPU, the packet is dropped to break the loop.",
      "cve": "CVE-2024-27010",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27010",
          "value": "CVE-2024-27010",
          "url": "https://scout.docker.com/v/CVE-2024-27010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6e0debcfbff337daad9f35d2332b1cb78403bd8d72be49ce543d9c37d9a363aa",
      "category": "container_scanning",
      "message": "CVE-2024-27011 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: fix memleak in map from abort path  The delete set command does not rely on the transaction object for element removal, therefore, a combination of delete element + delete set from the abort path could result in restoring twice the refcount of the mapping.  Check for inactive element in the next generation for the delete element command in the abort path, skip restoring state if next generation bit has been already cleared. This is similar to the activate logic using the set walk iterator.  [ 6170.286929] ------------[ cut here ]------------ [ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.287071] Modules linked in: [...] [ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365 [ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f [ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202 [ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000 [ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750 [ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55 [ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10 [ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100 [ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000 [ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0 [ 6170.287962] Call Trace: [ 6170.287967]  <TASK> [ 6170.287973]  ? __warn+0x9f/0x1a0 [ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288092]  ? report_bug+0x1b1/0x1e0 [ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288092]  ? report_bug+0x1b1/0x1e0 [ 6170.288104]  ? handle_bug+0x3c/0x70 [ 6170.288112]  ? exc_invalid_op+0x17/0x40 [ 6170.288120]  ? asm_exc_invalid_op+0x1a/0x20 [ 6170.288132]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables] [ 6170.288243]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288366]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables] [ 6170.288483]  nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]",
      "cve": "CVE-2024-27011",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27011",
          "value": "CVE-2024-27011",
          "url": "https://scout.docker.com/v/CVE-2024-27011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7f12aab30ebad8dff85591dd09e127bf052b0fa185bad50c38e40f60dd243951",
      "category": "container_scanning",
      "message": "CVE-2024-49968 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: filesystems without casefold feature cannot be mounted with siphash  When mounting the ext4 filesystem, if the default hash version is set to DX_HASH_SIPHASH but the casefold feature is not set, exit the mounting.",
      "cve": "CVE-2024-49968",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49968",
          "value": "CVE-2024-49968",
          "url": "https://scout.docker.com/v/CVE-2024-49968?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49968?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "11e00d8918638851d2e005a96633b1034e42499bd7cc6f67c9270077d3a4f1ff",
      "category": "container_scanning",
      "message": "CVE-2024-53093 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-multipath: defer partition scanning  We need to suppress the partition scan from occuring within the controller's scan_work context. If a path error occurs here, the IO will wait until a path becomes available or all paths are torn down, but that action also occurs within scan_work, so it would deadlock. Defer the partion scan to a different context that does not block scan_work.",
      "cve": "CVE-2024-53093",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53093",
          "value": "CVE-2024-53093",
          "url": "https://scout.docker.com/v/CVE-2024-53093?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53093?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "82bff13d94a4ecfc5ac3f0565c22dc863feafd5fd9e38d63620f3a5f262570cf",
      "category": "container_scanning",
      "message": "CVE-2025-21645 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  platform/x86/amd/pmc: Only disable IRQ1 wakeup where i8042 actually enabled it  Wakeup for IRQ1 should be disabled only in cases where i8042 had actually enabled it, otherwise \"wake_depth\" for this IRQ will try to drop below zero and there will be an unpleasant WARN() logged:  kernel: atkbd serio0: Disabling IRQ1 wakeup source to avoid platform firmware bug kernel: ------------[ cut here ]------------ kernel: Unbalanced IRQ 1 wake disable kernel: WARNING: CPU: 10 PID: 6431 at kernel/irq/manage.c:920 irq_set_irq_wake+0x147/0x1a0  The PMC driver uses DEFINE_SIMPLE_DEV_PM_OPS() to define its dev_pm_ops which sets amd_pmc_suspend_handler() to the .suspend, .freeze, and .poweroff handlers. i8042_pm_suspend(), however, is only set as the .suspend handler.  Fix the issue by call PMC suspend handler only from the same set of dev_pm_ops handlers as i8042_pm_suspend(), which currently means just the .suspend handler.  To reproduce this issue try hibernating (S4) the machine after a fresh boot without putting it into s2idle first.  [ij: edited the commit message.]",
      "cve": "CVE-2025-21645",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21645",
          "value": "CVE-2025-21645",
          "url": "https://scout.docker.com/v/CVE-2025-21645?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21645?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c6d016b4621c2ed6efe87887e7f5b96c31241a79a2487c543772fbff2e75f58f",
      "category": "container_scanning",
      "message": "CVE-2018-1121 on ubuntu/linux@5.15.0-161.171",
      "description": "procps-ng, procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order, a process occupying a high PID can use inotify events to determine when the process list is being scanned, and fork/exec to obtain a lower PID, thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15, newer versions might be affected also.",
      "cve": "CVE-2018-1121",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-1121",
          "value": "CVE-2018-1121",
          "url": "https://scout.docker.com/v/CVE-2018-1121?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-1121?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c3751e77a039e85dc5ce1387715fa6b8008648fb7f8a81157fcba7646b5ee34d",
      "category": "container_scanning",
      "message": "CVE-2023-7008 on ubuntu/systemd@249.11-0ubuntu3.16",
      "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
      "cve": "CVE-2023-7008",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/systemd@249.11-0ubuntu3.16?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "249.11-0ubuntu3.16"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-7008",
          "value": "CVE-2023-7008",
          "url": "https://scout.docker.com/v/CVE-2023-7008?s=ubuntu&n=systemd&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-7008?s=ubuntu&n=systemd&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5a163b51657bd3e6a05311eaf8a6a41d3a0e5a9a2089cefefcf62fe6e883891",
      "category": "container_scanning",
      "message": "CVE-2022-44032 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",
      "cve": "CVE-2022-44032",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-44032",
          "value": "CVE-2022-44032",
          "url": "https://scout.docker.com/v/CVE-2022-44032?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-44032?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3680ea056672130aad73a4b239aea939f63a4cecd992082afdabc7990878c8a5",
      "category": "container_scanning",
      "message": "CVE-2022-44033 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",
      "cve": "CVE-2022-44033",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-44033",
          "value": "CVE-2022-44033",
          "url": "https://scout.docker.com/v/CVE-2022-44033?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-44033?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d72173ec8e98438d696e3e75970cddc52091c6f0cb78bcefac713be6b093d49f",
      "category": "container_scanning",
      "message": "CVE-2022-44034 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",
      "cve": "CVE-2022-44034",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-44034",
          "value": "CVE-2022-44034",
          "url": "https://scout.docker.com/v/CVE-2022-44034?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-44034?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "00f846cf5fa4a1c4f682182813485c166bffff31b838c00b5f3957437942aaf6",
      "category": "container_scanning",
      "message": "CVE-2022-45888 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/char/xillybus/xillyusb.c has a race condition and use-after-free during physical removal of a USB device.",
      "cve": "CVE-2022-45888",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-45888",
          "value": "CVE-2022-45888",
          "url": "https://scout.docker.com/v/CVE-2022-45888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-45888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "07ca8a7ebc4c024e5cf64ba64971c044f7b49e72a80630ae840fa37e8c108065",
      "category": "container_scanning",
      "message": "CVE-2016-2781 on ubuntu/coreutils@8.32-4.1ubuntu1.2",
      "description": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
      "cve": "CVE-2016-2781",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/coreutils@8.32-4.1ubuntu1.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8.32-4.1ubuntu1.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2016-2781",
          "value": "CVE-2016-2781",
          "url": "https://scout.docker.com/v/CVE-2016-2781?s=ubuntu&n=coreutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2016-2781?s=ubuntu&n=coreutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "efcb6ac1c18d20669eea4505d8b9262b55e61633169ab941f72a00666fafe92c",
      "category": "container_scanning",
      "message": "CVE-2018-18064 on ubuntu/cairo@1.16.0-5ubuntu2",
      "description": "cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).",
      "cve": "CVE-2018-18064",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/cairo@1.16.0-5ubuntu2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.16.0-5ubuntu2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-18064",
          "value": "CVE-2018-18064",
          "url": "https://scout.docker.com/v/CVE-2018-18064?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-18064?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "610beafe2f53c30ee09b3b59dd5e4b63004321083e252f9e90035a8eae2cc13c",
      "category": "container_scanning",
      "message": "CVE-2019-6461 on ubuntu/cairo@1.16.0-5ubuntu2",
      "description": "An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.",
      "cve": "CVE-2019-6461",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/cairo@1.16.0-5ubuntu2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.16.0-5ubuntu2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-6461",
          "value": "CVE-2019-6461",
          "url": "https://scout.docker.com/v/CVE-2019-6461?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-6461?s=ubuntu&n=cairo&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b099cd05362eb0e2e716bb8d958785b79f59f407f45ad107915db9a0a1a946a4",
      "category": "container_scanning",
      "message": "CVE-2019-6988 on ubuntu/openjpeg2@2.4.0-6ubuntu0.4",
      "description": "An issue was discovered in OpenJPEG 2.3.0. It allows remote attackers to cause a denial of service (attempted excessive memory allocation) in opj_calloc in openjp2/opj_malloc.c, when called from opj_tcd_init_tile in openjp2/tcd.c, as demonstrated by the 64-bit opj_decompress.",
      "cve": "CVE-2019-6988",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openjpeg2@2.4.0-6ubuntu0.4?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.4.0-6ubuntu0.4"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-6988",
          "value": "CVE-2019-6988",
          "url": "https://scout.docker.com/v/CVE-2019-6988?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-6988?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0d39b6deafdfe821d6f32a073ee64ec33696fd6dd210ccdf77f1126de4fa1f9f",
      "category": "container_scanning",
      "message": "CVE-2021-3826 on ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2",
      "description": "Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.",
      "cve": "CVE-2021-3826",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/gcc-11@11.4.0-1ubuntu1~22.04.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "11.4.0-1ubuntu1~22.04.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3826",
          "value": "CVE-2021-3826",
          "url": "https://scout.docker.com/v/CVE-2021-3826?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3826?s=ubuntu&n=gcc-11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b7eeb844b974984134511884f988ef50ae200869850f112df3d518e5d6acae4d",
      "category": "container_scanning",
      "message": "CVE-2021-3941 on ubuntu/openexr@2.5.7-1",
      "description": "In ImfChromaticities.cpp routine RGBtoXYZ(), there are some division operations such as `float Z = (1 - chroma.white.x - chroma.white.y) * Y / chroma.white.y;` and `chroma.green.y * (X + Z))) / d;` but the divisor is not checked for a 0 value. A specially crafted file could trigger a divide-by-zero condition which could affect the availability of programs linked with OpenEXR.",
      "cve": "CVE-2021-3941",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openexr@2.5.7-1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.5.7-1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3941",
          "value": "CVE-2021-3941",
          "url": "https://scout.docker.com/v/CVE-2021-3941?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3941?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fad5ca67b2386b35ca02f5a654335c22b852fefb25ce19d1a7e120a09a78f758",
      "category": "container_scanning",
      "message": "CVE-2023-34969 on ubuntu/dbus@1.12.20-2ubuntu4.1",
      "description": "D-Bus before 1.15.6 sometimes allows unprivileged users to crash dbus-daemon. If a privileged user with control over the dbus-daemon is using the org.freedesktop.DBus.Monitoring interface to monitor message bus traffic, then an unprivileged user with the ability to connect to the same dbus-daemon can cause a dbus-daemon crash under some circumstances via an unreplyable message. When done on the well-known system bus, this is a denial-of-service vulnerability. The fixed versions are 1.12.28, 1.14.8, and 1.15.6.",
      "cve": "CVE-2023-34969",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/dbus@1.12.20-2ubuntu4.1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.12.20-2ubuntu4.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-34969",
          "value": "CVE-2023-34969",
          "url": "https://scout.docker.com/v/CVE-2023-34969?s=ubuntu&n=dbus&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-34969?s=ubuntu&n=dbus&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0cb793d158d9addb23a156625e2cd56608944bbf5f015649e2f7f8ae745fc4b2",
      "category": "container_scanning",
      "message": "CVE-2023-46361 on ubuntu/jbig2dec@0.19-3build2",
      "description": "Artifex Software jbig2dec v0.20 was discovered to contain a SEGV vulnerability via jbig2_error at /jbig2dec/jbig2.c.",
      "cve": "CVE-2023-46361",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/jbig2dec@0.19-3build2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "0.19-3build2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-46361",
          "value": "CVE-2023-46361",
          "url": "https://scout.docker.com/v/CVE-2023-46361?s=ubuntu&n=jbig2dec&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-46361?s=ubuntu&n=jbig2dec&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "171707143c8a67e43587b22fadb520c6327badda90effb3e951ee58c2ec0d32d",
      "category": "container_scanning",
      "message": "CVE-2023-50495 on ubuntu/ncurses@6.3-2ubuntu0.1",
      "description": "NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().",
      "cve": "CVE-2023-50495",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/ncurses@6.3-2ubuntu0.1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "6.3-2ubuntu0.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-50495",
          "value": "CVE-2023-50495",
          "url": "https://scout.docker.com/v/CVE-2023-50495?s=ubuntu&n=ncurses&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-50495?s=ubuntu&n=ncurses&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "25582a2fb7415cc9d384566c11fd74700d984144a547de4f5789b163dc4fcf36",
      "category": "container_scanning",
      "message": "CVE-2024-0564 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM), added in Linux kernel version 4.4.0-96.119, can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is \"max page sharing=256\", it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's \"max page share\". Through these operations, the attacker can leak the victim's page.",
      "cve": "CVE-2024-0564",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-0564",
          "value": "CVE-2024-0564",
          "url": "https://scout.docker.com/v/CVE-2024-0564?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-0564?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ed91657bf19d92fc77526ed44565e7ad1aa8fc4f9c7dcf63817773f8e67fea6c",
      "category": "container_scanning",
      "message": "CVE-2022-45885 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
      "cve": "CVE-2022-45885",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-45885",
          "value": "CVE-2022-45885",
          "url": "https://scout.docker.com/v/CVE-2022-45885?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-45885?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dcf11eefdec14484677282b8bf1c852d466e8e93fab6ab51d1239718992bade9",
      "category": "container_scanning",
      "message": "CVE-2019-14899 on ubuntu/linux@5.15.0-161.171",
      "description": "A vulnerability was discovered in Linux, FreeBSD, OpenBSD, MacOS, iOS, and Android that allows a malicious access point, or an adjacent user, to determine if a connected user is using a VPN, make positive inferences about the websites they are visiting, and determine the correct sequence and acknowledgement numbers in use, allowing the bad actor to inject data into the TCP stream. This provides everything that is needed for an attacker to hijack active connections inside the VPN tunnel.",
      "cve": "CVE-2019-14899",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-14899",
          "value": "CVE-2019-14899",
          "url": "https://scout.docker.com/v/CVE-2019-14899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-14899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cdf68e76af9ddea41d4202b9c1c9f8ab52f59e9747bd5076b5b8474e762042b8",
      "category": "container_scanning",
      "message": "CVE-2017-11164 on ubuntu/pcre3@2:8.39-13ubuntu0.22.04.1",
      "description": "In PCRE 8.41, the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.",
      "cve": "CVE-2017-11164",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/pcre3@2%3A8.39-13ubuntu0.22.04.1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2:8.39-13ubuntu0.22.04.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-11164",
          "value": "CVE-2017-11164",
          "url": "https://scout.docker.com/v/CVE-2017-11164?s=ubuntu&n=pcre3&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-11164?s=ubuntu&n=pcre3&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "41284f1cb2db3233a50fdad12e160b17b05a2d38dc67c091ff52be99998f8377",
      "category": "container_scanning",
      "message": "CVE-2018-6952 on ubuntu/patch@2.7.6-7build2",
      "description": "A double free exists in the another_hunk function in pch.c in GNU patch through 2.7.6.",
      "cve": "CVE-2018-6952",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/patch@2.7.6-7build2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.7.6-7build2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-6952",
          "value": "CVE-2018-6952",
          "url": "https://scout.docker.com/v/CVE-2018-6952?s=ubuntu&n=patch&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-6952?s=ubuntu&n=patch&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7191a5fcd3d2b316874b39c655bb70ba43e5d91eb842dc2283946df1e9af2613",
      "category": "container_scanning",
      "message": "CVE-2019-20426 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Lustre file system before 2.12.3, the ptlrpc module has an out-of-bounds access and panic due to the lack of validation for specific fields of packets sent by a client. In the function ldlm_cancel_hpreq_check, there is no lock_count bounds check.",
      "cve": "CVE-2019-20426",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-20426",
          "value": "CVE-2019-20426",
          "url": "https://scout.docker.com/v/CVE-2019-20426?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-20426?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "942cfd13fec103aee73895c385a8c6471a9473d7b6d06f4b6dbecd38e85bbeb0",
      "category": "container_scanning",
      "message": "CVE-2021-20309 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in versions before 7.0.11 and before 6.9.12, where a division by zero in WaveImage() of MagickCore/visual-effects.c may trigger undefined behavior via a crafted image file submitted to an application using ImageMagick. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20309",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20309",
          "value": "CVE-2021-20309",
          "url": "https://scout.docker.com/v/CVE-2021-20309?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20309?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f6716b357264728ca312ba83b7d11adef93920389c42b9a41143944dcd7d5d7a",
      "category": "container_scanning",
      "message": "CVE-2021-20312 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in versions 7.0.11, where an integer overflow in WriteTHUMBNAILImage of coders/thumbnail.c may trigger undefined behavior via a crafted image file that is submitted by an attacker and processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.",
      "cve": "CVE-2021-20312",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20312",
          "value": "CVE-2021-20312",
          "url": "https://scout.docker.com/v/CVE-2021-20312?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20312?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b52774b114a2dbfb6c0635b6b91730d6e4d021523c8193a6067dd573de2eef24",
      "category": "container_scanning",
      "message": "CVE-2021-20313 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A flaw was found in ImageMagick in versions before 7.0.11. A potential cipher leak when the calculate signatures in TransformSignature is possible. The highest threat from this vulnerability is to data confidentiality.",
      "cve": "CVE-2021-20313",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-20313",
          "value": "CVE-2021-20313",
          "url": "https://scout.docker.com/v/CVE-2021-20313?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-20313?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3eecfad307727ee7498f910e564267771f2f2eebc7ff0f72421b966008e55018",
      "category": "container_scanning",
      "message": "CVE-2022-41409 on ubuntu/pcre2@10.39-3ubuntu0.1",
      "description": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.",
      "cve": "CVE-2022-41409",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/pcre2@10.39-3ubuntu0.1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "10.39-3ubuntu0.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-41409",
          "value": "CVE-2022-41409",
          "url": "https://scout.docker.com/v/CVE-2022-41409?s=ubuntu&n=pcre2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-41409?s=ubuntu&n=pcre2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "33b06f1efa0ef1fcb3ef2d26b206c39e401080a5faca9fa230d8bc5edffb0960",
      "category": "container_scanning",
      "message": "CVE-2022-4899 on ubuntu/libzstd@1.4.8+dfsg-3build1",
      "description": "A vulnerability was found in zstd v1.4.10, where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.",
      "cve": "CVE-2022-4899",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libzstd@1.4.8%2Bdfsg-3build1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.4.8+dfsg-3build1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-4899",
          "value": "CVE-2022-4899",
          "url": "https://scout.docker.com/v/CVE-2022-4899?s=ubuntu&n=libzstd&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-4899?s=ubuntu&n=libzstd&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "84874c10e885008e287091634e002e5354bb587499aba7f1906606c64b93be65",
      "category": "container_scanning",
      "message": "CVE-2017-13165 on ubuntu/linux@5.15.0-161.171",
      "description": "An elevation of privilege vulnerability in the kernel file system. Product: Android. Versions: Android kernel. Android ID A-31269937.",
      "cve": "CVE-2017-13165",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2017-13165",
          "value": "CVE-2017-13165",
          "url": "https://scout.docker.com/v/CVE-2017-13165?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2017-13165?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db7b0ff1ea8edf19a744573973571681f479031405f5721a8d5cb6dbe5806417",
      "category": "container_scanning",
      "message": "CVE-2018-12930 on ubuntu/linux@5.15.0-161.171",
      "description": "ntfs_end_buffer_async_read in the ntfs.ko filesystem driver in the Linux kernel 4.15.0 allows attackers to trigger a stack-based out-of-bounds write and cause a denial of service (kernel oops or panic) or possibly have unspecified other impact via a crafted ntfs filesystem.",
      "cve": "CVE-2018-12930",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-12930",
          "value": "CVE-2018-12930",
          "url": "https://scout.docker.com/v/CVE-2018-12930?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-12930?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3be49bfd502de5ca1a26e566a9c5790e42acbc3fd269591d04032b74e5c9e435",
      "category": "container_scanning",
      "message": "CVE-2018-12931 on ubuntu/linux@5.15.0-161.171",
      "description": "ntfs_attr_find in the ntfs.ko filesystem driver in the Linux kernel 4.15.0 allows attackers to trigger a stack-based out-of-bounds write and cause a denial of service (kernel oops or panic) or possibly have unspecified other impact via a crafted ntfs filesystem.",
      "cve": "CVE-2018-12931",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-12931",
          "value": "CVE-2018-12931",
          "url": "https://scout.docker.com/v/CVE-2018-12931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-12931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c93784d81731c49a37eaab6c0414213e4ec74647e041ecba2d9769e6f81bb455",
      "category": "container_scanning",
      "message": "CVE-2019-19378 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.",
      "cve": "CVE-2019-19378",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-19378",
          "value": "CVE-2019-19378",
          "url": "https://scout.docker.com/v/CVE-2019-19378?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-19378?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9e7a5c55889a0b279fcf6e2bfa06803db03ef80f29182ba28951586f76598ec",
      "category": "container_scanning",
      "message": "CVE-2019-19814 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.",
      "cve": "CVE-2019-19814",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-19814",
          "value": "CVE-2019-19814",
          "url": "https://scout.docker.com/v/CVE-2019-19814?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-19814?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e130097f0c6c48434e0d5fbaf2eb1b9f421b8566bf44e33af7a90a18dfea9477",
      "category": "container_scanning",
      "message": "CVE-2021-26934 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in the Linux kernel 4.18 through 5.10.16, as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration, but this wasn't stated accordingly in its support status entry.",
      "cve": "CVE-2021-26934",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-26934",
          "value": "CVE-2021-26934",
          "url": "https://scout.docker.com/v/CVE-2021-26934?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-26934?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6938e61655e81a82f8bd5f9aaaaa710807931238e09ba28dc77fae60a5d886b9",
      "category": "container_scanning",
      "message": "CVE-2023-33053 on ubuntu/linux@5.15.0-161.171",
      "description": "Memory corruption in Kernel while parsing metadata.",
      "cve": "CVE-2023-33053",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-33053",
          "value": "CVE-2023-33053",
          "url": "https://scout.docker.com/v/CVE-2023-33053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-33053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4378170a4da380cb6fe4422b1451c10ed334cdb077d23f29080ac39e7b5564b9",
      "category": "container_scanning",
      "message": "CVE-2024-26983 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bootconfig: use memblock_free_late to free xbc memory to buddy  On the time to free xbc memory in xbc_exit(), memblock may has handed over memory to buddy allocator. So it doesn't make sense to free memory back to memblock. memblock_free() called by xbc_exit() even causes UAF bugs on architectures with CONFIG_ARCH_KEEP_MEMBLOCK disabled like x86. Following KASAN logs shows this case.  This patch fixes the xbc memory free problem by calling memblock_free() in early xbc init error rewind path and calling memblock_free_late() in xbc exit path to free memory to buddy allocator.  [    9.410890] ================================================================== [    9.418962] BUG: KASAN: use-after-free in memblock_isolate_range+0x12d/0x260 [    9.426850] Read of size 8 at addr ffff88845dd30000 by task swapper/0/1  [    9.435901] CPU: 9 PID: 1 Comm: swapper/0 Tainted: G     U 6.9.0-rc3-00208-g586b5dfb51b9 #5 [    9.446403] Hardware name: Intel Corporation RPLP LP5 (CPU:RaptorLake)/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 Dec 28 2023 [    9.460789] Call Trace: [    9.463518]  <TASK> [    9.465859]  dump_stack_lvl+0x53/0x70 [    9.469949]  print_report+0xce/0x610 [    9.473944]  ? __virt_addr_valid+0xf5/0x1b0 [    9.478619]  ? memblock_isolate_range+0x12d/0x260 [    9.483877]  kasan_report+0xc6/0x100 [    9.487870]  ? memblock_isolate_range+0x12d/0x260 [    9.493125]  memblock_isolate_range+0x12d/0x260 [    9.498187]  memblock_phys_free+0xb4/0x160 [    9.502762]  ? __pfx_memblock_phys_free+0x10/0x10 [    9.508021]  ? mutex_unlock+0x7e/0xd0 [    9.512111]  ? __pfx_mutex_unlock+0x10/0x10 [    9.516786]  ? kernel_init_freeable+0x2d4/0x430 [    9.521850]  ? __pfx_kernel_init+0x10/0x10 [    9.526426]  xbc_exit+0x17/0x70 [    9.529935]  kernel_init+0x38/0x1e0 [    9.533829]  ? _raw_spin_unlock_irq+0xd/0x30 [    9.538601]  ret_from_fork+0x2c/0x50 [    9.542596]  ? __pfx_kernel_init+0x10/0x10 [    9.547170]  ret_from_fork_asm+0x1a/0x30 [    9.551552]  </TASK>  [    9.555649] The buggy address belongs to the physical page: [    9.561875] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x45dd30 [    9.570821] flags: 0x200000000000000(node=0|zone=2) [    9.576271] page_type: 0xffffffff() [    9.580167] raw: 0200000000000000 ffffea0011774c48 ffffea0012ba1848 0000000000000000 [    9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000 [    9.597476] page dumped because: kasan: bad access detected  [    9.605362] Memory state around the buggy address: [    9.610714]  ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [    9.618786]  ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [    9.626857] >ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [    9.634930]                    ^ [    9.638534]  ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [    9.646605]  ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [    9.654675] ==================================================================",
      "cve": "CVE-2024-26983",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26983",
          "value": "CVE-2024-26983",
          "url": "https://scout.docker.com/v/CVE-2024-26983?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26983?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a1587c856ec9ee79dab6e8f731d000da94102a49fa6f06c368f90e5937537108",
      "category": "container_scanning",
      "message": "CVE-2024-47691 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()  syzbot reports a f2fs bug as below:  __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_report+0xe8/0x550 mm/kasan/report.c:491 kasan_report+0x143/0x180 mm/kasan/report.c:601 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 instrument_atomic_read_write include/linux/instrumented.h:96 [inline] atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline] __refcount_add include/linux/refcount.h:184 [inline] __refcount_inc include/linux/refcount.h:241 [inline] refcount_inc include/linux/refcount.h:258 [inline] get_task_struct include/linux/sched/task.h:118 [inline] kthread_stop+0xca/0x630 kernel/kthread.c:704 f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210 f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283 f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline] __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  The root cause is below race condition, it may cause use-after-free issue in sbi->gc_th pointer.  - remount - f2fs_remount - f2fs_stop_gc_thread - kfree(gc_th) - f2fs_ioc_shutdown - f2fs_do_shutdown - f2fs_stop_gc_thread - kthread_stop(gc_th->f2fs_gc_task) : sbi->gc_thread = NULL;  We will call f2fs_do_shutdown() in two paths: - for f2fs_ioc_shutdown() path, we should grab sb->s_umount semaphore for fixing. - for f2fs_shutdown() path, it's safe since caller has already grabbed sb->s_umount semaphore.",
      "cve": "CVE-2024-47691",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47691",
          "value": "CVE-2024-47691",
          "url": "https://scout.docker.com/v/CVE-2024-47691?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47691?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "49706f019aacac40623ef537f8e1b7e9921cef7b7625f44dcbd42fae9a7161da",
      "category": "container_scanning",
      "message": "CVE-2024-50217 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix use-after-free of block device file in __btrfs_free_extra_devids()  Mounting btrfs from two images (which have the same one fsid and two different dev_uuids) in certain executing order may trigger an UAF for variable 'device->bdev_file' in __btrfs_free_extra_devids(). And following are the details:  1. Attach image_1 to loop0, attach image_2 to loop1, and scan btrfs devices by ioctl(BTRFS_IOC_SCAN_DEV):  /  btrfs_device_1  loop0 fs_device \\  btrfs_device_2  loop1 2. mount /dev/loop0 /mnt btrfs_open_devices btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0) btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree fail: btrfs_close_devices // -ENOMEM btrfs_close_bdev(btrfs_device_1) fput(btrfs_device_1->bdev_file) // btrfs_device_1->bdev_file is freed btrfs_close_bdev(btrfs_device_2) fput(btrfs_device_2->bdev_file)  3. mount /dev/loop1 /mnt btrfs_open_devices btrfs_get_bdev_and_sb(&bdev_file) // EIO, btrfs_device_1->bdev_file is not assigned, // which points to a freed memory area btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree btrfs_free_extra_devids if (btrfs_device_1->bdev_file) fput(btrfs_device_1->bdev_file) // UAF !  Fix it by setting 'device->bdev_file' as 'NULL' after closing the btrfs_device in btrfs_close_one_device().",
      "cve": "CVE-2024-50217",
      "severity": "Low",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50217",
          "value": "CVE-2024-50217",
          "url": "https://scout.docker.com/v/CVE-2024-50217?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50217?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f32a9eb7d668b1146932752b400ca6b3ef66a116111c973684245edcc9be4fbb",
      "category": "container_scanning",
      "message": "CVE-2013-7445 on ubuntu/linux@5.15.0-161.171",
      "description": "The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.",
      "cve": "CVE-2013-7445",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2013-7445",
          "value": "CVE-2013-7445",
          "url": "https://scout.docker.com/v/CVE-2013-7445?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2013-7445?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5b9fbc6ba0f048f71bb780805ee23239148617ade47071967bfd044810352689",
      "category": "container_scanning",
      "message": "CVE-2021-47432 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  lib/generic-radix-tree.c: Don't overflow in peek()  When we started spreading new inode numbers throughout most of the 64 bit inode space, that triggered some corner case bugs, in particular some integer overflows related to the radix tree code. Oops.",
      "cve": "CVE-2021-47432",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-47432",
          "value": "CVE-2021-47432",
          "url": "https://scout.docker.com/v/CVE-2021-47432?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-47432?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "87f96bebe115d7103d71746c2f4f5a14b93ad2f3697e215e87fb82feb8202030",
      "category": "container_scanning",
      "message": "CVE-2022-48633 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/gma500: Fix WARN_ON(lock->magic != lock) error  psb_gem_unpin() calls dma_resv_lock() but the underlying ww_mutex gets destroyed by drm_gem_object_release() move the drm_gem_object_release() call in psb_gem_free_object() to after the unpin to fix the below warning:  [   79.693962] ------------[ cut here ]------------ [   79.693992] DEBUG_LOCKS_WARN_ON(lock->magic != lock) [   79.694015] WARNING: CPU: 0 PID: 240 at kernel/locking/mutex.c:582 __ww_mutex_lock.constprop.0+0x569/0xfb0 [   79.694052] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer qrtr bnep ath9k ath9k_common ath9k_hw snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio snd_hda_codec_hdmi snd_hda_intel ath3k snd_intel_dspcfg mac80211 snd_intel_sdw_acpi btusb snd_hda_codec btrtl btbcm btintel btmtk bluetooth at24 snd_hda_core snd_hwdep uvcvideo snd_seq libarc4 videobuf2_vmalloc ath videobuf2_memops videobuf2_v4l2 videobuf2_common snd_seq_device videodev acer_wmi intel_powerclamp coretemp mc snd_pcm joydev sparse_keymap ecdh_generic pcspkr wmi_bmof cfg80211 i2c_i801 i2c_smbus snd_timer snd r8169 rfkill lpc_ich soundcore acpi_cpufreq zram rtsx_pci_sdmmc mmc_core serio_raw rtsx_pci gma500_gfx(E) video wmi ip6_tables ip_tables i2c_dev fuse [   79.694436] CPU: 0 PID: 240 Comm: plymouthd Tainted: G        W   E 6.0.0-rc3+ #490 [   79.694457] Hardware name: Packard Bell dot s/SJE01_CT, BIOS V1.10 07/23/2013 [   79.694469] RIP: 0010:__ww_mutex_lock.constprop.0+0x569/0xfb0 [   79.694496] Code: ff 85 c0 0f 84 15 fb ff ff 8b 05 ca 3c 11 01 85 c0 0f 85 07 fb ff ff 48 c7 c6 30 cb 84 aa 48 c7 c7 a3 e1 82 aa e8 ac 29 f8 ff <0f> 0b e9 ed fa ff ff e8 5b 83 8a ff 85 c0 74 10 44 8b 0d 98 3c 11 [   79.694513] RSP: 0018:ffffad1dc048bbe0 EFLAGS: 00010282 [   79.694623] RAX: 0000000000000028 RBX: 0000000000000000 RCX: 0000000000000000 [   79.694636] RDX: 0000000000000001 RSI: ffffffffaa8b0ffc RDI: 00000000ffffffff [   79.694650] RBP: ffffad1dc048bc80 R08: 0000000000000000 R09: ffffad1dc048ba90 [   79.694662] R10: 0000000000000003 R11: ffffffffaad62fe8 R12: ffff9ff302103138 [   79.694675] R13: ffff9ff306ec8000 R14: ffff9ff307779078 R15: ffff9ff3014c0270 [   79.694690] FS:  00007ff1cccf1740(0000) GS:ffff9ff3bc200000(0000) knlGS:0000000000000000 [   79.694705] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [   79.694719] CR2: 0000559ecbcb4420 CR3: 0000000013210000 CR4: 00000000000006f0 [   79.694734] Call Trace: [   79.694749]  <TASK> [   79.694761]  ? __schedule+0x47f/0x1670 [   79.694796]  ? psb_gem_unpin+0x27/0x1a0 [gma500_gfx] [   79.694830]  ? lock_is_held_type+0xe3/0x140 [   79.694864]  ? ww_mutex_lock+0x38/0xa0 [   79.694885]  ? __cond_resched+0x1c/0x30 [   79.694902]  ww_mutex_lock+0x38/0xa0 [   79.694925]  psb_gem_unpin+0x27/0x1a0 [gma500_gfx] [   79.694964]  psb_gem_unpin+0x199/0x1a0 [gma500_gfx] [   79.694996]  drm_gem_object_release_handle+0x50/0x60 [   79.695020]  ? drm_gem_object_handle_put_unlocked+0xf0/0xf0 [   79.695042]  idr_for_each+0x4b/0xb0 [   79.695066]  ? _raw_spin_unlock_irqrestore+0x30/0x60 [   79.695095]  drm_gem_release+0x1c/0x30 [   79.695118]  drm_file_free.part.0+0x1ea/0x260 [   79.695150]  drm_release+0x6a/0x120 [   79.695175]  __fput+0x9f/0x260 [   79.695203]  task_work_run+0x59/0xa0 [   79.695227]  do_exit+0x387/0xbe0 [   79.695250]  ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90 [   79.695275]  ? lockdep_hardirqs_on+0x7d/0x100 [   79.695304]  do_group_exit+0x33/0xb0 [   79.695331]  __x64_sys_exit_group+0x14/0x20 [   79.695353]  do_syscall_64+0x58/0x80 [   79.695376]  ? up_read+0x17/0x20 [   79.695401]  ? lock_is_held_type+0xe3/0x140 [   79.695429]  ? asm_exc_page_fault+0x22/0x30 [   79.695450]  ? lockdep_hardirqs_on+0x7d/0x100 [   79.695473]  entry_SYSCALL_64_after_hwframe+0x63/0xcd [   79.695493] RIP: 0033:0x7ff1ccefe3f1 [   79.695516] Code: Unable to access opcode bytes at RIP 0x7ff1ccefe3c7. [   79.695607] RSP: 002b:00007ffed4413378 EFLAGS: ---truncated---",
      "cve": "CVE-2022-48633",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48633",
          "value": "CVE-2022-48633",
          "url": "https://scout.docker.com/v/CVE-2022-48633?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48633?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1f811a100f3e97343ec4f11e787bb985ce483494c680b28f107373c51dfff8f1",
      "category": "container_scanning",
      "message": "CVE-2022-48646 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  sfc/siena: fix null pointer dereference in efx_hard_start_xmit  Like in previous patch for sfc, prevent potential (but unlikely) NULL pointer dereference.",
      "cve": "CVE-2022-48646",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48646",
          "value": "CVE-2022-48646",
          "url": "https://scout.docker.com/v/CVE-2022-48646?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48646?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "72ee84428f3283fa41844888efafe6d42da6f9fdde0e83d025a8b173b438415e",
      "category": "container_scanning",
      "message": "CVE-2022-48900 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-48900",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48900",
          "value": "CVE-2022-48900",
          "url": "https://scout.docker.com/v/CVE-2022-48900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "93ec8c9927441d13fc6375355ce2424b1bf9980a5697340f402c5134cf9b7fda",
      "category": "container_scanning",
      "message": "CVE-2022-49127 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ref_tracker: implement use-after-free detection  Whenever ref_tracker_dir_init() is called, mark the struct ref_tracker_dir as dead.  Test the dead status from ref_tracker_alloc() and ref_tracker_free()  This should detect buggy dev_put()/dev_hold() happening too late in netdevice dismantle process.",
      "cve": "CVE-2022-49127",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49127",
          "value": "CVE-2022-49127",
          "url": "https://scout.docker.com/v/CVE-2022-49127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6bd8dbc8b7e2ee2fe871589719748fcf607194a62488c608ea99587143dc9060",
      "category": "container_scanning",
      "message": "CVE-2022-49136 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_sync: Fix queuing commands when HCI_UNREGISTER is set  hci_cmd_sync_queue shall return an error if HCI_UNREGISTER flag has been set as that means hci_unregister_dev has been called so it will likely cause a uaf after the timeout as the hdev will be freed.",
      "cve": "CVE-2022-49136",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49136",
          "value": "CVE-2022-49136",
          "url": "https://scout.docker.com/v/CVE-2022-49136?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49136?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1390587fe449b72a2bda35b5e873a8a14e8ed7dfbee35e559a310b4177114cd9",
      "category": "container_scanning",
      "message": "CVE-2022-49359 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/panfrost: Job should reference MMU not file_priv  For a while now it's been allowed for a MMU context to outlive it's corresponding panfrost_priv, however the job structure still references panfrost_priv to get hold of the MMU context. If panfrost_priv has been freed this is a use-after-free which I've been able to trigger resulting in a splat.  To fix this, drop the reference to panfrost_priv in the job structure and add a direct reference to the MMU structure which is what's actually needed.",
      "cve": "CVE-2022-49359",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49359",
          "value": "CVE-2022-49359",
          "url": "https://scout.docker.com/v/CVE-2022-49359?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49359?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0c9deff3ccd2b69f49d997b25946e1da9cc95ccb92549bde6bd0e7abe881bd42",
      "category": "container_scanning",
      "message": "CVE-2022-49465 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-throttle: Set BIO_THROTTLED when bio has been throttled  1.In current process, all bio will set the BIO_THROTTLED flag after __blk_throtl_bio().  2.If bio needs to be throttled, it will start the timer and stop submit bio directly. Bio will submit in blk_throtl_dispatch_work_fn() when the timer expires.But in the current process, if bio is throttled. The BIO_THROTTLED will be set to bio after timer start. If the bio has been completed, it may cause use-after-free blow.  BUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70 Read of size 2 at addr ffff88801b8902d4 by task fio/26380  dump_stack+0x9b/0xce print_address_description.constprop.6+0x3e/0x60 kasan_report.cold.9+0x22/0x3a blk_throtl_bio+0x12f0/0x2c70 submit_bio_checks+0x701/0x1550 submit_bio_noacct+0x83/0xc80 submit_bio+0xa7/0x330 mpage_readahead+0x380/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9  Allocated by task 26380: kasan_save_stack+0x19/0x40 __kasan_kmalloc.constprop.2+0xc1/0xd0 kmem_cache_alloc+0x146/0x440 mempool_alloc+0x125/0x2f0 bio_alloc_bioset+0x353/0x590 mpage_alloc+0x3b/0x240 do_mpage_readpage+0xddf/0x1ef0 mpage_readahead+0x264/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9  Freed by task 0: kasan_save_stack+0x19/0x40 kasan_set_track+0x1c/0x30 kasan_set_free_info+0x1b/0x30 __kasan_slab_free+0x111/0x160 kmem_cache_free+0x94/0x460 mempool_free+0xd6/0x320 bio_free+0xe0/0x130 bio_put+0xab/0xe0 bio_endio+0x3a6/0x5d0 blk_update_request+0x590/0x1370 scsi_end_request+0x7d/0x400 scsi_io_completion+0x1aa/0xe50 scsi_softirq_done+0x11b/0x240 blk_mq_complete_request+0xd4/0x120 scsi_mq_done+0xf0/0x200 virtscsi_vq_done+0xbc/0x150 vring_interrupt+0x179/0x390 __handle_irq_event_percpu+0xf7/0x490 handle_irq_event_percpu+0x7b/0x160 handle_irq_event+0xcc/0x170 handle_edge_irq+0x215/0xb20 common_interrupt+0x60/0x120 asm_common_interrupt+0x1e/0x40  Fix this by move BIO_THROTTLED set into the queue_lock.",
      "cve": "CVE-2022-49465",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49465",
          "value": "CVE-2022-49465",
          "url": "https://scout.docker.com/v/CVE-2022-49465?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49465?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "769e176660014f7f34a05fa92b5afbd4ebb2b2fb87205336830de1d6a75a16e8",
      "category": "container_scanning",
      "message": "CVE-2022-49614 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-49614",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49614",
          "value": "CVE-2022-49614",
          "url": "https://scout.docker.com/v/CVE-2022-49614?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49614?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b82668d9e9f54a1883f695bb5be28494ed8b930ecb3240d4c53178da877db651",
      "category": "container_scanning",
      "message": "CVE-2022-49622 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: avoid skb access on nf_stolen  When verdict is NF_STOLEN, the skb might have been freed.  When tracing is enabled, this can result in a use-after-free: 1. access to skb->nf_trace 2. access to skb->mark 3. computation of trace id 4. dump of packet payload  To avoid 1, keep a cached copy of skb->nf_trace in the trace state struct. Refresh this copy whenever verdict is != STOLEN.  Avoid 2 by skipping skb->mark access if verdict is STOLEN.  3 is avoided by precomputing the trace id.  Only dump the packet when verdict is not \"STOLEN\".",
      "cve": "CVE-2022-49622",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49622",
          "value": "CVE-2022-49622",
          "url": "https://scout.docker.com/v/CVE-2022-49622?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49622?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6ac544d67661fb64a6e2a4ce8ba4a51cde7ac58578553933a386c68c3bf3480",
      "category": "container_scanning",
      "message": "CVE-2022-49651 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  srcu: Tighten cleanup_srcu_struct() GP checks  Currently, cleanup_srcu_struct() checks for a grace period in progress, but it does not check for a grace period that has not yet started but which might start at any time.  Such a situation could result in a use-after-free bug, so this commit adds a check for a grace period that is needed but not yet started to cleanup_srcu_struct().",
      "cve": "CVE-2022-49651",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49651",
          "value": "CVE-2022-49651",
          "url": "https://scout.docker.com/v/CVE-2022-49651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0009da0e766dcef688725b09077a7b3b8d9f2ea822c78bd695190d9ba4dbda22",
      "category": "container_scanning",
      "message": "CVE-2022-49764 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Prevent bpf program recursion for raw tracepoint probes  We got report from sysbot [1] about warnings that were caused by bpf program attached to contention_begin raw tracepoint triggering the same tracepoint by using bpf_trace_printk helper that takes trace_printk_lock lock.  Call Trace: <TASK> ? trace_event_raw_event_bpf_trace_printk+0x5f/0x90 bpf_trace_printk+0x2b/0xe0 bpf_prog_a9aec6167c091eef_prog+0x1f/0x24 bpf_trace_run2+0x26/0x90 native_queued_spin_lock_slowpath+0x1c6/0x2b0 _raw_spin_lock_irqsave+0x44/0x50 bpf_trace_printk+0x3f/0xe0 bpf_prog_a9aec6167c091eef_prog+0x1f/0x24 bpf_trace_run2+0x26/0x90 native_queued_spin_lock_slowpath+0x1c6/0x2b0 _raw_spin_lock_irqsave+0x44/0x50 bpf_trace_printk+0x3f/0xe0 bpf_prog_a9aec6167c091eef_prog+0x1f/0x24 bpf_trace_run2+0x26/0x90 native_queued_spin_lock_slowpath+0x1c6/0x2b0 _raw_spin_lock_irqsave+0x44/0x50 bpf_trace_printk+0x3f/0xe0 bpf_prog_a9aec6167c091eef_prog+0x1f/0x24 bpf_trace_run2+0x26/0x90 native_queued_spin_lock_slowpath+0x1c6/0x2b0 _raw_spin_lock_irqsave+0x44/0x50 __unfreeze_partials+0x5b/0x160 ...  The can be reproduced by attaching bpf program as raw tracepoint on contention_begin tracepoint. The bpf prog calls bpf_trace_printk helper. Then by running perf bench the spin lock code is forced to take slow path and call contention_begin tracepoint.  Fixing this by skipping execution of the bpf program if it's already running, Using bpf prog 'active' field, which is being currently used by trampoline programs for the same reason.  Moving bpf_prog_inc_misses_counter to syscall.c because trampoline.c is compiled in just for CONFIG_BPF_JIT option.  [1] https://lore.kernel.org/bpf/YxhFe3EwqchC%2FfYf@krava/T/#t",
      "cve": "CVE-2022-49764",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49764",
          "value": "CVE-2022-49764",
          "url": "https://scout.docker.com/v/CVE-2022-49764?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49764?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6990d9d17fd7e82a03394c1c4fb26ec1ecfab1de91dd33b858d2cc1b6a0029d5",
      "category": "container_scanning",
      "message": "CVE-2022-49766 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netlink: Bounds-check struct nlmsgerr creation  In preparation for FORTIFY_SOURCE doing bounds-check on memcpy(), switch from __nlmsg_put to nlmsg_put(), and explain the bounds check for dealing with the memcpy() across a composite flexible array struct. Avoids this future run-time warning:  memcpy: detected field-spanning write (size 32) of single field \"&errmsg->msg\" at net/netlink/af_netlink.c:2447 (size 16)",
      "cve": "CVE-2022-49766",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49766",
          "value": "CVE-2022-49766",
          "url": "https://scout.docker.com/v/CVE-2022-49766?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49766?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d0a9612f5b22538cf139bc97d9babcc0f20e895df74837601e7cde0d31ee7df2",
      "category": "container_scanning",
      "message": "CVE-2022-49773 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix optc2_configure warning on dcn314  [Why] dcn314 uses optc2_configure_crc() that wraps optc1_configure_crc() + set additional registers not applicable to dcn314. It's not critical but when used leads to warning like: WARNING: drivers/gpu/drm/amd/amdgpu/../display/dc/dc_helper.c Call Trace: <TASK> generic_reg_set_ex+0x6d/0xe0 [amdgpu] optc2_configure_crc+0x60/0x80 [amdgpu] dc_stream_configure_crc+0x129/0x150 [amdgpu] amdgpu_dm_crtc_configure_crc_source+0x5d/0xe0 [amdgpu]  [How] Use optc1_configure_crc() directly",
      "cve": "CVE-2022-49773",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49773",
          "value": "CVE-2022-49773",
          "url": "https://scout.docker.com/v/CVE-2022-49773?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49773?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f7441b5c4476144bdfd2aa8c06ce517e665f200ef3f956c25b2e3650b9b336b7",
      "category": "container_scanning",
      "message": "CVE-2022-49783 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/fpu: Drop fpregs lock before inheriting FPU permissions  Mike Galbraith reported the following against an old fork of preempt-rt but the same issue also applies to the current preempt-rt tree.  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:46 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1, name: systemd preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 Preemption disabled at: fpu_clone CPU: 6 PID: 1 Comm: systemd Tainted: G            E       (unreleased) Call Trace: <TASK> dump_stack_lvl ? fpu_clone __might_resched rt_spin_lock fpu_clone ? copy_thread ? copy_process ? shmem_alloc_inode ? kmem_cache_alloc ? kernel_clone ? __do_sys_clone ? do_syscall_64 ? __x64_sys_rt_sigprocmask ? syscall_exit_to_user_mode ? do_syscall_64 ? syscall_exit_to_user_mode ? do_syscall_64 ? syscall_exit_to_user_mode ? do_syscall_64 ? exc_page_fault ? entry_SYSCALL_64_after_hwframe </TASK>  Mike says:  The splat comes from fpu_inherit_perms() being called under fpregs_lock(), and us reaching the spin_lock_irq() therein due to fpu_state_size_dynamic() returning true despite static key __fpu_state_size_dynamic having never been enabled.  Mike's assessment looks correct. fpregs_lock on a PREEMPT_RT kernel disables preemption so calling spin_lock_irq() in fpu_inherit_perms() is unsafe. This problem exists since commit  9e798e9aa14c (\"x86/fpu: Prepare fpu_clone() for dynamically enabled features\").  Even though the original bug report should not have enabled the paths at all, the bug still exists.  fpregs_lock is necessary when editing the FPU registers or a task's FP state but it is not necessary for fpu_inherit_perms(). The only write of any FP state in fpu_inherit_perms() is for the new child which is not running yet and cannot context switch or be borrowed by a kernel thread yet. Hence, fpregs_lock is not protecting anything in the new child until clone() completes and can be dropped earlier. The siglock still needs to be acquired by fpu_inherit_perms() as the read of the parent's permissions has to be serialised.  [ bp: Cleanup splat. ]",
      "cve": "CVE-2022-49783",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49783",
          "value": "CVE-2022-49783",
          "url": "https://scout.docker.com/v/CVE-2022-49783?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49783?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0ce08681ec917b7502f0da2a6f7f4aa30852bddd36bce3a7db8a131ee9ba3f7a",
      "category": "container_scanning",
      "message": "CVE-2022-49803 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netdevsim: Fix memory leak of nsim_dev->fa_cookie  kmemleak reports this issue:  unreferenced object 0xffff8881bac872d0 (size 8): comm \"sh\", pid 58603, jiffies 4481524462 (age 68.065s) hex dump (first 8 bytes): 04 00 00 00 de ad be ef                          ........ backtrace: [<00000000c80b8577>] __kmalloc+0x49/0x150 [<000000005292b8c6>] nsim_dev_trap_fa_cookie_write+0xc1/0x210 [netdevsim] [<0000000093d78e77>] full_proxy_write+0xf3/0x180 [<000000005a662c16>] vfs_write+0x1c5/0xaf0 [<000000007aabf84a>] ksys_write+0xed/0x1c0 [<000000005f1d2e47>] do_syscall_64+0x3b/0x90 [<000000006001c6ec>] entry_SYSCALL_64_after_hwframe+0x63/0xcd  The issue occurs in the following scenarios:  nsim_dev_trap_fa_cookie_write() kmalloc() fa_cookie nsim_dev->fa_cookie = fa_cookie .. nsim_drv_remove()  The fa_cookie allocked in nsim_dev_trap_fa_cookie_write() is not freed. To fix, add kfree(nsim_dev->fa_cookie) to nsim_drv_remove().",
      "cve": "CVE-2022-49803",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49803",
          "value": "CVE-2022-49803",
          "url": "https://scout.docker.com/v/CVE-2022-49803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fdfdbb308fe211849336d274407b78d94077fe5bc555ea8ab4ff95f346998445",
      "category": "container_scanning",
      "message": "CVE-2022-49810 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfs: Fix missing xas_retry() calls in xarray iteration  netfslib has a number of places in which it performs iteration of an xarray whilst being under the RCU read lock.  It *should* call xas_retry() as the first thing inside of the loop and do \"continue\" if it returns true in case the xarray walker passed out a special value indicating that the walk needs to be redone from the root[*].  Fix this by adding the missing retry checks.  [*] I wonder if this should be done inside xas_find(), xas_next_node() and suchlike, but I'm told that's not an simple change to effect.  This can cause an oops like that below.  Note the faulting address - this is an internal value (|0x2) returned from xarray.  BUG: kernel NULL pointer dereference, address: 0000000000000402 ... RIP: 0010:netfs_rreq_unlock+0xef/0x380 [netfs] ... Call Trace: netfs_rreq_assess+0xa6/0x240 [netfs] netfs_readpage+0x173/0x3b0 [netfs] ? init_wait_var_entry+0x50/0x50 filemap_read_page+0x33/0xf0 filemap_get_pages+0x2f2/0x3f0 filemap_read+0xaa/0x320 ? do_filp_open+0xb2/0x150 ? rmqueue+0x3be/0xe10 ceph_read_iter+0x1fe/0x680 [ceph] ? new_sync_read+0x115/0x1a0 new_sync_read+0x115/0x1a0 vfs_read+0xf3/0x180 ksys_read+0x5f/0xe0 do_syscall_64+0x38/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae  Changes: ======== ver #2) - Changed an unsigned int to a size_t to reduce the likelihood of an overflow as per Willy's suggestion. - Added an additional patch to fix the maths.",
      "cve": "CVE-2022-49810",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49810",
          "value": "CVE-2022-49810",
          "url": "https://scout.docker.com/v/CVE-2022-49810?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49810?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8346e1e6591c5590abadf2121289adf604a613aa1c5e23db2ac42855eb0e4ed4",
      "category": "container_scanning",
      "message": "CVE-2022-49829 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/scheduler: fix fence ref counting  We leaked dependency fences when processes were beeing killed.  Additional to that grab a reference to the last scheduled fence.",
      "cve": "CVE-2022-49829",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49829",
          "value": "CVE-2022-49829",
          "url": "https://scout.docker.com/v/CVE-2022-49829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6dfe2c076f73487104998dad698b0f993807b171bf03ecfdb63deec92cbd5e07",
      "category": "container_scanning",
      "message": "CVE-2022-49833 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: zoned: clone zoned device info when cloning a device  When cloning a btrfs_device, we're not cloning the associated btrfs_zoned_device_info structure of the device in case of a zoned filesystem.  Later on this leads to a NULL pointer dereference when accessing the device's zone_info for instance when setting a zone as active.  This was uncovered by fstests' testcase btrfs/161.",
      "cve": "CVE-2022-49833",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49833",
          "value": "CVE-2022-49833",
          "url": "https://scout.docker.com/v/CVE-2022-49833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9e2e59cdd1816e77560162b7d7fbafec582c6f132d8ad156b8c92c14a27f342b",
      "category": "container_scanning",
      "message": "CVE-2022-49858 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  octeontx2-pf: Fix SQE threshold checking  Current way of checking available SQE count which is based on HW updated SQB count could result in driver submitting an SQE even before CQE for the previously transmitted SQE at the same index is processed in NAPI resulting losing SKB pointers, hence a leak. Fix this by checking a consumer index which is updated once CQE is processed.",
      "cve": "CVE-2022-49858",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49858",
          "value": "CVE-2022-49858",
          "url": "https://scout.docker.com/v/CVE-2022-49858?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49858?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eef08ec3f6d2d59ed5d3c90d46028408e6a03e7ee9c448768e8b137c32d21673",
      "category": "container_scanning",
      "message": "CVE-2022-49910 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: L2CAP: Fix use-after-free caused by l2cap_reassemble_sdu  Fix the race condition between the following two flows that run in parallel:  1. l2cap_reassemble_sdu -> chan->ops->recv (l2cap_sock_recv_cb) -> __sock_queue_rcv_skb.  2. bt_sock_recvmsg -> skb_recv_datagram, skb_free_datagram.  An SKB can be queued by the first flow and immediately dequeued and freed by the second flow, therefore the callers of l2cap_reassemble_sdu can't use the SKB after that function returns. However, some places continue accessing struct l2cap_ctrl that resides in the SKB's CB for a short time after l2cap_reassemble_sdu returns, leading to a use-after-free condition (the stack trace is below, line numbers for kernel 5.19.8).  Fix it by keeping a local copy of struct l2cap_ctrl.  BUG: KASAN: use-after-free in l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth Read of size 1 at addr ffff88812025f2f0 by task kworker/u17:3/43169  Workqueue: hci0 hci_rx_work [bluetooth] Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:107 (discriminator 4)) print_report.cold (mm/kasan/report.c:314 mm/kasan/report.c:429) ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth kasan_report (mm/kasan/report.c:162 mm/kasan/report.c:493) ? l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth l2cap_rx_state_recv (net/bluetooth/l2cap_core.c:6906) bluetooth l2cap_rx (net/bluetooth/l2cap_core.c:7236 net/bluetooth/l2cap_core.c:7271) bluetooth ret_from_fork (arch/x86/entry/entry_64.S:306) </TASK>  Allocated by task 43169: kasan_save_stack (mm/kasan/common.c:39) __kasan_slab_alloc (mm/kasan/common.c:45 mm/kasan/common.c:436 mm/kasan/common.c:469) kmem_cache_alloc_node (mm/slab.h:750 mm/slub.c:3243 mm/slub.c:3293) __alloc_skb (net/core/skbuff.c:414) l2cap_recv_frag (./include/net/bluetooth/bluetooth.h:425 net/bluetooth/l2cap_core.c:8329) bluetooth l2cap_recv_acldata (net/bluetooth/l2cap_core.c:8442) bluetooth hci_rx_work (net/bluetooth/hci_core.c:3642 net/bluetooth/hci_core.c:3832) bluetooth process_one_work (kernel/workqueue.c:2289) worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2437) kthread (kernel/kthread.c:376) ret_from_fork (arch/x86/entry/entry_64.S:306)  Freed by task 27920: kasan_save_stack (mm/kasan/common.c:39) kasan_set_track (mm/kasan/common.c:45) kasan_set_free_info (mm/kasan/generic.c:372) ____kasan_slab_free (mm/kasan/common.c:368 mm/kasan/common.c:328) slab_free_freelist_hook (mm/slub.c:1780) kmem_cache_free (mm/slub.c:3536 mm/slub.c:3553) skb_free_datagram (./include/net/sock.h:1578 ./include/net/sock.h:1639 net/core/datagram.c:323) bt_sock_recvmsg (net/bluetooth/af_bluetooth.c:295) bluetooth l2cap_sock_recvmsg (net/bluetooth/l2cap_sock.c:1212) bluetooth sock_read_iter (net/socket.c:1087) new_sync_read (./include/linux/fs.h:2052 fs/read_write.c:401) vfs_read (fs/read_write.c:482) ksys_read (fs/read_write.c:620) do_syscall_64 (arch/x86/entry/common.c:50 arch/x86/entry/common.c:80) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:120)",
      "cve": "CVE-2022-49910",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49910",
          "value": "CVE-2022-49910",
          "url": "https://scout.docker.com/v/CVE-2022-49910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0e86cba8144c13350f5df54281e1b41fe9ceef28ab69d6b489efda1e278729b7",
      "category": "container_scanning",
      "message": "CVE-2022-49932 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: VMX: Do _all_ initialization before exposing /dev/kvm to userspace  Call kvm_init() only after _all_ setup is complete, as kvm_init() exposes /dev/kvm to userspace and thus allows userspace to create VMs (and call other ioctls).  E.g. KVM will encounter a NULL pointer when attempting to add a vCPU to the per-CPU loaded_vmcss_on_cpu list if userspace is able to create a VM before vmx_init() configures said list.  BUG: kernel NULL pointer dereference, address: 0000000000000008 #PF: supervisor write access in kernel mode #PF: error_code(0x0002) - not-present page PGD 0 P4D 0 Oops: 0002 [#1] SMP CPU: 6 PID: 1143 Comm: stable Not tainted 6.0.0-rc7+ #988 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 RIP: 0010:vmx_vcpu_load_vmcs+0x68/0x230 [kvm_intel] <TASK> vmx_vcpu_load+0x16/0x60 [kvm_intel] kvm_arch_vcpu_load+0x32/0x1f0 [kvm] vcpu_load+0x2f/0x40 [kvm] kvm_arch_vcpu_create+0x231/0x310 [kvm] kvm_vm_ioctl+0x79f/0xe10 [kvm] ? handle_mm_fault+0xb1/0x220 __x64_sys_ioctl+0x80/0xb0 do_syscall_64+0x2b/0x50 entry_SYSCALL_64_after_hwframe+0x46/0xb0 RIP: 0033:0x7f5a6b05743b </TASK> Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel(+) kvm irqbypass",
      "cve": "CVE-2022-49932",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49932",
          "value": "CVE-2022-49932",
          "url": "https://scout.docker.com/v/CVE-2022-49932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e15bfa4dad1868bf9fe9d207833a419df74a6bc0ea2828f39a012868a86182e6",
      "category": "container_scanning",
      "message": "CVE-2022-49933 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-49933",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49933",
          "value": "CVE-2022-49933",
          "url": "https://scout.docker.com/v/CVE-2022-49933?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49933?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f9fc53a5bd0806d4348e304a8060f13097bfc6cd430c2a05d7966ee32924e368",
      "category": "container_scanning",
      "message": "CVE-2022-49935 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dma-buf/dma-resv: check if the new fence is really later  Previously when we added a fence to a dma_resv object we always assumed the the newer than all the existing fences.  With Jason's work to add an UAPI to explicit export/import that's not necessary the case any more. So without this check we would allow userspace to force the kernel into an use after free error.  Since the change is very small and defensive it's probably a good idea to backport this to stable kernels as well just in case others are using the dma_resv object in the same way.",
      "cve": "CVE-2022-49935",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49935",
          "value": "CVE-2022-49935",
          "url": "https://scout.docker.com/v/CVE-2022-49935?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49935?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "590a8a4d60255c4f2080473ec0fa33447488e7e1ebe177d0e92b22be0561db97",
      "category": "container_scanning",
      "message": "CVE-2022-49940 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tty: n_gsm: add sanity check for gsm->receive in gsm_receive_buf()  A null pointer dereference can happen when attempting to access the \"gsm->receive()\" function in gsmld_receive_buf(). Currently, the code assumes that gsm->recieve is only called after MUX activation. Since the gsmld_receive_buf() function can be accessed without the need to initialize the MUX, the gsm->receive() function will not be set and a NULL pointer dereference will occur.  Fix this by avoiding the call to \"gsm->receive()\" in case the function is not initialized by adding a sanity check.  Call Trace: <TASK> gsmld_receive_buf+0x1c2/0x2f0 drivers/tty/n_gsm.c:2861 tiocsti drivers/tty/tty_io.c:2293 [inline] tty_ioctl+0xa75/0x15d0 drivers/tty/tty_io.c:2692 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:870 [inline] __se_sys_ioctl fs/ioctl.c:856 [inline] __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:856 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "cve": "CVE-2022-49940",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49940",
          "value": "CVE-2022-49940",
          "url": "https://scout.docker.com/v/CVE-2022-49940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1530a05ded87e4f06a8cc9c2bf7df14514bbf7eadfed1663e5fe430a7dc2d5af",
      "category": "container_scanning",
      "message": "CVE-2022-49941 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-49941",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49941",
          "value": "CVE-2022-49941",
          "url": "https://scout.docker.com/v/CVE-2022-49941?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49941?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "acb006471a286b9c280a9977091e12a100654981b8c3d761fdab0b235f71c31b",
      "category": "container_scanning",
      "message": "CVE-2022-49943 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  USB: gadget: Fix obscure lockdep violation for udc_mutex  A recent commit expanding the scope of the udc_lock mutex in the gadget core managed to cause an obscure and slightly bizarre lockdep violation.  In abbreviated form:  ====================================================== WARNING: possible circular locking dependency detected 5.19.0-rc7+ #12510 Not tainted ------------------------------------------------------ udevadm/312 is trying to acquire lock: ffff80000aae1058 (udc_lock){+.+.}-{3:3}, at: usb_udc_uevent+0x54/0xe0  but task is already holding lock: ffff000002277548 (kn->active#4){++++}-{0:0}, at: kernfs_seq_start+0x34/0xe0  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #3 (kn->active#4){++++}-{0:0}: lock_acquire+0x68/0x84 __kernfs_remove+0x268/0x380 kernfs_remove_by_name_ns+0x58/0xac sysfs_remove_file_ns+0x18/0x24 device_del+0x15c/0x440  -> #2 (device_links_lock){+.+.}-{3:3}: lock_acquire+0x68/0x84 __mutex_lock+0x9c/0x430 mutex_lock_nested+0x38/0x64 device_link_remove+0x3c/0xa0 _regulator_put.part.0+0x168/0x190 regulator_put+0x3c/0x54 devm_regulator_release+0x14/0x20  -> #1 (regulator_list_mutex){+.+.}-{3:3}: lock_acquire+0x68/0x84 __mutex_lock+0x9c/0x430 mutex_lock_nested+0x38/0x64 regulator_lock_dependent+0x54/0x284 regulator_enable+0x34/0x80 phy_power_on+0x24/0x130 __dwc2_lowlevel_hw_enable+0x100/0x130 dwc2_lowlevel_hw_enable+0x18/0x40 dwc2_hsotg_udc_start+0x6c/0x2f0 gadget_bind_driver+0x124/0x1f4  -> #0 (udc_lock){+.+.}-{3:3}: __lock_acquire+0x1298/0x20cc lock_acquire.part.0+0xe0/0x230 lock_acquire+0x68/0x84 __mutex_lock+0x9c/0x430 mutex_lock_nested+0x38/0x64 usb_udc_uevent+0x54/0xe0  Evidently this was caused by the scope of udc_mutex being too large. The mutex is only meant to protect udc->driver along with a few other things.  As far as I can tell, there's no reason for the mutex to be held while the gadget core calls a gadget driver's ->bind or ->unbind routine, or while a UDC is being started or stopped.  (This accounts for link #1 in the chain above, where the mutex is held while the dwc2_hsotg_udc is started as part of driver probing.)  Gadget drivers' ->disconnect callbacks are problematic.  Even though usb_gadget_disconnect() will now acquire the udc_mutex, there's a window in usb_gadget_bind_driver() between the times when the mutex is released and the ->bind callback is invoked.  If a disconnect occurred during that window, we could call the driver's ->disconnect routine before its ->bind routine.  To prevent this from happening, it will be necessary to prevent a UDC from connecting while it has no gadget driver.  This should be done already but it doesn't seem to be; currently usb_gadget_connect() has no check for this.  Such a check will have to be added later.  Some degree of mutual exclusion is required in soft_connect_store(), which can dereference udc->driver at arbitrary times since it is a sysfs callback.  The solution here is to acquire the gadget's device lock rather than the udc_mutex.  Since the driver core guarantees that the device lock is always held during driver binding and unbinding, this will make the accesses in soft_connect_store() mutually exclusive with any changes to udc->driver.  Lastly, it turns out there is one place which should hold the udc_mutex but currently does not: The function_show() routine needs protection while it dereferences udc->driver.  The missing lock and unlock calls are added.",
      "cve": "CVE-2022-49943",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49943",
          "value": "CVE-2022-49943",
          "url": "https://scout.docker.com/v/CVE-2022-49943?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49943?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d478cb9efd00dcd25ccd0e457421bea8f0c4f3b7107aa6737f0ebb1b470cf381",
      "category": "container_scanning",
      "message": "CVE-2022-49955 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/rtas: Fix RTAS MSR[HV] handling for Cell  The semi-recent changes to MSR handling when entering RTAS (firmware) cause crashes on IBM Cell machines. An example trace:  kernel tried to execute user page (2fff01a8) - exploit attempt? (uid: 0) BUG: Unable to handle kernel instruction fetch Faulting instruction address: 0x2fff01a8 Oops: Kernel access of bad area, sig: 11 [#1] BE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=4 NUMA Cell Modules linked in: CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W 6.0.0-rc2-00433-gede0a8d3307a #207 NIP:  000000002fff01a8 LR: 0000000000032608 CTR: 0000000000000000 REGS: c0000000015236b0 TRAP: 0400   Tainted: G        W (6.0.0-rc2-00433-gede0a8d3307a) MSR:  0000000008001002 <ME,RI>  CR: 00000000  XER: 20000000 ... NIP 0x2fff01a8 LR  0x32608 Call Trace: 0xc00000000143c5f8 (unreliable) .rtas_call+0x224/0x320 .rtas_get_boot_time+0x70/0x150 .read_persistent_clock64+0x114/0x140 .read_persistent_wall_and_boot_offset+0x24/0x80 .timekeeping_init+0x40/0x29c .start_kernel+0x674/0x8f0 start_here_common+0x1c/0x50  Unlike PAPR platforms where RTAS is only used in guests, on the IBM Cell machines Linux runs with MSR[HV] set but also uses RTAS, provided by SLOF.  Fix it by copying the MSR[HV] bit from the MSR value we've just read using mfmsr into the value used for RTAS.  It seems like we could also fix it using an #ifdef CELL to set MSR[HV], but that doesn't work because it's possible to build a single kernel image that runs on both Cell native and pseries.",
      "cve": "CVE-2022-49955",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49955",
          "value": "CVE-2022-49955",
          "url": "https://scout.docker.com/v/CVE-2022-49955?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49955?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f926351abff9476b68f6f09c8f2ccb57191665a6753a274fe2ee755fb8ec0e39",
      "category": "container_scanning",
      "message": "CVE-2022-49961 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Do mark_chain_precision for ARG_CONST_ALLOC_SIZE_OR_ZERO  Precision markers need to be propagated whenever we have an ARG_CONST_* style argument, as the verifier cannot consider imprecise scalars to be equivalent for the purposes of states_equal check when such arguments refine the return value (in this case, set mem_size for PTR_TO_MEM). The resultant mem_size for the R0 is derived from the constant value, and if the verifier incorrectly prunes states considering them equivalent where such arguments exist (by seeing that both registers have reg->precise as false in regsafe), we can end up with invalid programs passing the verifier which can do access beyond what should have been the correct mem_size in that explored state.  To show a concrete example of the problem:  0000000000000000 <prog>: 0:       r2 = *(u32 *)(r1 + 80) 1:       r1 = *(u32 *)(r1 + 76) 2:       r3 = r1 3:       r3 += 4 4:       if r3 > r2 goto +18 <LBB5_5> 5:       w2 = 0 6:       *(u32 *)(r1 + 0) = r2 7:       r1 = *(u32 *)(r1 + 0) 8:       r2 = 1 9:       if w1 == 0 goto +1 <LBB5_3> 10:       r2 = -1  0000000000000058 <LBB5_3>: 11:       r1 = 0 ll 13:       r3 = 0 14:       call bpf_ringbuf_reserve 15:       if r0 == 0 goto +7 <LBB5_5> 16:       r1 = r0 17:       r1 += 16777215 18:       w2 = 0 19:       *(u8 *)(r1 + 0) = r2 20:       r1 = r0 21:       r2 = 0 22:       call bpf_ringbuf_submit  00000000000000b8 <LBB5_5>: 23:       w0 = 0 24:       exit  For the first case, the single line execution's exploration will prune the search at insn 14 for the branch insn 9's second leg as it will be verified first using r2 = -1 (UINT_MAX), while as w1 at insn 9 will always be 0 so at runtime we don't get error for being greater than UINT_MAX/4 from bpf_ringbuf_reserve. The verifier during regsafe just sees reg->precise as false for both r2 registers in both states, hence considers them equal for purposes of states_equal.  If we propagated precise markers using the backtracking support, we would use the precise marking to then ensure that old r2 (UINT_MAX) was within the new r2 (1) and this would never be true, so the verification would rightfully fail.  The end result is that the out of bounds access at instruction 19 would be permitted without this fix.  Note that reg->precise is always set to true when user does not have CAP_BPF (or when subprog count is greater than 1 (i.e. use of any static or global functions)), hence this is only a problem when precision marks need to be explicitly propagated (i.e. privileged users with CAP_BPF).  A simplified test case has been included in the next patch to prevent future regressions.",
      "cve": "CVE-2022-49961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49961",
          "value": "CVE-2022-49961",
          "url": "https://scout.docker.com/v/CVE-2022-49961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "852bb4d059d0db212d766636accdc9ffb5977d5c4549747baaff45500967e24d",
      "category": "container_scanning",
      "message": "CVE-2022-49965 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: add missing ->fini_xxxx interfaces for some SMU13 asics  Without these, potential memory leak may be induced.",
      "cve": "CVE-2022-49965",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49965",
          "value": "CVE-2022-49965",
          "url": "https://scout.docker.com/v/CVE-2022-49965?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49965?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "099dea0e39487cab849412b66c03087cdf3d8d01de9254e5901374333fb99888",
      "category": "container_scanning",
      "message": "CVE-2022-49967 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix a data-race around bpf_jit_limit.  While reading bpf_jit_limit, it can be changed concurrently via sysctl, WRITE_ONCE() in __do_proc_doulongvec_minmax(). The size of bpf_jit_limit is long, so we need to add a paired READ_ONCE() to avoid load-tearing.",
      "cve": "CVE-2022-49967",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49967",
          "value": "CVE-2022-49967",
          "url": "https://scout.docker.com/v/CVE-2022-49967?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49967?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c6bb63ee7f0e6fcac664140d9151501343e29d15147bbd4d02de543f24193680",
      "category": "container_scanning",
      "message": "CVE-2022-49971 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: Fix a potential gpu_metrics_table memory leak  Memory is allocated for gpu_metrics_table in smu_v13_0_4_init_smc_tables(), but not freed in smu_v13_0_4_fini_smc_tables(). This may cause memory leaks, fix it.",
      "cve": "CVE-2022-49971",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49971",
          "value": "CVE-2022-49971",
          "url": "https://scout.docker.com/v/CVE-2022-49971?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49971?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9b54f99618a2ae22640c16adbc766d5ad63a41a89a479960e07f8991b8f9658b",
      "category": "container_scanning",
      "message": "CVE-2022-49974 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: nintendo: fix rumble worker null pointer deref  We can dereference a null pointer trying to queue work to a destroyed workqueue.  If the device is disconnected, nintendo_hid_remove is called, in which the rumble_queue is destroyed. Avoid using that queue to defer rumble work once the controller state is set to JOYCON_CTLR_STATE_REMOVED.  This eliminates the null pointer dereference.",
      "cve": "CVE-2022-49974",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49974",
          "value": "CVE-2022-49974",
          "url": "https://scout.docker.com/v/CVE-2022-49974?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49974?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "87a2e8b786d835e0b1015d5540118a335eea2712b3adf191043db98209de5b67",
      "category": "container_scanning",
      "message": "CVE-2022-49980 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  USB: gadget: Fix use-after-free Read in usb_udc_uevent()  The syzbot fuzzer found a race between uevent callbacks and gadget driver unregistration that can cause a use-after-free bug:  --------------------------------------------------------------- BUG: KASAN: use-after-free in usb_udc_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732 Read of size 8 at addr ffff888078ce2050 by task udevd/2968  CPU: 1 PID: 2968 Comm: udevd Not tainted 5.19.0-rc4-next-20220628-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/29/2022 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:317 [inline] print_report.cold+0x2ba/0x719 mm/kasan/report.c:433 kasan_report+0xbe/0x1f0 mm/kasan/report.c:495 usb_udc_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732 dev_uevent+0x290/0x770 drivers/base/core.c:2424 ---------------------------------------------------------------  The bug occurs because usb_udc_uevent() dereferences udc->driver but does so without acquiring the udc_lock mutex, which protects this field.  If the gadget driver is unbound from the udc concurrently with uevent processing, the driver structure may be accessed after it has been deallocated.  To prevent the race, we make sure that the routine holds the mutex around the racing accesses.",
      "cve": "CVE-2022-49980",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49980",
          "value": "CVE-2022-49980",
          "url": "https://scout.docker.com/v/CVE-2022-49980?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49980?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c9c3fe2f4bb071177189a489ea92e78d3fa02a08369a5c211d14d872f3ca0dc2",
      "category": "container_scanning",
      "message": "CVE-2022-49997 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: lantiq_xrx200: restore buffer if memory allocation failed  In a situation where memory allocation fails, an invalid buffer address is stored. When this descriptor is used again, the system panics in the build_skb() function when accessing memory.",
      "cve": "CVE-2022-49997",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49997",
          "value": "CVE-2022-49997",
          "url": "https://scout.docker.com/v/CVE-2022-49997?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49997?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ddcff8c40f6fc5fd5365edd86e5fa612beeb1b95923b2bbebf31cdaafbe54531",
      "category": "container_scanning",
      "message": "CVE-2022-50002 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: LAG, fix logic over MLX5_LAG_FLAG_NDEVS_READY  Only set MLX5_LAG_FLAG_NDEVS_READY if both netdevices are registered. Doing so guarantees that both ldev->pf[MLX5_LAG_P0].dev and ldev->pf[MLX5_LAG_P1].dev have valid pointers when MLX5_LAG_FLAG_NDEVS_READY is set.  The core issue is asymmetry in setting MLX5_LAG_FLAG_NDEVS_READY and clearing it. Setting it is done wrongly when both ldev->pf[MLX5_LAG_P0].dev and ldev->pf[MLX5_LAG_P1].dev are set; clearing it is done right when either of ldev->pf[i].netdev is cleared.  Consider the following scenario: 1. PF0 loads and sets ldev->pf[MLX5_LAG_P0].dev to a valid pointer 2. PF1 loads and sets both ldev->pf[MLX5_LAG_P1].dev and ldev->pf[MLX5_LAG_P1].netdev with valid pointers. This results in MLX5_LAG_FLAG_NDEVS_READY is set. 3. PF0 is unloaded before setting dev->pf[MLX5_LAG_P0].netdev. MLX5_LAG_FLAG_NDEVS_READY remains set.  Further execution of mlx5_do_bond() will result in null pointer dereference when calling mlx5_lag_is_multipath()  This patch fixes the following call trace actually encountered:  [ 1293.475195] BUG: kernel NULL pointer dereference, address: 00000000000009a8 [ 1293.478756] #PF: supervisor read access in kernel mode [ 1293.481320] #PF: error_code(0x0000) - not-present page [ 1293.483686] PGD 0 P4D 0 [ 1293.484434] Oops: 0000 [#1] SMP PTI [ 1293.485377] CPU: 1 PID: 23690 Comm: kworker/u16:2 Not tainted 5.18.0-rc5_for_upstream_min_debug_2022_05_05_10_13 #1 [ 1293.488039] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 1293.490836] Workqueue: mlx5_lag mlx5_do_bond_work [mlx5_core] [ 1293.492448] RIP: 0010:mlx5_lag_is_multipath+0x5/0x50 [mlx5_core] [ 1293.494044] Code: e8 70 40 ff e0 48 8b 14 24 48 83 05 5c 1a 1b 00 01 e9 19 ff ff ff 48 83 05 47 1a 1b 00 01 eb d7 0f 1f 44 00 00 0f 1f 44 00 00 <48> 8b 87 a8 09 00 00 48 85 c0 74 26 48 83 05 a7 1b 1b 00 01 41 b8 [ 1293.498673] RSP: 0018:ffff88811b2fbe40 EFLAGS: 00010202 [ 1293.500152] RAX: ffff88818a94e1c0 RBX: ffff888165eca6c0 RCX: 0000000000000000 [ 1293.501841] RDX: 0000000000000001 RSI: ffff88818a94e1c0 RDI: 0000000000000000 [ 1293.503585] RBP: 0000000000000000 R08: ffff888119886740 R09: ffff888165eca73c [ 1293.505286] R10: 0000000000000018 R11: 0000000000000018 R12: ffff88818a94e1c0 [ 1293.506979] R13: ffff888112729800 R14: 0000000000000000 R15: ffff888112729858 [ 1293.508753] FS:  0000000000000000(0000) GS:ffff88852cc40000(0000) knlGS:0000000000000000 [ 1293.510782] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1293.512265] CR2: 00000000000009a8 CR3: 00000001032d4002 CR4: 0000000000370ea0 [ 1293.514001] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 1293.515806] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400",
      "cve": "CVE-2022-50002",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50002",
          "value": "CVE-2022-50002",
          "url": "https://scout.docker.com/v/CVE-2022-50002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "68fdf14dd0f3089dd21e8437335bc88b20ee644e09b7c53b876c81f7324d3aaa",
      "category": "container_scanning",
      "message": "CVE-2022-50009 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix null-ptr-deref in f2fs_get_dnode_of_data  There is issue as follows when test f2fs atomic write: F2FS-fs (loop0): Can't find valid F2FS filesystem in 2th superblock F2FS-fs (loop0): invalid crc_offset: 0 F2FS-fs (loop0): f2fs_check_nid_range: out-of-range nid=1, run fsck to fix. F2FS-fs (loop0): f2fs_check_nid_range: out-of-range nid=2, run fsck to fix. ================================================================== BUG: KASAN: null-ptr-deref in f2fs_get_dnode_of_data+0xac/0x16d0 Read of size 8 at addr 0000000000000028 by task rep/1990  CPU: 4 PID: 1990 Comm: rep Not tainted 5.19.0-rc6-next-20220715 #266 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report.cold+0x49a/0x6bb kasan_report+0xa8/0x130 f2fs_get_dnode_of_data+0xac/0x16d0 f2fs_do_write_data_page+0x2a5/0x1030 move_data_page+0x3c5/0xdf0 do_garbage_collect+0x2015/0x36c0 f2fs_gc+0x554/0x1d30 f2fs_balance_fs+0x7f5/0xda0 f2fs_write_single_data_page+0xb66/0xdc0 f2fs_write_cache_pages+0x716/0x1420 f2fs_write_data_pages+0x84f/0x9a0 do_writepages+0x130/0x3a0 filemap_fdatawrite_wbc+0x87/0xa0 file_write_and_wait_range+0x157/0x1c0 f2fs_do_sync_file+0x206/0x12d0 f2fs_sync_file+0x99/0xc0 vfs_fsync_range+0x75/0x140 f2fs_file_write_iter+0xd7b/0x1850 vfs_write+0x645/0x780 ksys_write+0xf1/0x1e0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd  As 3db1de0e582c commit changed atomic write way which new a cow_inode for atomic write file, and also mark cow_inode as FI_ATOMIC_FILE. When f2fs_do_write_data_page write cow_inode will use cow_inode's cow_inode which is NULL. Then will trigger null-ptr-deref. To solve above issue, introduce FI_COW_FILE flag for COW inode.  Fiexes: 3db1de0e582c(\"f2fs: change the current atomic write way\")",
      "cve": "CVE-2022-50009",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50009",
          "value": "CVE-2022-50009",
          "url": "https://scout.docker.com/v/CVE-2022-50009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f49c40e31b3440303878a971df757020b0f576241088a78ef461a967c3324e35",
      "category": "container_scanning",
      "message": "CVE-2022-50015 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: Intel: hda-ipc: Do not process IPC reply before firmware boot  It is not yet clear, but it is possible to create a firmware so broken that it will send a reply message before a FW_READY message (it is not yet clear if FW_READY will arrive later). Since the reply_data is allocated only after the FW_READY message, this will lead to a NULL pointer dereference if not filtered out.  The issue was reported with IPC4 firmware but the same condition is present for IPC3.",
      "cve": "CVE-2022-50015",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50015",
          "value": "CVE-2022-50015",
          "url": "https://scout.docker.com/v/CVE-2022-50015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c9939af52cdeeeb306b3ca6d26f8be0f4cbda953372415d605064cd46be203ba",
      "category": "container_scanning",
      "message": "CVE-2022-50016 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: Intel: cnl: Do not process IPC reply before firmware boot  It is not yet clear, but it is possible to create a firmware so broken that it will send a reply message before a FW_READY message (it is not yet clear if FW_READY will arrive later). Since the reply_data is allocated only after the FW_READY message, this will lead to a NULL pointer dereference if not filtered out.  The issue was reported with IPC4 firmware but the same condition is present for IPC3.",
      "cve": "CVE-2022-50016",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50016",
          "value": "CVE-2022-50016",
          "url": "https://scout.docker.com/v/CVE-2022-50016?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50016?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a8d9c248ff86eeb21401fa6400e02646fab0397dd52ddc66ff6cc1118b18c884",
      "category": "container_scanning",
      "message": "CVE-2022-50018 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-50018",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50018",
          "value": "CVE-2022-50018",
          "url": "https://scout.docker.com/v/CVE-2022-50018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c8cbbcb2b04dfa4305187151ffda0bcd6ce07d27e55e5a422d0613efc3fb5873",
      "category": "container_scanning",
      "message": "CVE-2022-50031 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: iscsi: Fix HW conn removal use after free  If qla4xxx doesn't remove the connection before the session, the iSCSI class tries to remove the connection for it. We were doing a iscsi_put_conn() in the iter function which is not needed and will result in a use after free because iscsi_remove_conn() will free the connection.",
      "cve": "CVE-2022-50031",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50031",
          "value": "CVE-2022-50031",
          "url": "https://scout.docker.com/v/CVE-2022-50031?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50031?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "981c6ca32c9e14ce37632f574dc1faa5cafea238213d52ae5a80c089238b1440",
      "category": "container_scanning",
      "message": "CVE-2022-50071 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mptcp: move subflow cleanup in mptcp_destroy_common()  If the mptcp socket creation fails due to a CGROUP_INET_SOCK_CREATE eBPF program, the MPTCP protocol ends-up leaking all the subflows: the related cleanup happens in __mptcp_destroy_sock() that is not invoked in such code path.  Address the issue moving the subflow sockets cleanup in the mptcp_destroy_common() helper, which is invoked in every msk cleanup path.  Additionally get rid of the intermediate list_splice_init step, which is an unneeded relic from the past.  The issue is present since before the reported root cause commit, but any attempt to backport the fix before that hash will require a complete rewrite.",
      "cve": "CVE-2022-50071",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50071",
          "value": "CVE-2022-50071",
          "url": "https://scout.docker.com/v/CVE-2022-50071?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50071?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "136f4fc2a9206a43577c3acb7044b632101da130269bfaff2517fa857477a442",
      "category": "container_scanning",
      "message": "CVE-2022-50073 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: tap: NULL pointer derefence in dev_parse_header_protocol when skb->dev is null  Fixes a NULL pointer derefence bug triggered from tap driver. When tap_get_user calls virtio_net_hdr_to_skb the skb->dev is null (in tap.c skb->dev is set after the call to virtio_net_hdr_to_skb) virtio_net_hdr_to_skb calls dev_parse_header_protocol which needs skb->dev field to be valid.  The line that trigers the bug is in dev_parse_header_protocol (dev is at offset 0x10 from skb and is stored in RAX register) if (!dev->header_ops || !dev->header_ops->parse_protocol) 22e1:   mov    0x10(%rbx),%rax 22e5:\t  mov    0x230(%rax),%rax  Setting skb->dev before the call in tap.c fixes the issue.  BUG: kernel NULL pointer dereference, address: 0000000000000230 RIP: 0010:virtio_net_hdr_to_skb.constprop.0+0x335/0x410 [tap] Code: c0 0f 85 b7 fd ff ff eb d4 41 39 c6 77 cf 29 c6 48 89 df 44 01 f6 e8 7a 79 83 c1 48 85 c0 0f 85 d9 fd ff ff eb b7 48 8b 43 10 <48> 8b 80 30 02 00 00 48 85 c0 74 55 48 8b 40 28 48 85 c0 74 4c 48 RSP: 0018:ffffc90005c27c38 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff888298f25300 RCX: 0000000000000010 RDX: 0000000000000005 RSI: ffffc90005c27cb6 RDI: ffff888298f25300 RBP: ffffc90005c27c80 R08: 00000000ffffffea R09: 00000000000007e8 R10: ffff88858ec77458 R11: 0000000000000000 R12: 0000000000000001 R13: 0000000000000014 R14: ffffc90005c27e08 R15: ffffc90005c27cb6 FS:  0000000000000000(0000) GS:ffff88858ec40000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000230 CR3: 0000000281408006 CR4: 00000000003706e0 Call Trace: tap_get_user+0x3f1/0x540 [tap] tap_sendmsg+0x56/0x362 [tap] ? get_tx_bufs+0xc2/0x1e0 [vhost_net] handle_tx_copy+0x114/0x670 [vhost_net] handle_tx+0xb0/0xe0 [vhost_net] handle_tx_kick+0x15/0x20 [vhost_net] vhost_worker+0x7b/0xc0 [vhost] ? vhost_vring_call_reset+0x40/0x40 [vhost] kthread+0xfa/0x120 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x1f/0x30",
      "cve": "CVE-2022-50073",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50073",
          "value": "CVE-2022-50073",
          "url": "https://scout.docker.com/v/CVE-2022-50073?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50073?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4031bc8385b79f8fa70e7f3972a86e6f3133c9efe3c6710d5b0cf682afaf7741",
      "category": "container_scanning",
      "message": "CVE-2022-50090 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size  On zoned filesystem, data write out is limited by max_zone_append_size, and a large ordered extent is split according the size of a bio. OTOH, the number of extents to be written is calculated using BTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the metadata bytes to update and/or create the metadata items.  The metadata reservation is done at e.g, btrfs_buffered_write() and then released according to the estimation changes. Thus, if the number of extent increases massively, the reserved metadata can run out.  The increase of the number of extents easily occurs on zoned filesystem if BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the following warning on a small RAM environment with disabling metadata over-commit (in the following patch).  [75721.498492] ------------[ cut here ]------------ [75721.505624] BTRFS: block rsv 1 returned -28 [75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs] [75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109 [75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021 [75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs] [75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs] [75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286 [75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000 [75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e [75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7 [75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28 [75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a [75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000 [75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0 [75721.730499] Call Trace: [75721.735166]  <TASK> [75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs] [75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs] [75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs] [75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs] [75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs] [75721.776431]  ? memcpy+0x4e/0x60 [75721.781931]  split_leaf+0x433/0x12d0 [btrfs] [75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs] [75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs] [75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs] [75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs] [75721.818300]  ? lock_downgrade+0x7c0/0x7c0 [75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs] [75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs] [75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs] [75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs] [75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs] [75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs] [75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80 [75721.876085]  ? lock_release+0x552/0xf80 [75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs] [75721.888886]  ? __kasan_check_write+0x14/0x20 [75721.895152]  ? do_raw_read_unlock+0x44/0x80 [75721.901323]  ? _raw_write_lock_irq+0x60/0x80 [75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs] [75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs] [75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs] [75721.929166]  ? _raw_write_unlock+0x23/0x40 [75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs] [75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs] [75721.949906]  ? try_to_wake_up+0x30/0x14a0 [75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs] [75721.962661]  ? rcu ---truncated---",
      "cve": "CVE-2022-50090",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50090",
          "value": "CVE-2022-50090",
          "url": "https://scout.docker.com/v/CVE-2022-50090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6375557f1c1f6b5d053e998b3d427a52e2bb4e4f563086daa867ded7f1a676d2",
      "category": "container_scanning",
      "message": "CVE-2022-50095 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  posix-cpu-timers: Cleanup CPU timers before freeing them during exec  Commit 55e8c8eb2c7b (\"posix-cpu-timers: Store a reference to a pid not a task\") started looking up tasks by PID when deleting a CPU timer.  When a non-leader thread calls execve, it will switch PIDs with the leader process. Then, as it calls exit_itimers, posix_cpu_timer_del cannot find the task because the timer still points out to the old PID.  That means that armed timers won't be disarmed, that is, they won't be removed from the timerqueue_list. exit_itimers will still release their memory, and when that list is later processed, it leads to a use-after-free.  Clean up the timers from the de-threaded task before freeing them. This prevents a reported use-after-free.",
      "cve": "CVE-2022-50095",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50095",
          "value": "CVE-2022-50095",
          "url": "https://scout.docker.com/v/CVE-2022-50095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a66bc3dc844bd3a1f8752b634990ebb0ae3e163735f1f766a1b8cfb0c795ac2",
      "category": "container_scanning",
      "message": "CVE-2022-50116 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tty: n_gsm: fix deadlock and link starvation in outgoing data path  The current implementation queues up new control and user packets as needed and processes this queue down to the ldisc in the same code path. That means that the upper and the lower layer are hard coupled in the code. Due to this deadlocks can happen as seen below while transmitting data, especially during ldisc congestion. Furthermore, the data channels starve the control channel on high transmission load on the ldisc.  Introduce an additional control channel data queue to prevent timeouts and link hangups during ldisc congestion. This is being processed before the user channel data queue in gsm_data_kick(), i.e. with the highest priority. Put the queue to ldisc data path into a workqueue and trigger it whenever new data has been put into the transmission queue. Change gsm_dlci_data_sweep() accordingly to fill up the transmission queue until TX_THRESH_HI. This solves the locking issue, keeps latency low and provides good performance on high data load. Note that now all packets from a DLCI are removed from the internal queue if the associated DLCI was closed. This ensures that no data is sent by the introduced write task to an already closed DLCI.  BUG: spinlock recursion on CPU#0, test_v24_loop/124 lock: serial8250_ports+0x3a8/0x7500, .magic: dead4ead, .owner: test_v24_loop/124, .owner_cpu: 0 CPU: 0 PID: 124 Comm: test_v24_loop Tainted: G           O      5.18.0-rc2 #3 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace: <IRQ> dump_stack_lvl+0x34/0x44 do_raw_spin_lock+0x76/0xa0 _raw_spin_lock_irqsave+0x72/0x80 uart_write_room+0x3b/0xc0 gsm_data_kick+0x14b/0x240 [n_gsm] gsmld_write_wakeup+0x35/0x70 [n_gsm] tty_wakeup+0x53/0x60 tty_port_default_wakeup+0x1b/0x30 serial8250_tx_chars+0x12f/0x220 serial8250_handle_irq.part.0+0xfe/0x150 serial8250_default_handle_irq+0x48/0x80 serial8250_interrupt+0x56/0xa0 __handle_irq_event_percpu+0x78/0x1f0 handle_irq_event+0x34/0x70 handle_fasteoi_irq+0x90/0x1e0 __common_interrupt+0x69/0x100 common_interrupt+0x48/0xc0 asm_common_interrupt+0x1e/0x40 RIP: 0010:__do_softirq+0x83/0x34e Code: 2a 0a ff 0f b7 ed c7 44 24 10 0a 00 00 00 48 c7 c7 51 2a 64 82 e8 2d e2 d5 ff 65 66 c7 05 83 af 1e 7e 00 00 fb b8 ff ff ff ff <49> c7 c2 40 61 80 82 0f bc c5 41 89 c4 41 83 c4 01 0f 84 e6 00 00 RSP: 0018:ffffc90000003f98 EFLAGS: 00000286 RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffffffff82642a51 RDI: ffffffff825bb5e7 RBP: 0000000000000200 R08: 00000008de3271a8 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: 0000000000000030 R14: 0000000000000000 R15: 0000000000000000 ? __do_softirq+0x73/0x34e irq_exit_rcu+0xb5/0x100 common_interrupt+0xa4/0xc0 </IRQ> <TASK> asm_common_interrupt+0x1e/0x40 RIP: 0010:_raw_spin_unlock_irqrestore+0x2e/0x50 Code: 00 55 48 89 fd 48 83 c7 18 53 48 89 f3 48 8b 74 24 10 e8 85 28 36 ff 48 89 ef e8 cd 58 36 ff 80 e7 02 74 01 fb bf 01 00 00 00 <e8> 3d 97 33 ff 65 8b 05 96 23 2b 7e 85 c0 74 03 5b 5d c3 0f 1f 44 RSP: 0018:ffffc9000020fd08 EFLAGS: 00000202 RAX: 0000000000000000 RBX: 0000000000000246 RCX: 0000000000000000 RDX: 0000000000000004 RSI: ffffffff8257fd74 RDI: 0000000000000001 RBP: ffff8880057de3a0 R08: 00000008de233000 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: 0000000000000100 R14: 0000000000000202 R15: ffff8880057df0b8 ? _raw_spin_unlock_irqrestore+0x23/0x50 gsmtty_write+0x65/0x80 [n_gsm] n_tty_write+0x33f/0x530 ? swake_up_all+0xe0/0xe0 file_tty_write.constprop.0+0x1b1/0x320 ? n_tty_flush_buffer+0xb0/0xb0 new_sync_write+0x10c/0x190 vfs_write+0x282/0x310 ksys_write+0x68/0xe0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x7f3e5e35c15c Code: 8b 7c 24 08 89 c5 e8 c5 ff ff ff 89 ef 89 44 24 ---truncated---",
      "cve": "CVE-2022-50116",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50116",
          "value": "CVE-2022-50116",
          "url": "https://scout.docker.com/v/CVE-2022-50116?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50116?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "931519b63d8184578f5f76a3904b6546921252b1e778c67a5d5c0904c48081ec",
      "category": "container_scanning",
      "message": "CVE-2022-50150 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-50150",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50150",
          "value": "CVE-2022-50150",
          "url": "https://scout.docker.com/v/CVE-2022-50150?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50150?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "03c3df3b0b2a5ca018089c78feafbdcc5d375b6d82ccd39dc9aaca8aeefadbf1",
      "category": "container_scanning",
      "message": "CVE-2022-50163 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: fix incorrect dev_tracker usage  While investigating a separate rose issue [1], and enabling CONFIG_NET_DEV_REFCNT_TRACKER=y, Bernard reported an orthogonal ax25 issue [2]  An ax25_dev can be used by one (or many) struct ax25_cb. We thus need different dev_tracker, one per struct ax25_cb.  After this patch is applied, we are able to focus on rose.  [1] https://lore.kernel.org/netdev/fb7544a1-f42e-9254-18cc-c9b071f4ca70@free.fr/  [2] [  205.798723] reference already released. [  205.798732] allocated in: [  205.798734]  ax25_bind+0x1a2/0x230 [ax25] [  205.798747]  __sys_bind+0xea/0x110 [  205.798753]  __x64_sys_bind+0x18/0x20 [  205.798758]  do_syscall_64+0x5c/0x80 [  205.798763]  entry_SYSCALL_64_after_hwframe+0x44/0xae [  205.798768] freed in: [  205.798770]  ax25_release+0x115/0x370 [ax25] [  205.798778]  __sock_release+0x42/0xb0 [  205.798782]  sock_close+0x15/0x20 [  205.798785]  __fput+0x9f/0x260 [  205.798789]  ____fput+0xe/0x10 [  205.798792]  task_work_run+0x64/0xa0 [  205.798798]  exit_to_user_mode_prepare+0x18b/0x190 [  205.798804]  syscall_exit_to_user_mode+0x26/0x40 [  205.798808]  do_syscall_64+0x69/0x80 [  205.798812]  entry_SYSCALL_64_after_hwframe+0x44/0xae [  205.798827] ------------[ cut here ]------------ [  205.798829] WARNING: CPU: 2 PID: 2605 at lib/ref_tracker.c:136 ref_tracker_free.cold+0x60/0x81 [  205.798837] Modules linked in: rose netrom mkiss ax25 rfcomm cmac algif_hash algif_skcipher af_alg bnep snd_hda_codec_hdmi nls_iso8859_1 i915 rtw88_8821ce rtw88_8821c x86_pkg_temp_thermal rtw88_pci intel_powerclamp rtw88_core snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio coretemp snd_hda_intel kvm_intel snd_intel_dspcfg mac80211 snd_hda_codec kvm i2c_algo_bit drm_buddy drm_dp_helper btusb drm_kms_helper snd_hwdep btrtl snd_hda_core btbcm joydev crct10dif_pclmul btintel crc32_pclmul ghash_clmulni_intel mei_hdcp btmtk intel_rapl_msr aesni_intel bluetooth input_leds snd_pcm crypto_simd syscopyarea processor_thermal_device_pci_legacy sysfillrect cryptd intel_soc_dts_iosf snd_seq sysimgblt ecdh_generic fb_sys_fops rapl libarc4 processor_thermal_device intel_cstate processor_thermal_rfim cec snd_timer ecc snd_seq_device cfg80211 processor_thermal_mbox mei_me processor_thermal_rapl mei rc_core at24 snd intel_pch_thermal intel_rapl_common ttm soundcore int340x_thermal_zone video [  205.798948]  mac_hid acpi_pad sch_fq_codel ipmi_devintf ipmi_msghandler drm msr parport_pc ppdev lp parport ramoops pstore_blk reed_solomon pstore_zone efi_pstore ip_tables x_tables autofs4 hid_generic usbhid hid i2c_i801 i2c_smbus r8169 xhci_pci ahci libahci realtek lpc_ich xhci_pci_renesas [last unloaded: ax25] [  205.798992] CPU: 2 PID: 2605 Comm: ax25ipd Not tainted 5.18.11-F6BVP #3 [  205.798996] Hardware name: To be filled by O.E.M. To be filled by O.E.M./CK3, BIOS 5.011 09/16/2020 [  205.798999] RIP: 0010:ref_tracker_free.cold+0x60/0x81 [  205.799005] Code: e8 d2 01 9b ff 83 7b 18 00 74 14 48 c7 c7 2f d7 ff 98 e8 10 6e fc ff 8b 7b 18 e8 b8 01 9b ff 4c 89 ee 4c 89 e7 e8 5d fd 07 00 <0f> 0b b8 ea ff ff ff e9 30 05 9b ff 41 0f b6 f7 48 c7 c7 a0 fa 4e [  205.799008] RSP: 0018:ffffaf5281073958 EFLAGS: 00010286 [  205.799011] RAX: 0000000080000000 RBX: ffff9a0bd687ebe0 RCX: 0000000000000000 [  205.799014] RDX: 0000000000000001 RSI: 0000000000000282 RDI: 00000000ffffffff [  205.799016] RBP: ffffaf5281073a10 R08: 0000000000000003 R09: fffffffffffd5618 [  205.799019] R10: 0000000000ffff10 R11: 000000000000000f R12: ffff9a0bc53384d0 [  205.799022] R13: 0000000000000282 R14: 00000000ae000001 R15: 0000000000000001 [  205.799024] FS:  0000000000000000(0000) GS:ffff9a0d0f300000(0000) knlGS:0000000000000000 [  205.799028] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  205.799031] CR2: 00007ff6b8311554 CR3: 000000001ac10004 CR4: 00000000001706e0 [  205.799033] Call Trace: [  205.799035]  <TASK> [  205.799038]  ? ax25_dev_device_down+0xd9/ ---truncated---",
      "cve": "CVE-2022-50163",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50163",
          "value": "CVE-2022-50163",
          "url": "https://scout.docker.com/v/CVE-2022-50163?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50163?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b054ed278a05cf5bee4f46f7d5e14898251a6ea73bc0ac49a69a973f61222a8f",
      "category": "container_scanning",
      "message": "CVE-2022-50166 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: When HCI work queue is drained, only queue chained work  The HCI command, event, and data packet processing workqueue is drained to avoid deadlock in commit 76727c02c1e1 (\"Bluetooth: Call drain_workqueue() before resetting state\").  There is another delayed work, which will queue command to this drained workqueue. Which results in the following error report:  Bluetooth: hci2: command 0x040f tx timeout WARNING: CPU: 1 PID: 18374 at kernel/workqueue.c:1438 __queue_work+0xdad/0x1140 Workqueue: events hci_cmd_timeout RIP: 0010:__queue_work+0xdad/0x1140 RSP: 0000:ffffc90002cffc60 EFLAGS: 00010093 RAX: 0000000000000000 RBX: ffff8880b9d3ec00 RCX: 0000000000000000 RDX: ffff888024ba0000 RSI: ffffffff814e048d RDI: ffff8880b9d3ec08 RBP: 0000000000000008 R08: 0000000000000000 R09: 00000000b9d39700 R10: ffffffff814f73c6 R11: 0000000000000000 R12: ffff88807cce4c60 R13: 0000000000000000 R14: ffff8880796d8800 R15: ffff8880796d8800 FS:  0000000000000000(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000c0174b4000 CR3: 000000007cae9000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? queue_work_on+0xcb/0x110 ? lockdep_hardirqs_off+0x90/0xd0 queue_work_on+0xee/0x110 process_one_work+0x996/0x1610 ? pwq_dec_nr_in_flight+0x2a0/0x2a0 ? rwlock_bug.part.0+0x90/0x90 ? _raw_spin_lock_irq+0x41/0x50 worker_thread+0x665/0x1080 ? process_one_work+0x1610/0x1610 kthread+0x2e9/0x3a0 ? kthread_complete_and_exit+0x40/0x40 ret_from_fork+0x1f/0x30 </TASK>  To fix this, we can add a new HCI_DRAIN_WQ flag, and don't queue the timeout workqueue while command workqueue is draining.",
      "cve": "CVE-2022-50166",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50166",
          "value": "CVE-2022-50166",
          "url": "https://scout.docker.com/v/CVE-2022-50166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "94658ce8380f6faba9204624c7eae835c72bcad7f7253bc498d083e720aaf350",
      "category": "container_scanning",
      "message": "CVE-2022-50167 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: fix potential 32-bit overflow when accessing ARRAY map element  If BPF array map is bigger than 4GB, element pointer calculation can overflow because both index and elem_size are u32. Fix this everywhere by forcing 64-bit multiplication. Extract this formula into separate small helper and use it consistently in various places.  Speculative-preventing formula utilizing index_mask trick is left as is, but explicit u64 casts are added in both places.",
      "cve": "CVE-2022-50167",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50167",
          "value": "CVE-2022-50167",
          "url": "https://scout.docker.com/v/CVE-2022-50167?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50167?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8f6b84545a1d1e95749f09275a2b2dffb0230c0b5daffdd6b8cee6a9647db59e",
      "category": "container_scanning",
      "message": "CVE-2022-50178 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: 8852a: rfk: fix div 0 exception  The DPK is a kind of RF calibration whose algorithm is to fine tune parameters and calibrate, and check the result. If the result isn't good enough, it could adjust parameters and try again.  This issue is to read and show the result, but it could be a negative calibration result that causes divisor 0 and core dump. So, fix it by phy_div() that does division only if divisor isn't zero; otherwise, zero is adopted.  divide error: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 PID: 728 Comm: wpa_supplicant Not tainted 5.10.114-16019-g462a1661811a #1 <HASH:d024 28> RIP: 0010:rtw8852a_dpk+0x14ae/0x288f [rtw89_core] RSP: 0018:ffffa9bb412a7520 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 00000000000180fc RDI: ffffa141d01023c0 RBP: ffffa9bb412a76a0 R08: 0000000000001319 R09: 00000000ffffff92 R10: ffffffffc0292de3 R11: ffffffffc00d2f51 R12: 0000000000000000 R13: ffffa141d01023c0 R14: ffffffffc0290250 R15: ffffa141d0102638 FS:  00007fa99f5c2740(0000) GS:ffffa142e5e80000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000013e8e010 CR3: 0000000110d2c000 CR4: 0000000000750ee0 PKRU: 55555554 Call Trace: rtw89_core_sta_add+0x95/0x9c [rtw89_core <HASH:d239 29>] rtw89_ops_sta_state+0x5d/0x108 [rtw89_core <HASH:d239 29>] drv_sta_state+0x115/0x66f [mac80211 <HASH:81fe 30>] sta_info_insert_rcu+0x45c/0x713 [mac80211 <HASH:81fe 30>] sta_info_insert+0xf/0x1b [mac80211 <HASH:81fe 30>] ieee80211_prep_connection+0x9d6/0xb0c [mac80211 <HASH:81fe 30>] ieee80211_mgd_auth+0x2aa/0x352 [mac80211 <HASH:81fe 30>] cfg80211_mlme_auth+0x160/0x1f6 [cfg80211 <HASH:00cd 31>] nl80211_authenticate+0x2e5/0x306 [cfg80211 <HASH:00cd 31>] genl_rcv_msg+0x371/0x3a1 ? nl80211_stop_sched_scan+0xe5/0xe5 [cfg80211 <HASH:00cd 31>] ? genl_rcv+0x36/0x36 netlink_rcv_skb+0x8a/0xf9 genl_rcv+0x28/0x36 netlink_unicast+0x27b/0x3a0 netlink_sendmsg+0x2aa/0x469 sock_sendmsg_nosec+0x49/0x4d ____sys_sendmsg+0xe5/0x213 __sys_sendmsg+0xec/0x157 ? syscall_enter_from_user_mode+0xd7/0x116 do_syscall_64+0x43/0x55 entry_SYSCALL_64_after_hwframe+0x44/0xa9 RIP: 0033:0x7fa99f6e689b",
      "cve": "CVE-2022-50178",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50178",
          "value": "CVE-2022-50178",
          "url": "https://scout.docker.com/v/CVE-2022-50178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5f660f3533445f66558029bfcaab0d659c4aebbc8ecc1a7d2d8f87c2a11bcf0e",
      "category": "container_scanning",
      "message": "CVE-2022-50180 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-50180",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50180",
          "value": "CVE-2022-50180",
          "url": "https://scout.docker.com/v/CVE-2022-50180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d11e006a9387f3c657a458a52eb36fe0d5a94a02e4359edb2f11c53eca7edd9d",
      "category": "container_scanning",
      "message": "CVE-2022-50195 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ARM: dts: qcom: replace gcc PXO with pxo_board fixed clock  Replace gcc PXO phandle to pxo_board fixed clock declared in the dts. gcc driver doesn't provide PXO_SRC as it's a fixed-clock. This cause a kernel panic if any driver actually try to use it.",
      "cve": "CVE-2022-50195",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50195",
          "value": "CVE-2022-50195",
          "url": "https://scout.docker.com/v/CVE-2022-50195?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50195?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "16a06b32e65f49cb66a73b6b09f7395377d801bef9699768c4ed0ea4efc13450",
      "category": "container_scanning",
      "message": "CVE-2022-50212 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: do not allow CHAIN_ID to refer to another table  When doing lookups for chains on the same batch by using its ID, a chain from a different table can be used. If a rule is added to a table but refers to a chain in a different table, it will be linked to the chain in table2, but would have expressions referring to objects in table1.  Then, when table1 is removed, the rule will not be removed as its linked to a chain in table2. When expressions in the rule are processed or removed, that will lead to a use-after-free.  When looking for chains by ID, use the table that was used for the lookup by name, and only return chains belonging to that same table.",
      "cve": "CVE-2022-50212",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50212",
          "value": "CVE-2022-50212",
          "url": "https://scout.docker.com/v/CVE-2022-50212?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50212?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1761d6288c663a5b7ffde7bf15147029166bab74b3efc59b81f28889d8cda4c2",
      "category": "container_scanning",
      "message": "CVE-2022-50213 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nf_tables: do not allow SET_ID to refer to another table  When doing lookups for sets on the same batch by using its ID, a set from a different table can be used.  Then, when the table is removed, a reference to the set may be kept after the set is freed, leading to a potential use-after-free.  When looking for sets by ID, use the table that was used for the lookup by name, and only return sets belonging to that same table.  This fixes CVE-2022-2586, also reported as ZDI-CAN-17470.",
      "cve": "CVE-2022-50213",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50213",
          "value": "CVE-2022-50213",
          "url": "https://scout.docker.com/v/CVE-2022-50213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4526dbac356f27dae7edc4f85b3d1e9e7c58b2f935d122fcbbac1f6922cf7af9",
      "category": "container_scanning",
      "message": "CVE-2022-50216 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2022-50216",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50216",
          "value": "CVE-2022-50216",
          "url": "https://scout.docker.com/v/CVE-2022-50216?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50216?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "952192a30197817d3556bae14906928d2a4386ce34bde62edbeb77c81346a167",
      "category": "container_scanning",
      "message": "CVE-2022-50224 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86/mmu: Treat NX as a valid SPTE bit for NPT  Treat the NX bit as valid when using NPT, as KVM will set the NX bit when the NX huge page mitigation is enabled (mindblowing) and trigger the WARN that fires on reserved SPTE bits being set.  KVM has required NX support for SVM since commit b26a71a1a5b9 (\"KVM: SVM: Refuse to load kvm_amd if NX support is not available\") for exactly this reason, but apparently it never occurred to anyone to actually test NPT with the mitigation enabled.  ------------[ cut here ]------------ spte = 0x800000018a600ee7, level = 2, rsvd bits = 0x800f0000001fe000 WARNING: CPU: 152 PID: 15966 at arch/x86/kvm/mmu/spte.c:215 make_spte+0x327/0x340 [kvm] Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 10.48.0 01/27/2022 RIP: 0010:make_spte+0x327/0x340 [kvm] Call Trace: <TASK> tdp_mmu_map_handle_target_level+0xc3/0x230 [kvm] kvm_tdp_mmu_map+0x343/0x3b0 [kvm] direct_page_fault+0x1ae/0x2a0 [kvm] kvm_tdp_page_fault+0x7d/0x90 [kvm] kvm_mmu_page_fault+0xfb/0x2e0 [kvm] npf_interception+0x55/0x90 [kvm_amd] svm_invoke_exit_handler+0x31/0xf0 [kvm_amd] svm_handle_exit+0xf6/0x1d0 [kvm_amd] vcpu_enter_guest+0xb6d/0xee0 [kvm] ? kvm_pmu_trigger_event+0x6d/0x230 [kvm] vcpu_run+0x65/0x2c0 [kvm] kvm_arch_vcpu_ioctl_run+0x355/0x610 [kvm] kvm_vcpu_ioctl+0x551/0x610 [kvm] __se_sys_ioctl+0x77/0xc0 __x64_sys_ioctl+0x1d/0x20 do_syscall_64+0x44/0xa0 entry_SYSCALL_64_after_hwframe+0x46/0xb0 </TASK> ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2022-50224",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50224",
          "value": "CVE-2022-50224",
          "url": "https://scout.docker.com/v/CVE-2022-50224?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50224?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "43b97293401f7aa26627b54c84dd0d28071f1cc68d6398236b3bc0f634ee70a0",
      "category": "container_scanning",
      "message": "CVE-2022-50230 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: set UXN on swapper page tables  [ This issue was fixed upstream by accident in c3cee924bd85 (\"arm64: head: cover entire kernel image in initial ID map\") as part of a large refactoring of the arm64 boot flow. This simple fix is therefore preferred for -stable backporting ]  On a system that implements FEAT_EPAN, read/write access to the idmap is denied because UXN is not set on the swapper PTEs. As a result, idmap_kpti_install_ng_mappings panics the kernel when accessing __idmap_kpti_flag. Fix it by setting UXN on these PTEs.",
      "cve": "CVE-2022-50230",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50230",
          "value": "CVE-2022-50230",
          "url": "https://scout.docker.com/v/CVE-2022-50230?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50230?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ff839f02ab684a9d691920e4559def79dffcee917e58bbe1e8308ce76906e09b",
      "category": "container_scanning",
      "message": "CVE-2022-50232 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: set UXN on swapper page tables  [ This issue was fixed upstream by accident in c3cee924bd85 (\"arm64: head: cover entire kernel image in initial ID map\") as part of a large refactoring of the arm64 boot flow. This simple fix is therefore preferred for -stable backporting ]  On a system that implements FEAT_EPAN, read/write access to the idmap is denied because UXN is not set on the swapper PTEs. As a result, idmap_kpti_install_ng_mappings panics the kernel when accessing __idmap_kpti_flag. Fix it by setting UXN on these PTEs.",
      "cve": "CVE-2022-50232",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50232",
          "value": "CVE-2022-50232",
          "url": "https://scout.docker.com/v/CVE-2022-50232?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50232?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e9c511f083b8c6d888d1003bc23f17c9c40f49f3b01adc30316070f7dabb6524",
      "category": "container_scanning",
      "message": "CVE-2022-50234 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring/af_unix: defer registered files gc to io_uring release  Instead of putting io_uring's registered files in unix_gc() we want it to be done by io_uring itself. The trick here is to consider io_uring registered files for cycle detection but not actually putting them down. Because io_uring can't register other ring instances, this will remove all refs to the ring file triggering the ->release path and clean up with io_ring_ctx_free().  [axboe: add kerneldoc comment to skb, fold in skb leak fix]",
      "cve": "CVE-2022-50234",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50234",
          "value": "CVE-2022-50234",
          "url": "https://scout.docker.com/v/CVE-2022-50234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "58fdf7eb6625ccbf2844afbdd6201e7750b9831cc0e3c118daa21d77242b9ffb",
      "category": "container_scanning",
      "message": "CVE-2022-50236 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/mediatek: Fix crash on isr after kexec()  If the system is rebooted via isr(), the IRQ handler might be triggered before the domain is initialized. Resulting on an invalid memory access error.  Fix: [    0.500930] Unable to handle kernel read from unreadable memory at virtual address 0000000000000070 [    0.501166] Call trace: [    0.501174]  report_iommu_fault+0x28/0xfc [    0.501180]  mtk_iommu_isr+0x10c/0x1c0  [ joro: Fixed spelling in commit message ]",
      "cve": "CVE-2022-50236",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50236",
          "value": "CVE-2022-50236",
          "url": "https://scout.docker.com/v/CVE-2022-50236?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50236?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d799cf601053a27eae552f186d1ca7a80ce32e8edf83af1645c2856ab0320e96",
      "category": "container_scanning",
      "message": "CVE-2022-50240 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  android: binder: stop saving a pointer to the VMA  Do not record a pointer to a VMA outside of the mmap_lock for later use. This is unsafe and there are a number of failure paths *after* the recorded VMA pointer may be freed during setup.  There is no callback to the driver to clear the saved pointer from generic mm code.  Furthermore, the VMA pointer may become stale if any number of VMA operations end up freeing the VMA so saving it was fragile to being with.  Instead, change the binder_alloc struct to record the start address of the VMA and use vma_lookup() to get the vma when needed.  Add lockdep mmap_lock checks on updates to the vma pointer to ensure the lock is held and depend on that lock for synchronization of readers and writers - which was already the case anyways, so the smp_wmb()/smp_rmb() was not necessary.  [akpm@linux-foundation.org: fix drivers/android/binder_alloc_selftest.c]",
      "cve": "CVE-2022-50240",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50240",
          "value": "CVE-2022-50240",
          "url": "https://scout.docker.com/v/CVE-2022-50240?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50240?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "907e3d030c71d784d762071e4b3440369c4802fd70c724c6da1fabeeb0c0596e",
      "category": "container_scanning",
      "message": "CVE-2022-50256 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/meson: remove drm bridges at aggregate driver unbind time  drm bridges added by meson_encoder_hdmi_init and meson_encoder_cvbs_init were not manually removed at module unload time, which caused dangling references to freed memory to remain linked in the global bridge_list.  When loading the driver modules back in, the same functions would again call drm_bridge_add, and when traversing the global bridge_list, would end up peeking into freed memory.  Once again KASAN revealed the problem:  [  +0.000095] ============================================================= [  +0.000008] BUG: KASAN: use-after-free in __list_add_valid+0x9c/0x120 [  +0.000018] Read of size 8 at addr ffff00003da291f0 by task modprobe/2483  [  +0.000018] CPU: 3 PID: 2483 Comm: modprobe Tainted: G         C O 5.19.0-rc6-lrmbkasan+ #1 [  +0.000011] Hardware name: Hardkernel ODROID-N2Plus (DT) [  +0.000008] Call trace: [  +0.000006]  dump_backtrace+0x1ec/0x280 [  +0.000012]  show_stack+0x24/0x80 [  +0.000008]  dump_stack_lvl+0x98/0xd4 [  +0.000011]  print_address_description.constprop.0+0x80/0x520 [  +0.000011]  print_report+0x128/0x260 [  +0.000008]  kasan_report+0xb8/0xfc [  +0.000008]  __asan_report_load8_noabort+0x3c/0x50 [  +0.000009]  __list_add_valid+0x9c/0x120 [  +0.000009]  drm_bridge_add+0x6c/0x104 [drm] [  +0.000165]  dw_hdmi_probe+0x1900/0x2360 [dw_hdmi] [  +0.000022]  meson_dw_hdmi_bind+0x520/0x814 [meson_dw_hdmi] [  +0.000014]  component_bind+0x174/0x520 [  +0.000012]  component_bind_all+0x1a8/0x38c [  +0.000010]  meson_drv_bind_master+0x5e8/0xb74 [meson_drm] [  +0.000032]  meson_drv_bind+0x20/0x2c [meson_drm] [  +0.000027]  try_to_bring_up_aggregate_device+0x19c/0x390 [  +0.000010]  component_master_add_with_match+0x1c8/0x284 [  +0.000009]  meson_drv_probe+0x274/0x280 [meson_drm] [  +0.000026]  platform_probe+0xd0/0x220 [  +0.000009]  really_probe+0x3ac/0xa80 [  +0.000009]  __driver_probe_device+0x1f8/0x400 [  +0.000009]  driver_probe_device+0x68/0x1b0 [  +0.000009]  __driver_attach+0x20c/0x480 [  +0.000008]  bus_for_each_dev+0x114/0x1b0 [  +0.000009]  driver_attach+0x48/0x64 [  +0.000008]  bus_add_driver+0x390/0x564 [  +0.000009]  driver_register+0x1a8/0x3e4 [  +0.000009]  __platform_driver_register+0x6c/0x94 [  +0.000008]  meson_drm_platform_driver_init+0x3c/0x1000 [meson_drm] [  +0.000027]  do_one_initcall+0xc4/0x2b0 [  +0.000011]  do_init_module+0x154/0x570 [  +0.000011]  load_module+0x1a78/0x1ea4 [  +0.000008]  __do_sys_init_module+0x184/0x1cc [  +0.000009]  __arm64_sys_init_module+0x78/0xb0 [  +0.000009]  invoke_syscall+0x74/0x260 [  +0.000009]  el0_svc_common.constprop.0+0xcc/0x260 [  +0.000008]  do_el0_svc+0x50/0x70 [  +0.000007]  el0_svc+0x68/0x1a0 [  +0.000012]  el0t_64_sync_handler+0x11c/0x150 [  +0.000008]  el0t_64_sync+0x18c/0x190  [  +0.000016] Allocated by task 879: [  +0.000008]  kasan_save_stack+0x2c/0x5c [  +0.000011]  __kasan_kmalloc+0x90/0xd0 [  +0.000007]  __kmalloc+0x278/0x4a0 [  +0.000011]  mpi_resize+0x13c/0x1d0 [  +0.000011]  mpi_powm+0xd24/0x1570 [  +0.000009]  rsa_enc+0x1a4/0x30c [  +0.000009]  pkcs1pad_verify+0x3f0/0x580 [  +0.000009]  public_key_verify_signature+0x7a8/0xba4 [  +0.000010]  public_key_verify_signature_2+0x40/0x60 [  +0.000008]  verify_signature+0xb4/0x114 [  +0.000008]  pkcs7_validate_trust_one.constprop.0+0x3b8/0x574 [  +0.000009]  pkcs7_validate_trust+0xb8/0x15c [  +0.000008]  verify_pkcs7_message_sig+0xec/0x1b0 [  +0.000012]  verify_pkcs7_signature+0x78/0xac [  +0.000007]  mod_verify_sig+0x110/0x190 [  +0.000009]  module_sig_check+0x114/0x1e0 [  +0.000009]  load_module+0xa0/0x1ea4 [  +0.000008]  __do_sys_init_module+0x184/0x1cc [  +0.000008]  __arm64_sys_init_module+0x78/0xb0 [  +0.000008]  invoke_syscall+0x74/0x260 [  +0.000009]  el0_svc_common.constprop.0+0x1a8/0x260 [  +0.000008]  do_el0_svc+0x50/0x70 [  +0.000007]  el0_svc+0x68/0x1a0 [  +0.000009]  el0t_64_sync_handler+0x11c/0x150 [  +0.000009]  el0t_64 ---truncated---",
      "cve": "CVE-2022-50256",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50256",
          "value": "CVE-2022-50256",
          "url": "https://scout.docker.com/v/CVE-2022-50256?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50256?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c88293fa10ef024141d8349155cebf6cb3d272264a48e4fca63aeb80485c1367",
      "category": "container_scanning",
      "message": "CVE-2022-50260 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm: Make .remove and .shutdown HW shutdown consistent  Drivers' .remove and .shutdown callbacks are executed on different code paths. The former is called when a device is removed from the bus, while the latter is called at system shutdown time to quiesce the device.  This means that some overlap exists between the two, because both have to take care of properly shutting down the hardware. But currently the logic used in these two callbacks isn't consistent in msm drivers, which could lead to kernel panic.  For example, on .remove the component is deleted and its .unbind callback leads to the hardware being shutdown but only if the DRM device has been marked as registered.  That check doesn't exist in the .shutdown logic and this can lead to the driver calling drm_atomic_helper_shutdown() for a DRM device that hasn't been properly initialized.  A situation like this can happen if drivers for expected sub-devices fail to probe, since the .bind callback will never be executed. If that is the case, drm_atomic_helper_shutdown() will attempt to take mutexes that are only initialized if drm_mode_config_init() is called during a device bind.  This bug was attempted to be fixed in commit 623f279c7781 (\"drm/msm: fix shutdown hook in case GPU components failed to bind\"), but unfortunately it still happens in some cases as the one mentioned above, i.e:  systemd-shutdown[1]: Powering off. kvm: exiting hardware virtualization platform wifi-firmware.0: Removing from iommu group 12 platform video-firmware.0: Removing from iommu group 10 ------------[ cut here ]------------ WARNING: CPU: 6 PID: 1 at drivers/gpu/drm/drm_modeset_lock.c:317 drm_modeset_lock_all_ctx+0x3c4/0x3d0 ... Hardware name: Google CoachZ (rev3+) (DT) pstate: a0400009 (NzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : drm_modeset_lock_all_ctx+0x3c4/0x3d0 lr : drm_modeset_lock_all_ctx+0x48/0x3d0 sp : ffff80000805bb80 x29: ffff80000805bb80 x28: ffff327c00128000 x27: 0000000000000000 x26: 0000000000000000 x25: 0000000000000001 x24: ffffc95d820ec030 x23: ffff327c00bbd090 x22: ffffc95d8215eca0 x21: ffff327c039c5800 x20: ffff327c039c5988 x19: ffff80000805bbe8 x18: 0000000000000034 x17: 000000040044ffff x16: ffffc95d80cac920 x15: 0000000000000000 x14: 0000000000000315 x13: 0000000000000315 x12: 0000000000000000 x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000 x8 : ffff80000805bc28 x7 : 0000000000000000 x6 : 0000000000000000 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : ffff327c00128000 x1 : 0000000000000000 x0 : ffff327c039c59b0 Call trace: drm_modeset_lock_all_ctx+0x3c4/0x3d0 drm_atomic_helper_shutdown+0x70/0x134 msm_drv_shutdown+0x30/0x40 platform_shutdown+0x28/0x40 device_shutdown+0x148/0x350 kernel_power_off+0x38/0x80 __do_sys_reboot+0x288/0x2c0 __arm64_sys_reboot+0x28/0x34 invoke_syscall+0x48/0x114 el0_svc_common.constprop.0+0x44/0xec do_el0_svc+0x2c/0xc0 el0_svc+0x2c/0x84 el0t_64_sync_handler+0x11c/0x150 el0t_64_sync+0x18c/0x190 ---[ end trace 0000000000000000 ]--- Unable to handle kernel NULL pointer dereference at virtual address 0000000000000018 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004 CM = 0, WnR = 0 user pgtable: 4k pages, 48-bit VAs, pgdp=000000010eab1000 [0000000000000018] pgd=0000000000000000, p4d=0000000000000000 Internal error: Oops: 96000004 [#1] PREEMPT SMP ... Hardware name: Google CoachZ (rev3+) (DT) pstate: a0400009 (NzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : ww_mutex_lock+0x28/0x32c lr : drm_modeset_lock_all_ctx+0x1b0/0x3d0 sp : ffff80000805bb50 x29: ffff80000805bb50 x28: ffff327c00128000 x27: 0000000000000000 x26: 00000 ---truncated---",
      "cve": "CVE-2022-50260",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50260",
          "value": "CVE-2022-50260",
          "url": "https://scout.docker.com/v/CVE-2022-50260?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50260?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "76a28564398c9142f8aa1f7621452fc0f0baf7936ffe29cd2c147f193bd0edf2",
      "category": "container_scanning",
      "message": "CVE-2022-50266 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  kprobes: Fix check for probe enabled in kill_kprobe()  In kill_kprobe(), the check whether disarm_kprobe_ftrace() needs to be called always fails. This is because before that we set the KPROBE_FLAG_GONE flag for kprobe so that \"!kprobe_disabled(p)\" is always false.  The disarm_kprobe_ftrace() call introduced by commit:  0cb2f1372baa (\"kprobes: Fix NULL pointer dereference at kprobe_ftrace_handler\")  to fix the NULL pointer reference problem. When the probe is enabled, if we do not disarm it, this problem still exists.  Fix it by putting the probe enabled check before setting the KPROBE_FLAG_GONE flag.",
      "cve": "CVE-2022-50266",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50266",
          "value": "CVE-2022-50266",
          "url": "https://scout.docker.com/v/CVE-2022-50266?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50266?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3c62e7a4e61caf9c050d85211015b525817c6197c884953a78155eb7ae9b11eb",
      "category": "container_scanning",
      "message": "CVE-2022-50284 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipc: fix memory leak in init_mqueue_fs()  When setup_mq_sysctls() failed in init_mqueue_fs(), mqueue_inode_cachep is not released.  In order to fix this issue, the release path is reordered.",
      "cve": "CVE-2022-50284",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50284",
          "value": "CVE-2022-50284",
          "url": "https://scout.docker.com/v/CVE-2022-50284?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50284?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "27915d94a15453727154ae23ca69a405a77027b517a6ab48ab1cad00464ae648",
      "category": "container_scanning",
      "message": "CVE-2022-50303 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Fix double release compute pasid  If kfd_process_device_init_vm returns failure after vm is converted to compute vm and vm->pasid set to compute pasid, KFD will not take pdd->drm_file reference. As a result, drm close file handler maybe called to release the compute pasid before KFD process destroy worker to release the same pasid and set vm->pasid to zero, this generates below WARNING backtrace and NULL pointer access.  Add helper amdgpu_amdkfd_gpuvm_set_vm_pasid and call it at the last step of kfd_process_device_init_vm, to ensure vm pasid is the original pasid if acquiring vm failed or is the compute pasid with pdd->drm_file reference taken to avoid double release same pasid.  amdgpu: Failed to create process VM object ida_free called for id=32770 which is not allocated. WARNING: CPU: 57 PID: 72542 at ../lib/idr.c:522 ida_free+0x96/0x140 RIP: 0010:ida_free+0x96/0x140 Call Trace: amdgpu_pasid_free_delayed+0xe1/0x2a0 [amdgpu] amdgpu_driver_postclose_kms+0x2d8/0x340 [amdgpu] drm_file_free.part.13+0x216/0x270 [drm] drm_close_helper.isra.14+0x60/0x70 [drm] drm_release+0x6e/0xf0 [drm] __fput+0xcc/0x280 ____fput+0xe/0x20 task_work_run+0x96/0xc0 do_exit+0x3d0/0xc10  BUG: kernel NULL pointer dereference, address: 0000000000000000 RIP: 0010:ida_free+0x76/0x140 Call Trace: amdgpu_pasid_free_delayed+0xe1/0x2a0 [amdgpu] amdgpu_driver_postclose_kms+0x2d8/0x340 [amdgpu] drm_file_free.part.13+0x216/0x270 [drm] drm_close_helper.isra.14+0x60/0x70 [drm] drm_release+0x6e/0xf0 [drm] __fput+0xcc/0x280 ____fput+0xe/0x20 task_work_run+0x96/0xc0 do_exit+0x3d0/0xc10",
      "cve": "CVE-2022-50303",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50303",
          "value": "CVE-2022-50303",
          "url": "https://scout.docker.com/v/CVE-2022-50303?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50303?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8dbae831587c97c0a7e6711d51c55873cb74c6c1a851d3528bdde8e4a5cd0305",
      "category": "container_scanning",
      "message": "CVE-2022-50304 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mtd: core: fix possible resource leak in init_mtd()  I got the error report while inject fault in init_mtd():  sysfs: cannot create duplicate filename '/devices/virtual/bdi/mtd-0' Call Trace: <TASK> dump_stack_lvl+0x67/0x83 sysfs_warn_dup+0x60/0x70 sysfs_create_dir_ns+0x109/0x120 kobject_add_internal+0xce/0x2f0 kobject_add+0x98/0x110 device_add+0x179/0xc00 device_create_groups_vargs+0xf4/0x100 device_create+0x7b/0xb0 bdi_register_va.part.13+0x58/0x2d0 bdi_register+0x9b/0xb0 init_mtd+0x62/0x171 [mtd] do_one_initcall+0x6c/0x3c0 do_init_module+0x58/0x222 load_module+0x268e/0x27d0 __do_sys_finit_module+0xd5/0x140 do_syscall_64+0x37/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd </TASK> kobject_add_internal failed for mtd-0 with -EEXIST, don't try to register things with the same name in the same directory. Error registering mtd class or bdi: -17  If init_mtdchar() fails in init_mtd(), mtd_bdi will not be unregistered, as a result, we can't load the mtd module again, to fix this by calling bdi_unregister(mtd_bdi) after out_procfs label.",
      "cve": "CVE-2022-50304",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50304",
          "value": "CVE-2022-50304",
          "url": "https://scout.docker.com/v/CVE-2022-50304?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50304?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a19e65c8cb720674e926d72a8acd69b4200ce3cbf2e578a397346df532ccd2f2",
      "category": "container_scanning",
      "message": "CVE-2022-50316 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  orangefs: Fix kmemleak in orangefs_sysfs_init()  When insert and remove the orangefs module, there are kobjects memory leaked as below:  unreferenced object 0xffff88810f95af00 (size 64): comm \"insmod\", pid 783, jiffies 4294813439 (age 65.512s) hex dump (first 32 bytes): a0 83 af 01 81 88 ff ff 08 af 95 0f 81 88 ff ff  ................ 08 af 95 0f 81 88 ff ff 00 00 00 00 00 00 00 00  ................ backtrace: [<0000000031ab7788>] kmalloc_trace+0x27/0xa0 [<000000005a6e4dfe>] orangefs_sysfs_init+0x42/0x3a0 [<00000000722645ca>] 0xffffffffa02780fe [<000000004232d9f7>] do_one_initcall+0x87/0x2a0 [<0000000054f22384>] do_init_module+0xdf/0x320 [<000000003263bdea>] load_module+0x2f98/0x3330 [<0000000052cd4153>] __do_sys_finit_module+0x113/0x1b0 [<00000000250ae02b>] do_syscall_64+0x35/0x80 [<00000000f11c03c7>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  unreferenced object 0xffff88810f95ae80 (size 64): comm \"insmod\", pid 783, jiffies 4294813439 (age 65.512s) hex dump (first 32 bytes): c8 90 0f 02 81 88 ff ff 88 ae 95 0f 81 88 ff ff  ................ 88 ae 95 0f 81 88 ff ff 00 00 00 00 00 00 00 00  ................ backtrace: [<0000000031ab7788>] kmalloc_trace+0x27/0xa0 [<000000001a4841fa>] orangefs_sysfs_init+0xc7/0x3a0 [<00000000722645ca>] 0xffffffffa02780fe [<000000004232d9f7>] do_one_initcall+0x87/0x2a0 [<0000000054f22384>] do_init_module+0xdf/0x320 [<000000003263bdea>] load_module+0x2f98/0x3330 [<0000000052cd4153>] __do_sys_finit_module+0x113/0x1b0 [<00000000250ae02b>] do_syscall_64+0x35/0x80 [<00000000f11c03c7>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  unreferenced object 0xffff88810f95ae00 (size 64): comm \"insmod\", pid 783, jiffies 4294813440 (age 65.511s) hex dump (first 32 bytes): 60 87 a1 00 81 88 ff ff 08 ae 95 0f 81 88 ff ff  `............... 08 ae 95 0f 81 88 ff ff 00 00 00 00 00 00 00 00  ................ backtrace: [<0000000031ab7788>] kmalloc_trace+0x27/0xa0 [<000000005915e797>] orangefs_sysfs_init+0x12b/0x3a0 [<00000000722645ca>] 0xffffffffa02780fe [<000000004232d9f7>] do_one_initcall+0x87/0x2a0 [<0000000054f22384>] do_init_module+0xdf/0x320 [<000000003263bdea>] load_module+0x2f98/0x3330 [<0000000052cd4153>] __do_sys_finit_module+0x113/0x1b0 [<00000000250ae02b>] do_syscall_64+0x35/0x80 [<00000000f11c03c7>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  unreferenced object 0xffff88810f95ad80 (size 64): comm \"insmod\", pid 783, jiffies 4294813440 (age 65.511s) hex dump (first 32 bytes): 78 90 0f 02 81 88 ff ff 88 ad 95 0f 81 88 ff ff  x............... 88 ad 95 0f 81 88 ff ff 00 00 00 00 00 00 00 00  ................ backtrace: [<0000000031ab7788>] kmalloc_trace+0x27/0xa0 [<000000007a14eb35>] orangefs_sysfs_init+0x1ac/0x3a0 [<00000000722645ca>] 0xffffffffa02780fe [<000000004232d9f7>] do_one_initcall+0x87/0x2a0 [<0000000054f22384>] do_init_module+0xdf/0x320 [<000000003263bdea>] load_module+0x2f98/0x3330 [<0000000052cd4153>] __do_sys_finit_module+0x113/0x1b0 [<00000000250ae02b>] do_syscall_64+0x35/0x80 [<00000000f11c03c7>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  unreferenced object 0xffff88810f95ac00 (size 64): comm \"insmod\", pid 783, jiffies 4294813440 (age 65.531s) hex dump (first 32 bytes): e0 ff 67 02 81 88 ff ff 08 ac 95 0f 81 88 ff ff  ..g............. 08 ac 95 0f 81 88 ff ff 00 00 00 00 00 00 00 00  ................ backtrace: [<0000000031ab7788>] kmalloc_trace+0x27/0xa0 [<000000001f38adcb>] orangefs_sysfs_init+0x291/0x3a0 [<00000000722645ca>] 0xffffffffa02780fe [<000000004232d9f7>] do_one_initcall+0x87/0x2a0 [<0000000054f22384>] do_init_module+0xdf/0x320 [<000000003263bdea>] load_module+0x2f98/0x3330 [<0000000052cd4153>] __do_sys_finit_module+0x113/0x1b0 [<00000000250ae02b>] do_syscall_64+0x35/ ---truncated---",
      "cve": "CVE-2022-50316",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50316",
          "value": "CVE-2022-50316",
          "url": "https://scout.docker.com/v/CVE-2022-50316?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50316?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bb6bb15545ab9eadc9f6a72be1cc0ba0b3d81fbb0263c4c7135938e2fb9026e5",
      "category": "container_scanning",
      "message": "CVE-2022-50322 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rtc: msc313: Fix function prototype mismatch in msc313_rtc_probe()  With clang's kernel control flow integrity (kCFI, CONFIG_CFI_CLANG), indirect call targets are validated against the expected function pointer prototype to make sure the call target is valid to help mitigate ROP attacks. If they are not identical, there is a failure at run time, which manifests as either a kernel panic or thread getting killed.  msc313_rtc_probe() was passing clk_disable_unprepare() directly, which did not have matching prototypes for devm_add_action_or_reset()'s callback argument. Refactor to use devm_clk_get_enabled() instead.  This was found as a result of Clang's new -Wcast-function-type-strict flag, which is more sensitive than the simpler -Wcast-function-type, which only checks for type width mismatches.",
      "cve": "CVE-2022-50322",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50322",
          "value": "CVE-2022-50322",
          "url": "https://scout.docker.com/v/CVE-2022-50322?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50322?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9dc6de5ae6d1ca81b98ecc411771c01681eba82c1f9b8fa84f18d6235f6beca2",
      "category": "container_scanning",
      "message": "CVE-2022-50332 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  video/aperture: Call sysfb_disable() before removing PCI devices  Call sysfb_disable() from aperture_remove_conflicting_pci_devices() before removing PCI devices. Without, simpledrm can still bind to simple-framebuffer devices after the hardware driver has taken over the hardware. Both drivers interfere with each other and results are undefined.  Reported modesetting errors [1] are shown below.  ---- snap ---- rcu: INFO: rcu_sched detected expedited stalls on CPUs/tasks: { 13-.... } 7 jiffies s: 165 root: 0x2000/. rcu: blocking rcu_node structures (internal RCU debug): Task dump for CPU 13: task:X               state:R  running task     stack:    0 pid: 4242 ppid: 4228 flags:0x00000008 Call Trace: <TASK> ? commit_tail+0xd7/0x130 ? drm_atomic_helper_commit+0x126/0x150 ? drm_atomic_commit+0xa4/0xe0 ? drm_plane_get_damage_clips.cold+0x1c/0x1c ? drm_atomic_helper_dirtyfb+0x19e/0x280 ? drm_mode_dirtyfb_ioctl+0x10f/0x1e0 ? drm_mode_getfb2_ioctl+0x2d0/0x2d0 ? drm_ioctl_kernel+0xc4/0x150 ? drm_ioctl+0x246/0x3f0 ? drm_mode_getfb2_ioctl+0x2d0/0x2d0 ? __x64_sys_ioctl+0x91/0xd0 ? do_syscall_64+0x60/0xd0 ? entry_SYSCALL_64_after_hwframe+0x4b/0xb5 </TASK> ... rcu: INFO: rcu_sched detected expedited stalls on CPUs/tasks: { 13-.... } 30 jiffies s: 169 root: 0x2000/. rcu: blocking rcu_node structures (internal RCU debug): Task dump for CPU 13: task:X               state:R  running task     stack:    0 pid: 4242 ppid: 4228 flags:0x0000400e Call Trace: <TASK> ? memcpy_toio+0x76/0xc0 ? memcpy_toio+0x1b/0xc0 ? drm_fb_memcpy_toio+0x76/0xb0 ? drm_fb_blit_toio+0x75/0x2b0 ? simpledrm_simple_display_pipe_update+0x132/0x150 ? drm_atomic_helper_commit_planes+0xb6/0x230 ? drm_atomic_helper_commit_tail+0x44/0x80 ? commit_tail+0xd7/0x130 ? drm_atomic_helper_commit+0x126/0x150 ? drm_atomic_commit+0xa4/0xe0 ? drm_plane_get_damage_clips.cold+0x1c/0x1c ? drm_atomic_helper_dirtyfb+0x19e/0x280 ? drm_mode_dirtyfb_ioctl+0x10f/0x1e0 ? drm_mode_getfb2_ioctl+0x2d0/0x2d0 ? drm_ioctl_kernel+0xc4/0x150 ? drm_ioctl+0x246/0x3f0 ? drm_mode_getfb2_ioctl+0x2d0/0x2d0 ? __x64_sys_ioctl+0x91/0xd0 ? do_syscall_64+0x60/0xd0 ? entry_SYSCALL_64_after_hwframe+0x4b/0xb5 </TASK>  The problem was added by commit 5e0137612430 (\"video/aperture: Disable and unregister sysfb devices via aperture helpers\") to v6.0.3 and does not exist in the mainline branch.  The mainline commit 5e0137612430 (\"video/aperture: Disable and unregister sysfb devices via aperture helpers\") has been backported from v6.0-rc1 to stable v6.0.3 from a larger patch series [2] that reworks fbdev framebuffer ownership. The backport misses a change to aperture_remove_conflicting_pci_devices(). Mainline itself is fine, because the function does not exist there as a result of the patch series.  Instead of backporting the whole series, fix the additional function.",
      "cve": "CVE-2022-50332",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50332",
          "value": "CVE-2022-50332",
          "url": "https://scout.docker.com/v/CVE-2022-50332?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50332?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dc0ad5554a88f2c5f811d2f3ad1b885d57f04a8aa1b790b7b2a6beeb3bf398c4",
      "category": "container_scanning",
      "message": "CVE-2022-50354 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Fix kfd_process_device_init_vm error handling  Should only destroy the ib_mem and let process cleanup worker to free the outstanding BOs. Reset the pointer in pdd->qpd structure, to avoid NULL pointer access in process destroy worker.  BUG: kernel NULL pointer dereference, address: 0000000000000010 Call Trace: amdgpu_amdkfd_gpuvm_unmap_gtt_bo_from_kernel+0x46/0xb0 [amdgpu] kfd_process_device_destroy_cwsr_dgpu+0x40/0x70 [amdgpu] kfd_process_destroy_pdds+0x71/0x190 [amdgpu] kfd_process_wq_release+0x2a2/0x3b0 [amdgpu] process_one_work+0x2a1/0x600 worker_thread+0x39/0x3d0",
      "cve": "CVE-2022-50354",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50354",
          "value": "CVE-2022-50354",
          "url": "https://scout.docker.com/v/CVE-2022-50354?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50354?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c68f9304e88f25154c80200eb752cbf23e61054995128fe6874404cbcae42db7",
      "category": "container_scanning",
      "message": "CVE-2022-50357 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: dwc3: core: fix some leaks in probe  The dwc3_get_properties() function calls:  dwc->usb_psy = power_supply_get_by_name(usb_psy_name);  so there is some additional clean up required on these error paths.",
      "cve": "CVE-2022-50357",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50357",
          "value": "CVE-2022-50357",
          "url": "https://scout.docker.com/v/CVE-2022-50357?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50357?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d7e06243aac444f223d08aaa8829068a9632cf48ec02ebb39624b68571a6f20",
      "category": "container_scanning",
      "message": "CVE-2022-50380 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: /proc/pid/smaps_rollup: fix no vma's null-deref  Commit 258f669e7e88 (\"mm: /proc/pid/smaps_rollup: convert to single value seq_file\") introduced a null-deref if there are no vma's in the task in show_smaps_rollup.",
      "cve": "CVE-2022-50380",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50380",
          "value": "CVE-2022-50380",
          "url": "https://scout.docker.com/v/CVE-2022-50380?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50380?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e34a544a12d124cbdc1a050ecf494b7ce0f6eba6a99fda6b5cd481c6eeed1e5e",
      "category": "container_scanning",
      "message": "CVE-2022-50383 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: Can't set dst buffer to done when lat decode error  Core thread will call v4l2_m2m_buf_done to set dst buffer done for lat architecture. If lat call v4l2_m2m_buf_done_and_job_finish to free dst buffer when lat decode error, core thread will access kernel NULL pointer dereference, then crash.",
      "cve": "CVE-2022-50383",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50383",
          "value": "CVE-2022-50383",
          "url": "https://scout.docker.com/v/CVE-2022-50383?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50383?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d489215b5449d009ce6305836557b8fcecf021a93f1c9031f94e14ca5d21ba03",
      "category": "container_scanning",
      "message": "CVE-2022-50390 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/ttm: fix undefined behavior in bit shift for TTM_TT_FLAG_PRIV_POPULATED  Shifting signed 32-bit value by 31 bits is undefined, so changing significant bit to unsigned. The UBSAN warning calltrace like below:  UBSAN: shift-out-of-bounds in ./include/drm/ttm/ttm_tt.h:122:26 left shift of 1 by 31 places cannot be represented in type 'int' Call Trace: <TASK> dump_stack_lvl+0x7d/0xa5 dump_stack+0x15/0x1b ubsan_epilogue+0xe/0x4e __ubsan_handle_shift_out_of_bounds+0x1e7/0x20c ttm_bo_move_memcpy+0x3b4/0x460 [ttm] bo_driver_move+0x32/0x40 [drm_vram_helper] ttm_bo_handle_move_mem+0x118/0x200 [ttm] ttm_bo_validate+0xfa/0x220 [ttm] drm_gem_vram_pin_locked+0x70/0x1b0 [drm_vram_helper] drm_gem_vram_pin+0x48/0xb0 [drm_vram_helper] drm_gem_vram_plane_helper_prepare_fb+0x53/0xe0 [drm_vram_helper] drm_gem_vram_simple_display_pipe_prepare_fb+0x26/0x30 [drm_vram_helper] drm_simple_kms_plane_prepare_fb+0x4d/0xe0 [drm_kms_helper] drm_atomic_helper_prepare_planes+0xda/0x210 [drm_kms_helper] drm_atomic_helper_commit+0xc3/0x1e0 [drm_kms_helper] drm_atomic_commit+0x9c/0x160 [drm] drm_client_modeset_commit_atomic+0x33a/0x380 [drm] drm_client_modeset_commit_locked+0x77/0x220 [drm] drm_client_modeset_commit+0x31/0x60 [drm] __drm_fb_helper_restore_fbdev_mode_unlocked+0xa7/0x170 [drm_kms_helper] drm_fb_helper_set_par+0x51/0x90 [drm_kms_helper] fbcon_init+0x316/0x790 visual_init+0x113/0x1d0 do_bind_con_driver+0x2a3/0x5c0 do_take_over_console+0xa9/0x270 do_fbcon_takeover+0xa1/0x170 do_fb_registered+0x2a8/0x340 fbcon_fb_registered+0x47/0xe0 register_framebuffer+0x294/0x4a0 __drm_fb_helper_initial_config_and_unlock+0x43c/0x880 [drm_kms_helper] drm_fb_helper_initial_config+0x52/0x80 [drm_kms_helper] drm_fbdev_client_hotplug+0x156/0x1b0 [drm_kms_helper] drm_fbdev_generic_setup+0xfc/0x290 [drm_kms_helper] bochs_pci_probe+0x6ca/0x772 [bochs] local_pci_probe+0x4d/0xb0 pci_device_probe+0x119/0x320 really_probe+0x181/0x550 __driver_probe_device+0xc6/0x220 driver_probe_device+0x32/0x100 __driver_attach+0x195/0x200 bus_for_each_dev+0xbb/0x120 driver_attach+0x27/0x30 bus_add_driver+0x22e/0x2f0 driver_register+0xa9/0x190 __pci_register_driver+0x90/0xa0 bochs_pci_driver_init+0x52/0x1000 [bochs] do_one_initcall+0x76/0x430 do_init_module+0x61/0x28a load_module+0x1f82/0x2e50 __do_sys_finit_module+0xf8/0x190 __x64_sys_finit_module+0x23/0x30 do_syscall_64+0x58/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd </TASK>",
      "cve": "CVE-2022-50390",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50390",
          "value": "CVE-2022-50390",
          "url": "https://scout.docker.com/v/CVE-2022-50390?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50390?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2b5f1ca4df4a461506ca8c95c738ed377b2fc5f2529b4d1f6944488dfbfcaf7b",
      "category": "container_scanning",
      "message": "CVE-2022-50393 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: SDMA update use unlocked iterator  SDMA update page table may be called from unlocked context, this generate below warning. Use unlocked iterator to handle this case.  WARNING: CPU: 0 PID: 1475 at drivers/dma-buf/dma-resv.c:483 dma_resv_iter_next Call Trace: dma_resv_iter_first+0x43/0xa0 amdgpu_vm_sdma_update+0x69/0x2d0 [amdgpu] amdgpu_vm_ptes_update+0x29c/0x870 [amdgpu] amdgpu_vm_update_range+0x2f6/0x6c0 [amdgpu] svm_range_unmap_from_gpus+0x115/0x300 [amdgpu] svm_range_cpu_invalidate_pagetables+0x510/0x5e0 [amdgpu] __mmu_notifier_invalidate_range_start+0x1d3/0x230 unmap_vmas+0x140/0x150 unmap_region+0xa8/0x110",
      "cve": "CVE-2022-50393",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50393",
          "value": "CVE-2022-50393",
          "url": "https://scout.docker.com/v/CVE-2022-50393?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50393?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5d62325c66e8d6069150498578ffd00f25534a23cac32c8b880ef8e993f13a2f",
      "category": "container_scanning",
      "message": "CVE-2022-50406 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iomap: iomap: fix memory corruption when recording errors during writeback  Every now and then I see this crash on arm64:  Unable to handle kernel NULL pointer dereference at virtual address 00000000000000f8 Buffer I/O error on dev dm-0, logical block 8733687, async page read Mem abort info: ESR = 0x0000000096000006 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x06: level 2 translation fault Data abort info: ISV = 0, ISS = 0x00000006 CM = 0, WnR = 0 user pgtable: 64k pages, 42-bit VAs, pgdp=0000000139750000 [00000000000000f8] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000, pmd=0000000000000000 Internal error: Oops: 96000006 [#1] PREEMPT SMP Buffer I/O error on dev dm-0, logical block 8733688, async page read Dumping ftrace buffer: Buffer I/O error on dev dm-0, logical block 8733689, async page read (ftrace buffer empty) XFS (dm-0): log I/O error -5 Modules linked in: dm_thin_pool dm_persistent_data XFS (dm-0): Metadata I/O Error (0x1) detected at xfs_trans_read_buf_map+0x1ec/0x590 [xfs] (fs/xfs/xfs_trans_buf.c:296). dm_bio_prison XFS (dm-0): Please unmount the filesystem and rectify the problem(s) XFS (dm-0): xfs_imap_lookup: xfs_ialloc_read_agi() returned error -5, agno 0 dm_bufio dm_log_writes xfs nft_chain_nat xt_REDIRECT nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip6t_REJECT potentially unexpected fatal signal 6. nf_reject_ipv6 potentially unexpected fatal signal 6. ipt_REJECT nf_reject_ipv4 CPU: 1 PID: 122166 Comm: fsstress Tainted: G        W 6.0.0-rc5-djwa #rc5 3004c9f1de887ebae86015f2677638ce51ee7 rpcsec_gss_krb5 auth_rpcgss xt_tcpudp ip_set_hash_ip ip_set_hash_net xt_set nft_compat ip_set_hash_mac ip_set nf_tables Hardware name: QEMU KVM Virtual Machine, BIOS 1.5.1 06/16/2021 pstate: 60001000 (nZCv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--) ip_tables pc : 000003fd6d7df200 x_tables lr : 000003fd6d7df1ec overlay nfsv4 CPU: 0 PID: 54031 Comm: u4:3 Tainted: G        W          6.0.0-rc5-djwa #rc5 3004c9f1de887ebae86015f2677638ce51ee7405 Hardware name: QEMU KVM Virtual Machine, BIOS 1.5.1 06/16/2021 Workqueue: writeback wb_workfn sp : 000003ffd9522fd0 (flush-253:0) pstate: 60401005 (nZCv daif +PAN -UAO -TCO -DIT +SSBS BTYPE=--) pc : errseq_set+0x1c/0x100 x29: 000003ffd9522fd0 x28: 0000000000000023 x27: 000002acefeb6780 x26: 0000000000000005 x25: 0000000000000001 x24: 0000000000000000 x23: 00000000ffffffff x22: 0000000000000005 lr : __filemap_set_wb_err+0x24/0xe0 x21: 0000000000000006 sp : fffffe000f80f760 x29: fffffe000f80f760 x28: 0000000000000003 x27: fffffe000f80f9f8 x26: 0000000002523000 x25: 00000000fffffffb x24: fffffe000f80f868 x23: fffffe000f80fbb0 x22: fffffc0180c26a78 x21: 0000000002530000 x20: 0000000000000000 x19: 0000000000000000 x18: 0000000000000000  x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 x14: 0000000000000001 x13: 0000000000470af3 x12: fffffc0058f70000 x11: 0000000000000040 x10: 0000000000001b20 x9 : fffffe000836b288 x8 : fffffc00eb9fd480 x7 : 0000000000f83659 x6 : 0000000000000000 x5 : 0000000000000869 x4 : 0000000000000005 x3 : 00000000000000f8 x20: 000003fd6d740020 x19: 000000000001dd36 x18: 0000000000000001 x17: 000003fd6d78704c x16: 0000000000000001 x15: 000002acfac87668 x2 : 0000000000000ffa x1 : 00000000fffffffb x0 : 00000000000000f8 Call trace: errseq_set+0x1c/0x100 __filemap_set_wb_err+0x24/0xe0 iomap_do_writepage+0x5e4/0xd5c write_cache_pages+0x208/0x674 iomap_writepages+0x34/0x60 xfs_vm_writepages+0x8c/0xcc [xfs 7a861f39c43631f15d3a5884246ba5035d4ca78b] x14: 0000000000000000 x13: 2064656e72757465 x12: 0000000000002180 x11: 000003fd6d8a82d0 x10: 0000000000000000 x9 : 000003fd6d8ae288 x8 : 0000000000000083 x7 : 00000000ffffffff x6 : 00000000ffffffee x5 : 00000000fbad2887 x4 : 000003fd6d9abb58 x3 : 000003fd6d740020 x2 : 0000000000000006 x1 : 000000000001dd36 x0 : 0000000000000000 CPU: ---truncated---",
      "cve": "CVE-2022-50406",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50406",
          "value": "CVE-2022-50406",
          "url": "https://scout.docker.com/v/CVE-2022-50406?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50406?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "953099736f242f467202f9935438b3e6715fb3b34c8dea4cbf781d376e8b9577",
      "category": "container_scanning",
      "message": "CVE-2022-50407 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: hisilicon/qm - increase the memory of local variables  Increase the buffer to prevent stack overflow by fuzz test. The maximum length of the qos configuration buffer is 256 bytes. Currently, the value of the 'val buffer' is only 32 bytes. The sscanf does not check the dest memory length. So the 'val buffer' may stack overflow.",
      "cve": "CVE-2022-50407",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50407",
          "value": "CVE-2022-50407",
          "url": "https://scout.docker.com/v/CVE-2022-50407?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50407?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2196eb0f9a65e5c9d26137488ce839c2c3f5ec51b0cbb1a69cf3f141a35ef942",
      "category": "container_scanning",
      "message": "CVE-2022-50418 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: mhi: fix potential memory leak in ath11k_mhi_register()  mhi_alloc_controller() allocates a memory space for mhi_ctrl. When gets some error, mhi_ctrl should be freed with mhi_free_controller(). But when ath11k_mhi_read_addr_from_dt() fails, the function returns without calling mhi_free_controller(), which will lead to a memory leak.  We can fix it by calling mhi_free_controller() when ath11k_mhi_read_addr_from_dt() fails.",
      "cve": "CVE-2022-50418",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50418",
          "value": "CVE-2022-50418",
          "url": "https://scout.docker.com/v/CVE-2022-50418?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50418?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "89df09adc4aa130456e0d63388864301d4e3eb4a3337596576c7fbb23a0a370f",
      "category": "container_scanning",
      "message": "CVE-2022-50425 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/fpu: Fix copy_xstate_to_uabi() to copy init states correctly  When an extended state component is not present in fpstate, but in init state, the function copies from init_fpstate via copy_feature().  But, dynamic states are not present in init_fpstate because of all-zeros init states. Then retrieving them from init_fpstate will explode like this:  BUG: kernel NULL pointer dereference, address: 0000000000000000 ... RIP: 0010:memcpy_erms+0x6/0x10 ? __copy_xstate_to_uabi_buf+0x381/0x870 fpu_copy_guest_fpstate_to_uabi+0x28/0x80 kvm_arch_vcpu_ioctl+0x14c/0x1460 [kvm] ? __this_cpu_preempt_check+0x13/0x20 ? vmx_vcpu_put+0x2e/0x260 [kvm_intel] kvm_vcpu_ioctl+0xea/0x6b0 [kvm] ? kvm_vcpu_ioctl+0xea/0x6b0 [kvm] ? __fget_light+0xd4/0x130 __x64_sys_ioctl+0xe3/0x910 ? debug_smp_processor_id+0x17/0x20 ? fpregs_assert_state_consistent+0x27/0x50 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x63/0xcd  Adjust the 'mask' to zero out the userspace buffer for the features that are not available both from fpstate and from init_fpstate.  The dynamic features depend on the compacted XSAVE format. Ensure it is enabled before reading XCOMP_BV in init_fpstate.",
      "cve": "CVE-2022-50425",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50425",
          "value": "CVE-2022-50425",
          "url": "https://scout.docker.com/v/CVE-2022-50425?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50425?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cc86d07dd2a6a484e689b303af02b12545ef979b94bf0fa32943c45390dcc4cd",
      "category": "container_scanning",
      "message": "CVE-2022-50461 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ethernet: ti: am65-cpsw: Fix PM runtime leakage in am65_cpsw_nuss_ndo_slave_open()  Ensure pm_runtime_put() is issued in error path.",
      "cve": "CVE-2022-50461",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50461",
          "value": "CVE-2022-50461",
          "url": "https://scout.docker.com/v/CVE-2022-50461?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50461?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bb1c7afb4f3d65c2e888e2749188e29f3f5e4fb9a42fe8bff7b0f23fb71ff1ad",
      "category": "container_scanning",
      "message": "CVE-2022-50464 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mt76: mt7915: Fix PCI device refcount leak in mt7915_pci_init_hif2()  As comment of pci_get_device() says, it returns a pci_device with its refcount increased. We need to call pci_dev_put() to decrease the refcount. Save the return value of pci_get_device() and call pci_dev_put() to decrease the refcount.",
      "cve": "CVE-2022-50464",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50464",
          "value": "CVE-2022-50464",
          "url": "https://scout.docker.com/v/CVE-2022-50464?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50464?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "75ff63d7ec1cd38df6c7eb761a390f90507acfadc58910597a535ff1e43bcaab",
      "category": "container_scanning",
      "message": "CVE-2022-50467 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Fix null ndlp ptr dereference in abnormal exit path for GFT_ID  An error case exit from lpfc_cmpl_ct_cmd_gft_id() results in a call to lpfc_nlp_put() with a null pointer to a nodelist structure.  Changed lpfc_cmpl_ct_cmd_gft_id() to initialize nodelist pointer upon entry.",
      "cve": "CVE-2022-50467",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50467",
          "value": "CVE-2022-50467",
          "url": "https://scout.docker.com/v/CVE-2022-50467?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50467?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "02d45f994effd9f9bae94585de561f2ba1dae234843253ff8020a2c059bd31f2",
      "category": "container_scanning",
      "message": "CVE-2022-50479 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd: fix potential memory leak  This patch fix potential memory leak (clk_src) when function run into last return NULL.  s/free/kfree/ - Alex",
      "cve": "CVE-2022-50479",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50479",
          "value": "CVE-2022-50479",
          "url": "https://scout.docker.com/v/CVE-2022-50479?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50479?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "36c2e5d7b3a86bafd4c5dbc8a993ae12da807e030f661c28da45c24db769a1b0",
      "category": "container_scanning",
      "message": "CVE-2022-50492 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm: fix use-after-free on probe deferral  The bridge counter was never reset when tearing down the DRM device so that stale pointers to deallocated structures would be accessed on the next tear down (e.g. after a second late bind deferral).  Given enough bridges and a few probe deferrals this could currently also lead to data beyond the bridge array being corrupted.  Patchwork: https://patchwork.freedesktop.org/patch/502665/",
      "cve": "CVE-2022-50492",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50492",
          "value": "CVE-2022-50492",
          "url": "https://scout.docker.com/v/CVE-2022-50492?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50492?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "56420db586b4dcc09da15a88d93f3ea9482a865f60d537a22edd5e4aec23d6de",
      "category": "container_scanning",
      "message": "CVE-2022-50500 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netdevsim: fix memory leak in nsim_drv_probe() when nsim_dev_resources_register() failed  If some items in nsim_dev_resources_register() fail, memory leak will occur. The following is the memory leak information.  unreferenced object 0xffff888074c02600 (size 128): comm \"echo\", pid 8159, jiffies 4294945184 (age 493.530s) hex dump (first 32 bytes): 40 47 ea 89 ff ff ff ff 01 00 00 00 00 00 00 00  @G.............. ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  ................ backtrace: [<0000000011a31c98>] kmalloc_trace+0x22/0x60 [<0000000027384c69>] devl_resource_register+0x144/0x4e0 [<00000000a16db248>] nsim_drv_probe+0x37a/0x1260 [<000000007d1f448c>] really_probe+0x20b/0xb10 [<00000000c416848a>] __driver_probe_device+0x1b3/0x4a0 [<00000000077e0351>] driver_probe_device+0x49/0x140 [<0000000054f2465a>] __device_attach_driver+0x18c/0x2a0 [<000000008538f359>] bus_for_each_drv+0x151/0x1d0 [<0000000038e09747>] __device_attach+0x1c9/0x4e0 [<00000000dd86e533>] bus_probe_device+0x1d5/0x280 [<00000000839bea35>] device_add+0xae0/0x1cb0 [<000000009c2abf46>] new_device_store+0x3b6/0x5f0 [<00000000fb823d7f>] bus_attr_store+0x72/0xa0 [<000000007acc4295>] sysfs_kf_write+0x106/0x160 [<000000005f50cb4d>] kernfs_fop_write_iter+0x3a8/0x5a0 [<0000000075eb41bf>] vfs_write+0x8f0/0xc80",
      "cve": "CVE-2022-50500",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50500",
          "value": "CVE-2022-50500",
          "url": "https://scout.docker.com/v/CVE-2022-50500?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50500?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6faf127298fad3da3c84d524e62771a2a1e44641cae00f16927ed4b9a52c3dc5",
      "category": "container_scanning",
      "message": "CVE-2022-50518 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Fix locking in pdc_iodc_print() firmware call  Utilize pdc_lock spinlock to protect parallel modifications of the iodc_dbuf[] buffer, check length to prevent buffer overflow of iodc_dbuf[], drop the iodc_retbuf[] buffer and fix some wrong indentings.",
      "cve": "CVE-2022-50518",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50518",
          "value": "CVE-2022-50518",
          "url": "https://scout.docker.com/v/CVE-2022-50518?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50518?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2aed5134cead6cd19fde64f5bbeb49ad56f59ea43db641e5b5cd5a4d24aadebc",
      "category": "container_scanning",
      "message": "CVE-2022-50527 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix size validation for non-exclusive domains (v4)  Fix amdgpu_bo_validate_size() to check whether the TTM domain manager for the requested memory exists, else we get a kernel oops when dereferencing \"man\".  v2: Make the patch standalone, i.e. not dependent on local patches. v3: Preserve old behaviour and just check that the manager pointer is not NULL. v4: Complain if GTT domain requested and it is uninitialized--most likely a bug.",
      "cve": "CVE-2022-50527",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50527",
          "value": "CVE-2022-50527",
          "url": "https://scout.docker.com/v/CVE-2022-50527?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50527?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bb5f083ed4ede955b381ddb513519910672e7234c152c6dd210322b02c7fa38b",
      "category": "container_scanning",
      "message": "CVE-2022-50539 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ARM: OMAP2+: omap4-common: Fix refcount leak bug  In omap4_sram_init(), of_find_compatible_node() will return a node pointer with refcount incremented. We should use of_node_put() when it is not used anymore.",
      "cve": "CVE-2022-50539",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50539",
          "value": "CVE-2022-50539",
          "url": "https://scout.docker.com/v/CVE-2022-50539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a433f180c6a459102d97ad12de2977a35c21a422a7eec2d9304e26139bdef133",
      "category": "container_scanning",
      "message": "CVE-2022-50550 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-iolatency: Fix memory leak on add_disk() failures  When a gendisk is successfully initialized but add_disk() fails such as when a loop device has invalid number of minor device numbers specified, blkcg_init_disk() is called during init and then blkcg_exit_disk() during error handling. Unfortunately, iolatency gets initialized in the former but doesn't get cleaned up in the latter.  This is because, in non-error cases, the cleanup is performed by del_gendisk() calling rq_qos_exit(), the assumption being that rq_qos policies, iolatency being one of them, can only be activated once the disk is fully registered and visible. That assumption is true for wbt and iocost, but not so for iolatency as it gets initialized before add_disk() is called.  It is desirable to lazy-init rq_qos policies because they are optional features and add to hot path overhead once initialized - each IO has to walk all the registered rq_qos policies. So, we want to switch iolatency to lazy init too. However, that's a bigger change. As a fix for the immediate problem, let's just add an extra call to rq_qos_exit() in blkcg_exit_disk(). This is safe because duplicate calls to rq_qos_exit() become noop's.",
      "cve": "CVE-2022-50550",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50550",
          "value": "CVE-2022-50550",
          "url": "https://scout.docker.com/v/CVE-2022-50550?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50550?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5b4a0f1291afcff106803b7f69d52f5d611d617de2248b44dc5d9276cdbbc635",
      "category": "container_scanning",
      "message": "CVE-2022-50551 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: brcmfmac: Fix potential shift-out-of-bounds in brcmf_fw_alloc_request()  This patch fixes a shift-out-of-bounds in brcmfmac that occurs in BIT(chiprev) when a 'chiprev' provided by the device is too large. It should also not be equal to or greater than BITS_PER_TYPE(u32) as we do bitwise AND with a u32 variable and BIT(chiprev). The patch adds a check that makes the function return NULL if that is the case. Note that the NULL case is later handled by the bus-specific caller, brcmf_usb_probe_cb() or brcmf_usb_reset_resume(), for example.  Found by a modified version of syzkaller.  UBSAN: shift-out-of-bounds in drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c shift exponent 151055786 is too large for 64-bit type 'long unsigned int' CPU: 0 PID: 1885 Comm: kworker/0:2 Tainted: G           O      5.14.0+ #132 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58e9a3f-prebuilt.qemu.org 04/01/2014 Workqueue: usb_hub_wq hub_event Call Trace: dump_stack_lvl+0x57/0x7d ubsan_epilogue+0x5/0x40 __ubsan_handle_shift_out_of_bounds.cold+0x53/0xdb ? lock_chain_count+0x20/0x20 brcmf_fw_alloc_request.cold+0x19/0x3ea ? brcmf_fw_get_firmwares+0x250/0x250 ? brcmf_usb_ioctl_resp_wait+0x1a7/0x1f0 brcmf_usb_get_fwname+0x114/0x1a0 ? brcmf_usb_reset_resume+0x120/0x120 ? number+0x6c4/0x9a0 brcmf_c_process_clm_blob+0x168/0x590 ? put_dec+0x90/0x90 ? enable_ptr_key_workfn+0x20/0x20 ? brcmf_common_pd_remove+0x50/0x50 ? rcu_read_lock_sched_held+0xa1/0xd0 brcmf_c_preinit_dcmds+0x673/0xc40 ? brcmf_c_set_joinpref_default+0x100/0x100 ? rcu_read_lock_sched_held+0xa1/0xd0 ? rcu_read_lock_bh_held+0xb0/0xb0 ? lock_acquire+0x19d/0x4e0 ? find_held_lock+0x2d/0x110 ? brcmf_usb_deq+0x1cc/0x260 ? mark_held_locks+0x9f/0xe0 ? lockdep_hardirqs_on_prepare+0x273/0x3e0 ? _raw_spin_unlock_irqrestore+0x47/0x50 ? trace_hardirqs_on+0x1c/0x120 ? brcmf_usb_deq+0x1a7/0x260 ? brcmf_usb_rx_fill_all+0x5a/0xf0 brcmf_attach+0x246/0xd40 ? wiphy_new_nm+0x1476/0x1d50 ? kmemdup+0x30/0x40 brcmf_usb_probe+0x12de/0x1690 ? brcmf_usbdev_qinit.constprop.0+0x470/0x470 usb_probe_interface+0x25f/0x710 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 ? usb_match_id.part.0+0x88/0xc0 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 ? driver_allows_async_probing+0x120/0x120 bus_for_each_drv+0x123/0x1a0 ? bus_rescan_devices+0x20/0x20 ? lockdep_hardirqs_on_prepare+0x273/0x3e0 ? trace_hardirqs_on+0x1c/0x120 __device_attach+0x207/0x330 ? device_bind_driver+0xb0/0xb0 ? kobject_uevent_env+0x230/0x12c0 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 ? __mutex_unlock_slowpath+0xe7/0x660 ? __fw_devlink_link_to_suppliers+0x550/0x550 usb_set_configuration+0x984/0x1770 ? kernfs_create_link+0x175/0x230 usb_generic_driver_probe+0x69/0x90 usb_probe_device+0x9c/0x220 really_probe+0x1be/0xa90 __driver_probe_device+0x2ab/0x460 driver_probe_device+0x49/0x120 __device_attach_driver+0x18a/0x250 ? driver_allows_async_probing+0x120/0x120 bus_for_each_drv+0x123/0x1a0 ? bus_rescan_devices+0x20/0x20 ? lockdep_hardirqs_on_prepare+0x273/0x3e0 ? trace_hardirqs_on+0x1c/0x120 __device_attach+0x207/0x330 ? device_bind_driver+0xb0/0xb0 ? kobject_uevent_env+0x230/0x12c0 bus_probe_device+0x1a2/0x260 device_add+0xa61/0x1ce0 ? __fw_devlink_link_to_suppliers+0x550/0x550 usb_new_device.cold+0x463/0xf66 ? hub_disconnect+0x400/0x400 ? _raw_spin_unlock_irq+0x24/0x30 hub_event+0x10d5/0x3330 ? hub_port_debounce+0x280/0x280 ? __lock_acquire+0x1671/0x5790 ? wq_calc_node_cpumask+0x170/0x2a0 ? lock_release+0x640/0x640 ? rcu_read_lock_sched_held+0xa1/0xd0 ? rcu_read_lock_bh_held+0xb0/0xb0 ? lockdep_hardirqs_on_prepare+0x273/0x3e0 process_one_work+0x873/0x13e0 ? lock_release+0x640/0x640 ? pwq_dec_nr_in_flight+0x320/0x320 ? rwlock_bug.part.0+0x90/0x90 worker_thread+0x8b/0xd10 ? __kthread_parkme+0xd9/0x1d0 ? pr ---truncated---",
      "cve": "CVE-2022-50551",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50551",
          "value": "CVE-2022-50551",
          "url": "https://scout.docker.com/v/CVE-2022-50551?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50551?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "150d954885ba9fd75e38c1fdcf7dc74df779d38f939a75970aa2993c9e47a3fa",
      "category": "container_scanning",
      "message": "CVE-2022-50552 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-mq: use quiesced elevator switch when reinitializing queues  The hctx's run_work may be racing with the elevator switch when reinitializing hardware queues. The queue is merely frozen in this context, but that only prevents requests from allocating and doesn't stop the hctx work from running. The work may get an elevator pointer that's being torn down, and can result in use-after-free errors and kernel panics (example below). Use the quiesced elevator switch instead, and make the previous one static since it is now only used locally.  nvme nvme0: resetting controller nvme nvme0: 32/0/0 default/read/poll queues BUG: kernel NULL pointer dereference, address: 0000000000000008 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 80000020c8861067 P4D 80000020c8861067 PUD 250f8c8067 PMD 0 Oops: 0000 [#1] SMP PTI Workqueue: kblockd blk_mq_run_work_fn RIP: 0010:kyber_has_work+0x29/0x70  ...  Call Trace: __blk_mq_do_dispatch_sched+0x83/0x2b0 __blk_mq_sched_dispatch_requests+0x12e/0x170 blk_mq_sched_dispatch_requests+0x30/0x60 __blk_mq_run_hw_queue+0x2b/0x50 process_one_work+0x1ef/0x380 worker_thread+0x2d/0x3e0",
      "cve": "CVE-2022-50552",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50552",
          "value": "CVE-2022-50552",
          "url": "https://scout.docker.com/v/CVE-2022-50552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b4638d4d1f261e649fc37aea694342c6986ddc0f6a61c7b5ff4c5606e536b329",
      "category": "container_scanning",
      "message": "CVE-2022-50554 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-mq: avoid double ->queue_rq() because of early timeout  David Jeffery found one double ->queue_rq() issue, so far it can be triggered in VM use case because of long vmexit latency or preempt latency of vCPU pthread or long page fault in vCPU pthread, then block IO req could be timed out before queuing the request to hardware but after calling blk_mq_start_request() during ->queue_rq(), then timeout handler may handle it by requeue, then double ->queue_rq() is caused, and kernel panic.  So far, it is driver's responsibility to cover the race between timeout and completion, so it seems supposed to be solved in driver in theory, given driver has enough knowledge.  But it is really one common problem, lots of driver could have similar issue, and could be hard to fix all affected drivers, even it isn't easy for driver to handle the race. So David suggests this patch by draining in-progress ->queue_rq() for solving this issue.",
      "cve": "CVE-2022-50554",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50554",
          "value": "CVE-2022-50554",
          "url": "https://scout.docker.com/v/CVE-2022-50554?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50554?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db539e3da0523cd5e1f975dffa32291e37ea48216f2a57529e68ab67b18f2e39",
      "category": "container_scanning",
      "message": "CVE-2022-50571 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: call __btrfs_remove_free_space_cache_locked on cache load failure  Now that lockdep is staying enabled through our entire CI runs I started seeing the following stack in generic/475  ------------[ cut here ]------------ WARNING: CPU: 1 PID: 2171864 at fs/btrfs/discard.c:604 btrfs_discard_update_discardable+0x98/0xb0 CPU: 1 PID: 2171864 Comm: kworker/u4:0 Not tainted 5.19.0-rc8+ #789 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014 Workqueue: btrfs-cache btrfs_work_helper RIP: 0010:btrfs_discard_update_discardable+0x98/0xb0 RSP: 0018:ffffb857c2f7bad0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff8c85c605c200 RCX: 0000000000000001 RDX: 0000000000000000 RSI: ffffffff86807c5b RDI: ffffffff868a831e RBP: ffff8c85c4c54000 R08: 0000000000000000 R09: 0000000000000000 R10: ffff8c85c66932f0 R11: 0000000000000001 R12: ffff8c85c3899010 R13: ffff8c85d5be4f40 R14: ffff8c85c4c54000 R15: ffff8c86114bfa80 FS:  0000000000000000(0000) GS:ffff8c863bd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f2e7f168160 CR3: 000000010289a004 CR4: 0000000000370ee0 Call Trace:  __btrfs_remove_free_space_cache+0x27/0x30 load_free_space_cache+0xad2/0xaf0 caching_thread+0x40b/0x650 ? lock_release+0x137/0x2d0 btrfs_work_helper+0xf2/0x3e0 ? lock_is_held_type+0xe2/0x140 process_one_work+0x271/0x590 ? process_one_work+0x590/0x590 worker_thread+0x52/0x3b0 ? process_one_work+0x590/0x590 kthread+0xf0/0x120 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x1f/0x30  This is the code  ctl = block_group->free_space_ctl; discard_ctl = &block_group->fs_info->discard_ctl;  lockdep_assert_held(&ctl->tree_lock);  We have a temporary free space ctl for loading the free space cache in order to avoid having allocations happening while we're loading the cache.  When we hit an error we free it all up, however this also calls btrfs_discard_update_discardable, which requires block_group->free_space_ctl->tree_lock to be held.  However this is our temporary ctl so this lock isn't held.  Fix this by calling __btrfs_remove_free_space_cache_locked instead so that we only clean up the entries and do not mess with the discardable stats.",
      "cve": "CVE-2022-50571",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-50571",
          "value": "CVE-2022-50571",
          "url": "https://scout.docker.com/v/CVE-2022-50571?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-50571?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c6f2a97264bf91e522ef254c1c75c1bb53e926a4e746fe2cc64746264daeddc6",
      "category": "container_scanning",
      "message": "CVE-2023-39328 on ubuntu/openjpeg2@2.4.0-6ubuntu0.4",
      "description": "A vulnerability was found in OpenJPEG similar to CVE-2019-6988. This flaw allows an attacker to bypass existing protections and cause an application crash through a maliciously crafted file.",
      "cve": "CVE-2023-39328",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openjpeg2@2.4.0-6ubuntu0.4?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.4.0-6ubuntu0.4"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-39328",
          "value": "CVE-2023-39328",
          "url": "https://scout.docker.com/v/CVE-2023-39328?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-39328?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "926e6f211d21bb8686a0facb420c571528116af2483433e34eb667206720b3cf",
      "category": "container_scanning",
      "message": "CVE-2023-39329 on ubuntu/openjpeg2@2.4.0-6ubuntu0.4",
      "description": "A flaw was found in OpenJPEG. A resource exhaustion can occur in the opj_t1_decode_cblks function in tcd.c through a crafted image file, causing a denial of service.",
      "cve": "CVE-2023-39329",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openjpeg2@2.4.0-6ubuntu0.4?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.4.0-6ubuntu0.4"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-39329",
          "value": "CVE-2023-39329",
          "url": "https://scout.docker.com/v/CVE-2023-39329?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-39329?s=ubuntu&n=openjpeg2&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ca684b0a0f3ee44e21eb7af2058689d87c4bc5621d196c7fee76c87f681cfb42",
      "category": "container_scanning",
      "message": "CVE-2023-45896 on ubuntu/linux@5.15.0-161.171",
      "description": "ntfs3 in the Linux kernel through 6.8.0 allows a physically proximate attacker to read kernel memory by mounting a filesystem (e.g., if a Linux distribution is configured to allow unprivileged mounts of removable media) and then leveraging local access to trigger an out-of-bounds read. A length value can be larger than the amount of memory allocated. NOTE: the supplier's perspective is that there is no vulnerability when an attack requires an attacker-modified filesystem image.",
      "cve": "CVE-2023-45896",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-45896",
          "value": "CVE-2023-45896",
          "url": "https://scout.docker.com/v/CVE-2023-45896?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-45896?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7b3e2f3a332040ab37af82e200e2eef9cbc249b59be056e38cb497d47b3856ea",
      "category": "container_scanning",
      "message": "CVE-2023-51792 on ubuntu/libde265@1.0.8-1ubuntu0.3",
      "description": "Buffer Overflow vulnerability in libde265 v1.0.12 allows a local attacker to cause a denial of service via the allocation size exceeding the maximum supported size of 0x10000000000.",
      "cve": "CVE-2023-51792",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libde265@1.0.8-1ubuntu0.3?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.0.8-1ubuntu0.3"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-51792",
          "value": "CVE-2023-51792",
          "url": "https://scout.docker.com/v/CVE-2023-51792?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-51792?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "97fee11c223bc95f9f8cddfc7aa383791515a56bed9a1bea76ccef5d4876d464",
      "category": "container_scanning",
      "message": "CVE-2023-52481 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: errata: Add Cortex-A520 speculative unprivileged load workaround  Implement the workaround for ARM Cortex-A520 erratum 2966298. On an affected Cortex-A520 core, a speculatively executed unprivileged load might leak data from a privileged load via a cache side channel. The issue only exists for loads within a translation regime with the same translation (e.g. same ASID and VMID). Therefore, the issue only affects the return to EL0.  The workaround is to execute a TLBI before returning to EL0 after all loads of privileged data. A non-shareable TLBI to any address is sufficient.  The workaround isn't necessary if page table isolation (KPTI) is enabled, but for simplicity it will be. Page table isolation should normally be disabled for Cortex-A520 as it supports the CSV3 feature and the E0PD feature (used when KASLR is enabled).",
      "cve": "CVE-2023-52481",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52481",
          "value": "CVE-2023-52481",
          "url": "https://scout.docker.com/v/CVE-2023-52481?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52481?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5e32d9f35bf3de56394476c899e2c6d36772835cda9b60ccfe8dbeaff09c16cd",
      "category": "container_scanning",
      "message": "CVE-2023-52508 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-fc: Prevent null pointer dereference in nvme_fc_io_getuuid()  The nvme_fc_fcp_op structure describing an AEN operation is initialized with a null request structure pointer. An FC LLDD may make a call to nvme_fc_io_getuuid passing a pointer to an nvmefc_fcp_req for an AEN operation.  Add validation of the request structure pointer before dereference.",
      "cve": "CVE-2023-52508",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52508",
          "value": "CVE-2023-52508",
          "url": "https://scout.docker.com/v/CVE-2023-52508?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52508?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3d4ff509c74e6aa2ac93a3fd8ee8746ac21049d077208cdd1bfdd750d120164d",
      "category": "container_scanning",
      "message": "CVE-2023-52561 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  arm64: dts: qcom: sdm845-db845c: Mark cont splash memory region as reserved  Adding a reserved memory region for the framebuffer memory (the splash memory region set up by the bootloader).  It fixes a kernel panic (arm-smmu: Unhandled context fault at this particular memory region) reported on DB845c running v5.10.y.",
      "cve": "CVE-2023-52561",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52561",
          "value": "CVE-2023-52561",
          "url": "https://scout.docker.com/v/CVE-2023-52561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "10d827942e9a6c0ca7b17ad8dc37b048c579d37b9fe56a8c3b8882b92d1a9ded",
      "category": "container_scanning",
      "message": "CVE-2023-52576 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mm, kexec, ima: Use memblock_free_late() from ima_free_kexec_buffer()  The code calling ima_free_kexec_buffer() runs long after the memblock allocator has already been torn down, potentially resulting in a use after free in memblock_isolate_range().  With KASAN or KFENCE, this use after free will result in a BUG from the idle task, and a subsequent kernel panic.  Switch ima_free_kexec_buffer() over to memblock_free_late() to avoid that bug.",
      "cve": "CVE-2023-52576",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52576",
          "value": "CVE-2023-52576",
          "url": "https://scout.docker.com/v/CVE-2023-52576?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52576?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f4de00fd6aac4e7d266bf9055401292c7f394329253cced5ed70c64750e82a85",
      "category": "container_scanning",
      "message": "CVE-2023-52591 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  reiserfs: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change reiserfs rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
      "cve": "CVE-2023-52591",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52591",
          "value": "CVE-2023-52591",
          "url": "https://scout.docker.com/v/CVE-2023-52591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2fa38c34573e04c24bc3342b2bd974580537626a1c49ebe11e8382c9e7f627a4",
      "category": "container_scanning",
      "message": "CVE-2023-52653 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  SUNRPC: fix a memleak in gss_import_v2_context  The ctx->mech_used.data allocated by kmemdup is not freed in neither gss_import_v2_context nor it only caller gss_krb5_import_sec_context, which frees ctx on error.  Thus, this patch reform the last call of gss_import_v2_context to the gss_krb5_import_ctx_v2, preventing the memleak while keepping the return formation.",
      "cve": "CVE-2023-52653",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52653",
          "value": "CVE-2023-52653",
          "url": "https://scout.docker.com/v/CVE-2023-52653?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52653?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f13c5c110e59546363b7c8a1f2ca7d4233b238d3aa15c5feefcb72ea4ba6e7de",
      "category": "container_scanning",
      "message": "CVE-2023-52829 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix possible out-of-bound write in ath12k_wmi_ext_hal_reg_caps()  reg_cap.phy_id is extracted from WMI event and could be an unexpected value in case some errors happen. As a result out-of-bound write may occur to soc->hal_reg_cap. Fix it by validating reg_cap.phy_id before using it.  This is found during code review.  Compile tested only.",
      "cve": "CVE-2023-52829",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52829",
          "value": "CVE-2023-52829",
          "url": "https://scout.docker.com/v/CVE-2023-52829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "72d22d2d97952d126d2c347c86b04fa9d23118fdaec32cba1a9e430145def974",
      "category": "container_scanning",
      "message": "CVE-2023-52926 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  IORING_OP_READ did not correctly consume the provided buffer list when read i/o returned < 0 (except for -EAGAIN and -EIOCBQUEUED return). This can lead to a potential use-after-free when the completion via io_rw_done runs at separate context.",
      "cve": "CVE-2023-52926",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52926",
          "value": "CVE-2023-52926",
          "url": "https://scout.docker.com/v/CVE-2023-52926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "69cd972afae2b0f7ff789b0fbcb49a41b4f02aa9eba6eb26f9c99153cc8c3237",
      "category": "container_scanning",
      "message": "CVE-2023-52981 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/i915: Fix request ref counting during error capture & debugfs dump  When GuC support was added to error capture, the reference counting around the request object was broken. Fix it up.  The context based search manages the spinlocking around the search internally. So it needs to grab the reference count internally as well. The execlist only request based search relies on external locking, so it needs an external reference count but within the spinlock not outside it.  The only other caller of the context based search is the code for dumping engine state to debugfs. That code wasn't previously getting an explicit reference at all as it does everything while holding the execlist specific spinlock. So, that needs updaing as well as that spinlock doesn't help when using GuC submission. Rather than trying to conditionally get/put depending on submission model, just change it to always do the get/put.  v2: Explicitly document adding an extra blank line in some dense code (Andy Shevchenko). Fix multiple potential null pointer derefs in case of no request found (some spotted by Tvrtko, but there was more!). Also fix a leaked request in case of !started and another in __guc_reset_context now that intel_context_find_active_request is actually reference counting the returned request. v3: Add a _get suffix to intel_context_find_active_request now that it grabs a reference (Daniele). v4: Split the intel_guc_find_hung_context change to a separate patch and rename intel_context_find_active_request_get to intel_context_get_active_request (Tvrtko). v5: s/locking/reference counting/ in commit message (Tvrtko)  (cherry picked from commit 3700e353781e27f1bc7222f51f2cc36cbeb9b4ec)",
      "cve": "CVE-2023-52981",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52981",
          "value": "CVE-2023-52981",
          "url": "https://scout.docker.com/v/CVE-2023-52981?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52981?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ddc805b6cc18c332decd1a47eb1e3c4d372e640e7e2a7bdee85636407205b87b",
      "category": "container_scanning",
      "message": "CVE-2023-52990 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2023-52990",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52990",
          "value": "CVE-2023-52990",
          "url": "https://scout.docker.com/v/CVE-2023-52990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d5e478d20c9b9768544bf4907419881e0824d6d3fe203cab40dab5ff58606c2a",
      "category": "container_scanning",
      "message": "CVE-2023-53009 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Add sync after creating vram bo  There will be data corruption on vram allocated by svm if the initialization is not complete and application is writting on the memory. Adding sync to wait for the initialization completion is to resolve this issue.",
      "cve": "CVE-2023-53009",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53009",
          "value": "CVE-2023-53009",
          "url": "https://scout.docker.com/v/CVE-2023-53009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db7b8e4f0b1e491bf0a8a6b78370e0432b5b88e4c7d320e672b9a9915e0615b5",
      "category": "container_scanning",
      "message": "CVE-2023-53010 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bnxt: Do not read past the end of test names  Test names were being concatenated based on a offset beyond the end of the first name, which tripped the buffer overflow detection logic:  detected buffer overflow in strnlen [...] Call Trace: bnxt_ethtool_init.cold+0x18/0x18  Refactor struct hwrm_selftest_qlist_output to use an actual array, and adjust the concatenation to use snprintf() rather than a series of strncat() calls.",
      "cve": "CVE-2023-53010",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53010",
          "value": "CVE-2023-53010",
          "url": "https://scout.docker.com/v/CVE-2023-53010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "604a578e1566a336cc1f3eba216b8128a28b171d58c7beaa7b93058937e52d8f",
      "category": "container_scanning",
      "message": "CVE-2023-53036 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix call trace warning and hang when removing amdgpu device  On GPUs with RAS enabled, below call trace and hang are observed when shutting down device.  v2: use DRM device unplugged flag instead of shutdown flag as the check to prevent memory wipe in shutdown stage.  [ +0.000000] RIP: 0010:amdgpu_vram_mgr_fini+0x18d/0x1c0 [amdgpu] [ +0.000001] PKRU: 55555554 [ +0.000001] Call Trace: [ +0.000001] <TASK> [ +0.000002] amdgpu_ttm_fini+0x140/0x1c0 [amdgpu] [ +0.000183] amdgpu_bo_fini+0x27/0xa0 [amdgpu] [ +0.000184] gmc_v11_0_sw_fini+0x2b/0x40 [amdgpu] [ +0.000163] amdgpu_device_fini_sw+0xb6/0x510 [amdgpu] [ +0.000152] amdgpu_driver_release_kms+0x16/0x30 [amdgpu] [ +0.000090] drm_dev_release+0x28/0x50 [drm] [ +0.000016] devm_drm_dev_init_release+0x38/0x60 [drm] [ +0.000011] devm_action_release+0x15/0x20 [ +0.000003] release_nodes+0x40/0xc0 [ +0.000001] devres_release_all+0x9e/0xe0 [ +0.000001] device_unbind_cleanup+0x12/0x80 [ +0.000003] device_release_driver_internal+0xff/0x160 [ +0.000001] driver_detach+0x4a/0x90 [ +0.000001] bus_remove_driver+0x6c/0xf0 [ +0.000001] driver_unregister+0x31/0x50 [ +0.000001] pci_unregister_driver+0x40/0x90 [ +0.000003] amdgpu_exit+0x15/0x120 [amdgpu]",
      "cve": "CVE-2023-53036",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53036",
          "value": "CVE-2023-53036",
          "url": "https://scout.docker.com/v/CVE-2023-53036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2db4d67a84b4fe0dee2842834306d2cd22b9b39db66fca2eb2ff5ecd7b3e6c6f",
      "category": "container_scanning",
      "message": "CVE-2023-53037 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Bad drive in topology results kernel crash  When the SAS Transport Layer support is enabled and a device exposed to the OS by the driver fails INQUIRY commands, the driver frees up the memory allocated for an internal HBA port data structure. However, in some places, the reference to the freed memory is not cleared. When the firmware sends the Device Info change event for the same device again, the freed memory is accessed and that leads to memory corruption and OS crash.",
      "cve": "CVE-2023-53037",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53037",
          "value": "CVE-2023-53037",
          "url": "https://scout.docker.com/v/CVE-2023-53037?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53037?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "63b1394b884cb67b4f9244aae87594bdee8544da2ea76086c9b196011ead98ac",
      "category": "container_scanning",
      "message": "CVE-2023-53042 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Do not set DRR on pipe Commit  [WHY] Writing to DRR registers such as OTG_V_TOTAL_MIN on the same frame as a pipe commit can cause underflow.",
      "cve": "CVE-2023-53042",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53042",
          "value": "CVE-2023-53042",
          "url": "https://scout.docker.com/v/CVE-2023-53042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4346e158e847eaaaecb7a9571ce7db2a989232bdb10919acd69c08eb7ffd115b",
      "category": "container_scanning",
      "message": "CVE-2023-53063 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2023-53063",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53063",
          "value": "CVE-2023-53063",
          "url": "https://scout.docker.com/v/CVE-2023-53063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c671963dbd916b5ce294cf7e0d73a53c1c5b30da455c81078c164d52a955e1b0",
      "category": "container_scanning",
      "message": "CVE-2023-53067 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  LoongArch: Only call get_timer_irq() once in constant_clockevent_init()  Under CONFIG_DEBUG_ATOMIC_SLEEP=y and CONFIG_DEBUG_PREEMPT=y, we can see the following messages on LoongArch, this is because using might_sleep() in preemption disable context.  [    0.001127] smp: Bringing up secondary CPUs ... [    0.001222] Booting CPU#1... [    0.001244] 64-bit Loongson Processor probed (LA464 Core) [    0.001247] CPU1 revision is: 0014c012 (Loongson-64bit) [    0.001250] FPU1 revision is: 00000000 [    0.001252] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283 [    0.001255] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1 [    0.001257] preempt_count: 1, expected: 0 [    0.001258] RCU nest depth: 0, expected: 0 [    0.001259] Preemption disabled at: [    0.001261] [<9000000000223800>] arch_dup_task_struct+0x20/0x110 [    0.001272] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc7+ #43 [    0.001275] Hardware name: Loongson Loongson-3A5000-7A1000-1w-A2101/Loongson-LS3A5000-7A1000-1w-A2101, BIOS vUDK2018-LoongArch-V4.0.05132-beta10 12/13/202 [    0.001277] Stack : 0072617764726148 0000000000000000 9000000000222f1c 90000001001e0000 [    0.001286]         90000001001e3be0 90000001001e3be8 0000000000000000 0000000000000000 [    0.001292]         90000001001e3be8 0000000000000040 90000001001e3cb8 90000001001e3a50 [    0.001297]         9000000001642000 90000001001e3be8 be694d10ce4139dd 9000000100174500 [    0.001303]         0000000000000001 0000000000000001 00000000ffffe0a2 0000000000000020 [    0.001309]         000000000000002f 9000000001354116 00000000056b0000 ffffffffffffffff [    0.001314]         0000000000000000 0000000000000000 90000000014f6e90 9000000001642000 [    0.001320]         900000000022b69c 0000000000000001 0000000000000000 9000000001736a90 [    0.001325]         9000000100038000 0000000000000000 9000000000222f34 0000000000000000 [    0.001331]         00000000000000b0 0000000000000004 0000000000000000 0000000000070000 [    0.001337]         ... [    0.001339] Call Trace: [    0.001342] [<9000000000222f34>] show_stack+0x5c/0x180 [    0.001346] [<90000000010bdd80>] dump_stack_lvl+0x60/0x88 [    0.001352] [<9000000000266418>] __might_resched+0x180/0x1cc [    0.001356] [<90000000010c742c>] mutex_lock+0x20/0x64 [    0.001359] [<90000000002a8ccc>] irq_find_matching_fwspec+0x48/0x124 [    0.001364] [<90000000002259c4>] constant_clockevent_init+0x68/0x204 [    0.001368] [<900000000022acf4>] start_secondary+0x40/0xa8 [    0.001371] [<90000000010c0124>] smpboot_entry+0x60/0x64  Here are the complete call chains:  smpboot_entry() start_secondary() constant_clockevent_init() get_timer_irq() irq_find_matching_fwnode() irq_find_matching_fwspec() mutex_lock() might_sleep() __might_sleep() __might_resched()  In order to avoid the above issue, we should break the call chains, using timer_irq_installed variable as check condition to only call get_timer_irq() once in constant_clockevent_init() is a simple and proper way.",
      "cve": "CVE-2023-53067",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53067",
          "value": "CVE-2023-53067",
          "url": "https://scout.docker.com/v/CVE-2023-53067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "884a1229ef8c10fcd28d3791117c361053e5711d2e2eb7bccf71b45b3c8e8b9e",
      "category": "container_scanning",
      "message": "CVE-2023-53068 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: usb: lan78xx: Limit packet length to skb->len  Packet length retrieved from descriptor may be larger than the actual socket buffer length. In such case the cloned skb passed up the network stack will leak kernel memory contents.  Additionally prevent integer underflow when size is less than ETH_FCS_LEN.",
      "cve": "CVE-2023-53068",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53068",
          "value": "CVE-2023-53068",
          "url": "https://scout.docker.com/v/CVE-2023-53068?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53068?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4e36e42cabecf0ead9999f25addd415bc459b72ac744db6bf580b86299857ab5",
      "category": "container_scanning",
      "message": "CVE-2023-53072 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mptcp: use the workqueue to destroy unaccepted sockets  Christoph reported a UaF at token lookup time after having refactored the passive socket initialization part:  BUG: KASAN: use-after-free in __token_bucket_busy+0x253/0x260 Read of size 4 at addr ffff88810698d5b0 by task syz-executor653/3198  CPU: 1 PID: 3198 Comm: syz-executor653 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x6e/0x91 print_report+0x16a/0x46f kasan_report+0xad/0x130 __token_bucket_busy+0x253/0x260 mptcp_token_new_connect+0x13d/0x490 mptcp_connect+0x4ed/0x860 __inet_stream_connect+0x80e/0xd90 tcp_sendmsg_fastopen+0x3ce/0x710 mptcp_sendmsg+0xff1/0x1a20 inet_sendmsg+0x11d/0x140 __sys_sendto+0x405/0x490 __x64_sys_sendto+0xdc/0x1b0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc  We need to properly clean-up all the paired MPTCP-level resources and be sure to release the msk last, even when the unaccepted subflow is destroyed by the TCP internals via inet_child_forget().  We can re-use the existing MPTCP_WORK_CLOSE_SUBFLOW infra, explicitly checking that for the critical scenario: the closed subflow is the MPC one, the msk is not accepted and eventually going through full cleanup.  With such change, __mptcp_destroy_sock() is always called on msk sockets, even on accepted ones. We don't need anymore to transiently drop one sk reference at msk clone time.  Please note this commit depends on the parent one:  mptcp: refactor passive socket initialization",
      "cve": "CVE-2023-53072",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53072",
          "value": "CVE-2023-53072",
          "url": "https://scout.docker.com/v/CVE-2023-53072?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53072?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ef2ce1015c12bed41c91e5020a704b7f15ff93e048982661ad9ba27492997e2e",
      "category": "container_scanning",
      "message": "CVE-2023-53093 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Do not let histogram values have some modifiers  Histogram values can not be strings, stacktraces, graphs, symbols, syscalls, or grouped in buckets or log. Give an error if a value is set to do so.  Note, the histogram code was not prepared to handle these modifiers for histograms and caused a bug.  Mark Rutland reported:  # echo 'p:copy_to_user __arch_copy_to_user n=$arg2' >> /sys/kernel/tracing/kprobe_events # echo 'hist:keys=n:vals=hitcount.buckets=8:sort=hitcount' > /sys/kernel/tracing/events/kprobes/copy_to_user/trigger # cat /sys/kernel/tracing/events/kprobes/copy_to_user/hist [  143.694628] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [  143.695190] Mem abort info: [  143.695362]   ESR = 0x0000000096000004 [  143.695604]   EC = 0x25: DABT (current EL), IL = 32 bits [  143.695889]   SET = 0, FnV = 0 [  143.696077]   EA = 0, S1PTW = 0 [  143.696302]   FSC = 0x04: level 0 translation fault [  143.702381] Data abort info: [  143.702614]   ISV = 0, ISS = 0x00000004 [  143.702832]   CM = 0, WnR = 0 [  143.703087] user pgtable: 4k pages, 48-bit VAs, pgdp=00000000448f9000 [  143.703407] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 [  143.704137] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [  143.704714] Modules linked in: [  143.705273] CPU: 0 PID: 133 Comm: cat Not tainted 6.2.0-00003-g6fc512c10a7c #3 [  143.706138] Hardware name: linux,dummy-virt (DT) [  143.706723] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  143.707120] pc : hist_field_name.part.0+0x14/0x140 [  143.707504] lr : hist_field_name.part.0+0x104/0x140 [  143.707774] sp : ffff800008333a30 [  143.707952] x29: ffff800008333a30 x28: 0000000000000001 x27: 0000000000400cc0 [  143.708429] x26: ffffd7a653b20260 x25: 0000000000000000 x24: ffff10d303ee5800 [  143.708776] x23: ffffd7a6539b27b0 x22: ffff10d303fb8c00 x21: 0000000000000001 [  143.709127] x20: ffff10d303ec2000 x19: 0000000000000000 x18: 0000000000000000 [  143.709478] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 [  143.709824] x14: 0000000000000000 x13: 203a6f666e692072 x12: 6567676972742023 [  143.710179] x11: 0a230a6d6172676f x10: 000000000000002c x9 : ffffd7a6521e018c [  143.710584] x8 : 000000000000002c x7 : 7f7f7f7f7f7f7f7f x6 : 000000000000002c [  143.710915] x5 : ffff10d303b0103e x4 : ffffd7a653b20261 x3 : 000000000000003d [  143.711239] x2 : 0000000000020001 x1 : 0000000000000001 x0 : 0000000000000000 [  143.711746] Call trace: [  143.712115]  hist_field_name.part.0+0x14/0x140 [  143.712642]  hist_field_name.part.0+0x104/0x140 [  143.712925]  hist_field_print+0x28/0x140 [  143.713125]  event_hist_trigger_print+0x174/0x4d0 [  143.713348]  hist_show+0xf8/0x980 [  143.713521]  seq_read_iter+0x1bc/0x4b0 [  143.713711]  seq_read+0x8c/0xc4 [  143.713876]  vfs_read+0xc8/0x2a4 [  143.714043]  ksys_read+0x70/0xfc [  143.714218]  __arm64_sys_read+0x24/0x30 [  143.714400]  invoke_syscall+0x50/0x120 [  143.714587]  el0_svc_common.constprop.0+0x4c/0x100 [  143.714807]  do_el0_svc+0x44/0xd0 [  143.714970]  el0_svc+0x2c/0x84 [  143.715134]  el0t_64_sync_handler+0xbc/0x140 [  143.715334]  el0t_64_sync+0x190/0x194 [  143.715742] Code: a9bd7bfd 910003fd a90153f3 aa0003f3 (f9400000) [  143.716510] ---[ end trace 0000000000000000 ]--- Segmentation fault",
      "cve": "CVE-2023-53093",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53093",
          "value": "CVE-2023-53093",
          "url": "https://scout.docker.com/v/CVE-2023-53093?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53093?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9fa49f62c80c0a7373bc54496ab8ba467709d3e544e5c4d7b2f8d4622a6f992a",
      "category": "container_scanning",
      "message": "CVE-2023-53105 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Fix cleanup null-ptr deref on encap lock  During module is unloaded while a peer tc flow is still offloaded, first the peer uplink rep profile is changed to a nic profile, and so neigh encap lock is destroyed. Next during unload, the VF reps netdevs are unregistered which causes the original non-peer tc flow to be deleted, which deletes the peer flow. The peer flow deletion detaches the encap entry and try to take the already destroyed encap lock, causing the below trace.  Fix this by clearing peer flows during tc eswitch cleanup (mlx5e_tc_esw_cleanup()).  Relevant trace: [ 4316.837128] BUG: kernel NULL pointer dereference, address: 00000000000001d8 [ 4316.842239] RIP: 0010:__mutex_lock+0xb5/0xc40 [ 4316.851897] Call Trace: [ 4316.852481]  <TASK> [ 4316.857214]  mlx5e_rep_neigh_entry_release+0x93/0x790 [mlx5_core] [ 4316.858258]  mlx5e_rep_encap_entry_detach+0xa7/0xf0 [mlx5_core] [ 4316.859134]  mlx5e_encap_dealloc+0xa3/0xf0 [mlx5_core] [ 4316.859867]  clean_encap_dests.part.0+0x5c/0xe0 [mlx5_core] [ 4316.860605]  mlx5e_tc_del_fdb_flow+0x32a/0x810 [mlx5_core] [ 4316.862609]  __mlx5e_tc_del_fdb_peer_flow+0x1a2/0x250 [mlx5_core] [ 4316.863394]  mlx5e_tc_del_flow+0x(/0x630 [mlx5_core] [ 4316.864090]  mlx5e_flow_put+0x5f/0x100 [mlx5_core] [ 4316.864771]  mlx5e_delete_flower+0x4de/0xa40 [mlx5_core] [ 4316.865486]  tc_setup_cb_reoffload+0x20/0x80 [ 4316.865905]  fl_reoffload+0x47c/0x510 [cls_flower] [ 4316.869181]  tcf_block_playback_offloads+0x91/0x1d0 [ 4316.869649]  tcf_block_unbind+0xe7/0x1b0 [ 4316.870049]  tcf_block_offload_cmd.isra.0+0x1ee/0x270 [ 4316.879266]  tcf_block_offload_unbind+0x61/0xa0 [ 4316.879711]  __tcf_block_put+0xa4/0x310",
      "cve": "CVE-2023-53105",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53105",
          "value": "CVE-2023-53105",
          "url": "https://scout.docker.com/v/CVE-2023-53105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e046b2d97c6a594e6e7465575121c20d6fed2e51ca48fbbc087852a34adeba72",
      "category": "container_scanning",
      "message": "CVE-2023-53115 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Fix memory leaks in mpi3mr_init_ioc()  Don't allocate memory again when IOC is being reinitialized.",
      "cve": "CVE-2023-53115",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53115",
          "value": "CVE-2023-53115",
          "url": "https://scout.docker.com/v/CVE-2023-53115?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53115?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c5d06e44a0ccb2ad4ef2d3799bdc89f53311458523df568a5bc0cc3b9f373bbd",
      "category": "container_scanning",
      "message": "CVE-2023-53122 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2023-53122",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53122",
          "value": "CVE-2023-53122",
          "url": "https://scout.docker.com/v/CVE-2023-53122?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53122?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "04dea2f5ab6442b2440871d43fa78cb32103ff81c7c0c7ed339a035a0dd6f158",
      "category": "container_scanning",
      "message": "CVE-2023-53149 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: avoid deadlock in fs reclaim with page writeback  Ext4 has a filesystem wide lock protecting ext4_writepages() calls to avoid races with switching of journalled data flag or inode format. This lock can however cause a deadlock like:  CPU0                            CPU1  ext4_writepages() percpu_down_read(sbi->s_writepages_rwsem); ext4_change_inode_journal_flag()  percpu_down_write(sbi->s_writepages_rwsem); - blocks, all readers block from now on ext4_do_writepages() ext4_init_io_end() kmem_cache_zalloc(io_end_cachep, GFP_KERNEL) fs_reclaim frees dentry... dentry_unlink_inode() iput() - last ref => iput_final() - inode dirty => write_inode_now()... ext4_writepages() tries to acquire sbi->s_writepages_rwsem and blocks forever  Make sure we cannot recurse into filesystem reclaim from writeback code to avoid the deadlock.",
      "cve": "CVE-2023-53149",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53149",
          "value": "CVE-2023-53149",
          "url": "https://scout.docker.com/v/CVE-2023-53149?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53149?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "67a40d7721e5b3e4daa70403ceb3852b74583b19d5425b0338d9322a02523fb2",
      "category": "container_scanning",
      "message": "CVE-2023-53152 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix calltrace warning in amddrm_buddy_fini  The following call trace is observed when removing the amdgpu driver, which is caused by that BOs allocated for psp are not freed until removing.  [61811.450562] RIP: 0010:amddrm_buddy_fini.cold+0x29/0x47 [amddrm_buddy] [61811.450577] Call Trace: [61811.450577]  <TASK> [61811.450579]  amdgpu_vram_mgr_fini+0x135/0x1c0 [amdgpu] [61811.450728]  amdgpu_ttm_fini+0x207/0x290 [amdgpu] [61811.450870]  amdgpu_bo_fini+0x27/0xa0 [amdgpu] [61811.451012]  gmc_v9_0_sw_fini+0x4a/0x60 [amdgpu] [61811.451166]  amdgpu_device_fini_sw+0x117/0x520 [amdgpu] [61811.451306]  amdgpu_driver_release_kms+0x16/0x30 [amdgpu] [61811.451447]  devm_drm_dev_init_release+0x4d/0x80 [drm] [61811.451466]  devm_action_release+0x15/0x20 [61811.451469]  release_nodes+0x40/0xb0 [61811.451471]  devres_release_all+0x9b/0xd0 [61811.451473]  __device_release_driver+0x1bb/0x2a0 [61811.451476]  driver_detach+0xf3/0x140 [61811.451479]  bus_remove_driver+0x6c/0xf0 [61811.451481]  driver_unregister+0x31/0x60 [61811.451483]  pci_unregister_driver+0x40/0x90 [61811.451486]  amdgpu_exit+0x15/0x447 [amdgpu]  For smu v13_0_2, if the GPU supports xgmi, refer to  commit f5c7e7797060 (\"drm/amdgpu: Adjust removal control flow for smu v13_0_2\"),  it will run gpu recover in AMDGPU_RESET_FOR_DEVICE_REMOVE mode when removing, which makes all devices in hive list have hw reset but no resume except the basic ip blocks, then other ip blocks will not call .hw_fini according to ip_block.status.hw.  Since psp_free_shared_bufs just includes some software operations, so move it to psp_sw_fini.",
      "cve": "CVE-2023-53152",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53152",
          "value": "CVE-2023-53152",
          "url": "https://scout.docker.com/v/CVE-2023-53152?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53152?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0a10bdd66f862522e337c28016ecf0e5235b461a49e2158840fbfd79f17bafcc",
      "category": "container_scanning",
      "message": "CVE-2023-53168 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: ucsi_acpi: Increase the command completion timeout  Commit 130a96d698d7 (\"usb: typec: ucsi: acpi: Increase command completion timeout value\") increased the timeout from 5 seconds to 60 seconds due to issues related to alternate mode discovery.  After the alternate mode discovery switch to polled mode the timeout was reduced, but instead of being set back to 5 seconds it was reduced to 1 second.  This is causing problems when using a Lenovo ThinkPad X1 yoga gen7 connected over Type-C to a LG 27UL850-W (charging DP over Type-C).  When the monitor is already connected at boot the following error is logged: \"PPM init failed (-110)\", /sys/class/typec is empty and on unplugging the NULL pointer deref fixed earlier in this series happens.  When the monitor is connected after boot the following error is logged instead: \"GET_CONNECTOR_STATUS failed (-110)\".  Setting the timeout back to 5 seconds fixes both cases.",
      "cve": "CVE-2023-53168",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53168",
          "value": "CVE-2023-53168",
          "url": "https://scout.docker.com/v/CVE-2023-53168?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53168?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "859c11b0337c24086504beae35505faf7845f1673d5d66ce8031167f6e816f4a",
      "category": "container_scanning",
      "message": "CVE-2023-53178 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: fix zswap writeback race condition  The zswap writeback mechanism can cause a race condition resulting in memory corruption, where a swapped out page gets swapped in with data that was written to a different page.  The race unfolds like this: 1. a page with data A and swap offset X is stored in zswap 2. page A is removed off the LRU by zpool driver for writeback in zswap-shrink work, data for A is mapped by zpool driver 3. user space program faults and invalidates page entry A, offset X is considered free 4. kswapd stores page B at offset X in zswap (zswap could also be full, if so, page B would then be IOed to X, then skip step 5.) 5. entry A is replaced by B in tree->rbroot, this doesn't affect the local reference held by zswap-shrink work 6. zswap-shrink work writes back A at X, and frees zswap entry A 7. swapin of slot X brings A in memory instead of B  The fix: Once the swap page cache has been allocated (case ZSWAP_SWAPCACHE_NEW), zswap-shrink work just checks that the local zswap_entry reference is still the same as the one in the tree.  If it's not the same it means that it's either been invalidated or replaced, in both cases the writeback is aborted because the local entry contains stale data.  Reproducer: I originally found this by running `stress` overnight to validate my work on the zswap writeback mechanism, it manifested after hours on my test machine.  The key to make it happen is having zswap writebacks, so whatever setup pumps /sys/kernel/debug/zswap/written_back_pages should do the trick.  In order to reproduce this faster on a vm, I setup a system with ~100M of available memory and a 500M swap file, then running `stress --vm 1 --vm-bytes 300000000 --vm-stride 4000` makes it happen in matter of tens of minutes.  One can speed things up even more by swinging /sys/module/zswap/parameters/max_pool_percent up and down between, say, 20 and 1; this makes it reproduce in tens of seconds.  It's crucial to set `--vm-stride` to something other than 4096 otherwise `stress` won't realize that memory has been corrupted because all pages would have the same data.",
      "cve": "CVE-2023-53178",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53178",
          "value": "CVE-2023-53178",
          "url": "https://scout.docker.com/v/CVE-2023-53178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "58855f8f34d35477b019d58d369282223c4cb9799eaa65402d98c073bbe9f424",
      "category": "container_scanning",
      "message": "CVE-2023-53180 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Avoid NULL pointer access during management transmit cleanup  Currently 'ar' reference is not added in skb_cb. Though this is generally not used during transmit completion callbacks, on interface removal the remaining idr cleanup callback uses the ar pointer from skb_cb from management txmgmt_idr. Hence fill them during transmit call for proper usage to avoid NULL pointer dereference.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2023-53180",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53180",
          "value": "CVE-2023-53180",
          "url": "https://scout.docker.com/v/CVE-2023-53180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "62df927c06f02d21d911a289c12cc4cef1592fb7b9ce26dd16877be29765940a",
      "category": "container_scanning",
      "message": "CVE-2023-53187 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix use-after-free of new block group that became unused  If a task creates a new block group and that block group becomes unused before we finish its creation, at btrfs_create_pending_block_groups(), then when btrfs_mark_bg_unused() is called against the block group, we assume that the block group is currently in the list of block groups to reclaim, and we move it out of the list of new block groups and into the list of unused block groups. This has two consequences:  1) We move it out of the list of new block groups associated to the current transaction. So the block group creation is not finished and if we attempt to delete the bg because it's unused, we will not find the block group item in the extent tree (or the new block group tree), its device extent items in the device tree etc, resulting in the deletion to fail due to the missing items;  2) We don't increment the reference count on the block group when we move it to the list of unused block groups, because we assumed the block group was on the list of block groups to reclaim, and in that case it already has the correct reference count. However the block group was on the list of new block groups, in which case no extra reference was taken because it's local to the current task. This later results in doing an extra reference count decrement when removing the block group from the unused list, eventually leading the reference count to 0.  This second case was caught when running generic/297 from fstests, which produced the following assertion failure and stack trace:  [589.559] assertion failed: refcount_read(&block_group->refs) == 1, in fs/btrfs/block-group.c:4299 [589.559] ------------[ cut here ]------------ [589.559] kernel BUG at fs/btrfs/block-group.c:4299! [589.560] invalid opcode: 0000 [#1] PREEMPT SMP PTI [589.560] CPU: 8 PID: 2819134 Comm: umount Tainted: G        W 6.4.0-rc6-btrfs-next-134+ #1 [589.560] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014 [589.560] RIP: 0010:btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.561] Code: 68 62 da c0 (...) [589.561] RSP: 0018:ffffa55a8c3b3d98 EFLAGS: 00010246 [589.561] RAX: 0000000000000058 RBX: ffff8f030d7f2000 RCX: 0000000000000000 [589.562] RDX: 0000000000000000 RSI: ffffffff953f0878 RDI: 00000000ffffffff [589.562] RBP: ffff8f030d7f2088 R08: 0000000000000000 R09: ffffa55a8c3b3c50 [589.562] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8f05850b4c00 [589.562] R13: ffff8f030d7f2090 R14: ffff8f05850b4cd8 R15: dead000000000100 [589.563] FS:  00007f497fd2e840(0000) GS:ffff8f09dfc00000(0000) knlGS:0000000000000000 [589.563] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [589.563] CR2: 00007f497ff8ec10 CR3: 0000000271472006 CR4: 0000000000370ee0 [589.563] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [589.564] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [589.564] Call Trace: [589.564]  <TASK> [589.565]  ? __die_body+0x1b/0x60 [589.565]  ? die+0x39/0x60 [589.565]  ? do_trap+0xeb/0x110 [589.565]  ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.566]  ? do_error_trap+0x6a/0x90 [589.566]  ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.566]  ? exc_invalid_op+0x4e/0x70 [589.566]  ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567]  ? asm_exc_invalid_op+0x16/0x20 [589.567]  ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567]  ? btrfs_free_block_groups+0x449/0x4a0 [btrfs] [589.567]  close_ctree+0x35d/0x560 [btrfs] [589.568]  ? fsnotify_sb_delete+0x13e/0x1d0 [589.568]  ? dispose_list+0x3a/0x50 [589.568]  ? evict_inodes+0x151/0x1a0 [589.568]  generic_shutdown_super+0x73/0x1a0 [589.569]  kill_anon_super+0x14/0x30 [589.569]  btrfs_kill_super+0x12/0x20 [btrfs] [589.569]  deactivate_locked ---truncated---",
      "cve": "CVE-2023-53187",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53187",
          "value": "CVE-2023-53187",
          "url": "https://scout.docker.com/v/CVE-2023-53187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3145fe05d0aacabee81ed249889fd4ae16cac56c3710a7d9753f70e496f567d",
      "category": "container_scanning",
      "message": "CVE-2023-53198 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  raw: Fix NULL deref in raw_get_next().  Dae R. Jeong reported a NULL deref in raw_get_next() [0].  It seems that the repro was running these sequences in parallel so that one thread was iterating on a socket that was being freed in another netns.  unshare(0x40060200) r0 = syz_open_procfs(0x0, &(0x7f0000002080)='net/raw\\x00') socket$inet_icmp_raw(0x2, 0x3, 0x1) pread64(r0, &(0x7f0000000000)=\"\"/10, 0xa, 0x10000000007f)  After commit 0daf07e52709 (\"raw: convert raw sockets to RCU\"), we use RCU and hlist_nulls_for_each_entry() to iterate over SOCK_RAW sockets.  However, we should use spinlock for slow paths to avoid the NULL deref.  Also, SOCK_RAW does not use SLAB_TYPESAFE_BY_RCU, and the slab object is not reused during iteration in the grace period.  In fact, the lockless readers do not check the nulls marker with get_nulls_value(). So, SOCK_RAW should use hlist instead of hlist_nulls.  Instead of adding an unnecessary barrier by sk_nulls_for_each_rcu(), let's convert hlist_nulls to hlist and use sk_for_each_rcu() for fast paths and sk_for_each() and spinlock for /proc/net/raw.  [0]: general protection fault, probably for non-canonical address 0xdffffc0000000005: 0000 [#1] PREEMPT SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000028-0x000000000000002f] CPU: 2 PID: 20952 Comm: syz-executor.0 Not tainted 6.2.0-g048ec869bafd-dirty #7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 RIP: 0010:read_pnet include/net/net_namespace.h:383 [inline] RIP: 0010:sock_net include/net/sock.h:649 [inline] RIP: 0010:raw_get_next net/ipv4/raw.c:974 [inline] RIP: 0010:raw_get_idx net/ipv4/raw.c:986 [inline] RIP: 0010:raw_seq_start+0x431/0x800 net/ipv4/raw.c:995 Code: ef e8 33 3d 94 f7 49 8b 6d 00 4c 89 ef e8 b7 65 5f f7 49 89 ed 49 83 c5 98 0f 84 9a 00 00 00 48 83 c5 c8 48 89 e8 48 c1 e8 03 <42> 80 3c 30 00 74 08 48 89 ef e8 00 3d 94 f7 4c 8b 7d 00 48 89 ef RSP: 0018:ffffc9001154f9b0 EFLAGS: 00010206 RAX: 0000000000000005 RBX: 1ffff1100302c8fd RCX: 0000000000000000 RDX: 0000000000000028 RSI: ffffc9001154f988 RDI: ffffc9000f77a338 RBP: 0000000000000029 R08: ffffffff8a50ffb4 R09: fffffbfff24b6bd9 R10: fffffbfff24b6bd9 R11: 0000000000000000 R12: ffff88801db73b78 R13: fffffffffffffff9 R14: dffffc0000000000 R15: 0000000000000030 FS:  00007f843ae8e700(0000) GS:ffff888063700000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055bb9614b35f CR3: 000000003c672000 CR4: 00000000003506e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> seq_read_iter+0x4c6/0x10f0 fs/seq_file.c:225 seq_read+0x224/0x320 fs/seq_file.c:162 pde_read fs/proc/inode.c:316 [inline] proc_reg_read+0x23f/0x330 fs/proc/inode.c:328 vfs_read+0x31e/0xd30 fs/read_write.c:468 ksys_pread64 fs/read_write.c:665 [inline] __do_sys_pread64 fs/read_write.c:675 [inline] __se_sys_pread64 fs/read_write.c:672 [inline] __x64_sys_pread64+0x1e9/0x280 fs/read_write.c:672 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x4e/0xa0 arch/x86/entry/common.c:82 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x478d29 Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f843ae8dbe8 EFLAGS: 00000246 ORIG_RAX: 0000000000000011 RAX: ffffffffffffffda RBX: 0000000000791408 RCX: 0000000000478d29 RDX: 000000000000000a RSI: 0000000020000000 RDI: 0000000000000003 RBP: 00000000f477909a R08: 0000000000000000 R09: 0000000000000000 R10: 000010000000007f R11: 0000000000000246 R12: 0000000000791740 R13: 0000000000791414 R14: 0000000000791408 R15: 00007ffc2eb48a50 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010 ---truncated---",
      "cve": "CVE-2023-53198",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53198",
          "value": "CVE-2023-53198",
          "url": "https://scout.docker.com/v/CVE-2023-53198?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53198?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "871b2d27a38172cffc2e2802b19c08618ac81d35597027a9c05539e973bf2bfa",
      "category": "container_scanning",
      "message": "CVE-2023-53209 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211_hwsim: Fix possible NULL dereference  In a call to mac80211_hwsim_select_tx_link() the sta pointer might be NULL, thus need to check that it is not NULL before accessing it.",
      "cve": "CVE-2023-53209",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53209",
          "value": "CVE-2023-53209",
          "url": "https://scout.docker.com/v/CVE-2023-53209?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53209?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a4dd4717c5ec2b9928973f338dbadab2579a865df685867ecf1c50364c4a6ba",
      "category": "container_scanning",
      "message": "CVE-2023-53218 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rxrpc: Make it so that a waiting process can be aborted  When sendmsg() creates an rxrpc call, it queues it to wait for a connection and channel to be assigned and then waits before it can start shovelling data as the encrypted DATA packet content includes a summary of the connection parameters.  However, sendmsg() may get interrupted before a connection gets assigned and further sendmsg() calls will fail with EBUSY until an assignment is made.  Fix this so that the call can at least be aborted without failing on EBUSY.  We have to be careful here as sendmsg() mustn't be allowed to start the call timer if the call doesn't yet have a connection assigned as an oops may follow shortly thereafter.",
      "cve": "CVE-2023-53218",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53218",
          "value": "CVE-2023-53218",
          "url": "https://scout.docker.com/v/CVE-2023-53218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "43086e384ab801e2f8d80959cbe3a91290adcea02ac42fbe00146454d07a7bf4",
      "category": "container_scanning",
      "message": "CVE-2023-53221 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix memleak due to fentry attach failure  If it fails to attach fentry, the allocated bpf trampoline image will be left in the system. That can be verified by checking /proc/kallsyms.  This meamleak can be verified by a simple bpf program as follows:  SEC(\"fentry/trap_init\") int fentry_run() { return 0; }  It will fail to attach trap_init because this function is freed after kernel init, and then we can find the trampoline image is left in the system by checking /proc/kallsyms.  $ tail /proc/kallsyms ffffffffc0613000 t bpf_trampoline_6442453466_1  [bpf] ffffffffc06c3000 t bpf_trampoline_6442453466_1  [bpf]  $ bpftool btf dump file /sys/kernel/btf/vmlinux | grep \"FUNC 'trap_init'\" [2522] FUNC 'trap_init' type_id=119 linkage=static  $ echo $((6442453466 & 0x7fffffff)) 2522  Note that there are two left bpf trampoline images, that is because the libbpf will fallback to raw tracepoint if -EINVAL is returned.",
      "cve": "CVE-2023-53221",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53221",
          "value": "CVE-2023-53221",
          "url": "https://scout.docker.com/v/CVE-2023-53221?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53221?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "02c33a2cdf5ac88b575d7d13e47cf9547d19235dfec50979098e9d8a3651c43b",
      "category": "container_scanning",
      "message": "CVE-2023-53231 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: Fix detection of atomic context  Current check for atomic context is not sufficient as z_erofs_decompressqueue_endio can be called under rcu lock from blk_mq_flush_plug_list(). See the stacktrace [1]  In such case we should hand off the decompression work for async processing rather than trying to do sync decompression in current context. Patch fixes the detection by checking for rcu_read_lock_any_held() and while at it use more appropriate !in_task() check than in_atomic().  Background: Historically erofs would always schedule a kworker for decompression which would incur the scheduling cost regardless of the context. But z_erofs_decompressqueue_endio() may not always be in atomic context and we could actually benefit from doing the decompression in z_erofs_decompressqueue_endio() if we are in thread context, for example when running with dm-verity. This optimization was later added in patch [2] which has shown improvement in performance benchmarks.  ============================================== [1] Problem stacktrace [name:core&]BUG: sleeping function called from invalid context at kernel/locking/mutex.c:291 [name:core&]in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 1615, name: CpuMonitorServi [name:core&]preempt_count: 0, expected: 0 [name:core&]RCU nest depth: 1, expected: 0 CPU: 7 PID: 1615 Comm: CpuMonitorServi Tainted: G S      W  OE 6.1.25-android14-5-maybe-dirty-mainline #1 Hardware name: MT6897 (DT) Call trace: dump_backtrace+0x108/0x15c show_stack+0x20/0x30 dump_stack_lvl+0x6c/0x8c dump_stack+0x20/0x48 __might_resched+0x1fc/0x308 __might_sleep+0x50/0x88 mutex_lock+0x2c/0x110 z_erofs_decompress_queue+0x11c/0xc10 z_erofs_decompress_kickoff+0x110/0x1a4 z_erofs_decompressqueue_endio+0x154/0x180 bio_endio+0x1b0/0x1d8 __dm_io_complete+0x22c/0x280 clone_endio+0xe4/0x280 bio_endio+0x1b0/0x1d8 blk_update_request+0x138/0x3a4 blk_mq_plug_issue_direct+0xd4/0x19c blk_mq_flush_plug_list+0x2b0/0x354 __blk_flush_plug+0x110/0x160 blk_finish_plug+0x30/0x4c read_pages+0x2fc/0x370 page_cache_ra_unbounded+0xa4/0x23c page_cache_ra_order+0x290/0x320 do_sync_mmap_readahead+0x108/0x2c0 filemap_fault+0x19c/0x52c __do_fault+0xc4/0x114 handle_mm_fault+0x5b4/0x1168 do_page_fault+0x338/0x4b4 do_translation_fault+0x40/0x60 do_mem_abort+0x60/0xc8 el0_da+0x4c/0xe0 el0t_64_sync_handler+0xd4/0xfc el0t_64_sync+0x1a0/0x1a4  [2] Link: https://lore.kernel.org/all/20210317035448.13921-1-huangjianan@oppo.com/",
      "cve": "CVE-2023-53231",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53231",
          "value": "CVE-2023-53231",
          "url": "https://scout.docker.com/v/CVE-2023-53231?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53231?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c496f08ba93c2f930e8f6723720c030e5af1763f54d9185a4c6bf6eb34968976",
      "category": "container_scanning",
      "message": "CVE-2023-53240 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xsk: check IFF_UP earlier in Tx path  Xsk Tx can be triggered via either sendmsg() or poll() syscalls. These two paths share a call to common function xsk_xmit() which has two sanity checks within. A pseudo code example to show the two paths:  __xsk_sendmsg() :                       xsk_poll(): if (unlikely(!xsk_is_bound(xs)))        if (unlikely(!xsk_is_bound(xs))) return -ENXIO;                          return mask; if (unlikely(need_wait))                (...) return -EOPNOTSUPP;                 xsk_xmit() mark napi id (...) xsk_xmit()  xsk_xmit(): if (unlikely(!(xs->dev->flags & IFF_UP))) return -ENETDOWN; if (unlikely(!xs->tx)) return -ENOBUFS;  As it can be observed above, in sendmsg() napi id can be marked on interface that was not brought up and this causes a NULL ptr dereference:  [31757.505631] BUG: kernel NULL pointer dereference, address: 0000000000000018 [31757.512710] #PF: supervisor read access in kernel mode [31757.517936] #PF: error_code(0x0000) - not-present page [31757.523149] PGD 0 P4D 0 [31757.525726] Oops: 0000 [#1] PREEMPT SMP NOPTI [31757.530154] CPU: 26 PID: 95641 Comm: xdpsock Not tainted 6.2.0-rc5+ #40 [31757.536871] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019 [31757.547457] RIP: 0010:xsk_sendmsg+0xde/0x180 [31757.551799] Code: 00 75 a2 48 8b 00 a8 04 75 9b 84 d2 74 69 8b 85 14 01 00 00 85 c0 75 1b 48 8b 85 28 03 00 00 48 8b 80 98 00 00 00 48 8b 40 20 <8b> 40 18 89 85 14 01 00 00 8b bd 14 01 00 00 81 ff 00 01 00 00 0f [31757.570840] RSP: 0018:ffffc90034f27dc0 EFLAGS: 00010246 [31757.576143] RAX: 0000000000000000 RBX: ffffc90034f27e18 RCX: 0000000000000000 [31757.583389] RDX: 0000000000000001 RSI: ffffc90034f27e18 RDI: ffff88984cf3c100 [31757.590631] RBP: ffff88984714a800 R08: ffff88984714a800 R09: 0000000000000000 [31757.597877] R10: 0000000000000001 R11: 0000000000000000 R12: 00000000fffffffa [31757.605123] R13: 0000000000000000 R14: 0000000000000003 R15: 0000000000000000 [31757.612364] FS:  00007fb4c5931180(0000) GS:ffff88afdfa00000(0000) knlGS:0000000000000000 [31757.620571] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [31757.626406] CR2: 0000000000000018 CR3: 000000184b41c003 CR4: 00000000007706e0 [31757.633648] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [31757.640894] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [31757.648139] PKRU: 55555554 [31757.650894] Call Trace: [31757.653385]  <TASK> [31757.655524]  sock_sendmsg+0x8f/0xa0 [31757.659077]  ? sockfd_lookup_light+0x12/0x70 [31757.663416]  __sys_sendto+0xfc/0x170 [31757.667051]  ? do_sched_setscheduler+0xdb/0x1b0 [31757.671658]  __x64_sys_sendto+0x20/0x30 [31757.675557]  do_syscall_64+0x38/0x90 [31757.679197]  entry_SYSCALL_64_after_hwframe+0x72/0xdc [31757.687969] Code: 8e f6 ff 44 8b 4c 24 2c 4c 8b 44 24 20 41 89 c4 44 8b 54 24 28 48 8b 54 24 18 b8 2c 00 00 00 48 8b 74 24 10 8b 7c 24 08 0f 05 <48> 3d 00 f0 ff ff 77 3a 44 89 e7 48 89 44 24 08 e8 b5 8e f6 ff 48 [31757.707007] RSP: 002b:00007ffd49c73c70 EFLAGS: 00000293 ORIG_RAX: 000000000000002c [31757.714694] RAX: ffffffffffffffda RBX: 000055a996565380 RCX: 00007fb4c5727c16 [31757.721939] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003 [31757.729184] RBP: 0000000000000040 R08: 0000000000000000 R09: 0000000000000000 [31757.736429] R10: 0000000000000040 R11: 0000000000000293 R12: 0000000000000000 [31757.743673] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [31757.754940]  </TASK>  To fix this, let's make xsk_xmit a function that will be responsible for generic Tx, where RCU is handled accordingly and pull out sanity checks and xs->zc handling. Populate sanity checks to __xsk_sendmsg() and xsk_poll().",
      "cve": "CVE-2023-53240",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53240",
          "value": "CVE-2023-53240",
          "url": "https://scout.docker.com/v/CVE-2023-53240?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53240?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5f107aa16a948b200b4435766af6e4857b441d97df5dae0e20cfa8b3cf125cea",
      "category": "container_scanning",
      "message": "CVE-2023-53247 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: set_page_extent_mapped after read_folio in btrfs_cont_expand  While trying to get the subpage blocksize tests running, I hit the following panic on generic/476  assertion failed: PagePrivate(page) && page->private, in fs/btrfs/subpage.c:229 kernel BUG at fs/btrfs/subpage.c:229! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP CPU: 1 PID: 1453 Comm: fsstress Not tainted 6.4.0-rc7+ #12 Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20230301gitf80f052277c8-26.fc38 03/01/2023 pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) pc : btrfs_subpage_assert+0xbc/0xf0 lr : btrfs_subpage_assert+0xbc/0xf0 Call trace: btrfs_subpage_assert+0xbc/0xf0 btrfs_subpage_clear_checked+0x38/0xc0 btrfs_page_clear_checked+0x48/0x98 btrfs_truncate_block+0x5d0/0x6a8 btrfs_cont_expand+0x5c/0x528 btrfs_write_check.isra.0+0xf8/0x150 btrfs_buffered_write+0xb4/0x760 btrfs_do_write_iter+0x2f8/0x4b0 btrfs_file_write_iter+0x1c/0x30 do_iter_readv_writev+0xc8/0x158 do_iter_write+0x9c/0x210 vfs_iter_write+0x24/0x40 iter_file_splice_write+0x224/0x390 direct_splice_actor+0x38/0x68 splice_direct_to_actor+0x12c/0x260 do_splice_direct+0x90/0xe8 generic_copy_file_range+0x50/0x90 vfs_copy_file_range+0x29c/0x470 __arm64_sys_copy_file_range+0xcc/0x498 invoke_syscall.constprop.0+0x80/0xd8 do_el0_svc+0x6c/0x168 el0_svc+0x50/0x1b0 el0t_64_sync_handler+0x114/0x120 el0t_64_sync+0x194/0x198  This happens because during btrfs_cont_expand we'll get a page, set it as mapped, and if it's not Uptodate we'll read it.  However between the read and re-locking the page we could have called release_folio() on the page, but left the page in the file mapping.  release_folio() can clear the page private, and thus further down we blow up when we go to modify the subpage bits.  Fix this by putting the set_page_extent_mapped() after the read.  This is safe because read_folio() will call set_page_extent_mapped() before it does the read, and then if we clear page private but leave it on the mapping we're completely safe re-setting set_page_extent_mapped().  With this patch I can now run generic/476 without panicing.",
      "cve": "CVE-2023-53247",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53247",
          "value": "CVE-2023-53247",
          "url": "https://scout.docker.com/v/CVE-2023-53247?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53247?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a8a2330c4e18915bcb604a9b7449dd6cb2599a3e3f3a0a7ad7f82057ebef55a5",
      "category": "container_scanning",
      "message": "CVE-2023-53248 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: install stub fence into potential unused fence pointers  When using cpu to update page tables, vm update fences are unused. Install stub fence into these fence pointers instead of NULL to avoid NULL dereference when calling dma_fence_wait() on them.",
      "cve": "CVE-2023-53248",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53248",
          "value": "CVE-2023-53248",
          "url": "https://scout.docker.com/v/CVE-2023-53248?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53248?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "238e501fdd92ec698516a08262478bbb4a25a46c758e94a6ad8203483a8d7ec1",
      "category": "container_scanning",
      "message": "CVE-2023-53254 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cacheinfo: Fix shared_cpu_map to handle shared caches at different levels  The cacheinfo sets up the shared_cpu_map by checking whether the caches with the same index are shared between CPUs. However, this will trigger slab-out-of-bounds access if the CPUs do not have the same cache hierarchy. Another problem is the mismatched shared_cpu_map when the shared cache does not have the same index between CPUs.  CPU0\tI\tD\tL3 index\t0\t1\t2\tx ^\t^\t^\t^ index\t0\t1\t2\t3 CPU1\tI\tD\tL2\tL3  This patch checks each cache is shared with all caches on other CPUs.",
      "cve": "CVE-2023-53254",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53254",
          "value": "CVE-2023-53254",
          "url": "https://scout.docker.com/v/CVE-2023-53254?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53254?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "24eeb560ef139e5c2df2f5c5f101ccb7bd53cafc4387d8834433caf581792e3a",
      "category": "container_scanning",
      "message": "CVE-2023-53258 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix possible underflow for displays with large vblank  [Why] Underflow observed when using a display with a large vblank region and low refresh rate  [How] Simplify calculation of vblank_nom  Increase value for VBlankNomDefaultUS to 800us",
      "cve": "CVE-2023-53258",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53258",
          "value": "CVE-2023-53258",
          "url": "https://scout.docker.com/v/CVE-2023-53258?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53258?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fbc01e96c6543fa867a84a603839a6f1d766563884c12d8abc185902ce12d952",
      "category": "container_scanning",
      "message": "CVE-2023-53261 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  coresight: Fix memory leak in acpi_buffer->pointer  There are memory leaks reported by kmemleak: ... unreferenced object 0xffff00213c141000 (size 1024): comm \"systemd-udevd\", pid 2123, jiffies 4294909467 (age 6062.160s) hex dump (first 32 bytes): 04 00 00 00 02 00 00 00 18 10 14 3c 21 00 ff ff  ...........<!... 00 00 00 00 00 00 00 00 03 00 00 00 10 00 00 00  ................ backtrace: [<000000004b7c9001>] __kmem_cache_alloc_node+0x2f8/0x348 [<00000000b0fc7ceb>] __kmalloc+0x58/0x108 [<0000000064ff4695>] acpi_os_allocate+0x2c/0x68 [<000000007d57d116>] acpi_ut_initialize_buffer+0x54/0xe0 [<0000000024583908>] acpi_evaluate_object+0x388/0x438 [<0000000017b2e72b>] acpi_evaluate_object_typed+0xe8/0x240 [<000000005df0eac2>] coresight_get_platform_data+0x1b4/0x988 [coresight] ...  The ACPI buffer memory (buf.pointer) should be freed. But the buffer is also used after returning from acpi_get_dsd_graph(). Move the temporary variables buf to acpi_coresight_parse_graph(), and free it before the function return to prevent memory leak.",
      "cve": "CVE-2023-53261",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53261",
          "value": "CVE-2023-53261",
          "url": "https://scout.docker.com/v/CVE-2023-53261?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53261?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "982e8720b09173137e983f9ab2751ae56a3292e30a1af9b3fb80800e03757da6",
      "category": "container_scanning",
      "message": "CVE-2023-53347 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Handle pairing of E-switch via uplink un/load APIs  In case user switch a device from switchdev mode to legacy mode, mlx5 first unpair the E-switch and afterwards unload the uplink vport. From the other hand, in case user remove or reload a device, mlx5 first unload the uplink vport and afterwards unpair the E-switch.  The latter is causing a bug[1], hence, handle pairing of E-switch as part of uplink un/load APIs.  [1] In case VF_LAG is used, every tc fdb flow is duplicated to the peer esw. However, the original esw keeps a pointer to this duplicated flow, not the peer esw. e.g.: if user create tc fdb flow over esw0, the flow is duplicated over esw1, in FW/HW, but in SW, esw0 keeps a pointer to the duplicated flow. During module unload while a peer tc fdb flow is still offloaded, in case the first device to be removed is the peer device (esw1 in the example above), the peer net-dev is destroyed, and so the mlx5e_priv is memset to 0. Afterwards, the peer device is trying to unpair himself from the original device (esw0 in the example above). Unpair API invoke the original device to clear peer flow from its eswitch (esw0), but the peer flow, which is stored over the original eswitch (esw0), is trying to use the peer mlx5e_priv, which is memset to 0 and result in bellow kernel-oops.  [  157.964081 ] BUG: unable to handle page fault for address: 000000000002ce60 [  157.964662 ] #PF: supervisor read access in kernel mode [  157.965123 ] #PF: error_code(0x0000) - not-present page [  157.965582 ] PGD 0 P4D 0 [  157.965866 ] Oops: 0000 [#1] SMP [  157.967670 ] RIP: 0010:mlx5e_tc_del_fdb_flow+0x48/0x460 [mlx5_core] [  157.976164 ] Call Trace: [  157.976437 ]  <TASK> [  157.976690 ]  __mlx5e_tc_del_fdb_peer_flow+0xe6/0x100 [mlx5_core] [  157.977230 ]  mlx5e_tc_clean_fdb_peer_flows+0x67/0x90 [mlx5_core] [  157.977767 ]  mlx5_esw_offloads_unpair+0x2d/0x1e0 [mlx5_core] [  157.984653 ]  mlx5_esw_offloads_devcom_event+0xbf/0x130 [mlx5_core] [  157.985212 ]  mlx5_devcom_send_event+0xa3/0xb0 [mlx5_core] [  157.985714 ]  esw_offloads_disable+0x5a/0x110 [mlx5_core] [  157.986209 ]  mlx5_eswitch_disable_locked+0x152/0x170 [mlx5_core] [  157.986757 ]  mlx5_eswitch_disable+0x51/0x80 [mlx5_core] [  157.987248 ]  mlx5_unload+0x2a/0xb0 [mlx5_core] [  157.987678 ]  mlx5_uninit_one+0x5f/0xd0 [mlx5_core] [  157.988127 ]  remove_one+0x64/0xe0 [mlx5_core] [  157.988549 ]  pci_device_remove+0x31/0xa0 [  157.988933 ]  device_release_driver_internal+0x18f/0x1f0 [  157.989402 ]  driver_detach+0x3f/0x80 [  157.989754 ]  bus_remove_driver+0x70/0xf0 [  157.990129 ]  pci_unregister_driver+0x34/0x90 [  157.990537 ]  mlx5_cleanup+0xc/0x1c [mlx5_core] [  157.990972 ]  __x64_sys_delete_module+0x15a/0x250 [  157.991398 ]  ? exit_to_user_mode_prepare+0xea/0x110 [  157.991840 ]  do_syscall_64+0x3d/0x90 [  157.992198 ]  entry_SYSCALL_64_after_hwframe+0x46/0xb0",
      "cve": "CVE-2023-53347",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53347",
          "value": "CVE-2023-53347",
          "url": "https://scout.docker.com/v/CVE-2023-53347?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53347?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cd157967af3090608ce10efd90c26d26c1d744c84f9c663f4f7ba6f225da9b07",
      "category": "container_scanning",
      "message": "CVE-2023-53348 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix deadlock when aborting transaction during relocation with scrub  Before relocating a block group we pause scrub, then do the relocation and then unpause scrub. The relocation process requires starting and committing a transaction, and if we have a failure in the critical section of the transaction commit path (transaction state >= TRANS_STATE_COMMIT_START), we will deadlock if there is a paused scrub.  That results in stack traces like the following:  [42.479] BTRFS info (device sdc): relocating block group 53876686848 flags metadata|raid6 [42.936] BTRFS warning (device sdc): Skipping commit of aborted transaction. [42.936] ------------[ cut here ]------------ [42.936] BTRFS: Transaction aborted (error -28) [42.936] WARNING: CPU: 11 PID: 346822 at fs/btrfs/transaction.c:1977 btrfs_commit_transaction+0xcc8/0xeb0 [btrfs] [42.936] Modules linked in: dm_flakey dm_mod loop btrfs (...) [42.936] CPU: 11 PID: 346822 Comm: btrfs Tainted: G        W 6.3.0-rc2-btrfs-next-127+ #1 [42.936] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [42.936] RIP: 0010:btrfs_commit_transaction+0xcc8/0xeb0 [btrfs] [42.936] Code: ff ff 45 8b (...) [42.936] RSP: 0018:ffffb58649633b48 EFLAGS: 00010282 [42.936] RAX: 0000000000000000 RBX: ffff8be6ef4d5bd8 RCX: 0000000000000000 [42.936] RDX: 0000000000000002 RSI: ffffffffb35e7782 RDI: 00000000ffffffff [42.936] RBP: ffff8be6ef4d5c98 R08: 0000000000000000 R09: ffffb586496339e8 [42.936] R10: 0000000000000001 R11: 0000000000000001 R12: ffff8be6d38c7c00 [42.936] R13: 00000000ffffffe4 R14: ffff8be6c268c000 R15: ffff8be6ef4d5cf0 [42.936] FS:  00007f381a82b340(0000) GS:ffff8beddfcc0000(0000) knlGS:0000000000000000 [42.936] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [42.936] CR2: 00007f1e35fb7638 CR3: 0000000117680006 CR4: 0000000000370ee0 [42.936] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [42.936] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [42.936] Call Trace: [42.936]  <TASK> [42.936]  ? start_transaction+0xcb/0x610 [btrfs] [42.936]  prepare_to_relocate+0x111/0x1a0 [btrfs] [42.936]  relocate_block_group+0x57/0x5d0 [btrfs] [42.936]  ? btrfs_wait_nocow_writers+0x25/0xb0 [btrfs] [42.936]  btrfs_relocate_block_group+0x248/0x3c0 [btrfs] [42.936]  ? __pfx_autoremove_wake_function+0x10/0x10 [42.936]  btrfs_relocate_chunk+0x3b/0x150 [btrfs] [42.936]  btrfs_balance+0x8ff/0x11d0 [btrfs] [42.936]  ? __kmem_cache_alloc_node+0x14a/0x410 [42.936]  btrfs_ioctl+0x2334/0x32c0 [btrfs] [42.937]  ? mod_objcg_state+0xd2/0x360 [42.937]  ? refill_obj_stock+0xb0/0x160 [42.937]  ? seq_release+0x25/0x30 [42.937]  ? __rseq_handle_notify_resume+0x3b5/0x4b0 [42.937]  ? percpu_counter_add_batch+0x2e/0xa0 [42.937]  ? __x64_sys_ioctl+0x88/0xc0 [42.937]  __x64_sys_ioctl+0x88/0xc0 [42.937]  do_syscall_64+0x38/0x90 [42.937]  entry_SYSCALL_64_after_hwframe+0x72/0xdc [42.937] RIP: 0033:0x7f381a6ffe9b [42.937] Code: 00 48 89 44 24 (...) [42.937] RSP: 002b:00007ffd45ecf060 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 [42.937] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 00007f381a6ffe9b [42.937] RDX: 00007ffd45ecf150 RSI: 00000000c4009420 RDI: 0000000000000003 [42.937] RBP: 0000000000000003 R08: 0000000000000013 R09: 0000000000000000 [42.937] R10: 00007f381a60c878 R11: 0000000000000246 R12: 00007ffd45ed0423 [42.937] R13: 00007ffd45ecf150 R14: 0000000000000000 R15: 00007ffd45ecf148 [42.937]  </TASK> [42.937] ---[ end trace 0000000000000000 ]--- [42.937] BTRFS: error (device sdc: state A) in cleanup_transaction:1977: errno=-28 No space left [59.196] INFO: task btrfs:346772 blocked for more than 120 seconds. [59.196]       Tainted: G        W          6.3.0-rc2-btrfs-next-127+ #1 [59.196] \"echo 0 > /proc/sys/kernel/hung_ ---truncated---",
      "cve": "CVE-2023-53348",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53348",
          "value": "CVE-2023-53348",
          "url": "https://scout.docker.com/v/CVE-2023-53348?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53348?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "312df12ae437ddb6807859300ba8a484083ceeb704b6b39ba5bf5a86dbd8e247",
      "category": "container_scanning",
      "message": "CVE-2023-53353 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  accel/habanalabs: postpone mem_mgr IDR destruction to hpriv_release()  The memory manager IDR is currently destroyed when user releases the file descriptor. However, at this point the user context might be still held, and memory buffers might be still in use. Later on, calls to release those buffers will fail due to not finding their handles in the IDR, leading to a memory leak. To avoid this leak, split the IDR destruction from the memory manager fini, and postpone it to hpriv_release() when there is no user context and no buffers are used.",
      "cve": "CVE-2023-53353",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53353",
          "value": "CVE-2023-53353",
          "url": "https://scout.docker.com/v/CVE-2023-53353?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53353?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a22cf3a205f5ca6e154e5a50d3b077448ac3b264e6495cbf8c982e523d35ba6",
      "category": "container_scanning",
      "message": "CVE-2023-53355 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  staging: pi433: fix memory leak with using debugfs_lookup()  When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time.  To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.  This requires saving off the root directory dentry to make creation of individual device subdirectories easier.",
      "cve": "CVE-2023-53355",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53355",
          "value": "CVE-2023-53355",
          "url": "https://scout.docker.com/v/CVE-2023-53355?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53355?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a0fd7401c40c58a04c87fa99b56eded97e8fc25bd5dd51ddb4c85b39cbb3b081",
      "category": "container_scanning",
      "message": "CVE-2023-53362 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bus: fsl-mc: don't assume child devices are all fsl-mc devices  Changes in VFIO caused a pseudo-device to be created as child of fsl-mc devices causing a crash [1] when trying to bind a fsl-mc device to VFIO. Fix this by checking the device type when enumerating fsl-mc child devices.  [1] Modules linked in: Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP CPU: 6 PID: 1289 Comm: sh Not tainted 6.2.0-rc5-00047-g7c46948a6e9c #2 Hardware name: NXP Layerscape LX2160ARDB (DT) pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : mc_send_command+0x24/0x1f0 lr : dprc_get_obj_region+0xfc/0x1c0 sp : ffff80000a88b900 x29: ffff80000a88b900 x28: ffff48a9429e1400 x27: 00000000000002b2 x26: ffff48a9429e1718 x25: 0000000000000000 x24: 0000000000000000 x23: ffffd59331ba3918 x22: ffffd59331ba3000 x21: 0000000000000000 x20: ffff80000a88b9b8 x19: 0000000000000000 x18: 0000000000000001 x17: 7270642f636d2d6c x16: 73662e3030303030 x15: ffffffffffffffff x14: ffffd59330f1d668 x13: ffff48a8727dc389 x12: ffff48a8727dc386 x11: 0000000000000002 x10: 00008ceaf02f35d4 x9 : 0000000000000012 x8 : 0000000000000000 x7 : 0000000000000006 x6 : ffff80000a88bab0 x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff80000a88b9e8 x2 : ffff80000a88b9e8 x1 : 0000000000000000 x0 : ffff48a945142b80 Call trace: mc_send_command+0x24/0x1f0 dprc_get_obj_region+0xfc/0x1c0 fsl_mc_device_add+0x340/0x590 fsl_mc_obj_device_add+0xd0/0xf8 dprc_scan_objects+0x1c4/0x340 dprc_scan_container+0x38/0x60 vfio_fsl_mc_probe+0x9c/0xf8 fsl_mc_driver_probe+0x24/0x70 really_probe+0xbc/0x2a8 __driver_probe_device+0x78/0xe0 device_driver_attach+0x30/0x68 bind_store+0xa8/0x130 drv_attr_store+0x24/0x38 sysfs_kf_write+0x44/0x60 kernfs_fop_write_iter+0x128/0x1b8 vfs_write+0x334/0x448 ksys_write+0x68/0xf0 __arm64_sys_write+0x1c/0x28 invoke_syscall+0x44/0x108 el0_svc_common.constprop.1+0x94/0xf8 do_el0_svc+0x38/0xb0 el0_svc+0x20/0x50 el0t_64_sync_handler+0x98/0xc0 el0t_64_sync+0x174/0x178 Code: aa0103f4 a9025bf5 d5384100 b9400801 (79401260) ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2023-53362",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53362",
          "value": "CVE-2023-53362",
          "url": "https://scout.docker.com/v/CVE-2023-53362?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53362?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6ae3470756a5f1e5b507bad1496541613439b53cdd48e1e351ce272ed8568320",
      "category": "container_scanning",
      "message": "CVE-2023-53366 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: be a bit more careful in checking for NULL bdev while polling  Wei reports a crash with an application using polled IO:  PGD 14265e067 P4D 14265e067 PUD 47ec50067 PMD 0 Oops: 0000 [#1] SMP CPU: 0 PID: 21915 Comm: iocore_0 Kdump: loaded Tainted: G S 5.12.0-0_fbk12_clang_7346_g1bb6f2e7058f #1 Hardware name: Wiwynn Delta Lake MP T8/Delta Lake-Class2, BIOS Y3DLM08 04/10/2022 RIP: 0010:bio_poll+0x25/0x200 Code: 0f 1f 44 00 00 0f 1f 44 00 00 55 41 57 41 56 41 55 41 54 53 48 83 ec 28 65 48 8b 04 25 28 00 00 00 48 89 44 24 20 48 8b 47 08 <48> 8b 80 70 02 00 00 4c 8b 70 50 8b 6f 34 31 db 83 fd ff 75 25 65 RSP: 0018:ffffc90005fafdf8 EFLAGS: 00010292 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 74b43cd65dd66600 RDX: 0000000000000003 RSI: ffffc90005fafe78 RDI: ffff8884b614e140 RBP: ffff88849964df78 R08: 0000000000000000 R09: 0000000000000008 R10: 0000000000000000 R11: 0000000000000000 R12: ffff88849964df00 R13: ffffc90005fafe78 R14: ffff888137d3c378 R15: 0000000000000001 FS:  00007fd195000640(0000) GS:ffff88903f400000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000270 CR3: 0000000466121001 CR4: 00000000007706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: iocb_bio_iopoll+0x1d/0x30 io_do_iopoll+0xac/0x250 __se_sys_io_uring_enter+0x3c5/0x5a0 ? __x64_sys_write+0x89/0xd0 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xae RIP: 0033:0x94f225d Code: 24 cc 00 00 00 41 8b 84 24 d0 00 00 00 c1 e0 04 83 e0 10 41 09 c2 8b 33 8b 53 04 4c 8b 43 18 4c 63 4b 0c b8 aa 01 00 00 0f 05 <85> c0 0f 88 85 00 00 00 29 03 45 84 f6 0f 84 88 00 00 00 41 f6 c7 RSP: 002b:00007fd194ffcd88 EFLAGS: 00000202 ORIG_RAX: 00000000000001aa RAX: ffffffffffffffda RBX: 00007fd194ffcdc0 RCX: 00000000094f225d RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000007 RBP: 00007fd194ffcdb0 R08: 0000000000000000 R09: 0000000000000008 R10: 0000000000000001 R11: 0000000000000202 R12: 00007fd269d68030 R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000000  which is due to bio->bi_bdev being NULL. This can happen if we have two tasks doing polled IO, and task B ends up completing IO from task A if they are sharing a poll queue. If task B completes the IO and puts the bio into our cache, then it can allocate that bio again before task A is done polling for it. As that would necessitate a preempt between the two tasks, it's enough to just be a bit more careful in checking for whether or not bio->bi_bdev is NULL.",
      "cve": "CVE-2023-53366",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53366",
          "value": "CVE-2023-53366",
          "url": "https://scout.docker.com/v/CVE-2023-53366?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53366?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fca7930dfa51946feda85c4cb58b3a0e87df9c946002cc1298b03f6f89a80df0",
      "category": "container_scanning",
      "message": "CVE-2023-53367 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  accel/habanalabs: fix mem leak in capture user mappings  This commit fixes a memory leak caused when clearing the user_mappings info when a new context is opened immediately after user_mapping is captured and a hard reset is performed.",
      "cve": "CVE-2023-53367",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53367",
          "value": "CVE-2023-53367",
          "url": "https://scout.docker.com/v/CVE-2023-53367?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53367?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "01929080de026be71568ecd11d206ac2db2086f4c9c1c5e2474caca1c814b1ef",
      "category": "container_scanning",
      "message": "CVE-2023-53370 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix memory leak in mes self test  The fences associated with mes queue have to be freed up during amdgpu_ring_fini.",
      "cve": "CVE-2023-53370",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53370",
          "value": "CVE-2023-53370",
          "url": "https://scout.docker.com/v/CVE-2023-53370?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53370?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5420c289d9241045ba09da3c2d3cc5597a3525483bb6ecd0c2c6b3690b0560e9",
      "category": "container_scanning",
      "message": "CVE-2023-53371 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: fix memory leak in mlx5e_fs_tt_redirect_any_create  The memory pointed to by the fs->any pointer is not freed in the error path of mlx5e_fs_tt_redirect_any_create, which can lead to a memory leak. Fix by freeing the memory in the error path, thereby making the error path identical to mlx5e_fs_tt_redirect_any_destroy().",
      "cve": "CVE-2023-53371",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53371",
          "value": "CVE-2023-53371",
          "url": "https://scout.docker.com/v/CVE-2023-53371?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53371?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "225247c1a98e1fab76dd40abf1eeb6d2d443c772fff01649f9ca73617e4aeab9",
      "category": "container_scanning",
      "message": "CVE-2023-53376 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Use number of bits to manage bitmap sizes  To allocate bitmaps, the mpi3mr driver calculates sizes of bitmaps using byte as unit. However, bitmap helper functions assume that bitmaps are allocated using unsigned long as unit. This gap causes memory access beyond the bitmap sizes and results in \"BUG: KASAN: slab-out-of-bounds\".  The BUG was observed at firmware download to eHBA-9600. Call trace indicated that the out-of-bounds access happened in find_first_zero_bit() called from mpi3mr_send_event_ack() for miroc->evtack_cmds_bitmap.  To fix the BUG, do not use bytes to manage bitmap sizes. Instead, use number of bits, and call bitmap helper functions which take number of bits as arguments. For memory allocation, call bitmap_zalloc() instead of kzalloc() and krealloc(). For memory free, call bitmap_free() instead of kfree(). For zero clear, call bitmap_clear() instead of memset().  Remove three fields for bitmap byte sizes in struct scmd_priv which are no longer required. Replace the field dev_handle_bitmap_sz with dev_handle_bitmap_bits to keep number of bits of removepend_bitmap across resize.",
      "cve": "CVE-2023-53376",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53376",
          "value": "CVE-2023-53376",
          "url": "https://scout.docker.com/v/CVE-2023-53376?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53376?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3248d75c761cad790274ce098802c2bc39bab8164001c55606926e0ae5478f18",
      "category": "container_scanning",
      "message": "CVE-2023-53382 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: Reset connection when trying to use SMCRv2 fails.  We found a crash when using SMCRv2 with 2 Mellanox ConnectX-4. It can be reproduced by:  - smc_run nginx - smc_run wrk -t 32 -c 500 -d 30 http://<ip>:<port>  BUG: kernel NULL pointer dereference, address: 0000000000000014 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 8000000108713067 P4D 8000000108713067 PUD 151127067 PMD 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 4 PID: 2441 Comm: kworker/4:249 Kdump: loaded Tainted: G        W   E 6.4.0-rc1+ #42 Workqueue: smc_hs_wq smc_listen_work [smc] RIP: 0010:smc_clc_send_confirm_accept+0x284/0x580 [smc] RSP: 0018:ffffb8294b2d7c78 EFLAGS: 00010a06 RAX: ffff8f1873238880 RBX: ffffb8294b2d7dc8 RCX: 0000000000000000 RDX: 00000000000000b4 RSI: 0000000000000001 RDI: 0000000000b40c00 RBP: ffffb8294b2d7db8 R08: ffff8f1815c5860c R09: 0000000000000000 R10: 0000000000000400 R11: 0000000000000000 R12: ffff8f1846f56180 R13: ffff8f1815c5860c R14: 0000000000000001 R15: 0000000000000001 FS:  0000000000000000(0000) GS:ffff8f1aefd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000014 CR3: 00000001027a0001 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? mlx5_ib_map_mr_sg+0xa1/0xd0 [mlx5_ib] ? smcr_buf_map_link+0x24b/0x290 [smc] ? __smc_buf_create+0x4ee/0x9b0 [smc] smc_clc_send_accept+0x4c/0xb0 [smc] smc_listen_work+0x346/0x650 [smc] ? __schedule+0x279/0x820 process_one_work+0x1e5/0x3f0 worker_thread+0x4d/0x2f0 ? __pfx_worker_thread+0x10/0x10 kthread+0xe5/0x120 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2c/0x50 </TASK>  During the CLC handshake, server sequentially tries available SMCRv2 and SMCRv1 devices in smc_listen_work().  If an SMCRv2 device is found. SMCv2 based link group and link will be assigned to the connection. Then assumed that some buffer assignment errors happen later in the CLC handshake, such as RMB registration failure, server will give up SMCRv2 and try SMCRv1 device instead. But the resources assigned to the connection won't be reset.  When server tries SMCRv1 device, the connection creation process will be executed again. Since conn->lnk has been assigned when trying SMCRv2, it will not be set to the correct SMCRv1 link in smcr_lgr_conn_assign_link(). So in such situation, conn->lgr points to correct SMCRv1 link group but conn->lnk points to the SMCRv2 link mistakenly.  Then in smc_clc_send_confirm_accept(), conn->rmb_desc->mr[link->link_idx] will be accessed. Since the link->link_idx is not correct, the related MR may not have been initialized, so crash happens.  | Try SMCRv2 device first |     |-> conn->lgr:\tassign existed SMCRv2 link group; |     |-> conn->link:\tassign existed SMCRv2 link (link_idx may be 1 in SMC_LGR_SYMMETRIC); |     |-> sndbuf & RMB creation fails, quit; | | Try SMCRv1 device then |     |-> conn->lgr:\tcreate SMCRv1 link group and assign; |     |-> conn->link:\tkeep SMCRv2 link mistakenly; |     |-> sndbuf & RMB creation succeed, only RMB->mr[link_idx = 0] |         initialized. | | Then smc_clc_send_confirm_accept() accesses | conn->rmb_desc->mr[conn->link->link_idx, which is 1], then crash. v  This patch tries to fix this by cleaning conn->lnk before assigning link. In addition, it is better to reset the connection and clean the resources assigned if trying SMCRv2 failed in buffer creation or registration.",
      "cve": "CVE-2023-53382",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53382",
          "value": "CVE-2023-53382",
          "url": "https://scout.docker.com/v/CVE-2023-53382?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53382?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4425b996c826d50be32a8d31eafb9cbf632f50fb01f4d8957eea51762fb34c45",
      "category": "container_scanning",
      "message": "CVE-2023-53383 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  irqchip/gicv3: Workaround for NVIDIA erratum T241-FABRIC-4  The T241 platform suffers from the T241-FABRIC-4 erratum which causes unexpected behavior in the GIC when multiple transactions are received simultaneously from different sources. This hardware issue impacts NVIDIA server platforms that use more than two T241 chips interconnected. Each chip has support for 320 {E}SPIs.  This issue occurs when multiple packets from different GICs are incorrectly interleaved at the target chip. The erratum text below specifies exactly what can cause multiple transfer packets susceptible to interleaving and GIC state corruption. GIC state corruption can lead to a range of problems, including kernel panics, and unexpected behavior.  >From the erratum text: \"In some cases, inter-socket AXI4 Stream packets with multiple transfers, may be interleaved by the fabric when presented to ARM Generic Interrupt Controller. GIC expects all transfers of a packet to be delivered without any interleaving.  The following GICv3 commands may result in multiple transfer packets over inter-socket AXI4 Stream interface: - Register reads from GICD_I* and GICD_N* - Register writes to 64-bit GICD registers other than GICD_IROUTERn* - ITS command MOVALL  Multiple commands in GICv4+ utilize multiple transfer packets, including VMOVP, VMOVI, VMAPP, and 64-bit register accesses.\"  This issue impacts system configurations with more than 2 sockets, that require multi-transfer packets to be sent over inter-socket AXI4 Stream interface between GIC instances on different sockets. GICv4 cannot be supported. GICv3 SW model can only be supported with the workaround. Single and Dual socket configurations are not impacted by this issue and support GICv3 and GICv4.\"   Writing to the chip alias region of the GICD_In{E} registers except GICD_ICENABLERn has an equivalent effect as writing to the global distributor. The SPI interrupt deactivate path is not impacted by the erratum.  To fix this problem, implement a workaround that ensures read accesses to the GICD_In{E} registers are directed to the chip that owns the SPI, and disable GICv4.x features. To simplify code changes, the gic_configure_irq() function uses the same alias region for both read and write operations to GICD_ICFGR.",
      "cve": "CVE-2023-53383",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53383",
          "value": "CVE-2023-53383",
          "url": "https://scout.docker.com/v/CVE-2023-53383?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53383?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "78df0603621aac46453d850a589048af2612219b4d331f34fa8510a9d1be876e",
      "category": "container_scanning",
      "message": "CVE-2023-53385 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mdp3: Fix resource leaks in of_find_device_by_node  Use put_device to release the object get through of_find_device_by_node, avoiding resource leaks.",
      "cve": "CVE-2023-53385",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53385",
          "value": "CVE-2023-53385",
          "url": "https://scout.docker.com/v/CVE-2023-53385?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53385?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c7c9500e17d98b793fcba18efe32ff9ab9796d114884a2e26b71753d0db9231c",
      "category": "container_scanning",
      "message": "CVE-2023-53387 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Fix device management cmd timeout flow  In the UFS error handling flow, the host will send a device management cmd (NOP OUT) to the device for link recovery. If this cmd times out and clearing the doorbell fails, ufshcd_wait_for_dev_cmd() will do nothing and return. hba->dev_cmd.complete struct is not set to NULL.  When this happens, if cmd has been completed by device, then we will call complete() in __ufshcd_transfer_req_compl(). Because the complete struct is allocated on the stack, the following crash will occur:  ipanic_die+0x24/0x38 [mrdump] die+0x344/0x748 arm64_notify_die+0x44/0x104 do_debug_exception+0x104/0x1e0 el1_dbg+0x38/0x54 el1_sync_handler+0x40/0x88 el1_sync+0x8c/0x140 queued_spin_lock_slowpath+0x2e4/0x3c0 __ufshcd_transfer_req_compl+0x3b0/0x1164 ufshcd_trc_handler+0x15c/0x308 ufshcd_host_reset_and_restore+0x54/0x260 ufshcd_reset_and_restore+0x28c/0x57c ufshcd_err_handler+0xeb8/0x1b6c process_one_work+0x288/0x964 worker_thread+0x4bc/0xc7c kthread+0x15c/0x264 ret_from_fork+0x10/0x30",
      "cve": "CVE-2023-53387",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53387",
          "value": "CVE-2023-53387",
          "url": "https://scout.docker.com/v/CVE-2023-53387?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53387?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9cf7c75991f71c51a86d02637b4c3b1d27e4498d1e1a5edcaa61f1eb34fe0d8f",
      "category": "container_scanning",
      "message": "CVE-2023-53401 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: kmem: fix a NULL pointer dereference in obj_stock_flush_required()  KCSAN found an issue in obj_stock_flush_required(): stock->cached_objcg can be reset between the check and dereference:  ================================================================== BUG: KCSAN: data-race in drain_all_stock / drain_obj_stock  write to 0xffff888237c2a2f8 of 8 bytes by task 19625 on cpu 0: drain_obj_stock+0x408/0x4e0 mm/memcontrol.c:3306 refill_obj_stock+0x9c/0x1e0 mm/memcontrol.c:3340 obj_cgroup_uncharge+0xe/0x10 mm/memcontrol.c:3408 memcg_slab_free_hook mm/slab.h:587 [inline] __cache_free mm/slab.c:3373 [inline] __do_kmem_cache_free mm/slab.c:3577 [inline] kmem_cache_free+0x105/0x280 mm/slab.c:3602 __d_free fs/dcache.c:298 [inline] dentry_free fs/dcache.c:375 [inline] __dentry_kill+0x422/0x4a0 fs/dcache.c:621 dentry_kill+0x8d/0x1e0 dput+0x118/0x1f0 fs/dcache.c:913 __fput+0x3bf/0x570 fs/file_table.c:329 ____fput+0x15/0x20 fs/file_table.c:349 task_work_run+0x123/0x160 kernel/task_work.c:179 resume_user_mode_work include/linux/resume_user_mode.h:49 [inline] exit_to_user_mode_loop+0xcf/0xe0 kernel/entry/common.c:171 exit_to_user_mode_prepare+0x6a/0xa0 kernel/entry/common.c:203 __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline] syscall_exit_to_user_mode+0x26/0x140 kernel/entry/common.c:296 do_syscall_64+0x4d/0xc0 arch/x86/entry/common.c:86 entry_SYSCALL_64_after_hwframe+0x63/0xcd  read to 0xffff888237c2a2f8 of 8 bytes by task 19632 on cpu 1: obj_stock_flush_required mm/memcontrol.c:3319 [inline] drain_all_stock+0x174/0x2a0 mm/memcontrol.c:2361 try_charge_memcg+0x6d0/0xd10 mm/memcontrol.c:2703 try_charge mm/memcontrol.c:2837 [inline] mem_cgroup_charge_skmem+0x51/0x140 mm/memcontrol.c:7290 sock_reserve_memory+0xb1/0x390 net/core/sock.c:1025 sk_setsockopt+0x800/0x1e70 net/core/sock.c:1525 udp_lib_setsockopt+0x99/0x6c0 net/ipv4/udp.c:2692 udp_setsockopt+0x73/0xa0 net/ipv4/udp.c:2817 sock_common_setsockopt+0x61/0x70 net/core/sock.c:3668 __sys_setsockopt+0x1c3/0x230 net/socket.c:2271 __do_sys_setsockopt net/socket.c:2282 [inline] __se_sys_setsockopt net/socket.c:2279 [inline] __x64_sys_setsockopt+0x66/0x80 net/socket.c:2279 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd  value changed: 0xffff8881382d52c0 -> 0xffff888138893740  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 19632 Comm: syz-executor.0 Not tainted 6.3.0-rc2-syzkaller-00387-g534293368afa #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/02/2023  Fix it by using READ_ONCE()/WRITE_ONCE() for all accesses to stock->cached_objcg.",
      "cve": "CVE-2023-53401",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53401",
          "value": "CVE-2023-53401",
          "url": "https://scout.docker.com/v/CVE-2023-53401?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53401?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "69b254fc1fcc9b649c813d06dd20989979aa7a43874335ffaec42c7c024c5cd0",
      "category": "container_scanning",
      "message": "CVE-2023-53410 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  USB: ULPI: fix memory leak with using debugfs_lookup()  When calling debugfs_lookup() the result must have dput() called on it, otherwise the memory will leak over time.  To make things simpler, just call debugfs_lookup_and_remove() instead which handles all of the logic at once.",
      "cve": "CVE-2023-53410",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53410",
          "value": "CVE-2023-53410",
          "url": "https://scout.docker.com/v/CVE-2023-53410?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53410?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6b2ddce329e09ff853ad0be44c0a413e68b22347fd27a67801be41bbc85e12f1",
      "category": "container_scanning",
      "message": "CVE-2023-53421 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-cgroup: Reinit blkg_iostat_set after clearing in blkcg_reset_stats()  When blkg_alloc() is called to allocate a blkcg_gq structure with the associated blkg_iostat_set's, there are 2 fields within blkg_iostat_set that requires proper initialization - blkg & sync. The former field was introduced by commit 3b8cc6298724 (\"blk-cgroup: Optimize blkcg_rstat_flush()\") while the later one was introduced by commit f73316482977 (\"blk-cgroup: reimplement basic IO stats using cgroup rstat\").  Unfortunately those fields in the blkg_iostat_set's are not properly re-initialized when they are cleared in v1's blkcg_reset_stats(). This can lead to a kernel panic due to NULL pointer access of the blkg pointer. The missing initialization of sync is less problematic and can be a problem in a debug kernel due to missing lockdep initialization.  Fix these problems by re-initializing them after memory clearing.",
      "cve": "CVE-2023-53421",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53421",
          "value": "CVE-2023-53421",
          "url": "https://scout.docker.com/v/CVE-2023-53421?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53421?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0835db9a437e691c965d56cf33053f6e8ae2e6ae021df1d1c226150ce7b8582d",
      "category": "container_scanning",
      "message": "CVE-2023-53424 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  clk: mediatek: fix of_iomap memory leak  Smatch reports: drivers/clk/mediatek/clk-mtk.c:583 mtk_clk_simple_probe() warn: 'base' from of_iomap() not released on lines: 496.  This problem was also found in linux-next. In mtk_clk_simple_probe(), base is not released when handling errors if clk_data is not existed, which may cause a leak. So free_base should be added here to release base.",
      "cve": "CVE-2023-53424",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53424",
          "value": "CVE-2023-53424",
          "url": "https://scout.docker.com/v/CVE-2023-53424?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53424?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e311998a13d671fa49555980ff7c071eae4799d62cb7b83be4b06378b7c0dca5",
      "category": "container_scanning",
      "message": "CVE-2023-53429 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't check PageError in __extent_writepage  __extent_writepage currenly sets PageError whenever any error happens, and the also checks for PageError to decide if to call error handling. This leads to very unclear responsibility for cleaning up on errors. In the VM and generic writeback helpers the basic idea is that once I/O is fired off all error handling responsibility is delegated to the end I/O handler.  But if that end I/O handler sets the PageError bit, and the submitter checks it, the bit could in some cases leak into the submission context for fast enough I/O.  Fix this by simply not checking PageError and just using the local ret variable to check for submission errors.  This also fundamentally solves the long problem documented in a comment in __extent_writepage by never leaking the error bit into the submission context.",
      "cve": "CVE-2023-53429",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53429",
          "value": "CVE-2023-53429",
          "url": "https://scout.docker.com/v/CVE-2023-53429?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53429?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "09c7e755603a36105bf62267ed2e76eebd13ec2d0df82179984cf6e964499bc0",
      "category": "container_scanning",
      "message": "CVE-2023-53434 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  remoteproc: imx_dsp_rproc: Add custom memory copy implementation for i.MX DSP Cores  The IRAM is part of the HiFi DSP. According to hardware specification only 32-bits write are allowed otherwise we get a Kernel panic.  Therefore add a custom memory copy and memset functions to deal with the above restriction.",
      "cve": "CVE-2023-53434",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53434",
          "value": "CVE-2023-53434",
          "url": "https://scout.docker.com/v/CVE-2023-53434?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53434?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "adc693e57c4a233610b062dc6f9bc14c4e79507a81d1ce79295079fc068f8336",
      "category": "container_scanning",
      "message": "CVE-2023-53438 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/MCE: Always save CS register on AMD Zen IF Poison errors  The Instruction Fetch (IF) units on current AMD Zen-based systems do not guarantee a synchronous #MC is delivered for poison consumption errors. Therefore, MCG_STATUS[EIPV|RIPV] will not be set. However, the microarchitecture does guarantee that the exception is delivered within the same context. In other words, the exact rIP is not known, but the context is known to not have changed.  There is no architecturally-defined method to determine this behavior.  The Code Segment (CS) register is always valid on such IF unit poison errors regardless of the value of MCG_STATUS[EIPV|RIPV].  Add a quirk to save the CS register for poison consumption from the IF unit banks.  This is needed to properly determine the context of the error. Otherwise, the severity grading function will assume the context is IN_KERNEL due to the m->cs value being 0 (the initialized value). This leads to unnecessary kernel panics on data poison errors due to the kernel believing the poison consumption occurred in kernel context.",
      "cve": "CVE-2023-53438",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53438",
          "value": "CVE-2023-53438",
          "url": "https://scout.docker.com/v/CVE-2023-53438?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53438?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c729627d1dd55b9b29ae4b6e3505f2d15282dabbaa5588f73329f5c6b3901492",
      "category": "container_scanning",
      "message": "CVE-2023-53447 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: don't reset unchangable mount option in f2fs_remount()  syzbot reports a bug as below:  general protection fault, probably for non-canonical address 0xdffffc0000000009: 0000 [#1] PREEMPT SMP KASAN RIP: 0010:__lock_acquire+0x69/0x2000 kernel/locking/lockdep.c:4942 Call Trace: lock_acquire+0x1e3/0x520 kernel/locking/lockdep.c:5691 __raw_write_lock include/linux/rwlock_api_smp.h:209 [inline] _raw_write_lock+0x2e/0x40 kernel/locking/spinlock.c:300 __drop_extent_tree+0x3ac/0x660 fs/f2fs/extent_cache.c:1100 f2fs_drop_extent_tree+0x17/0x30 fs/f2fs/extent_cache.c:1116 f2fs_insert_range+0x2d5/0x3c0 fs/f2fs/file.c:1664 f2fs_fallocate+0x4e4/0x6d0 fs/f2fs/file.c:1838 vfs_fallocate+0x54b/0x6b0 fs/open.c:324 ksys_fallocate fs/open.c:347 [inline] __do_sys_fallocate fs/open.c:355 [inline] __se_sys_fallocate fs/open.c:353 [inline] __x64_sys_fallocate+0xbd/0x100 fs/open.c:353 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd  The root cause is race condition as below: - since it tries to remount rw filesystem, so that do_remount won't call sb_prepare_remount_readonly to block fallocate, there may be race condition in between remount and fallocate. - in f2fs_remount(), default_options() will reset mount option to default one, and then update it based on result of parse_options(), so there is a hole which race condition can happen.  Thread A\t\t\tThread B - f2fs_fill_super - parse_options - clear_opt(READ_EXTENT_CACHE)  - f2fs_remount - default_options - set_opt(READ_EXTENT_CACHE) - f2fs_fallocate - f2fs_insert_range - f2fs_drop_extent_tree - __drop_extent_tree - __may_extent_tree - test_opt(READ_EXTENT_CACHE) return true - write_lock(&et->lock) access NULL pointer - parse_options - clear_opt(READ_EXTENT_CACHE)",
      "cve": "CVE-2023-53447",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53447",
          "value": "CVE-2023-53447",
          "url": "https://scout.docker.com/v/CVE-2023-53447?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53447?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ffc49dc565b9c19b51a2d312d0de7a42c61dbef95f4e656b526a61131e85369b",
      "category": "container_scanning",
      "message": "CVE-2023-53452 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: fix potential race condition between napi_init and napi_enable  A race condition can happen if netdev is registered, but NAPI isn't initialized yet, and meanwhile user space starts the netdev that will enable NAPI. Then, it hits BUG_ON():  kernel BUG at net/core/dev.c:6423! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 0 PID: 417 Comm: iwd Not tainted 6.2.7-slab-dirty #3 eb0f5a8a9d91 Hardware name: LENOVO 21DL/LNVNB161216, BIOS JPCN20WW(V1.06) 09/20/2022 RIP: 0010:napi_enable+0x3f/0x50 Code: 48 89 c2 48 83 e2 f6 f6 81 89 08 00 00 02 74 0d 48 83 ... RSP: 0018:ffffada1414f3548 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffa01425802080 RCX: 0000000000000000 RDX: 00000000000002ff RSI: ffffada14e50c614 RDI: ffffa01425808dc0 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000100 R12: ffffa01425808f58 R13: 0000000000000000 R14: ffffa01423498940 R15: 0000000000000001 FS:  00007f5577c0a740(0000) GS:ffffa0169fc00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5577a19972 CR3: 0000000125a7a000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> rtw89_pci_ops_start+0x1c/0x70 [rtw89_pci 6cbc75429515c181cbc386478d5cfb32ffc5a0f8] rtw89_core_start+0xbe/0x160 [rtw89_core fe07ecb874820b6d778370d4acb6ef8a37847f22] rtw89_ops_start+0x26/0x40 [rtw89_core fe07ecb874820b6d778370d4acb6ef8a37847f22] drv_start+0x42/0x100 [mac80211 c07fa22af8c3cf3f7d7ab3884ca990784d72e2d2] ieee80211_do_open+0x311/0x7d0 [mac80211 c07fa22af8c3cf3f7d7ab3884ca990784d72e2d2] ieee80211_open+0x6a/0x90 [mac80211 c07fa22af8c3cf3f7d7ab3884ca990784d72e2d2] __dev_open+0xe0/0x180 __dev_change_flags+0x1da/0x250 dev_change_flags+0x26/0x70 do_setlink+0x37c/0x12c0 ? ep_poll_callback+0x246/0x290 ? __nla_validate_parse+0x61/0xd00 ? __wake_up_common_lock+0x8f/0xd0  To fix this, follow Jonas' suggestion to switch the order of these functions and move register netdev to be the last step of PCI probe. Also, correct the error handling of rtw89_core_register_hw().",
      "cve": "CVE-2023-53452",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53452",
          "value": "CVE-2023-53452",
          "url": "https://scout.docker.com/v/CVE-2023-53452?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53452?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "893ad20d70a04fc1f97fa94c79abee36d81d2af0c306a1ae9918c358bdbd094b",
      "category": "container_scanning",
      "message": "CVE-2023-53460 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw88: fix memory leak in rtw_usb_probe()  drivers/net/wireless/realtek/rtw88/usb.c:876 rtw_usb_probe() warn: 'hw' from ieee80211_alloc_hw() not released on lines: 811  Fix this by modifying return to a goto statement.",
      "cve": "CVE-2023-53460",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53460",
          "value": "CVE-2023-53460",
          "url": "https://scout.docker.com/v/CVE-2023-53460?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53460?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "35d363e03760cd711529f7b884ef6995b2e2b6477ba7953de51e530769bf44a4",
      "category": "container_scanning",
      "message": "CVE-2023-53466 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7915: fix memory leak in mt7915_mcu_exit  Always purge mcu skb queues in mt7915_mcu_exit routine even if mt7915_firmware_state fails.",
      "cve": "CVE-2023-53466",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53466",
          "value": "CVE-2023-53466",
          "url": "https://scout.docker.com/v/CVE-2023-53466?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53466?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aad1f9428d0e2c8d24703027450276eec37cff13f96d2cf987a32790682e473e",
      "category": "container_scanning",
      "message": "CVE-2023-53469 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  af_unix: Fix null-ptr-deref in unix_stream_sendpage().  Bing-Jhong Billy Jheng reported null-ptr-deref in unix_stream_sendpage() with detailed analysis and a nice repro.  unix_stream_sendpage() tries to add data to the last skb in the peer's recv queue without locking the queue.  If the peer's FD is passed to another socket and the socket's FD is passed to the peer, there is a loop between them.  If we close both sockets without receiving FD, the sockets will be cleaned up by garbage collection.  The garbage collection iterates such sockets and unlinks skb with FD from the socket's receive queue under the queue's lock.  So, there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free.  To avoid the issue, unix_stream_sendpage() must lock the peer's recv queue.  Note the issue does not exist in 6.5+ thanks to the recent sendpage() refactoring.  This patch is originally written by Linus Torvalds.  BUG: unable to handle page fault for address: ffff988004dd6870 PF: supervisor read access in kernel mode PF: error_code(0x0000) - not-present page PGD 0 P4D 0 PREEMPT SMP PTI CPU: 4 PID: 297 Comm: garbage_uaf Not tainted 6.1.46 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:kmem_cache_alloc_node+0xa2/0x1e0 Code: c0 0f 84 32 01 00 00 41 83 fd ff 74 10 48 8b 00 48 c1 e8 3a 41 39 c5 0f 85 1c 01 00 00 41 8b 44 24 28 49 8b 3c 24 48 8d 4a 40 <49> 8b 1c 06 4c 89 f0 65 48 0f c7 0f 0f 94 c0 84 c0 74 a1 41 8b 44 RSP: 0018:ffffc9000079fac0 EFLAGS: 00000246 RAX: 0000000000000070 RBX: 0000000000000005 RCX: 000000000001a284 RDX: 000000000001a244 RSI: 0000000000400cc0 RDI: 000000000002eee0 RBP: 0000000000400cc0 R08: 0000000000400cc0 R09: 0000000000000003 R10: 0000000000000001 R11: 0000000000000000 R12: ffff888003970f00 R13: 00000000ffffffff R14: ffff988004dd6800 R15: 00000000000000e8 FS:  00007f174d6f3600(0000) GS:ffff88807db00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffff988004dd6870 CR3: 00000000092be000 CR4: 00000000007506e0 PKRU: 55555554 Call Trace: <TASK> ? __die_body.cold+0x1a/0x1f ? page_fault_oops+0xa9/0x1e0 ? fixup_exception+0x1d/0x310 ? exc_page_fault+0xa8/0x150 ? asm_exc_page_fault+0x22/0x30 ? kmem_cache_alloc_node+0xa2/0x1e0 ? __alloc_skb+0x16c/0x1e0 __alloc_skb+0x16c/0x1e0 alloc_skb_with_frags+0x48/0x1e0 sock_alloc_send_pskb+0x234/0x270 unix_stream_sendmsg+0x1f5/0x690 sock_sendmsg+0x5d/0x60 ____sys_sendmsg+0x210/0x260 ___sys_sendmsg+0x83/0xd0 ? kmem_cache_alloc+0xc6/0x1c0 ? avc_disable+0x20/0x20 ? percpu_counter_add_batch+0x53/0xc0 ? alloc_empty_file+0x5d/0xb0 ? alloc_file+0x91/0x170 ? alloc_file_pseudo+0x94/0x100 ? __fget_light+0x9f/0x120 __sys_sendmsg+0x54/0xa0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x69/0xd3 RIP: 0033:0x7f174d639a7d Code: 28 89 54 24 1c 48 89 74 24 10 89 7c 24 08 e8 8a c1 f4 ff 8b 54 24 1c 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 33 44 89 c7 48 89 44 24 08 e8 de c1 f4 ff 48 RSP: 002b:00007ffcb563ea50 EFLAGS: 00000293 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f174d639a7d RDX: 0000000000000000 RSI: 00007ffcb563eab0 RDI: 0000000000000007 RBP: 00007ffcb563eb10 R08: 0000000000000000 R09: 00000000ffffffff R10: 00000000004040a0 R11: 0000000000000293 R12: 00007ffcb563ec28 R13: 0000000000401398 R14: 0000000000403e00 R15: 00007f174d72c000 </TASK>",
      "cve": "CVE-2023-53469",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53469",
          "value": "CVE-2023-53469",
          "url": "https://scout.docker.com/v/CVE-2023-53469?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53469?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e3ebb396780e96687fd7c9f8fdd8bf733fc379ec096d69f879eff1f981370f94",
      "category": "container_scanning",
      "message": "CVE-2023-53478 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing/synthetic: Fix races on freeing last_cmd  Currently, the \"last_cmd\" variable can be accessed by multiple processes asynchronously when multiple users manipulate synthetic_events node at the same time, it could lead to use-after-free or double-free.  This patch add \"lastcmd_mutex\" to prevent \"last_cmd\" from being accessed asynchronously.  ================================================================  It's easy to reproduce in the KASAN environment by running the two scripts below in different shells.  script 1: while : do echo -n -e '\\x88' > /sys/kernel/tracing/synthetic_events done  script 2: while : do echo -n -e '\\xb0' > /sys/kernel/tracing/synthetic_events done  ================================================================ double-free scenario:  process A                       process B -------------------               --------------- 1.kstrdup last_cmd 2.free last_cmd 3.free last_cmd(double-free)  ================================================================ use-after-free scenario:  process A                       process B -------------------               --------------- 1.kstrdup last_cmd 2.free last_cmd 3.tracing_log_err(use-after-free)  ================================================================  Appendix 1. KASAN report double-free:  BUG: KASAN: double-free in kfree+0xdc/0x1d4 Free of addr ***** by task sh/4879 Call trace: ... kfree+0xdc/0x1d4 create_or_delete_synth_event+0x60/0x1e8 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...  Allocated by task 4879: ... kstrdup+0x5c/0x98 create_or_delete_synth_event+0x6c/0x1e8 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...  Freed by task 5464: ... kfree+0xdc/0x1d4 create_or_delete_synth_event+0x60/0x1e8 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...  ================================================================ Appendix 2. KASAN report use-after-free:  BUG: KASAN: use-after-free in strlen+0x5c/0x7c Read of size 1 at addr ***** by task sh/5483 sh: CPU: 7 PID: 5483 Comm: sh ... __asan_report_load1_noabort+0x34/0x44 strlen+0x5c/0x7c tracing_log_err+0x60/0x444 create_or_delete_synth_event+0xc4/0x204 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...  Allocated by task 5483: ... kstrdup+0x5c/0x98 create_or_delete_synth_event+0x80/0x204 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...  Freed by task 5480: ... kfree+0xdc/0x1d4 create_or_delete_synth_event+0x74/0x204 trace_parse_run_command+0x2bc/0x4b8 synth_events_write+0x20/0x30 vfs_write+0x200/0x830 ...",
      "cve": "CVE-2023-53478",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53478",
          "value": "CVE-2023-53478",
          "url": "https://scout.docker.com/v/CVE-2023-53478?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53478?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3891cb983c6bc31c528d3d2d6a464e5fc915ffcdb6c213eca56af0f219c8251",
      "category": "container_scanning",
      "message": "CVE-2023-53483 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ACPI: processor: Check for null return of devm_kzalloc() in fch_misc_setup()  devm_kzalloc() may fail, clk_data->name might be NULL and will cause a NULL pointer dereference later.  [ rjw: Subject and changelog edits ]",
      "cve": "CVE-2023-53483",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53483",
          "value": "CVE-2023-53483",
          "url": "https://scout.docker.com/v/CVE-2023-53483?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53483?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "19b498d5a04f560f9b52ee31a4edea40a3605d91b844ea7639c9ee26e5d6ea74",
      "category": "container_scanning",
      "message": "CVE-2023-53491 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  start_kernel: Add __no_stack_protector function attribute  Back during the discussion of commit a9a3ed1eff36 (\"x86: Fix early boot crash on gcc-10, third try\") we discussed the need for a function attribute to control the omission of stack protectors on a per-function basis; at the time Clang had support for no_stack_protector but GCC did not. This was fixed in gcc-11. Now that the function attribute is available, let's start using it.  Callers of boot_init_stack_canary need to use this function attribute unless they're compiled with -fno-stack-protector, otherwise the canary stored in the stack slot of the caller will differ upon the call to boot_init_stack_canary. This will lead to a call to __stack_chk_fail() then panic.",
      "cve": "CVE-2023-53491",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53491",
          "value": "CVE-2023-53491",
          "url": "https://scout.docker.com/v/CVE-2023-53491?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53491?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bf008d324ab6506edf32794f311d56581ea5bf7b95e978562a1f4b218f1da93b",
      "category": "container_scanning",
      "message": "CVE-2023-53509 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  qed: allow sleep in qed_mcp_trace_dump()  By default, qed_mcp_cmd_and_union() delays 10us at a time in a loop that can run 500K times, so calls to qed_mcp_nvm_rd_cmd() may block the current thread for over 5s. We observed thread scheduling delays over 700ms in production, with stacktraces pointing to this code as the culprit.  qed_mcp_trace_dump() is called from ethtool, so sleeping is permitted. It already can sleep in qed_mcp_halt(), which calls qed_mcp_cmd(). Add a \"can sleep\" parameter to qed_find_nvram_image() and qed_nvram_read() so they can sleep during qed_mcp_trace_dump(). qed_mcp_trace_get_meta_info() and qed_mcp_trace_read_meta(), called only by qed_mcp_trace_dump(), allow these functions to sleep. I can't tell if the other caller (qed_grc_dump_mcp_hw_dump()) can sleep, so keep b_can_sleep set to false when it calls these functions.  An example stacktrace from a custom warning we added to the kernel showing a thread that has not scheduled despite long needing resched: [ 2745.362925,17] ------------[ cut here ]------------ [ 2745.362941,17] WARNING: CPU: 23 PID: 5640 at arch/x86/kernel/irq.c:233 do_IRQ+0x15e/0x1a0() [ 2745.362946,17] Thread not rescheduled for 744 ms after irq 99 [ 2745.362956,17] Modules linked in: ... [ 2745.363339,17] CPU: 23 PID: 5640 Comm: lldpd Tainted: P           O 4.4.182+ #202104120910+6d1da174272d.61x [ 2745.363343,17] Hardware name: FOXCONN MercuryB/Quicksilver Controller, BIOS H11P1N09 07/08/2020 [ 2745.363346,17]  0000000000000000 ffff885ec07c3ed8 ffffffff8131eb2f ffff885ec07c3f20 [ 2745.363358,17]  ffffffff81d14f64 ffff885ec07c3f10 ffffffff81072ac2 ffff88be98ed0000 [ 2745.363369,17]  0000000000000063 0000000000000174 0000000000000074 0000000000000000 [ 2745.363379,17] Call Trace: [ 2745.363382,17]  <IRQ>  [<ffffffff8131eb2f>] dump_stack+0x8e/0xcf [ 2745.363393,17]  [<ffffffff81072ac2>] warn_slowpath_common+0x82/0xc0 [ 2745.363398,17]  [<ffffffff81072b4c>] warn_slowpath_fmt+0x4c/0x50 [ 2745.363404,17]  [<ffffffff810d5a8e>] ? rcu_irq_exit+0xae/0xc0 [ 2745.363408,17]  [<ffffffff817c99fe>] do_IRQ+0x15e/0x1a0 [ 2745.363413,17]  [<ffffffff817c7ac9>] common_interrupt+0x89/0x89 [ 2745.363416,17]  <EOI>  [<ffffffff8132aa74>] ? delay_tsc+0x24/0x50 [ 2745.363425,17]  [<ffffffff8132aa04>] __udelay+0x34/0x40 [ 2745.363457,17]  [<ffffffffa04d45ff>] qed_mcp_cmd_and_union+0x36f/0x7d0 [qed] [ 2745.363473,17]  [<ffffffffa04d5ced>] qed_mcp_nvm_rd_cmd+0x4d/0x90 [qed] [ 2745.363490,17]  [<ffffffffa04e1dc7>] qed_mcp_trace_dump+0x4a7/0x630 [qed] [ 2745.363504,17]  [<ffffffffa04e2556>] ? qed_fw_asserts_dump+0x1d6/0x1f0 [qed] [ 2745.363520,17]  [<ffffffffa04e4ea7>] qed_dbg_mcp_trace_get_dump_buf_size+0x37/0x80 [qed] [ 2745.363536,17]  [<ffffffffa04ea881>] qed_dbg_feature_size+0x61/0xa0 [qed] [ 2745.363551,17]  [<ffffffffa04eb427>] qed_dbg_all_data_size+0x247/0x260 [qed] [ 2745.363560,17]  [<ffffffffa0482c10>] qede_get_regs_len+0x30/0x40 [qede] [ 2745.363566,17]  [<ffffffff816c9783>] ethtool_get_drvinfo+0xe3/0x190 [ 2745.363570,17]  [<ffffffff816cc152>] dev_ethtool+0x1362/0x2140 [ 2745.363575,17]  [<ffffffff8109bcc6>] ? finish_task_switch+0x76/0x260 [ 2745.363580,17]  [<ffffffff817c2116>] ? __schedule+0x3c6/0x9d0 [ 2745.363585,17]  [<ffffffff810dbd50>] ? hrtimer_start_range_ns+0x1d0/0x370 [ 2745.363589,17]  [<ffffffff816c1e5b>] ? dev_get_by_name_rcu+0x6b/0x90 [ 2745.363594,17]  [<ffffffff816de6a8>] dev_ioctl+0xe8/0x710 [ 2745.363599,17]  [<ffffffff816a58a8>] sock_do_ioctl+0x48/0x60 [ 2745.363603,17]  [<ffffffff816a5d87>] sock_ioctl+0x1c7/0x280 [ 2745.363608,17]  [<ffffffff8111f393>] ? seccomp_phase1+0x83/0x220 [ 2745.363612,17]  [<ffffffff811e3503>] do_vfs_ioctl+0x2b3/0x4e0 [ 2745.363616,17]  [<ffffffff811e3771>] SyS_ioctl+0x41/0x70 [ 2745.363619,17]  [<ffffffff817c6ffe>] entry_SYSCALL_64_fastpath+0x1e/0x79 [ 2745.363622,17] ---[ end trace f6954aa440266421 ]---",
      "cve": "CVE-2023-53509",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53509",
          "value": "CVE-2023-53509",
          "url": "https://scout.docker.com/v/CVE-2023-53509?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53509?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "abfca937479a9ee2a7bb073344c03196c7c6176b6df162b1472dba1201cec393",
      "category": "container_scanning",
      "message": "CVE-2023-53510 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Fix handling of lrbp->cmd  ufshcd_queuecommand() may be called two times in a row for a SCSI command before it is completed. Hence make the following changes:  - In the functions that submit a command, do not check the old value of lrbp->cmd nor clear lrbp->cmd in error paths.  - In ufshcd_release_scsi_cmd(), do not clear lrbp->cmd.  See also scsi_send_eh_cmnd().  This commit prevents that the following appears if a command times out:  WARNING: at drivers/ufs/core/ufshcd.c:2965 ufshcd_queuecommand+0x6f8/0x9a8 Call trace: ufshcd_queuecommand+0x6f8/0x9a8 scsi_send_eh_cmnd+0x2c0/0x960 scsi_eh_test_devices+0x100/0x314 scsi_eh_ready_devs+0xd90/0x114c scsi_error_handler+0x2b4/0xb70 kthread+0x16c/0x1e0",
      "cve": "CVE-2023-53510",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53510",
          "value": "CVE-2023-53510",
          "url": "https://scout.docker.com/v/CVE-2023-53510?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53510?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f677f0bd3d1477084f0651e067b47fcd0dd7f20c961b0231da5000b756f8ca2d",
      "category": "container_scanning",
      "message": "CVE-2023-53520 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: Fix hci_suspend_sync crash  If hci_unregister_dev() frees the hci_dev object but hci_suspend_notifier may still be accessing it, it can cause the program to crash. Here's the call trace: <4>[102152.653246] Call Trace: <4>[102152.653254]  hci_suspend_sync+0x109/0x301 [bluetooth] <4>[102152.653259]  hci_suspend_dev+0x78/0xcd [bluetooth] <4>[102152.653263]  hci_suspend_notifier+0x42/0x7a [bluetooth] <4>[102152.653268]  notifier_call_chain+0x43/0x6b <4>[102152.653271]  __blocking_notifier_call_chain+0x48/0x69 <4>[102152.653273]  __pm_notifier_call_chain+0x22/0x39 <4>[102152.653276]  pm_suspend+0x287/0x57c <4>[102152.653278]  state_store+0xae/0xe5 <4>[102152.653281]  kernfs_fop_write+0x109/0x173 <4>[102152.653284]  __vfs_write+0x16f/0x1a2 <4>[102152.653287]  ? selinux_file_permission+0xca/0x16f <4>[102152.653289]  ? security_file_permission+0x36/0x109 <4>[102152.653291]  vfs_write+0x114/0x21d <4>[102152.653293]  __x64_sys_write+0x7b/0xdb <4>[102152.653296]  do_syscall_64+0x59/0x194 <4>[102152.653299]  entry_SYSCALL_64_after_hwframe+0x5c/0xc1  This patch holds the reference count of the hci_dev object while processing it in hci_suspend_notifier to avoid potential crash caused by the race condition.",
      "cve": "CVE-2023-53520",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53520",
          "value": "CVE-2023-53520",
          "url": "https://scout.docker.com/v/CVE-2023-53520?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53520?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a80596e7a4465b750e141cfcb6f43d56e26d803b72ce279e5b6a62c4c7df960c",
      "category": "container_scanning",
      "message": "CVE-2023-53529 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw88: Fix memory leak in rtw88_usb  Kmemleak shows the following leak arising from routine in the usb probe routine:  unreferenced object 0xffff895cb29bba00 (size 512): comm \"(udev-worker)\", pid 534, jiffies 4294903932 (age 102751.088s) hex dump (first 32 bytes): 77 30 30 30 00 00 00 00 02 2f 2d 2b 30 00 00 00  w000...../-+0... 02 00 2a 28 00 00 00 00 ff 55 ff ff ff 00 00 00  ..*(.....U...... backtrace: [<ffffffff9265fa36>] kmalloc_trace+0x26/0x90 [<ffffffffc17eec41>] rtw_usb_probe+0x2f1/0x680 [rtw_usb] [<ffffffffc03e19fd>] usb_probe_interface+0xdd/0x2e0 [usbcore] [<ffffffff92b4f2fe>] really_probe+0x18e/0x3d0 [<ffffffff92b4f5b8>] __driver_probe_device+0x78/0x160 [<ffffffff92b4f6bf>] driver_probe_device+0x1f/0x90 [<ffffffff92b4f8df>] __driver_attach+0xbf/0x1b0 [<ffffffff92b4d350>] bus_for_each_dev+0x70/0xc0 [<ffffffff92b4e51e>] bus_add_driver+0x10e/0x210 [<ffffffff92b50935>] driver_register+0x55/0xf0 [<ffffffffc03e0708>] usb_register_driver+0x88/0x140 [usbcore] [<ffffffff92401153>] do_one_initcall+0x43/0x210 [<ffffffff9254f42a>] do_init_module+0x4a/0x200 [<ffffffff92551d1c>] __do_sys_finit_module+0xac/0x120 [<ffffffff92ee6626>] do_syscall_64+0x56/0x80 [<ffffffff9300006a>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  The leak was verified to be real by unloading the driver, which resulted in a dangling pointer to the allocation.  The allocated memory is freed in rtw_usb_intf_deinit().",
      "cve": "CVE-2023-53529",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53529",
          "value": "CVE-2023-53529",
          "url": "https://scout.docker.com/v/CVE-2023-53529?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53529?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a3344abea28bab9f6bbf9f766a953519f8b8b897285f47a99982f02c3147511",
      "category": "container_scanning",
      "message": "CVE-2023-53538 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: insert tree mod log move in push_node_left  There is a fairly unlikely race condition in tree mod log rewind that can result in a kernel panic which has the following trace:  [530.569] BTRFS critical (device sda3): unable to find logical 0 length 4096 [530.585] BTRFS critical (device sda3): unable to find logical 0 length 4096 [530.602] BUG: kernel NULL pointer dereference, address: 0000000000000002 [530.618] #PF: supervisor read access in kernel mode [530.629] #PF: error_code(0x0000) - not-present page [530.641] PGD 0 P4D 0 [530.647] Oops: 0000 [#1] SMP [530.654] CPU: 30 PID: 398973 Comm: below Kdump: loaded Tainted: G S O  K   5.12.0-0_fbk13_clang_7455_gb24de3bdb045 #1 [530.680] Hardware name: Quanta Mono Lake-M.2 SATA 1HY9U9Z001G/Mono Lake-M.2 SATA, BIOS F20_3A15 08/16/2017 [530.703] RIP: 0010:__btrfs_map_block+0xaa/0xd00 [530.755] RSP: 0018:ffffc9002c2f7600 EFLAGS: 00010246 [530.767] RAX: ffffffffffffffea RBX: ffff888292e41000 RCX: f2702d8b8be15100 [530.784] RDX: ffff88885fda6fb8 RSI: ffff88885fd973c8 RDI: ffff88885fd973c8 [530.800] RBP: ffff888292e410d0 R08: ffffffff82fd7fd0 R09: 00000000fffeffff [530.816] R10: ffffffff82e57fd0 R11: ffffffff82e57d70 R12: 0000000000000000 [530.832] R13: 0000000000001000 R14: 0000000000001000 R15: ffffc9002c2f76f0 [530.848] FS:  00007f38d64af000(0000) GS:ffff88885fd80000(0000) knlGS:0000000000000000 [530.866] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [530.880] CR2: 0000000000000002 CR3: 00000002b6770004 CR4: 00000000003706e0 [530.896] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [530.912] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [530.928] Call Trace: [530.934]  ? btrfs_printk+0x13b/0x18c [530.943]  ? btrfs_bio_counter_inc_blocked+0x3d/0x130 [530.955]  btrfs_map_bio+0x75/0x330 [530.963]  ? kmem_cache_alloc+0x12a/0x2d0 [530.973]  ? btrfs_submit_metadata_bio+0x63/0x100 [530.984]  btrfs_submit_metadata_bio+0xa4/0x100 [530.995]  submit_extent_page+0x30f/0x360 [531.004]  read_extent_buffer_pages+0x49e/0x6d0 [531.015]  ? submit_extent_page+0x360/0x360 [531.025]  btree_read_extent_buffer_pages+0x5f/0x150 [531.037]  read_tree_block+0x37/0x60 [531.046]  read_block_for_search+0x18b/0x410 [531.056]  btrfs_search_old_slot+0x198/0x2f0 [531.066]  resolve_indirect_ref+0xfe/0x6f0 [531.076]  ? ulist_alloc+0x31/0x60 [531.084]  ? kmem_cache_alloc_trace+0x12e/0x2b0 [531.095]  find_parent_nodes+0x720/0x1830 [531.105]  ? ulist_alloc+0x10/0x60 [531.113]  iterate_extent_inodes+0xea/0x370 [531.123]  ? btrfs_previous_extent_item+0x8f/0x110 [531.134]  ? btrfs_search_path_in_tree+0x240/0x240 [531.146]  iterate_inodes_from_logical+0x98/0xd0 [531.157]  ? btrfs_search_path_in_tree+0x240/0x240 [531.168]  btrfs_ioctl_logical_to_ino+0xd9/0x180 [531.179]  btrfs_ioctl+0xe2/0x2eb0  This occurs when logical inode resolution takes a tree mod log sequence number, and then while backref walking hits a rewind on a busy node which has the following sequence of tree mod log operations (numbers filled in from a specific example, but they are somewhat arbitrary)  REMOVE_WHILE_FREEING slot 532 REMOVE_WHILE_FREEING slot 531 REMOVE_WHILE_FREEING slot 530 ... REMOVE_WHILE_FREEING slot 0 REMOVE slot 455 REMOVE slot 454 REMOVE slot 453 ... REMOVE slot 0 ADD slot 455 ADD slot 454 ADD slot 453 ... ADD slot 0 MOVE src slot 0 -> dst slot 456 nritems 533 REMOVE slot 455 REMOVE slot 454 REMOVE slot 453 ... REMOVE slot 0  When this sequence gets applied via btrfs_tree_mod_log_rewind, it allocates a fresh rewind eb, and first inserts the correct key info for the 533 elements, then overwrites the first 456 of them, then decrements the count by 456 via the add ops, then rewinds the move by doing a memmove from 456:988->0:532. We have never written anything past 532, ---truncated---",
      "cve": "CVE-2023-53538",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53538",
          "value": "CVE-2023-53538",
          "url": "https://scout.docker.com/v/CVE-2023-53538?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53538?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e200cf505032657ea3df6144edf64a63021964738a97a15ca5b9b649f1eec7f7",
      "category": "container_scanning",
      "message": "CVE-2023-53539 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/rxe: Fix incomplete state save in rxe_requester  If a send packet is dropped by the IP layer in rxe_requester() the call to rxe_xmit_packet() can fail with err == -EAGAIN. To recover, the state of the wqe is restored to the state before the packet was sent so it can be resent. However, the routines that save and restore the state miss a significnt part of the variable state in the wqe, the dma struct which is used to process through the sge table. And, the state is not saved before the packet is built which modifies the dma struct.  Under heavy stress testing with many QPs on a fast node sending large messages to a slow node dropped packets are observed and the resent packets are corrupted because the dma struct was not restored. This patch fixes this behavior and allows the test cases to succeed.",
      "cve": "CVE-2023-53539",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53539",
          "value": "CVE-2023-53539",
          "url": "https://scout.docker.com/v/CVE-2023-53539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c2ee9e418a63ca0a9800f01d7d2315509b1c35f9c9a44006e4bbbbe8c0d0dcdd",
      "category": "container_scanning",
      "message": "CVE-2023-53540 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: cfg80211: reject auth/assoc to AP with our address  If the AP uses our own address as its MLD address or BSSID, then clearly something's wrong. Reject such connections so we don't try and fail later.",
      "cve": "CVE-2023-53540",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53540",
          "value": "CVE-2023-53540",
          "url": "https://scout.docker.com/v/CVE-2023-53540?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53540?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8cee72f3ee7e29565d8df7b9c17eac32e67786dfe930e0619797e083327799af",
      "category": "container_scanning",
      "message": "CVE-2023-53544 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpufreq: davinci: Fix clk use after free  The remove function first frees the clks and only then calls cpufreq_unregister_driver(). If one of the cpufreq callbacks is called just before cpufreq_unregister_driver() is run, the freed clks might be used.",
      "cve": "CVE-2023-53544",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53544",
          "value": "CVE-2023-53544",
          "url": "https://scout.docker.com/v/CVE-2023-53544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "114fc9acd86f4d45c5e4f40466cde3f7b3ce1ba7331e142658739f9bd5480090",
      "category": "container_scanning",
      "message": "CVE-2023-53545 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: unmap and remove csa_va properly  Root PD BO should be reserved before unmap and remove a bo_va from VM otherwise lockdep will complain.  v2: check fpriv->csa_va is not NULL instead of amdgpu_mcbp (christian)  [14616.936827] WARNING: CPU: 6 PID: 1711 at drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c:1762 amdgpu_vm_bo_del+0x399/0x3f0 [amdgpu] [14616.937096] Call Trace: [14616.937097]  <TASK> [14616.937102]  amdgpu_driver_postclose_kms+0x249/0x2f0 [amdgpu] [14616.937187]  drm_file_free+0x1d6/0x300 [drm] [14616.937207]  drm_close_helper.isra.0+0x62/0x70 [drm] [14616.937220]  drm_release+0x5e/0x100 [drm] [14616.937234]  __fput+0x9f/0x280 [14616.937239]  ____fput+0xe/0x20 [14616.937241]  task_work_run+0x61/0x90 [14616.937246]  exit_to_user_mode_prepare+0x215/0x220 [14616.937251]  syscall_exit_to_user_mode+0x2a/0x60 [14616.937254]  do_syscall_64+0x48/0x90 [14616.937257]  entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "cve": "CVE-2023-53545",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53545",
          "value": "CVE-2023-53545",
          "url": "https://scout.docker.com/v/CVE-2023-53545?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53545?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ca40e43084aa2b94140ced2461f92f559ea24b6384a8aa458d013c5a09b6d67c",
      "category": "container_scanning",
      "message": "CVE-2023-53547 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix sdma v4 sw fini error  Fix sdma v4 sw fini error for sdma 4.2.2 to solve the following general protection fault  [  +0.108196] general protection fault, probably for non-canonical address 0xd5e5a4ae79d24a32: 0000 [#1] PREEMPT SMP PTI [  +0.000018] RIP: 0010:free_fw_priv+0xd/0x70 [  +0.000022] Call Trace: [  +0.000012]  <TASK> [  +0.000011]  release_firmware+0x55/0x80 [  +0.000021]  amdgpu_ucode_release+0x11/0x20 [amdgpu] [  +0.000415]  amdgpu_sdma_destroy_inst_ctx+0x4f/0x90 [amdgpu] [  +0.000360]  sdma_v4_0_sw_fini+0xce/0x110 [amdgpu]",
      "cve": "CVE-2023-53547",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53547",
          "value": "CVE-2023-53547",
          "url": "https://scout.docker.com/v/CVE-2023-53547?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53547?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6d05b65ef63cfeec384cbc9e22a7725b7eb4c261edd6922e9b20db2b8d3afcc",
      "category": "container_scanning",
      "message": "CVE-2023-53558 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcu-tasks: Avoid pr_info() with spin lock in cblist_init_generic()  pr_info() is called with rtp->cbs_gbl_lock spin lock locked.  Because pr_info() calls printk() that might sleep, this will result in BUG like below:  [    0.206455] cblist_init_generic: Setting adjustable number of callback queues. [    0.206463] [    0.206464] ============================= [    0.206464] [ BUG: Invalid wait context ] [    0.206465] 5.19.0-00428-g9de1f9c8ca51 #5 Not tainted [    0.206466] ----------------------------- [    0.206466] swapper/0/1 is trying to lock: [    0.206467] ffffffffa0167a58 (&port_lock_key){....}-{3:3}, at: serial8250_console_write+0x327/0x4a0 [    0.206473] other info that might help us debug this: [    0.206473] context-{5:5} [    0.206474] 3 locks held by swapper/0/1: [    0.206474]  #0: ffffffff9eb597e0 (rcu_tasks.cbs_gbl_lock){....}-{2:2}, at: cblist_init_generic.constprop.0+0x14/0x1f0 [    0.206478]  #1: ffffffff9eb579c0 (console_lock){+.+.}-{0:0}, at: _printk+0x63/0x7e [    0.206482]  #2: ffffffff9ea77780 (console_owner){....}-{0:0}, at: console_emit_next_record.constprop.0+0x111/0x330 [    0.206485] stack backtrace: [    0.206486] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-00428-g9de1f9c8ca51 #5 [    0.206488] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-1.fc36 04/01/2014 [    0.206489] Call Trace: [    0.206490]  <TASK> [    0.206491]  dump_stack_lvl+0x6a/0x9f [    0.206493]  __lock_acquire.cold+0x2d7/0x2fe [    0.206496]  ? stack_trace_save+0x46/0x70 [    0.206497]  lock_acquire+0xd1/0x2f0 [    0.206499]  ? serial8250_console_write+0x327/0x4a0 [    0.206500]  ? __lock_acquire+0x5c7/0x2720 [    0.206502]  _raw_spin_lock_irqsave+0x3d/0x90 [    0.206504]  ? serial8250_console_write+0x327/0x4a0 [    0.206506]  serial8250_console_write+0x327/0x4a0 [    0.206508]  console_emit_next_record.constprop.0+0x180/0x330 [    0.206511]  console_unlock+0xf7/0x1f0 [    0.206512]  vprintk_emit+0xf7/0x330 [    0.206514]  _printk+0x63/0x7e [    0.206516]  cblist_init_generic.constprop.0.cold+0x24/0x32 [    0.206518]  rcu_init_tasks_generic+0x5/0xd9 [    0.206522]  kernel_init_freeable+0x15b/0x2a2 [    0.206523]  ? rest_init+0x160/0x160 [    0.206526]  kernel_init+0x11/0x120 [    0.206527]  ret_from_fork+0x1f/0x30 [    0.206530]  </TASK> [    0.207018] cblist_init_generic: Setting shift to 1 and lim to 1.  This patch moves pr_info() so that it is called without rtp->cbs_gbl_lock locked.",
      "cve": "CVE-2023-53558",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53558",
          "value": "CVE-2023-53558",
          "url": "https://scout.docker.com/v/CVE-2023-53558?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53558?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1722317d987f5b1b25fd8eeb49aa3aecaded86ec73bd84ffcae59d1060f6e04a",
      "category": "container_scanning",
      "message": "CVE-2023-53561 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: wwan: iosm: fix NULL pointer dereference when removing device  In suspend and resume cycle, the removal and rescan of device ends up in NULL pointer dereference.  During driver initialization, if the ipc_imem_wwan_channel_init() fails to get the valid device capabilities it returns an error and further no resource (wwan struct) will be allocated. Now in this situation if driver removal procedure is initiated it would result in NULL pointer exception since unallocated wwan struct is dereferenced inside ipc_wwan_deinit().  ipc_imem_run_state_worker() to handle the called functions return value and to release the resource in failure case. It also reports the link down event in failure cases. The user space application can handle this event to do a device reset for restoring the device communication.",
      "cve": "CVE-2023-53561",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53561",
          "value": "CVE-2023-53561",
          "url": "https://scout.docker.com/v/CVE-2023-53561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e618a5737ca4bc93d5d40c9e4b1c9884cbf614fb816e2ab44ae10e2fea750c2",
      "category": "container_scanning",
      "message": "CVE-2023-53562 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm: fix vram leak on bind errors  Make sure to release the VRAM buffer also in a case a subcomponent fails to bind.  Patchwork: https://patchwork.freedesktop.org/patch/525094/",
      "cve": "CVE-2023-53562",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53562",
          "value": "CVE-2023-53562",
          "url": "https://scout.docker.com/v/CVE-2023-53562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "25cd45e5a1c340171fa91596d7cf09cf3a70241f702a3d4dad1fdbc1e79c24b2",
      "category": "container_scanning",
      "message": "CVE-2023-53574 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw88: delete timer and free skb queue when unloading  Fix possible crash and memory leak on driver unload by deleting TX purge timer and freeing C2H queue in 'rtw_core_deinit()', shrink critical section in the latter by freeing COEX queue out of TX report lock scope.",
      "cve": "CVE-2023-53574",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53574",
          "value": "CVE-2023-53574",
          "url": "https://scout.docker.com/v/CVE-2023-53574?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53574?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eb0590033917f597622ec77c539379e76334b0f1edfe362df19fa5956061cc93",
      "category": "container_scanning",
      "message": "CVE-2023-53575 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: fix potential array out of bounds access  Account for IWL_SEC_WEP_KEY_OFFSET when needed while verifying key_len size in iwl_mvm_sec_key_add().",
      "cve": "CVE-2023-53575",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53575",
          "value": "CVE-2023-53575",
          "url": "https://scout.docker.com/v/CVE-2023-53575?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53575?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7f631cf20264dbd285b17b8fdf064b7d9359abd1da9119232c776922e8fe732c",
      "category": "container_scanning",
      "message": "CVE-2023-53584 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ubifs: ubifs_releasepage: Remove ubifs_assert(0) to valid this process  There are two states for ubifs writing pages: 1. Dirty, Private 2. Not Dirty, Not Private  The normal process cannot go to ubifs_releasepage() which means there exists pages being private but not dirty. Reproducer[1] shows that it could occur (which maybe related to [2]) with following process:  PA                     PB                    PC lock(page)[PA] ubifs_write_end attach_page_private         // set Private __set_page_dirty_nobuffers  // set Dirty unlock(page)  write_cache_pages[PA] lock(page) clear_page_dirty_for_io(page)\t// clear Dirty ubifs_writepage  do_truncation[PB] truncate_setsize i_size_write(inode, newsize) // newsize = 0  i_size = i_size_read(inode)\t// i_size = 0 end_index = i_size >> PAGE_SHIFT if (page->index > end_index) goto out // jump out: unlock(page)   // Private, Not Dirty  generic_fadvise[PC] lock(page) invalidate_inode_page try_to_release_page ubifs_releasepage ubifs_assert(c, 0) // bad assertion! unlock(page) truncate_pagecache[PB]  Then we may get following assertion failed: UBIFS error (ubi0:0 pid 1683): ubifs_assert_failed [ubifs]: UBIFS assert failed: 0, in fs/ubifs/file.c:1513 UBIFS warning (ubi0:0 pid 1683): ubifs_ro_mode [ubifs]: switched to read-only mode, error -22 CPU: 2 PID: 1683 Comm: aa Not tainted 5.16.0-rc5-00184-g0bca5994cacc-dirty #308 Call Trace: dump_stack+0x13/0x1b ubifs_ro_mode+0x54/0x60 [ubifs] ubifs_assert_failed+0x4b/0x80 [ubifs] ubifs_releasepage+0x67/0x1d0 [ubifs] try_to_release_page+0x57/0xe0 invalidate_inode_page+0xfb/0x130 __invalidate_mapping_pages+0xb9/0x280 invalidate_mapping_pagevec+0x12/0x20 generic_fadvise+0x303/0x3c0 ksys_fadvise64_64+0x4c/0xb0  [1] https://bugzilla.kernel.org/show_bug.cgi?id=215373 [2] https://linux-mtd.infradead.narkive.com/NQoBeT1u/patch-rfc-ubifs-fix-assert-failed-in-ubifs-set-page-dirty",
      "cve": "CVE-2023-53584",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53584",
          "value": "CVE-2023-53584",
          "url": "https://scout.docker.com/v/CVE-2023-53584?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53584?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5ba974f6a3254bbbc5bea53aad0ebceedb822d88538c2a47fc32e8368e58e6f",
      "category": "container_scanning",
      "message": "CVE-2023-53588 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: check for station first in client probe  When probing a client, first check if we have it, and then check for the channel context, otherwise you can trigger the warning there easily by probing when the AP isn't even started yet. Since a client existing means the AP is also operating, we can then keep the warning.  Also simplify the moved code a bit.",
      "cve": "CVE-2023-53588",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53588",
          "value": "CVE-2023-53588",
          "url": "https://scout.docker.com/v/CVE-2023-53588?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53588?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0128b07b258143131db4fadcdf6e4c46b4afa837e4625d0b6df90e0529a9f150",
      "category": "container_scanning",
      "message": "CVE-2023-53596 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drivers: base: Free devm resources when unregistering a device  In the current code, devres_release_all() only gets called if the device has a bus and has been probed.  This leads to issues when using bus-less or driver-less devices where the device might never get freed if a managed resource holds a reference to the device. This is happening in the DRM framework for example.  We should thus call devres_release_all() in the device_del() function to make sure that the device-managed actions are properly executed when the device is unregistered, even if it has neither a bus nor a driver.  This is effectively the same change than commit 2f8d16a996da (\"devres: release resources on device_del()\") that got reverted by commit a525a3ddeaca (\"driver core: free devres in device_release\") over memory leaks concerns.  This patch effectively combines the two commits mentioned above to release the resources both on device_del() and device_release() and get the best of both worlds.",
      "cve": "CVE-2023-53596",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53596",
          "value": "CVE-2023-53596",
          "url": "https://scout.docker.com/v/CVE-2023-53596?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53596?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6108e6fd852cce25b32090b53b228e7500774ae401fad86e79fede8ded3fd550",
      "category": "container_scanning",
      "message": "CVE-2023-53602 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: fix memory leak in WMI firmware stats  Memory allocated for firmware pdev, vdev and beacon statistics are not released during rmmod.  Fix it by calling ath11k_fw_stats_free() function before hardware unregister.  While at it, avoid calling ath11k_fw_stats_free() while processing the firmware stats received in the WMI event because the local list is getting spliced and reinitialised and hence there are no elements in the list after splicing.  Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2023-53602",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53602",
          "value": "CVE-2023-53602",
          "url": "https://scout.docker.com/v/CVE-2023-53602?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53602?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5964bdf28a879b733eb7a0bc5f8cd635904373331e05ae282491a00b675bcfa8",
      "category": "container_scanning",
      "message": "CVE-2023-53609 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: Revert \"scsi: core: Do not increase scsi_device's iorequest_cnt if dispatch failed\"  The \"atomic_inc(&cmd->device->iorequest_cnt)\" in scsi_queue_rq() would cause kernel panic because cmd->device may be freed after returning from scsi_dispatch_cmd().  This reverts commit cfee29ffb45b1c9798011b19d454637d1b0fe87d.",
      "cve": "CVE-2023-53609",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53609",
          "value": "CVE-2023-53609",
          "url": "https://scout.docker.com/v/CVE-2023-53609?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53609?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "219de5847643fdada42bec0aa1eb18a653a4344eb77a69769acbc6fe332057a5",
      "category": "container_scanning",
      "message": "CVE-2023-53620 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md: fix soft lockup in status_resync  status_resync() will calculate 'curr_resync - recovery_active' to show user a progress bar like following:  [============>........]  resync = 61.4%  'curr_resync' and 'recovery_active' is updated in md_do_sync(), and status_resync() can read them concurrently, hence it's possible that 'curr_resync - recovery_active' can overflow to a huge number. In this case status_resync() will be stuck in the loop to print a large amount of '=', which will end up soft lockup.  Fix the problem by setting 'resync' to MD_RESYNC_ACTIVE in this case, this way resync in progress will be reported to user.",
      "cve": "CVE-2023-53620",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53620",
          "value": "CVE-2023-53620",
          "url": "https://scout.docker.com/v/CVE-2023-53620?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53620?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "579a2f113e03138ada62d0c4a47bcba3ec05540cbff90448ded0bb3a082a4220",
      "category": "container_scanning",
      "message": "CVE-2023-53627 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: hisi_sas: Grab sas_dev lock when traversing the members of sas_dev.list  When freeing slots in function slot_complete_v3_hw(), it is possible that sas_dev.list is being traversed elsewhere, and it may trigger a NULL pointer exception, such as follows:  ==>cq thread                    ==>scsi_eh_6  ==>scsi_error_handler() ==>sas_eh_handle_sas_errors() ==>sas_scsi_find_task() ==>lldd_abort_task() ==>slot_complete_v3_hw()              ==>hisi_sas_abort_task() ==>hisi_sas_slot_task_free()\t        ==>dereg_device_v3_hw() ==>list_del_init()        \t\t  ==>list_for_each_entry_safe()  [ 7165.434918] sas: Enter sas_scsi_recover_host busy: 32 failed: 32 [ 7165.434926] sas: trying to find task 0x00000000769b5ba5 [ 7165.434927] sas: sas_scsi_find_task: aborting task 0x00000000769b5ba5 [ 7165.434940] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000769b5ba5) aborted [ 7165.434964] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000c9f7aa07) ignored [ 7165.434965] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(00000000e2a1cf01) ignored [ 7165.434968] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [ 7165.434972] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000022d52d93) ignored [ 7165.434975] hisi_sas_v3_hw 0000:b4:02.0: slot complete: task(0000000066a7516c) ignored [ 7165.434976] Mem abort info: [ 7165.434982]   ESR = 0x96000004 [ 7165.434991]   Exception class = DABT (current EL), IL = 32 bits [ 7165.434992]   SET = 0, FnV = 0 [ 7165.434993]   EA = 0, S1PTW = 0 [ 7165.434994] Data abort info: [ 7165.434994]   ISV = 0, ISS = 0x00000004 [ 7165.434995]   CM = 0, WnR = 0 [ 7165.434997] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000f29543f2 [ 7165.434998] [0000000000000000] pgd=0000000000000000 [ 7165.435003] Internal error: Oops: 96000004 [#1] SMP [ 7165.439863] Process scsi_eh_6 (pid: 4109, stack limit = 0x00000000c43818d5) [ 7165.468862] pstate: 00c00009 (nzcv daif +PAN +UAO) [ 7165.473637] pc : dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw] [ 7165.479443] lr : dereg_device_v3_hw+0x2c/0xa8 [hisi_sas_v3_hw] [ 7165.485247] sp : ffff00001d623bc0 [ 7165.488546] x29: ffff00001d623bc0 x28: ffffa027d03b9508 [ 7165.493835] x27: ffff80278ed50af0 x26: ffffa027dd31e0a8 [ 7165.499123] x25: ffffa027d9b27f88 x24: ffffa027d9b209f8 [ 7165.504411] x23: ffffa027c45b0d60 x22: ffff80278ec07c00 [ 7165.509700] x21: 0000000000000008 x20: ffffa027d9b209f8 [ 7165.514988] x19: ffffa027d9b27f88 x18: ffffffffffffffff [ 7165.520276] x17: 0000000000000000 x16: 0000000000000000 [ 7165.525564] x15: ffff0000091d9708 x14: ffff0000093b7dc8 [ 7165.530852] x13: ffff0000093b7a23 x12: 6e7265746e692067 [ 7165.536140] x11: 0000000000000000 x10: 0000000000000bb0 [ 7165.541429] x9 : ffff00001d6238f0 x8 : ffffa027d877af00 [ 7165.546718] x7 : ffffa027d6329600 x6 : ffff7e809f58ca00 [ 7165.552006] x5 : 0000000000001f8a x4 : 000000000000088e [ 7165.557295] x3 : ffffa027d9b27fa8 x2 : 0000000000000000 [ 7165.562583] x1 : 0000000000000000 x0 : 000000003000188e [ 7165.567872] Call trace: [ 7165.570309]  dereg_device_v3_hw+0x68/0xa8 [hisi_sas_v3_hw] [ 7165.575775]  hisi_sas_abort_task+0x248/0x358 [hisi_sas_main] [ 7165.581415]  sas_eh_handle_sas_errors+0x258/0x8e0 [libsas] [ 7165.586876]  sas_scsi_recover_host+0x134/0x458 [libsas] [ 7165.592082]  scsi_error_handler+0xb4/0x488 [ 7165.596163]  kthread+0x134/0x138 [ 7165.599380]  ret_from_fork+0x10/0x18 [ 7165.602940] Code: d5033e9f b9000040 aa0103e2 eb03003f (f9400021) [ 7165.609004] kernel fault(0x1) notification starting on CPU 75 [ 7165.700728] ---[ end trace fc042cbbea224efc ]--- [ 7165.705326] Kernel panic - not syncing: Fatal exception  To fix the issue, grab sas_dev lock when traversing the members of sas_dev.list in dereg_device_v3_hw() and hisi_sas_release_tasks() to avoid concurrency of adding and deleting member. When ---truncated---",
      "cve": "CVE-2023-53627",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53627",
          "value": "CVE-2023-53627",
          "url": "https://scout.docker.com/v/CVE-2023-53627?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53627?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "daccd7420cd4f2e87cd364797e59bffee2ec31136162e00de309e0b655cbfd87",
      "category": "container_scanning",
      "message": "CVE-2023-53628 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: drop gfx_v11_0_cp_ecc_error_irq_funcs  The gfx.cp_ecc_error_irq is retired in gfx11. In gfx_v11_0_hw_fini still use amdgpu_irq_put to disable this interrupt, which caused the call trace in this function.  [  102.873958] Call Trace: [  102.873959]  <TASK> [  102.873961]  gfx_v11_0_hw_fini+0x23/0x1e0 [amdgpu] [  102.874019]  gfx_v11_0_suspend+0xe/0x20 [amdgpu] [  102.874072]  amdgpu_device_ip_suspend_phase2+0x240/0x460 [amdgpu] [  102.874122]  amdgpu_device_ip_suspend+0x3d/0x80 [amdgpu] [  102.874172]  amdgpu_device_pre_asic_reset+0xd9/0x490 [amdgpu] [  102.874223]  amdgpu_device_gpu_recover.cold+0x548/0xce6 [amdgpu] [  102.874321]  amdgpu_debugfs_reset_work+0x4c/0x70 [amdgpu] [  102.874375]  process_one_work+0x21f/0x3f0 [  102.874377]  worker_thread+0x200/0x3e0 [  102.874378]  ? process_one_work+0x3f0/0x3f0 [  102.874379]  kthread+0xfd/0x130 [  102.874380]  ? kthread_complete_and_exit+0x20/0x20 [  102.874381]  ret_from_fork+0x22/0x30  v2: - Handle umc and gfx ras cases in separated patch - Retired the gfx_v11_0_cp_ecc_error_irq_funcs in gfx11  v3: - Improve the subject and code comments - Add judgment on gfx11 in the function of amdgpu_gfx_ras_late_init  v4: - Drop the define of CP_ME1_PIPE_INST_ADDR_INTERVAL and SET_ECC_ME_PIPE_STATE which using in gfx_v11_0_set_cp_ecc_error_state - Check cp_ecc_error_irq.funcs rather than ip version for a more sustainable life  v5: - Simplify judgment conditions",
      "cve": "CVE-2023-53628",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53628",
          "value": "CVE-2023-53628",
          "url": "https://scout.docker.com/v/CVE-2023-53628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7488f257b9989f5dc621a538df5bf6c706a800083e6b491fc41d0e082dbd79ea",
      "category": "container_scanning",
      "message": "CVE-2023-53629 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs: dlm: fix use after free in midcomms commit  While working on processing dlm message in softirq context I experienced the following KASAN use-after-free warning:  [  151.760477] ================================================================== [  151.761803] BUG: KASAN: use-after-free in dlm_midcomms_commit_mhandle+0x19d/0x4b0 [  151.763414] Read of size 4 at addr ffff88811a980c60 by task lock_torture/1347  [  151.765284] CPU: 7 PID: 1347 Comm: lock_torture Not tainted 6.1.0-rc4+ #2828 [  151.766778] Hardware name: Red Hat KVM/RHEL-AV, BIOS 1.16.0-3.module+el8.7.0+16134+e5908aa2 04/01/2014 [  151.768726] Call Trace: [  151.769277]  <TASK> [  151.769748]  dump_stack_lvl+0x5b/0x86 [  151.770556]  print_report+0x180/0x4c8 [  151.771378]  ? kasan_complete_mode_report_info+0x7c/0x1e0 [  151.772241]  ? dlm_midcomms_commit_mhandle+0x19d/0x4b0 [  151.773069]  kasan_report+0x93/0x1a0 [  151.773668]  ? dlm_midcomms_commit_mhandle+0x19d/0x4b0 [  151.774514]  __asan_load4+0x7e/0xa0 [  151.775089]  dlm_midcomms_commit_mhandle+0x19d/0x4b0 [  151.775890]  ? create_message.isra.29.constprop.64+0x57/0xc0 [  151.776770]  send_common+0x19f/0x1b0 [  151.777342]  ? remove_from_waiters+0x60/0x60 [  151.778017]  ? lock_downgrade+0x410/0x410 [  151.778648]  ? __this_cpu_preempt_check+0x13/0x20 [  151.779421]  ? rcu_lockdep_current_cpu_online+0x88/0xc0 [  151.780292]  _convert_lock+0x46/0x150 [  151.780893]  convert_lock+0x7b/0xc0 [  151.781459]  dlm_lock+0x3ac/0x580 [  151.781993]  ? 0xffffffffc0540000 [  151.782522]  ? torture_stop+0x120/0x120 [dlm_locktorture] [  151.783379]  ? dlm_scan_rsbs+0xa70/0xa70 [  151.784003]  ? preempt_count_sub+0xd6/0x130 [  151.784661]  ? is_module_address+0x47/0x70 [  151.785309]  ? torture_stop+0x120/0x120 [dlm_locktorture] [  151.786166]  ? 0xffffffffc0540000 [  151.786693]  ? lockdep_init_map_type+0xc3/0x360 [  151.787414]  ? 0xffffffffc0540000 [  151.787947]  torture_dlm_lock_sync.isra.3+0xe9/0x150 [dlm_locktorture] [  151.789004]  ? torture_stop+0x120/0x120 [dlm_locktorture] [  151.789858]  ? 0xffffffffc0540000 [  151.790392]  ? lock_torture_cleanup+0x20/0x20 [dlm_locktorture] [  151.791347]  ? delay_tsc+0x94/0xc0 [  151.791898]  torture_ex_iter+0xc3/0xea [dlm_locktorture] [  151.792735]  ? torture_start+0x30/0x30 [dlm_locktorture] [  151.793606]  lock_torture+0x177/0x270 [dlm_locktorture] [  151.794448]  ? torture_dlm_lock_sync.isra.3+0x150/0x150 [dlm_locktorture] [  151.795539]  ? lock_torture_stats+0x80/0x80 [dlm_locktorture] [  151.796476]  ? do_raw_spin_lock+0x11e/0x1e0 [  151.797152]  ? mark_held_locks+0x34/0xb0 [  151.797784]  ? _raw_spin_unlock_irqrestore+0x30/0x70 [  151.798581]  ? __kthread_parkme+0x79/0x110 [  151.799246]  ? trace_preempt_on+0x2a/0xf0 [  151.799902]  ? __kthread_parkme+0x79/0x110 [  151.800579]  ? preempt_count_sub+0xd6/0x130 [  151.801271]  ? __kasan_check_read+0x11/0x20 [  151.801963]  ? __kthread_parkme+0xec/0x110 [  151.802630]  ? lock_torture_stats+0x80/0x80 [dlm_locktorture] [  151.803569]  kthread+0x192/0x1d0 [  151.804104]  ? kthread_complete_and_exit+0x30/0x30 [  151.804881]  ret_from_fork+0x1f/0x30 [  151.805480]  </TASK>  [  151.806111] Allocated by task 1347: [  151.806681]  kasan_save_stack+0x26/0x50 [  151.807308]  kasan_set_track+0x25/0x30 [  151.807920]  kasan_save_alloc_info+0x1e/0x30 [  151.808609]  __kasan_slab_alloc+0x63/0x80 [  151.809263]  kmem_cache_alloc+0x1ad/0x830 [  151.809916]  dlm_allocate_mhandle+0x17/0x20 [  151.810590]  dlm_midcomms_get_mhandle+0x96/0x260 [  151.811344]  _create_message+0x95/0x180 [  151.811994]  create_message.isra.29.constprop.64+0x57/0xc0 [  151.812880]  send_common+0x129/0x1b0 [  151.813467]  _convert_lock+0x46/0x150 [  151.814074]  convert_lock+0x7b/0xc0 [  151.814648]  dlm_lock+0x3ac/0x580 [  151.815199]  torture_dlm_lock_sync.isra.3+0xe9/0x150 [dlm_locktorture] [  151.816258]  torture_ex_iter+0xc3/0xea [dlm_locktorture] [  151.817129]  lock_t ---truncated---",
      "cve": "CVE-2023-53629",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53629",
          "value": "CVE-2023-53629",
          "url": "https://scout.docker.com/v/CVE-2023-53629?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53629?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f693f0666e6edb9b13a0dd592438b57cfd57c0f26e1fccbfa7fce30f3237579",
      "category": "container_scanning",
      "message": "CVE-2023-53635 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: conntrack: fix wrong ct->timeout value  (struct nf_conn)->timeout is an interval before the conntrack confirmed.  After confirmed, it becomes a timestamp.  It is observed that timeout of an unconfirmed conntrack: - Set by calling ctnetlink_change_timeout(). As a result, `nfct_time_stamp` was wrongly added to `ct->timeout` twice. - Get by calling ctnetlink_dump_timeout(). As a result, `nfct_time_stamp` was wrongly subtracted.  Call Trace: <TASK> dump_stack_lvl ctnetlink_dump_timeout __ctnetlink_glue_build ctnetlink_glue_build __nfqnl_enqueue_packet nf_queue nf_hook_slow ip_mc_output ? __pfx_ip_finish_output ip_send_skb ? __pfx_dst_output udp_send_skb udp_sendmsg ? __pfx_ip_generic_getfrag sock_sendmsg  Separate the 2 cases in: - Setting `ct->timeout` in __nf_ct_set_timeout(). - Getting `ct->timeout` in ctnetlink_dump_timeout().  Pablo appends:  Update ctnetlink to set up the timeout _after_ the IPS_CONFIRMED flag is set on, otherwise conntrack creation via ctnetlink breaks.  Note that the problem described in this patch occurs since the introduction of the nfnetlink_queue conntrack support, select a sufficiently old Fixes: tag for -stable kernel to pick up this fix.",
      "cve": "CVE-2023-53635",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53635",
          "value": "CVE-2023-53635",
          "url": "https://scout.docker.com/v/CVE-2023-53635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "be42ca78ab98abfb4ca065dcf8ac1bd2c4eafab30dc7a49a0975a4de2fac0e63",
      "category": "container_scanning",
      "message": "CVE-2023-53647 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Drivers: hv: vmbus: Don't dereference ACPI root object handle  Since the commit referenced in the Fixes: tag below the VMBus client driver is walking the ACPI namespace up from the VMBus ACPI device to the ACPI namespace root object trying to find Hyper-V MMIO ranges.  However, if it is not able to find them it ends trying to walk resources of the ACPI namespace root object itself. This object has all-ones handle, which causes a NULL pointer dereference in the ACPI code (from dereferencing this pointer with an offset).  This in turn causes an oops on boot with VMBus host implementations that do not provide Hyper-V MMIO ranges in their VMBus ACPI device or its ancestors. The QEMU VMBus implementation is an example of such implementation.  I guess providing these ranges is optional, since all tested Windows versions seem to be able to use VMBus devices without them.  Fix this by explicitly terminating the lookup at the ACPI namespace root object.  Note that Linux guests under KVM/QEMU do not use the Hyper-V PV interface by default - they only do so if the KVM PV interface is missing or disabled.  Example stack trace of such oops: [ 3.710827] ? __die+0x1f/0x60 [ 3.715030] ? page_fault_oops+0x159/0x460 [ 3.716008] ? exc_page_fault+0x73/0x170 [ 3.716959] ? asm_exc_page_fault+0x22/0x30 [ 3.717957] ? acpi_ns_lookup+0x7a/0x4b0 [ 3.718898] ? acpi_ns_internalize_name+0x79/0xc0 [ 3.720018] acpi_ns_get_node_unlocked+0xb5/0xe0 [ 3.721120] ? acpi_ns_check_object_type+0xfe/0x200 [ 3.722285] ? acpi_rs_convert_aml_to_resource+0x37/0x6e0 [ 3.723559] ? down_timeout+0x3a/0x60 [ 3.724455] ? acpi_ns_get_node+0x3a/0x60 [ 3.725412] acpi_ns_get_node+0x3a/0x60 [ 3.726335] acpi_ns_evaluate+0x1c3/0x2c0 [ 3.727295] acpi_ut_evaluate_object+0x64/0x1b0 [ 3.728400] acpi_rs_get_method_data+0x2b/0x70 [ 3.729476] ? vmbus_platform_driver_probe+0x1d0/0x1d0 [hv_vmbus] [ 3.730940] ? vmbus_platform_driver_probe+0x1d0/0x1d0 [hv_vmbus] [ 3.732411] acpi_walk_resources+0x78/0xd0 [ 3.733398] vmbus_platform_driver_probe+0x9f/0x1d0 [hv_vmbus] [ 3.734802] platform_probe+0x3d/0x90 [ 3.735684] really_probe+0x19b/0x400 [ 3.736570] ? __device_attach_driver+0x100/0x100 [ 3.737697] __driver_probe_device+0x78/0x160 [ 3.738746] driver_probe_device+0x1f/0x90 [ 3.739743] __driver_attach+0xc2/0x1b0 [ 3.740671] bus_for_each_dev+0x70/0xc0 [ 3.741601] bus_add_driver+0x10e/0x210 [ 3.742527] driver_register+0x55/0xf0 [ 3.744412] ? 0xffffffffc039a000 [ 3.745207] hv_acpi_init+0x3c/0x1000 [hv_vmbus]",
      "cve": "CVE-2023-53647",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53647",
          "value": "CVE-2023-53647",
          "url": "https://scout.docker.com/v/CVE-2023-53647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b7f0b7be6488ec93dc56b1fd89825bc406d1185caace5ab6cb245ba46fe6da0e",
      "category": "container_scanning",
      "message": "CVE-2023-53651 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Input: exc3000 - properly stop timer on shutdown  We need to stop the timer on driver unbind or probe failures, otherwise we get UAF/Oops.",
      "cve": "CVE-2023-53651",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53651",
          "value": "CVE-2023-53651",
          "url": "https://scout.docker.com/v/CVE-2023-53651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "19e2616725a2b9c2a739a3d5d86637378757f7f558d4291b43ac31f891f87392",
      "category": "container_scanning",
      "message": "CVE-2023-53657 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: Don't tx before switchdev is fully configured  There is possibility that ice_eswitch_port_start_xmit might be called while some resources are still not allocated which might cause NULL pointer dereference. Fix this by checking if switchdev configuration was finished.",
      "cve": "CVE-2023-53657",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53657",
          "value": "CVE-2023-53657",
          "url": "https://scout.docker.com/v/CVE-2023-53657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1a1157f00d5605e610c3e3a74046d129c996f5bfeed1c5df562fce01b20c449b",
      "category": "container_scanning",
      "message": "CVE-2023-53662 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: fix memory leaks in ext4_fname_{setup_filename,prepare_lookup}  If the filename casefolding fails, we'll be leaking memory from the fscrypt_name struct, namely from the 'crypto_buf.name' member.  Make sure we free it in the error path on both ext4_fname_setup_filename() and ext4_fname_prepare_lookup() functions.",
      "cve": "CVE-2023-53662",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53662",
          "value": "CVE-2023-53662",
          "url": "https://scout.docker.com/v/CVE-2023-53662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "de4fe28bfd2947b8e782bc548fc3f5e361942f8b7ce959be0b921a8c75477874",
      "category": "container_scanning",
      "message": "CVE-2023-53671 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  srcu: Delegate work to the boot cpu if using SRCU_SIZE_SMALL  Commit 994f706872e6 (\"srcu: Make Tree SRCU able to operate without snp_node array\") assumes that cpu 0 is always online.  However, there really are situations when some other CPU is the boot CPU, for example, when booting a kdump kernel with the maxcpus=1 boot parameter.  On PowerPC, the kdump kernel can hang as follows: ... [    1.740036] systemd[1]: Hostname set to <xyz.com> [  243.686240] INFO: task systemd:1 blocked for more than 122 seconds. [  243.686264]       Not tainted 6.1.0-rc1 #1 [  243.686272] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [  243.686281] task:systemd         state:D stack:0     pid:1     ppid:0 flags:0x00042000 [  243.686296] Call Trace: [  243.686301] [c000000016657640] [c000000016657670] 0xc000000016657670 (unreliable) [  243.686317] [c000000016657830] [c00000001001dec0] __switch_to+0x130/0x220 [  243.686333] [c000000016657890] [c000000010f607b8] __schedule+0x1f8/0x580 [  243.686347] [c000000016657940] [c000000010f60bb4] schedule+0x74/0x140 [  243.686361] [c0000000166579b0] [c000000010f699b8] schedule_timeout+0x168/0x1c0 [  243.686374] [c000000016657a80] [c000000010f61de8] __wait_for_common+0x148/0x360 [  243.686387] [c000000016657b20] [c000000010176bb0] __flush_work.isra.0+0x1c0/0x3d0 [  243.686401] [c000000016657bb0] [c0000000105f2768] fsnotify_wait_marks_destroyed+0x28/0x40 [  243.686415] [c000000016657bd0] [c0000000105f21b8] fsnotify_destroy_group+0x68/0x160 [  243.686428] [c000000016657c40] [c0000000105f6500] inotify_release+0x30/0xa0 [  243.686440] [c000000016657cb0] [c0000000105751a8] __fput+0xc8/0x350 [  243.686452] [c000000016657d00] [c00000001017d524] task_work_run+0xe4/0x170 [  243.686464] [c000000016657d50] [c000000010020e94] do_notify_resume+0x134/0x140 [  243.686478] [c000000016657d80] [c00000001002eb18] interrupt_exit_user_prepare_main+0x198/0x270 [  243.686493] [c000000016657de0] [c00000001002ec60] syscall_exit_prepare+0x70/0x180 [  243.686505] [c000000016657e10] [c00000001000bf7c] system_call_vectored_common+0xfc/0x280 [  243.686520] --- interrupt: 3000 at 0x7fffa47d5ba4 [  243.686528] NIP:  00007fffa47d5ba4 LR: 0000000000000000 CTR: 0000000000000000 [  243.686538] REGS: c000000016657e80 TRAP: 3000   Not tainted  (6.1.0-rc1) [  243.686548] MSR:  800000000000d033 <SF,EE,PR,ME,IR,DR,RI,LE>  CR: 42044440  XER: 00000000 [  243.686572] IRQMASK: 0 [  243.686572] GPR00: 0000000000000006 00007ffffa606710 00007fffa48e7200 0000000000000000 [  243.686572] GPR04: 0000000000000002 000000000000000a 0000000000000000 0000000000000001 [  243.686572] GPR08: 000001000c172dd0 0000000000000000 0000000000000000 0000000000000000 [  243.686572] GPR12: 0000000000000000 00007fffa4ff4bc0 0000000000000000 0000000000000000 [  243.686572] GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000 [  243.686572] GPR20: 0000000132dfdc50 000000000000000e 0000000000189375 0000000000000000 [  243.686572] GPR24: 00007ffffa606ae0 0000000000000005 000001000c185490 000001000c172570 [  243.686572] GPR28: 000001000c172990 000001000c184850 000001000c172e00 00007fffa4fedd98 [  243.686683] NIP [00007fffa47d5ba4] 0x7fffa47d5ba4 [  243.686691] LR [0000000000000000] 0x0 [  243.686698] --- interrupt: 3000 [  243.686708] INFO: task kworker/u16:1:24 blocked for more than 122 seconds. [  243.686717]       Not tainted 6.1.0-rc1 #1 [  243.686724] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [  243.686733] task:kworker/u16:1   state:D stack:0     pid:24    ppid:2 flags:0x00000800 [  243.686747] Workqueue: events_unbound fsnotify_mark_destroy_workfn [  243.686758] Call Trace: [  243.686762] [c0000000166736e0] [c00000004fd91000] 0xc00000004fd91000 (unreliable) [  243.686775] [c0000000166738d0] [c00000001001dec0] __switch_to+0x130/0x220 [  243.686788] [c000000016673930] [c000000010f607b8] __schedule+0x1f8/0x ---truncated---",
      "cve": "CVE-2023-53671",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53671",
          "value": "CVE-2023-53671",
          "url": "https://scout.docker.com/v/CVE-2023-53671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "084186ed2f322d655f749db69ef812b8e7d13009944f53d0c4914bdaead99bb1",
      "category": "container_scanning",
      "message": "CVE-2023-53673 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_event: call disconnect callback before deleting conn  In hci_cs_disconnect, we do hci_conn_del even if disconnection failed.  ISO, L2CAP and SCO connections refer to the hci_conn without hci_conn_get, so disconn_cfm must be called so they can clean up their conn, otherwise use-after-free occurs.  ISO: ========================================================== iso_sock_connect:880: sk 00000000eabd6557 iso_connect_cis:356: 70:1a:b8:98:ff:a2 -> 28:3d:c2:4a:7e:da ... iso_conn_add:140: hcon 000000001696f1fd conn 00000000b6251073 hci_dev_put:1487: hci0 orig refcnt 17 __iso_chan_add:214: conn 00000000b6251073 iso_sock_clear_timer:117: sock 00000000eabd6557 state 3 ... hci_rx_work:4085: hci0 Event packet hci_event_packet:7601: hci0: event 0x0f hci_cmd_status_evt:4346: hci0: opcode 0x0406 hci_cs_disconnect:2760: hci0: status 0x0c hci_sent_cmd_data:3107: hci0 opcode 0x0406 hci_conn_del:1151: hci0 hcon 000000001696f1fd handle 2560 hci_conn_unlink:1102: hci0: hcon 000000001696f1fd hci_conn_drop:1451: hcon 00000000d8521aaf orig refcnt 2 hci_chan_list_flush:2780: hcon 000000001696f1fd hci_dev_put:1487: hci0 orig refcnt 21 hci_dev_put:1487: hci0 orig refcnt 20 hci_req_cmd_complete:3978: opcode 0x0406 status 0x0c ... <no iso_* activity on sk/conn> ... iso_sock_sendmsg:1098: sock 00000000dea5e2e0, sk 00000000eabd6557 BUG: kernel NULL pointer dereference, address: 0000000000000668 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014 RIP: 0010:iso_sock_sendmsg (net/bluetooth/iso.c:1112) bluetooth ==========================================================  L2CAP: ================================================================== hci_cmd_status_evt:4359: hci0: opcode 0x0406 hci_cs_disconnect:2760: hci0: status 0x0c hci_sent_cmd_data:3085: hci0 opcode 0x0406 hci_conn_del:1151: hci0 hcon ffff88800c999000 handle 3585 hci_conn_unlink:1102: hci0: hcon ffff88800c999000 hci_chan_list_flush:2780: hcon ffff88800c999000 hci_chan_del:2761: hci0 hcon ffff88800c999000 chan ffff888018ddd280 ... BUG: KASAN: slab-use-after-free in hci_send_acl+0x2d/0x540 [bluetooth] Read of size 8 at addr ffff888018ddd298 by task bluetoothd/1175  CPU: 0 PID: 1175 Comm: bluetoothd Tainted: G            E      6.4.0-rc4+ #2 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x5b/0x90 print_report+0xcf/0x670 ? __virt_addr_valid+0xf8/0x180 ? hci_send_acl+0x2d/0x540 [bluetooth] kasan_report+0xa8/0xe0 ? hci_send_acl+0x2d/0x540 [bluetooth] hci_send_acl+0x2d/0x540 [bluetooth] ? __pfx___lock_acquire+0x10/0x10 l2cap_chan_send+0x1fd/0x1300 [bluetooth] ? l2cap_sock_sendmsg+0xf2/0x170 [bluetooth] ? __pfx_l2cap_chan_send+0x10/0x10 [bluetooth] ? lock_release+0x1d5/0x3c0 ? mark_held_locks+0x1a/0x90 l2cap_sock_sendmsg+0x100/0x170 [bluetooth] sock_write_iter+0x275/0x280 ? __pfx_sock_write_iter+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 do_iter_readv_writev+0x176/0x220 ? __pfx_do_iter_readv_writev+0x10/0x10 ? find_held_lock+0x83/0xa0 ? selinux_file_permission+0x13e/0x210 do_iter_write+0xda/0x340 vfs_writev+0x1b4/0x400 ? __pfx_vfs_writev+0x10/0x10 ? __seccomp_filter+0x112/0x750 ? populate_seccomp_data+0x182/0x220 ? __fget_light+0xdf/0x100 ? do_writev+0x19d/0x210 do_writev+0x19d/0x210 ? __pfx_do_writev+0x10/0x10 ? mark_held_locks+0x1a/0x90 do_syscall_64+0x60/0x90 ? lockdep_hardirqs_on_prepare+0x149/0x210 ? do_syscall_64+0x6c/0x90 ? lockdep_hardirqs_on_prepare+0x149/0x210 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7ff45cb23e64 Code: 15 d1 1f 0d 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 80 3d 9d a7 0d 00 00 74 13 b8 14 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 48 83 ec 28 89 54 24 1c 48 89 RSP: 002b:00007fff21ae09b8 EFLAGS: 00000202 ORIG_RAX: 0000000000000014 RAX: ffffffffffffffda RBX: ---truncated---",
      "cve": "CVE-2023-53673",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53673",
          "value": "CVE-2023-53673",
          "url": "https://scout.docker.com/v/CVE-2023-53673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b441bef4aa721f2d51e2286c747cf211d7f6c687840359fadcf524f23919dd70",
      "category": "container_scanning",
      "message": "CVE-2023-53681 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bcache: Fix __bch_btree_node_alloc to make the failure behavior consistent  In some specific situations, the return value of __bch_btree_node_alloc may be NULL. This may lead to a potential NULL pointer dereference in caller function like a calling chain : btree_split->bch_btree_node_alloc->__bch_btree_node_alloc.  Fix it by initializing the return value in __bch_btree_node_alloc.",
      "cve": "CVE-2023-53681",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53681",
          "value": "CVE-2023-53681",
          "url": "https://scout.docker.com/v/CVE-2023-53681?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53681?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "538ee4a808fd4f168c34a7d8365e673c62db9eae9ee9f779c32d633a42545022",
      "category": "container_scanning",
      "message": "CVE-2023-53682 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hwmon: (xgene) Fix ioremap and memremap leak  Smatch reports:  drivers/hwmon/xgene-hwmon.c:757 xgene_hwmon_probe() warn: 'ctx->pcc_comm_addr' from ioremap() not released on line: 757.  This is because in drivers/hwmon/xgene-hwmon.c:701 xgene_hwmon_probe(), ioremap and memremap is not released, which may cause a leak.  To fix this, ioremap and memremap is modified to devm_ioremap and devm_memremap.  [groeck: Fixed formatting and subject]",
      "cve": "CVE-2023-53682",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53682",
          "value": "CVE-2023-53682",
          "url": "https://scout.docker.com/v/CVE-2023-53682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9c91d6295676dcb2565d25b7e9e2010a2777d9896b1de2a38d9cf179ed9ef26a",
      "category": "container_scanning",
      "message": "CVE-2023-53685 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tun: Fix memory leak for detached NAPI queue.  syzkaller reported [0] memory leaks of sk and skb related to the TUN device with no repro, but we can reproduce it easily with:  struct ifreq ifr = {} int fd_tun, fd_tmp; char buf[4] = {};  fd_tun = openat(AT_FDCWD, \"/dev/net/tun\", O_WRONLY, 0); ifr.ifr_flags = IFF_TUN | IFF_NAPI | IFF_MULTI_QUEUE; ioctl(fd_tun, TUNSETIFF, &ifr);  ifr.ifr_flags = IFF_DETACH_QUEUE; ioctl(fd_tun, TUNSETQUEUE, &ifr);  fd_tmp = socket(AF_PACKET, SOCK_PACKET, 0); ifr.ifr_flags = IFF_UP; ioctl(fd_tmp, SIOCSIFFLAGS, &ifr);  write(fd_tun, buf, sizeof(buf)); close(fd_tun);  If we enable NAPI and multi-queue on a TUN device, we can put skb into tfile->sk.sk_write_queue after the queue is detached.  We should prevent it by checking tfile->detached before queuing skb.  Note this must be done under tfile->sk.sk_write_queue.lock because write() and ioctl(IFF_DETACH_QUEUE) can run concurrently.  Otherwise, there would be a small race window:  write()                             ioctl(IFF_DETACH_QUEUE) `- tun_get_user                     `- __tun_detach |- if (tfile->detached)             |- tun_disable_queue |  `-> false                        |  `- tfile->detached = tun |                                   `- tun_queue_purge |- spin_lock_bh(&queue->lock) `- __skb_queue_tail(queue, skb)  Another solution is to call tun_queue_purge() when closing and reattaching the detached queue, but it could paper over another problems.  Also, we do the same kind of test for IFF_NAPI_FRAGS.  [0]: unreferenced object 0xffff88801edbc800 (size 2048): comm \"syz-executor.1\", pid 33269, jiffies 4295743834 (age 18.756s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00  ...@............ backtrace: [<000000008c16ea3d>] __do_kmalloc_node mm/slab_common.c:965 [inline] [<000000008c16ea3d>] __kmalloc+0x4a/0x130 mm/slab_common.c:979 [<000000003addde56>] kmalloc include/linux/slab.h:563 [inline] [<000000003addde56>] sk_prot_alloc+0xef/0x1b0 net/core/sock.c:2035 [<000000003e20621f>] sk_alloc+0x36/0x2f0 net/core/sock.c:2088 [<0000000028e43843>] tun_chr_open+0x3d/0x190 drivers/net/tun.c:3438 [<000000001b0f1f28>] misc_open+0x1a6/0x1f0 drivers/char/misc.c:165 [<000000004376f706>] chrdev_open+0x111/0x300 fs/char_dev.c:414 [<00000000614d379f>] do_dentry_open+0x2f9/0x750 fs/open.c:920 [<000000008eb24774>] do_open fs/namei.c:3636 [inline] [<000000008eb24774>] path_openat+0x143f/0x1a30 fs/namei.c:3791 [<00000000955077b5>] do_filp_open+0xce/0x1c0 fs/namei.c:3818 [<00000000b78973b0>] do_sys_openat2+0xf0/0x260 fs/open.c:1356 [<00000000057be699>] do_sys_open fs/open.c:1372 [inline] [<00000000057be699>] __do_sys_openat fs/open.c:1388 [inline] [<00000000057be699>] __se_sys_openat fs/open.c:1383 [inline] [<00000000057be699>] __x64_sys_openat+0x83/0xf0 fs/open.c:1383 [<00000000a7d2182d>] do_syscall_x64 arch/x86/entry/common.c:50 [inline] [<00000000a7d2182d>] do_syscall_64+0x3c/0x90 arch/x86/entry/common.c:80 [<000000004cc4e8c4>] entry_SYSCALL_64_after_hwframe+0x72/0xdc  unreferenced object 0xffff88802f671700 (size 240): comm \"syz-executor.1\", pid 33269, jiffies 4295743854 (age 18.736s) hex dump (first 32 bytes): 68 c9 db 1e 80 88 ff ff 68 c9 db 1e 80 88 ff ff  h.......h....... 00 c0 7b 2f 80 88 ff ff 00 c8 db 1e 80 88 ff ff  ..{/............ backtrace: [<00000000e9d9fdb6>] __alloc_skb+0x223/0x250 net/core/skbuff.c:644 [<000000002c3e4e0b>] alloc_skb include/linux/skbuff.h:1288 [inline] [<000000002c3e4e0b>] alloc_skb_with_frags+0x6f/0x350 net/core/skbuff.c:6378 [<00000000825f98d7>] sock_alloc_send_pskb+0x3ac/0x3e0 net/core/sock.c:2729 [<00000000e9eb3df3>] tun_alloc_skb drivers/net/tun.c:1529 [inline] [< ---truncated---",
      "cve": "CVE-2023-53685",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53685",
          "value": "CVE-2023-53685",
          "url": "https://scout.docker.com/v/CVE-2023-53685?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53685?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1e1d261bda60def9b3f1580c74d34de68efb38e9376d4c586793d2a962004d80",
      "category": "container_scanning",
      "message": "CVE-2023-53694 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: ftrace: Fixup panic by disabling preemption  In RISCV, we must use an AUIPC + JALR pair to encode an immediate, forming a jump that jumps to an address over 4K. This may cause errors if we want to enable kernel preemption and remove dependency from patching code with stop_machine(). For example, if a task was switched out on auipc. And, if we changed the ftrace function before it was switched back, then it would jump to an address that has updated 11:0 bits mixing with previous XLEN:12 part.  p: patched area performed by dynamic ftrace ftrace_prologue: p|      REG_S   ra, -SZREG(sp) p|      auipc   ra, 0x? ------------> preempted ... change ftrace function ... p|      jalr    -?(ra) <------------- switched back p|      REG_L   ra, -SZREG(sp) func: xxx ret",
      "cve": "CVE-2023-53694",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53694",
          "value": "CVE-2023-53694",
          "url": "https://scout.docker.com/v/CVE-2023-53694?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53694?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a6c26c6e753bd4549e3a0537c77c36e9e31236bd43d300db5555459843ab0d1",
      "category": "container_scanning",
      "message": "CVE-2023-53702 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/crypto: use vector instructions only if available for ChaCha20  Commit 349d03ffd5f6 (\"crypto: s390 - add crypto library interface for ChaCha20\") added a library interface to the s390 specific ChaCha20 implementation. However no check was added to verify if the required facilities are installed before branching into the assembler code.  If compiled into the kernel, this will lead to the following crash, if vector instructions are not available:  data exception: 0007 ilc:3 [#1] SMP Modules linked in: CPU: 0 PID: 1 Comm: swapper/0 Not tainted 6.3.0-rc7+ #11 Hardware name: IBM 3931 A01 704 (KVM/Linux) Krnl PSW : 0704e00180000000 000000001857277a (chacha20_vx+0x32/0x818) R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3 Krnl GPRS: 0000037f0000000a ffffffffffffff60 000000008184b000 0000000019f5c8e6 0000000000000109 0000037fffb13c58 0000037fffb13c78 0000000019bb1780 0000037fffb13c58 0000000019f5c8e6 000000008184b000 0000000000000109 00000000802d8000 0000000000000109 0000000018571ebc 0000037fffb13718 Krnl Code: 000000001857276a: c07000b1f80b        larl %r7,0000000019bb1780 0000000018572770: a708000a            lhi     %r0,10 #0000000018572774: e78950000c36        vlm     %v24,%v25,0(%r5),0 >000000001857277a: e7a060000806        vl      %v26,0(%r6),0 0000000018572780: e7bf70004c36        vlm     %v27,%v31,0(%r7),4 0000000018572786: e70b00000456        vlr     %v0,%v27 000000001857278c: e71800000456        vlr     %v1,%v24 0000000018572792: e74b00000456        vlr     %v4,%v27 Call Trace: [<000000001857277a>] chacha20_vx+0x32/0x818 Last Breaking-Event-Address: [<0000000018571eb6>] chacha20_crypt_s390.constprop.0+0x6e/0xd8 ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b  Fix this by adding a missing MACHINE_HAS_VX check.  [agordeev@linux.ibm.com: remove duplicates in commit message]",
      "cve": "CVE-2023-53702",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53702",
          "value": "CVE-2023-53702",
          "url": "https://scout.docker.com/v/CVE-2023-53702?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53702?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dd8637616da94cd001ad13cd40d2507f168d41ca972c79d0458f74ce95fb1158",
      "category": "container_scanning",
      "message": "CVE-2023-53707 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix integer overflow in amdgpu_cs_pass1  The type of size is unsigned int, if size is 0x40000000, there will be an integer overflow, size will be zero after size *= sizeof(uint32_t), will cause uninitialized memory to be referenced later.",
      "cve": "CVE-2023-53707",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53707",
          "value": "CVE-2023-53707",
          "url": "https://scout.docker.com/v/CVE-2023-53707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "64b1be4d6d35d7400fc5a2b4d94aa5edf63a53b433ab7f8feaeed14aeeaf154c",
      "category": "container_scanning",
      "message": "CVE-2023-53714 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/stm: ltdc: fix late dereference check  In ltdc_crtc_set_crc_source(), struct drm_crtc was dereferenced in a container_of() before the pointer check. This could cause a kernel panic.  Fix this smatch warning: drivers/gpu/drm/stm/ltdc.c:1124 ltdc_crtc_set_crc_source() warn: variable dereferenced before check 'crtc' (see line 1119)",
      "cve": "CVE-2023-53714",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53714",
          "value": "CVE-2023-53714",
          "url": "https://scout.docker.com/v/CVE-2023-53714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0aa6f231afed3b1589fff68e82d7febfc89a1ccc89a75406ffb9040d5c81df6d",
      "category": "container_scanning",
      "message": "CVE-2023-53721 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Fix a NULL pointer dereference in ath12k_mac_op_hw_scan()  In ath12k_mac_op_hw_scan(), the return value of kzalloc() is directly used in memcpy(), which may lead to a NULL pointer dereference on failure of kzalloc().  Fix this bug by adding a check of arg.extraie.ptr.  Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0-03427-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1.15378.4",
      "cve": "CVE-2023-53721",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53721",
          "value": "CVE-2023-53721",
          "url": "https://scout.docker.com/v/CVE-2023-53721?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53721?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aaaa9d1f14bb777de9ae83832158ae396689f53cd23ce5678d5bc97c937019b0",
      "category": "container_scanning",
      "message": "CVE-2023-53733 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: sched: cls_u32: Undo tcf_bind_filter if u32_replace_hw_knode  When u32_replace_hw_knode fails, we need to undo the tcf_bind_filter operation done at u32_set_parms.",
      "cve": "CVE-2023-53733",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53733",
          "value": "CVE-2023-53733",
          "url": "https://scout.docker.com/v/CVE-2023-53733?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53733?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1b119e3e23a44953cba4f7fb429c386082d0c53fe43cb158800f40d984200739",
      "category": "container_scanning",
      "message": "CVE-2023-6597 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue was found in the CPython `tempfile.TemporaryDirectory` class affecting versions 3.12.1, 3.11.7, 3.10.13, 3.9.18, and 3.8.18 and prior.  The tempfile.TemporaryDirectory class would dereference symlinks during cleanup of permissions-related errors. This means users which can run privileged programs are potentially able to modify permissions of files referenced by symlinks in some circumstances.",
      "cve": "CVE-2023-6597",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-6597",
          "value": "CVE-2023-6597",
          "url": "https://scout.docker.com/v/CVE-2023-6597?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-6597?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "514df6a799468ea8b46acfde72013a1c300e4cf151bc7ceb62b6420b5f7eb8cd",
      "category": "container_scanning",
      "message": "CVE-2024-0450 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue was found in the CPython `zipfile` module affecting versions 3.12.1, 3.11.7, 3.10.13, 3.9.18, and 3.8.18 and prior.  The zipfile module is vulnerable to quoted-overlap zip-bombs which exploit the zip format to create a zip-bomb with a high compression ratio. The fixed versions of CPython makes the zipfile module reject zip archives which overlap entries in the archive.",
      "cve": "CVE-2024-0450",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-0450",
          "value": "CVE-2024-0450",
          "url": "https://scout.docker.com/v/CVE-2024-0450?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-0450?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "50697f8f5d12129072d305460946a54f2cdfc547df838a8d9f5538af5fe73164",
      "category": "container_scanning",
      "message": "CVE-2024-11168 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.",
      "cve": "CVE-2024-11168",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-11168",
          "value": "CVE-2024-11168",
          "url": "https://scout.docker.com/v/CVE-2024-11168?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-11168?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3b311a4071d1fca73d321a725726401d10306e18740ab46c68e7691cf1813fe",
      "category": "container_scanning",
      "message": "CVE-2024-26648 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()  In edp_setup_replay(), 'struct dc *dc' & 'struct dmub_replay *replay' was dereferenced before the pointer 'link' & 'replay' NULL check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",
      "cve": "CVE-2024-26648",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26648",
          "value": "CVE-2024-26648",
          "url": "https://scout.docker.com/v/CVE-2024-26648?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26648?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "156e27e8c55ffca0983bbb4df1fa7e1eedf43565ef9ca3e3b944c45f16b40787",
      "category": "container_scanning",
      "message": "CVE-2024-26662 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()'  'panel_cntl' structure used to control the display panel could be null, dereferencing it could lead to a null pointer access.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250)",
      "cve": "CVE-2024-26662",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26662",
          "value": "CVE-2024-26662",
          "url": "https://scout.docker.com/v/CVE-2024-26662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9512d285028e9503b412a3a94c4d2db0082a276cb3ac5ed2d33359aa8fd21306",
      "category": "container_scanning",
      "message": "CVE-2024-26672 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'  Fixes the below:  drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)  357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev, enum amdgpu_mca_error_type type, 358                                  int idx, struct mca_bank_entry *entry) 359 { 360         const struct amdgpu_mca_smu_funcs *mca_funcs = adev->mca.mca_funcs; 361         int count; 362 363         switch (type) { 364         case AMDGPU_MCA_ERROR_TYPE_UE: 365                 count = mca_funcs->max_ue_count;  mca_funcs is dereferenced here.  366                 break; 367         case AMDGPU_MCA_ERROR_TYPE_CE: 368                 count = mca_funcs->max_ce_count;  mca_funcs is dereferenced here.  369                 break; 370         default: 371                 return -EINVAL; 372         } 373 374         if (idx >= count) 375                 return -EINVAL; 376 377         if (mca_funcs && mca_funcs->mca_get_mca_entry) ^^^^^^^^^  Checked too late!",
      "cve": "CVE-2024-26672",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26672",
          "value": "CVE-2024-26672",
          "url": "https://scout.docker.com/v/CVE-2024-26672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1beff54df4ac186f1aa5d03eecc42b909f90af3ea1d6fa17a936b82305cfe4bc",
      "category": "container_scanning",
      "message": "CVE-2024-26757 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md: Don't ignore read-only array in md_check_recovery()  Usually if the array is not read-write, md_check_recovery() won't register new sync_thread in the first place. And if the array is read-write and sync_thread is registered, md_set_readonly() will unregister sync_thread before setting the array read-only. md/raid follow this behavior hence there is no problem.  After commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), following hang can be triggered by test shell/integrity-caching.sh:  1) array is read-only. dm-raid update super block: rs_update_sbs ro = mddev->ro mddev->ro = 0 -> set array read-write md_update_sb  2) register new sync thread concurrently.  3) dm-raid set array back to read-only: rs_update_sbs mddev->ro = ro  4) stop the array: raid_dtr md_stop stop_sync_thread set_bit(MD_RECOVERY_INTR, &mddev->recovery); md_wakeup_thread_directly(mddev->sync_thread); wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))  5) sync thread done: md_do_sync set_bit(MD_RECOVERY_DONE, &mddev->recovery); md_wakeup_thread(mddev->thread);  6) daemon thread can't unregister sync thread: md_check_recovery if (!md_is_rdwr(mddev) && !test_bit(MD_RECOVERY_NEEDED, &mddev->recovery)) return; -> -> MD_RECOVERY_RUNNING can't be cleared, hence step 4 hang;  The root cause is that dm-raid manipulate 'mddev->ro' by itself, however, dm-raid really should stop sync thread before setting the array read-only. Unfortunately, I need to read more code before I can refacter the handler of 'mddev->ro' in dm-raid, hence let's fix the problem the easy way for now to prevent dm-raid regression.",
      "cve": "CVE-2024-26757",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26757",
          "value": "CVE-2024-26757",
          "url": "https://scout.docker.com/v/CVE-2024-26757?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26757?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b05b6b1b73bc621fcfa7ab7198984c83fd91b44014776f27d9bbc58c9f5c6b14",
      "category": "container_scanning",
      "message": "CVE-2024-26758 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md: Don't ignore suspended array in md_check_recovery()  mddev_suspend() never stop sync_thread, hence it doesn't make sense to ignore suspended array in md_check_recovery(), which might cause sync_thread can't be unregistered.  After commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), following hang can be triggered by test shell/integrity-caching.sh:  1) suspend the array: raid_postsuspend mddev_suspend  2) stop the array: raid_dtr md_stop __md_stop_writes stop_sync_thread set_bit(MD_RECOVERY_INTR, &mddev->recovery); md_wakeup_thread_directly(mddev->sync_thread); wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))  3) sync thread done: md_do_sync set_bit(MD_RECOVERY_DONE, &mddev->recovery); md_wakeup_thread(mddev->thread);  4) daemon thread can't unregister sync thread: md_check_recovery if (mddev->suspended) return; -> return directly md_read_sync_thread clear_bit(MD_RECOVERY_RUNNING, &mddev->recovery); -> MD_RECOVERY_RUNNING can't be cleared, hence step 2 hang;  This problem is not just related to dm-raid, fix it by ignoring suspended array in md_check_recovery(). And follow up patches will improve dm-raid better to frozen sync thread during suspend.",
      "cve": "CVE-2024-26758",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26758",
          "value": "CVE-2024-26758",
          "url": "https://scout.docker.com/v/CVE-2024-26758?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26758?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c11804d6e798a983608a23a64e11351d74e267b64e674af1a6c536c88b321e48",
      "category": "container_scanning",
      "message": "CVE-2024-27005 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  interconnect: Don't access req_list while it's being manipulated  The icc_lock mutex was split into separate icc_lock and icc_bw_lock mutexes in [1] to avoid lockdep splats. However, this didn't adequately protect access to icc_node::req_list.  The icc_set_bw() function will eventually iterate over req_list while only holding icc_bw_lock, but req_list can be modified while only holding icc_lock. This causes races between icc_set_bw(), of_icc_get(), and icc_put().  Example A:  CPU0                               CPU1 ----                               ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock); icc_put(path_b) mutex_lock(&icc_lock); aggregate_requests() hlist_for_each_entry(r, ... hlist_del(... <r = invalid pointer>  Example B:  CPU0                               CPU1 ----                               ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock); path_b = of_icc_get() of_icc_get_by_index() mutex_lock(&icc_lock); path_find() path_init() aggregate_requests() hlist_for_each_entry(r, ... hlist_add_head(... <r = invalid pointer>  Fix this by ensuring icc_bw_lock is always held before manipulating icc_node::req_list. The additional places icc_bw_lock is held don't perform any memory allocations, so we should still be safe from the original lockdep splats that motivated the separate locks.  [1] commit af42269c3523 (\"interconnect: Fix locking for runpm vs reclaim\")",
      "cve": "CVE-2024-27005",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27005",
          "value": "CVE-2024-27005",
          "url": "https://scout.docker.com/v/CVE-2024-27005?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27005?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8818bef56192758c0d5e60aed722c863a7fe14a4b5687772c3e63f80f867f3bc",
      "category": "container_scanning",
      "message": "CVE-2024-27032 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to avoid potential panic during recovery  During recovery, if FAULT_BLOCK is on, it is possible that f2fs_reserve_new_block() will return -ENOSPC during recovery, then it may trigger panic.  Also, if fault injection rate is 1 and only FAULT_BLOCK fault type is on, it may encounter deadloop in loop of block reservation.  Let's change as below to fix these issues: - remove bug_on() to avoid panic. - limit the loop count of block reservation to avoid potential deadloop.",
      "cve": "CVE-2024-27032",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27032",
          "value": "CVE-2024-27032",
          "url": "https://scout.docker.com/v/CVE-2024-27032?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27032?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c581430812ea2a8edadfd1193d5ccfb17a288036291e64d411252b3f1f09ef42",
      "category": "container_scanning",
      "message": "CVE-2024-27041 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: fix NULL checks for adev->dm.dc in amdgpu_dm_fini()  Since 'adev->dm.dc' in amdgpu_dm_fini() might turn out to be NULL before the call to dc_enable_dmub_notifications(), check beforehand to ensure there will not be a possible NULL-ptr-deref there.  Also, since commit 1e88eb1b2c25 (\"drm/amd/display: Drop CONFIG_DRM_AMD_DC_HDCP\") there are two separate checks for NULL in 'adev->dm.dc' before dc_deinit_callbacks() and dc_dmub_srv_destroy(). Clean up by combining them all under one 'if'.  Found by Linux Verification Center (linuxtesting.org) with static analysis tool SVACE.",
      "cve": "CVE-2024-27041",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27041",
          "value": "CVE-2024-27041",
          "url": "https://scout.docker.com/v/CVE-2024-27041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "292c2a9e955fc7703d05a7affa50da92fc631726e7dccee7ab34f758dae31071",
      "category": "container_scanning",
      "message": "CVE-2024-27062 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nouveau: lock the client object tree.  It appears the client object tree has no locking unless I've missed something else. Fix races around adding/removing client objects, mostly vram bar mappings.  4562.099306] general protection fault, probably for non-canonical address 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTI [ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27 [ 4562.099324] Hardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021 [ 4562.099330] RIP: 0010:nvkm_object_search+0x1d/0x70 [nouveau] [ 4562.099503] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 <48> 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fe [ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206 [ 4562.099512] RAX: 6677ed422bceb814 RBX: ffff98108791f400 RCX: ffff9810f26b8f58 [ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400 [ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000 [ 4562.099521] R10: ffffa94cc420bc48 R11: 0000000000000001 R12: ffff9810f02a7cc0 [ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007 [ 4562.099528] FS:  00007f629c5017c0(0000) GS:ffff98142c700000(0000) knlGS:0000000000000000 [ 4562.099534] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 4562.099536] CR2: 00007f629a882000 CR3: 000000017019e004 CR4: 00000000003706f0 [ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 4562.099542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 4562.099544] Call Trace: [ 4562.099555]  <TASK> [ 4562.099573]  ? die_addr+0x36/0x90 [ 4562.099583]  ? exc_general_protection+0x246/0x4a0 [ 4562.099593]  ? asm_exc_general_protection+0x26/0x30 [ 4562.099600]  ? nvkm_object_search+0x1d/0x70 [nouveau] [ 4562.099730]  nvkm_ioctl+0xa1/0x250 [nouveau] [ 4562.099861]  nvif_object_map_handle+0xc8/0x180 [nouveau] [ 4562.099986]  nouveau_ttm_io_mem_reserve+0x122/0x270 [nouveau] [ 4562.100156]  ? dma_resv_test_signaled+0x26/0xb0 [ 4562.100163]  ttm_bo_vm_fault_reserved+0x97/0x3c0 [ttm] [ 4562.100182]  ? __mutex_unlock_slowpath+0x2a/0x270 [ 4562.100189]  nouveau_ttm_fault+0x69/0xb0 [nouveau] [ 4562.100356]  __do_fault+0x32/0x150 [ 4562.100362]  do_fault+0x7c/0x560 [ 4562.100369]  __handle_mm_fault+0x800/0xc10 [ 4562.100382]  handle_mm_fault+0x17c/0x3e0 [ 4562.100388]  do_user_addr_fault+0x208/0x860 [ 4562.100395]  exc_page_fault+0x7f/0x200 [ 4562.100402]  asm_exc_page_fault+0x26/0x30 [ 4562.100412] RIP: 0033:0x9b9870 [ 4562.100419] Code: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 <44> 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 44 89 32 e9 e7 [ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246 [ 4562.100426] RAX: 0000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000000 [ 4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066 [ 4562.100432] RBP: 00007fff9ba2e570 R08: 0000000000000000 R09: 0000000123ddf000 [ 4562.100434] R10: 0000000000000001 R11: 0000000000000246 R12: 000000007fffffff [ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 4562.100446]  </TASK> [ 4562.100448] Modules linked in: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac80211 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink ---truncated---",
      "cve": "CVE-2024-27062",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27062",
          "value": "CVE-2024-27062",
          "url": "https://scout.docker.com/v/CVE-2024-27062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "923bd6720c2840258ecbef96afb10c2a56c0e3e6b210da02a72db42add4f0a98",
      "category": "container_scanning",
      "message": "CVE-2024-27400 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: once more fix the call oder in amdgpu_ttm_move() v2  This reverts drm/amdgpu: fix ftrace event amdgpu_bo_move always move on same heap. The basic problem here is that after the move the old location is simply not available any more.  Some fixes were suggested, but essentially we should call the move notification before actually moving things because only this way we have the correct order for DMA-buf and VM move notifications as well.  Also rework the statistic handling so that we don't update the eviction counter before the move.  v2: add missing NULL check",
      "cve": "CVE-2024-27400",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27400",
          "value": "CVE-2024-27400",
          "url": "https://scout.docker.com/v/CVE-2024-27400?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27400?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8140a702fc8e676e52c7227d6d08001d1b6e8941b838a770caf40c2d5eb3a83f",
      "category": "container_scanning",
      "message": "CVE-2024-35195 on ubuntu/python-pip@22.0.2+dfsg-1ubuntu0.7",
      "description": "Requests is a HTTP library. Prior to 2.32.0, when making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same host will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool. This vulnerability is fixed in 2.32.0.",
      "cve": "CVE-2024-35195",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python-pip@22.0.2%2Bdfsg-1ubuntu0.7?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "22.0.2+dfsg-1ubuntu0.7"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35195",
          "value": "CVE-2024-35195",
          "url": "https://scout.docker.com/v/CVE-2024-35195?s=ubuntu&n=python-pip&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35195?s=ubuntu&n=python-pip&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3de14fa48baf7aab10ece2e3beb60850ac0da1abc74b6530cae8b48984e2f47",
      "category": "container_scanning",
      "message": "CVE-2024-35843 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/vt-d: Use device rbtree in iopf reporting path  The existing I/O page fault handler currently locates the PCI device by calling pci_get_domain_bus_and_slot(). This function searches the list of all PCI devices until the desired device is found. To improve lookup efficiency, replace it with device_rbtree_find() to search the device within the probed device rbtree.  The I/O page fault is initiated by the device, which does not have any synchronization mechanism with the software to ensure that the device stays in the probed device tree. Theoretically, a device could be released by the IOMMU subsystem after device_rbtree_find() and before iopf_get_dev_fault_param(), which would cause a use-after-free problem.  Add a mutex to synchronize the I/O page fault reporting path and the IOMMU release device path. This lock doesn't introduce any performance overhead, as the conflict between I/O page fault reporting and device releasing is very rare.",
      "cve": "CVE-2024-35843",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35843",
          "value": "CVE-2024-35843",
          "url": "https://scout.docker.com/v/CVE-2024-35843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "48818709054732a6498c5feab06ea4cfce2210f0a0bab44e95db5d584264538a",
      "category": "container_scanning",
      "message": "CVE-2024-35865 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential UAF in smb2_is_valid_oplock_break()  Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "cve": "CVE-2024-35865",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35865",
          "value": "CVE-2024-35865",
          "url": "https://scout.docker.com/v/CVE-2024-35865?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35865?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9c4bb0a36156a379ca5c3859b05728c6d127661a2b077c793c5135a9b157028c",
      "category": "container_scanning",
      "message": "CVE-2024-35878 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  of: module: prevent NULL pointer dereference in vsnprintf()  In of_modalias(), we can get passed the str and len parameters which would cause a kernel oops in vsnprintf() since it only allows passing a NULL ptr when the length is also 0. Also, we need to filter out the negative values of the len parameter as these will result in a really huge buffer since snprintf() takes size_t parameter while ours is ssize_t...  Found by Linux Verification Center (linuxtesting.org) with the Svace static analysis tool.",
      "cve": "CVE-2024-35878",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35878",
          "value": "CVE-2024-35878",
          "url": "https://scout.docker.com/v/CVE-2024-35878?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35878?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "edb4933f0f679c59d315baa9fbe869131dc11c52078f0b386591b751b40d7d92",
      "category": "container_scanning",
      "message": "CVE-2024-35949 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: make sure that WRITTEN is set on all metadata blocks  We previously would call btrfs_check_leaf() if we had the check integrity code enabled, which meant that we could only run the extended leaf checks if we had WRITTEN set on the header flags.  This leaves a gap in our checking, because we could end up with corruption on disk where WRITTEN isn't set on the leaf, and then the extended leaf checks don't get run which we rely on to validate all of the item pointers to make sure we don't access memory outside of the extent buffer.  However, since 732fab95abe2 (\"btrfs: check-integrity: remove CONFIG_BTRFS_FS_CHECK_INTEGRITY option\") we no longer call btrfs_check_leaf() from btrfs_mark_buffer_dirty(), which means we only ever call it on blocks that are being written out, and thus have WRITTEN set, or that are being read in, which should have WRITTEN set.  Add checks to make sure we have WRITTEN set appropriately, and then make sure __btrfs_check_leaf() always does the item checking.  This will protect us from file systems that have been corrupted and no longer have WRITTEN set on some of the blocks.  This was hit on a crafted image tweaking the WRITTEN bit and reported by KASAN as out-of-bound access in the eb accessors. The example is a dir item at the end of an eb.  [2.042] BTRFS warning (device loop1): bad eb member start: ptr 0x3fff start 30572544 member offset 16410 size 2 [2.040] general protection fault, probably for non-canonical address 0xe0009d1000000003: 0000 [#1] PREEMPT SMP KASAN NOPTI [2.537] KASAN: maybe wild-memory-access in range [0x0005088000000018-0x000508800000001f] [2.729] CPU: 0 PID: 2587 Comm: mount Not tainted 6.8.2 #1 [2.729] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 [2.621] RIP: 0010:btrfs_get_16+0x34b/0x6d0 [2.621] RSP: 0018:ffff88810871fab8 EFLAGS: 00000206 [2.621] RAX: 0000a11000000003 RBX: ffff888104ff8720 RCX: ffff88811b2288c0 [2.621] RDX: dffffc0000000000 RSI: ffffffff81dd8aca RDI: ffff88810871f748 [2.621] RBP: 000000000000401a R08: 0000000000000001 R09: ffffed10210e3ee9 [2.621] R10: ffff88810871f74f R11: 205d323430333737 R12: 000000000000001a [2.621] R13: 000508800000001a R14: 1ffff110210e3f5d R15: ffffffff850011e8 [2.621] FS:  00007f56ea275840(0000) GS:ffff88811b200000(0000) knlGS:0000000000000000 [2.621] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [2.621] CR2: 00007febd13b75c0 CR3: 000000010bb50000 CR4: 00000000000006f0 [2.621] Call Trace: [2.621]  <TASK> [2.621]  ? show_regs+0x74/0x80 [2.621]  ? die_addr+0x46/0xc0 [2.621]  ? exc_general_protection+0x161/0x2a0 [2.621]  ? asm_exc_general_protection+0x26/0x30 [2.621]  ? btrfs_get_16+0x33a/0x6d0 [2.621]  ? btrfs_get_16+0x34b/0x6d0 [2.621]  ? btrfs_get_16+0x33a/0x6d0 [2.621]  ? __pfx_btrfs_get_16+0x10/0x10 [2.621]  ? __pfx_mutex_unlock+0x10/0x10 [2.621]  btrfs_match_dir_item_name+0x101/0x1a0 [2.621]  btrfs_lookup_dir_item+0x1f3/0x280 [2.621]  ? __pfx_btrfs_lookup_dir_item+0x10/0x10 [2.621]  btrfs_get_tree+0xd25/0x1910  [ copy more details from report ]",
      "cve": "CVE-2024-35949",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35949",
          "value": "CVE-2024-35949",
          "url": "https://scout.docker.com/v/CVE-2024-35949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "33816573160ec251acdc5fbfdab564ac54820898397c941f6dffee2eeff8a483",
      "category": "container_scanning",
      "message": "CVE-2024-35999 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb3: missing lock when picking channel  Coverity spotted a place where we should have been holding the channel lock when accessing the ses channel index.  Addresses-Coverity: 1582039 (\"Data race condition (MISSING_LOCK)\")",
      "cve": "CVE-2024-35999",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35999",
          "value": "CVE-2024-35999",
          "url": "https://scout.docker.com/v/CVE-2024-35999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c24d688dbc028418297ad7cf7f19969e0c4f49929d551f17dd2d65cb7a9089b2",
      "category": "container_scanning",
      "message": "CVE-2024-36013 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()  Extend a critical section to prevent chan from early freeing. Also make the l2cap_connect() return type void. Nothing is using the returned value but it is ugly to return a potentially freed pointer. Making it void will help with backports because earlier kernels did use the return value. Now the compile will break for kernels where this patch is not a complete fix.  Call stack summary:  [use] l2cap_bredr_sig_cmd l2cap_connect  mutex_lock(&conn->chan_lock);  chan = pchan->ops->new_connection(pchan); <- alloc chan  __l2cap_chan_add(conn, chan);    l2cap_chan_hold(chan);    list_add(&chan->list, &conn->chan_l);   ... (1)  mutex_unlock(&conn->chan_lock); chan->conf_state              ... (4) <- use after free  [free] l2cap_conn_del  mutex_lock(&conn->chan_lock);  foreach chan in conn->chan_l:            ... (2)    l2cap_chan_put(chan);      l2cap_chan_destroy        kfree(chan)               ... (3) <- chan freed  mutex_unlock(&conn->chan_lock);  ================================================================== BUG: KASAN: slab-use-after-free in instrument_atomic_read include/linux/instrumented.h:68 [inline] BUG: KASAN: slab-use-after-free in _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline] BUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0 net/bluetooth/l2cap_core.c:4260 Read of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311",
      "cve": "CVE-2024-36013",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36013",
          "value": "CVE-2024-36013",
          "url": "https://scout.docker.com/v/CVE-2024-36013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cc2d7459a2b6a6e65e669426114c8a2a58cb46f7dfe6771947b0f53cdd4d87c7",
      "category": "container_scanning",
      "message": "CVE-2024-36331 on ubuntu/linux@5.15.0-161.171",
      "description": "Improper initialization of CPU cache memory could allow a privileged attacker with hypervisor access to overwrite SEV-SNP guest memory resulting in loss of data integrity.",
      "cve": "CVE-2024-36331",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36331",
          "value": "CVE-2024-36331",
          "url": "https://scout.docker.com/v/CVE-2024-36331?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36331?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "18b828f271966361d21509c9ed33e7cfcb3965cc5412860e681aa9ccd377de90",
      "category": "container_scanning",
      "message": "CVE-2024-36347 on ubuntu/linux@5.15.0-161.171",
      "description": "Improper signature verification in AMD CPU ROM microcode patch loader may allow an attacker with local administrator privilege to load malicious microcode, potentially resulting in loss of integrity of x86 instruction execution, loss of confidentiality and integrity of data in x86 CPU privileged context and compromise of SMM execution environment.",
      "cve": "CVE-2024-36347",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36347",
          "value": "CVE-2024-36347",
          "url": "https://scout.docker.com/v/CVE-2024-36347?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36347?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1575fad6d98ca5bd8e195c36bed9a57e2ce0ddb23f488861de043033f33827e6",
      "category": "container_scanning",
      "message": "CVE-2024-36350 on ubuntu/linux@5.15.0-161.171",
      "description": "A transient execution vulnerability in some AMD processors may allow an attacker to infer data from previous stores, potentially resulting in the leakage of privileged information.",
      "cve": "CVE-2024-36350",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36350",
          "value": "CVE-2024-36350",
          "url": "https://scout.docker.com/v/CVE-2024-36350?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36350?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2a23df5303ff640bffcf0320839e7d6aedbde582a482ad3494eec42aba7f0f08",
      "category": "container_scanning",
      "message": "CVE-2024-36357 on ubuntu/linux@5.15.0-161.171",
      "description": "A transient execution vulnerability in some AMD processors may allow an attacker to infer data in the L1D cache, potentially resulting in the leakage of sensitive information across privileged boundaries.",
      "cve": "CVE-2024-36357",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36357",
          "value": "CVE-2024-36357",
          "url": "https://scout.docker.com/v/CVE-2024-36357?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36357?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c9140aec9896cfa5cf7472a13796d56dd028fe31b4e9365d85e5bdca684a2d8c",
      "category": "container_scanning",
      "message": "CVE-2024-36910 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  uio_hv_generic: Don't free decrypted memory  In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues.  The VMBus device UIO driver could free decrypted/shared pages if set_memory_decrypted() fails. Check the decrypted field in the gpadl to decide whether to free the memory.",
      "cve": "CVE-2024-36910",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36910",
          "value": "CVE-2024-36910",
          "url": "https://scout.docker.com/v/CVE-2024-36910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "22834bcfad18d2b13c684e3bca00aa0d42fced1dfc6bdad98bbe9f035cedd0b8",
      "category": "container_scanning",
      "message": "CVE-2024-38594 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: stmmac: move the EST lock to struct stmmac_priv  Reinitialize the whole EST structure would also reset the mutex lock which is embedded in the EST structure, and then trigger the following warning. To address this, move the lock to struct stmmac_priv. We also need to reacquire the mutex lock when doing this initialization.  DEBUG_LOCKS_WARN_ON(lock->magic != lock) WARNING: CPU: 3 PID: 505 at kernel/locking/mutex.c:587 __mutex_lock+0xd84/0x1068 Modules linked in: CPU: 3 PID: 505 Comm: tc Not tainted 6.9.0-rc6-00053-g0106679839f7-dirty #29 Hardware name: NXP i.MX8MPlus EVK board (DT) pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __mutex_lock+0xd84/0x1068 lr : __mutex_lock+0xd84/0x1068 sp : ffffffc0864e3570 x29: ffffffc0864e3570 x28: ffffffc0817bdc78 x27: 0000000000000003 x26: ffffff80c54f1808 x25: ffffff80c9164080 x24: ffffffc080d723ac x23: 0000000000000000 x22: 0000000000000002 x21: 0000000000000000 x20: 0000000000000000 x19: ffffffc083bc3000 x18: ffffffffffffffff x17: ffffffc08117b080 x16: 0000000000000002 x15: ffffff80d2d40000 x14: 00000000000002da x13: ffffff80d2d404b8 x12: ffffffc082b5a5c8 x11: ffffffc082bca680 x10: ffffffc082bb2640 x9 : ffffffc082bb2698 x8 : 0000000000017fe8 x7 : c0000000ffffefff x6 : 0000000000000001 x5 : ffffff8178fe0d48 x4 : 0000000000000000 x3 : 0000000000000027 x2 : ffffff8178fe0d50 x1 : 0000000000000000 x0 : 0000000000000000 Call trace: __mutex_lock+0xd84/0x1068 mutex_lock_nested+0x28/0x34 tc_setup_taprio+0x118/0x68c stmmac_setup_tc+0x50/0xf0 taprio_change+0x868/0xc9c",
      "cve": "CVE-2024-38594",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38594",
          "value": "CVE-2024-38594",
          "url": "https://scout.docker.com/v/CVE-2024-38594?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38594?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "599d4b30afa7ae095e2ec7306f219d7ba086d76723e1ae4c0b09c08fc2dd7532",
      "category": "container_scanning",
      "message": "CVE-2024-38628 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: gadget: u_audio: Fix race condition use of controls after free during gadget unbind.  Hang on to the control IDs instead of pointers since those are correctly handled with locks.",
      "cve": "CVE-2024-38628",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38628",
          "value": "CVE-2024-38628",
          "url": "https://scout.docker.com/v/CVE-2024-38628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "770facd8e0b311c9a150ff3871165451e24293a62b8baa07c39730c60a1a583e",
      "category": "container_scanning",
      "message": "CVE-2024-38949 on ubuntu/libde265@1.0.8-1ubuntu0.3",
      "description": "Heap Buffer Overflow vulnerability in Libde265 v1.0.15 allows attackers to crash the application via crafted payload to display444as420 function at sdl.cc",
      "cve": "CVE-2024-38949",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libde265@1.0.8-1ubuntu0.3?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.0.8-1ubuntu0.3"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38949",
          "value": "CVE-2024-38949",
          "url": "https://scout.docker.com/v/CVE-2024-38949?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38949?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "65e37ee39086d7eaf00464b678c66446f8b0e3f97f44c7a9fc54db719d67799b",
      "category": "container_scanning",
      "message": "CVE-2024-38950 on ubuntu/libde265@1.0.8-1ubuntu0.3",
      "description": "Heap Buffer Overflow vulnerability in Libde265 v1.0.15 allows attackers to crash the application via crafted payload to __interceptor_memcpy function.",
      "cve": "CVE-2024-38950",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libde265@1.0.8-1ubuntu0.3?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.0.8-1ubuntu0.3"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38950",
          "value": "CVE-2024-38950",
          "url": "https://scout.docker.com/v/CVE-2024-38950?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38950?s=ubuntu&n=libde265&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2ce37790578de25948f32e0cde1150ee72b28c4cb85a73bfb30f8dc7f6968e7e",
      "category": "container_scanning",
      "message": "CVE-2024-53095 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: Fix use-after-free of network namespace.  Recently, we got a customer report that CIFS triggers oops while reconnecting to a server.  [0]  The workload runs on Kubernetes, and some pods mount CIFS servers in non-root network namespaces.  The problem rarely happened, but it was always while the pod was dying.  The root cause is wrong reference counting for network namespace.  CIFS uses kernel sockets, which do not hold refcnt of the netns that the socket belongs to.  That means CIFS must ensure the socket is always freed before its netns; otherwise, use-after-free happens.  The repro steps are roughly:  1. mount CIFS in a non-root netns 2. drop packets from the netns 3. destroy the netns 4. unmount CIFS  We can reproduce the issue quickly with the script [1] below and see the splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled.  When the socket is TCP, it is hard to guarantee the netns lifetime without holding refcnt due to async timers.  Let's hold netns refcnt for each socket as done for SMC in commit 9744d2bf1976 (\"smc: Fix use-after-free in tcp_write_timer_handler().\").  Note that we need to move put_net() from cifs_put_tcp_session() to clean_demultiplex_info(); otherwise, __sock_create() still could touch a freed netns while cifsd tries to reconnect from cifs_demultiplex_thread().  Also, maybe_get_net() cannot be put just before __sock_create() because the code is not under RCU and there is a small chance that the same address happened to be reallocated to another netns.  [0]: CIFS: VFS: \\\\XXXXXXXXXXX has not responded in 15 seconds. Reconnecting... CIFS: Serverclose failed 4 times, giving up Unable to handle kernel paging request at virtual address 14de99e461f84a07 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004 CM = 0, WnR = 0 [14de99e461f84a07] address between user and kernel address ranges Internal error: Oops: 0000000096000004 [#1] SMP Modules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfs CPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1 Hardware name: Amazon EC2 r7g.4xlarge/, BIOS 1.0 11/1/2018 pstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : fib_rules_lookup+0x44/0x238 lr : __fib_lookup+0x64/0xbc sp : ffff8000265db790 x29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01 x26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580 x23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500 x20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002 x11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294 x8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000 x5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0 x2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500 Call trace: fib_rules_lookup+0x44/0x238 __fib_lookup+0x64/0xbc ip_route_output_key_hash_rcu+0x2c4/0x398 ip_route_output_key_hash+0x60/0x8c tcp_v4_connect+0x290/0x488 __inet_stream_connect+0x108/0x3d0 inet_stream_connect+0x50/0x78 kernel_connect+0x6c/0xac generic_ip_conne ---truncated---",
      "cve": "CVE-2024-53095",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53095",
          "value": "CVE-2024-53095",
          "url": "https://scout.docker.com/v/CVE-2024-53095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b4d15359a873ae5d18d15a6e584de42d2d051f7b8324830ce219a9f5fdb5cb3a",
      "category": "container_scanning",
      "message": "CVE-2024-53102 on ubuntu/linux@5.15.0-161.171",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "cve": "CVE-2024-53102",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53102",
          "value": "CVE-2024-53102",
          "url": "https://scout.docker.com/v/CVE-2024-53102?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53102?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "339149c8e81393442a66230fca5dc46f64119f6e97dc9ec5a21f2bb73cabc3c2",
      "category": "container_scanning",
      "message": "CVE-2024-53177 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: prevent use-after-free due to open_cached_dir error paths  If open_cached_dir() encounters an error parsing the lease from the server, the error handling may race with receiving a lease break, resulting in open_cached_dir() freeing the cfid while the queued work is pending.  Update open_cached_dir() to drop refs rather than directly freeing the cfid.  Have cached_dir_lease_break(), cfids_laundromat_worker(), and invalidate_all_cached_dirs() clear has_lease immediately while still holding cfids->cfid_list_lock, and then use this to also simplify the reference counting in cfids_laundromat_worker() and invalidate_all_cached_dirs().  Fixes this KASAN splat (which manually injects an error and lease break in open_cached_dir()):  ================================================================== BUG: KASAN: slab-use-after-free in smb2_cached_lease_break+0x27/0xb0 Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65  CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Workqueue: cifsiod smb2_cached_lease_break Call Trace: <TASK> dump_stack_lvl+0x77/0xb0 print_report+0xce/0x660 kasan_report+0xd3/0x110 smb2_cached_lease_break+0x27/0xb0 process_one_work+0x50a/0xc50 worker_thread+0x2ba/0x530 kthread+0x17c/0x1c0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 </TASK>  Allocated by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 open_cached_dir+0xa7d/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Freed by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x51/0x70 kfree+0x174/0x520 open_cached_dir+0x97f/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Last potentially related work creation: kasan_save_stack+0x33/0x60 __kasan_record_aux_stack+0xad/0xc0 insert_work+0x32/0x100 __queue_work+0x5c9/0x870 queue_work_on+0x82/0x90 open_cached_dir+0x1369/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e  The buggy address belongs to the object at ffff88811cc24c00 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 16 bytes inside of freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)",
      "cve": "CVE-2024-53177",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53177",
          "value": "CVE-2024-53177",
          "url": "https://scout.docker.com/v/CVE-2024-53177?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53177?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "74b85211d6ac15478b67b5d98852eeea3674f8622199e79f89a3bf13034dae6e",
      "category": "container_scanning",
      "message": "CVE-2024-53216 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nfsd: release svc_expkey/svc_export with rcu_work  The last reference for `cache_head` can be reduced to zero in `c_show` and `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequently, `svc_export_put` and `expkey_put` will be invoked, leading to two issues:  1. The `svc_export_put` will directly free ex_uuid. However, `e_show`/`c_show` will access `ex_uuid` after `cache_put`, which can trigger a use-after-free issue, shown below.  ================================================================== BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd] Read of size 1 at addr ff11000010fdc120 by task cat/870  CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x53/0x70 print_address_description.constprop.0+0x2c/0x3a0 print_report+0xb9/0x280 kasan_report+0xae/0xe0 svc_export_show+0x362/0x430 [nfsd] c_show+0x161/0x390 [sunrpc] seq_read_iter+0x589/0x770 seq_read+0x1e5/0x270 proc_reg_read+0xe1/0x140 vfs_read+0x125/0x530 ksys_read+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Allocated by task 830: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __kmalloc_node_track_caller_noprof+0x1bc/0x400 kmemdup_noprof+0x22/0x50 svc_export_parse+0x8a9/0xb80 [nfsd] cache_do_downcall+0x71/0xa0 [sunrpc] cache_write_procfs+0x8e/0xd0 [sunrpc] proc_reg_write+0xe1/0x140 vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Freed by task 868: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x37/0x50 kfree+0xf3/0x3e0 svc_export_put+0x87/0xb0 [nfsd] cache_purge+0x17f/0x1f0 [sunrpc] nfsd_destroy_serv+0x226/0x2d0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`. However, `svc_export_put`/`expkey_put` will call path_put, which subsequently triggers a sleeping operation due to the following `dput`.  ============================= WARNING: suspicious RCU usage 5.10.0-dirty #141 Not tainted ----------------------------- ... Call Trace: dump_stack+0x9a/0xd0 ___might_sleep+0x231/0x240 dput+0x39/0x600 path_put+0x1b/0x30 svc_export_put+0x17/0x80 e_show+0x1c9/0x200 seq_read_iter+0x63f/0x7c0 seq_read+0x226/0x2d0 vfs_read+0x113/0x2c0 ksys_read+0xc9/0x170 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x67/0xd1  Fix these issues by using `rcu_work` to help release `svc_expkey`/`svc_export`. This approach allows for an asynchronous context to invoke `path_put` and also facilitates the freeing of `uuid/exp/key` after an RCU grace period.",
      "cve": "CVE-2024-53216",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53216",
          "value": "CVE-2024-53216",
          "url": "https://scout.docker.com/v/CVE-2024-53216?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53216?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "91b9396719d233ca1933856c119611d7360a1c9048d1d0d638fc90af141015c9",
      "category": "container_scanning",
      "message": "CVE-2024-56557 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iio: adc: ad7923: Fix buffer overflow for tx_buf and ring_xfer  The AD7923 was updated to support devices with 8 channels, but the size of tx_buf and ring_xfer was not increased accordingly, leading to a potential buffer overflow in ad7923_update_scan_mode().",
      "cve": "CVE-2024-56557",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56557",
          "value": "CVE-2024-56557",
          "url": "https://scout.docker.com/v/CVE-2024-56557?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56557?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "31b98b5d1c2042cf2c2f9f4e49581d5312b3b40cf42c956c1718bb5ce03c0f38",
      "category": "container_scanning",
      "message": "CVE-2024-57795 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/rxe: Remove the direct link to net_device  The similar patch in siw is in the link: https://git.kernel.org/rdma/rdma/c/16b87037b48889  This problem also occurred in RXE. The following analyze this problem. In the following Call Traces: \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 Read of size 4 at addr ffff8880554640b0 by task kworker/1:4/5295  CPU: 1 UID: 0 PID: 5295 Comm: kworker/1:4 Not tainted 6.12.0-rc3-syzkaller-00399-g9197b73fd7bb #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: infiniband ib_cache_event_task Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 rxe_query_port+0x12d/0x260 drivers/infiniband/sw/rxe/rxe_verbs.c:60 __ib_query_port drivers/infiniband/core/device.c:2111 [inline] ib_query_port+0x168/0x7d0 drivers/infiniband/core/device.c:2143 ib_cache_update+0x1a9/0xb80 drivers/infiniband/core/cache.c:1494 ib_cache_event_task+0xf3/0x1e0 drivers/infiniband/core/cache.c:1568 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f2/0x390 kernel/kthread.c:389 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> \"  1). In the link [1],  \" infiniband syz2: set down \"  This means that on 839.350575, the event ib_cache_event_task was sent andi queued in ib_wq.  2). In the link [1],  \" team0 (unregistering): Port device team_slave_0 removed \"  It indicates that before 843.251853, the net device should be freed.  3). In the link [1],  \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 \"  This means that on 850.559070, this slab-use-after-free problem occurred.  In all, on 839.350575, the event ib_cache_event_task was sent and queued in ib_wq,  before 843.251853, the net device veth was freed.  on 850.559070, this event was executed, and the mentioned freed net device was called. Thus, the above call trace occurred.  [1] https://syzkaller.appspot.com/x/log.txt?x=12e7025f980000",
      "cve": "CVE-2024-57795",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57795",
          "value": "CVE-2024-57795",
          "url": "https://scout.docker.com/v/CVE-2024-57795?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57795?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "97b5d638b404f41124ed1f39aafe2aa8f6c674837cdbe1c789dc2bb525945d59",
      "category": "container_scanning",
      "message": "CVE-2024-57857 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/siw: Remove direct link to net_device  Do not manage a per device direct link to net_device. Rely on associated ib_devices net_device management, not doubling the effort locally. A badly managed local link to net_device was causing a 'KASAN: slab-use-after-free' exception during siw_query_port() call.",
      "cve": "CVE-2024-57857",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57857",
          "value": "CVE-2024-57857",
          "url": "https://scout.docker.com/v/CVE-2024-57857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ccedfa9585c2b9edac8883a6e58eaae0e7a89c43203634d020f3b4b752e3db03",
      "category": "container_scanning",
      "message": "CVE-2024-58013 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_sync  This fixes the following crash:  ================================================================== BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 Read of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961  CPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK>  Allocated by task 16026: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269 mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296 remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568 hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:711 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:726 sock_write_iter+0x2d7/0x3f0 net/socket.c:1147 new_sync_write fs/read_write.c:586 [inline] vfs_write+0xaeb/0xd30 fs/read_write.c:679 ksys_write+0x18f/0x2b0 fs/read_write.c:731 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Freed by task 16022: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2338 [inline] slab_free mm/slub.c:4598 [inline] kfree+0x196/0x420 mm/slub.c:4746 mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259 __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550 hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208 hci_dev_do_close net/bluetooth/hci_core.c:483 [inline] hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508 sock_do_ioctl+0x158/0x460 net/socket.c:1209 sock_ioctl+0x626/0x8e0 net/socket.c:1328 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "cve": "CVE-2024-58013",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58013",
          "value": "CVE-2024-58013",
          "url": "https://scout.docker.com/v/CVE-2024-58013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2438d5aeb008ac291759fa2f91df412b646cd70c5e8bba835e271e43be180d54",
      "category": "container_scanning",
      "message": "CVE-2024-58019 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvkm/gsp: correctly advance the read pointer of GSP message queue  A GSP event message consists three parts: message header, RPC header, message body. GSP calculates the number of pages to write from the total size of a GSP message. This behavior can be observed from the movement of the write pointer.  However, nvkm takes only the size of RPC header and message body as the message size when advancing the read pointer. When handling a two-page GSP message in the non rollback case, It wrongly takes the message body of the previous message as the message header of the next message. As the \"message length\" tends to be zero, in the calculation of size needs to be copied (0 - size of (message header)), the size needs to be copied will be \"0xffffffxx\". It also triggers a kernel panic due to a NULL pointer error.  [  547.614102] msg: 00000f90: ff ff ff ff ff ff ff ff 40 d7 18 fb 8b 00 00 00  ........@....... [  547.622533] msg: 00000fa0: 00 00 00 00 ff ff ff ff ff ff ff ff 00 00 00 00  ................ [  547.630965] msg: 00000fb0: ff ff ff ff ff ff ff ff 00 00 00 00 ff ff ff ff  ................ [  547.639397] msg: 00000fc0: ff ff ff ff 00 00 00 00 ff ff ff ff ff ff ff ff  ................ [  547.647832] nvkm 0000:c1:00.0: gsp: peek msg rpc fn:0 len:0x0/0xffffffffffffffe0 [  547.655225] nvkm 0000:c1:00.0: gsp: get msg rpc fn:0 len:0x0/0xffffffffffffffe0 [  547.662532] BUG: kernel NULL pointer dereference, address: 0000000000000020 [  547.669485] #PF: supervisor read access in kernel mode [  547.674624] #PF: error_code(0x0000) - not-present page [  547.679755] PGD 0 P4D 0 [  547.682294] Oops: 0000 [#1] PREEMPT SMP NOPTI [  547.686643] CPU: 22 PID: 322 Comm: kworker/22:1 Tainted: G            E 6.9.0-rc6+ #1 [  547.694893] Hardware name: ASRockRack 1U1G-MILAN/N/ROMED8-NL, BIOS L3.12E 09/06/2022 [  547.702626] Workqueue: events r535_gsp_msgq_work [nvkm] [  547.707921] RIP: 0010:r535_gsp_msg_recv+0x87/0x230 [nvkm] [  547.713375] Code: 00 8b 70 08 48 89 e1 31 d2 4c 89 f7 e8 12 f5 ff ff 48 89 c5 48 85 c0 0f 84 cf 00 00 00 48 81 fd 00 f0 ff ff 0f 87 c4 00 00 00 <8b> 55 10 41 8b 46 30 85 d2 0f 85 f6 00 00 00 83 f8 04 76 10 ba 05 [  547.732119] RSP: 0018:ffffabe440f87e10 EFLAGS: 00010203 [  547.737335] RAX: 0000000000000010 RBX: 0000000000000008 RCX: 000000000000003f [  547.744461] RDX: 0000000000000000 RSI: ffffabe4480a8030 RDI: 0000000000000010 [  547.751585] RBP: 0000000000000010 R08: 0000000000000000 R09: ffffabe440f87bb0 [  547.758707] R10: ffffabe440f87dc8 R11: 0000000000000010 R12: 0000000000000000 [  547.765834] R13: 0000000000000000 R14: ffff9351df1e5000 R15: 0000000000000000 [  547.772958] FS:  0000000000000000(0000) GS:ffff93708eb00000(0000) knlGS:0000000000000000 [  547.781035] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  547.786771] CR2: 0000000000000020 CR3: 00000003cc220002 CR4: 0000000000770ef0 [  547.793896] PKRU: 55555554 [  547.796600] Call Trace: [  547.799046]  <TASK> [  547.801152]  ? __die+0x20/0x70 [  547.804211]  ? page_fault_oops+0x75/0x170 [  547.808221]  ? print_hex_dump+0x100/0x160 [  547.812226]  ? exc_page_fault+0x64/0x150 [  547.816152]  ? asm_exc_page_fault+0x22/0x30 [  547.820341]  ? r535_gsp_msg_recv+0x87/0x230 [nvkm] [  547.825184]  r535_gsp_msgq_work+0x42/0x50 [nvkm] [  547.829845]  process_one_work+0x196/0x3d0 [  547.833861]  worker_thread+0x2fc/0x410 [  547.837613]  ? __pfx_worker_thread+0x10/0x10 [  547.841885]  kthread+0xdf/0x110 [  547.845031]  ? __pfx_kthread+0x10/0x10 [  547.848775]  ret_from_fork+0x30/0x50 [  547.852354]  ? __pfx_kthread+0x10/0x10 [  547.856097]  ret_from_fork_asm+0x1a/0x30 [  547.860019]  </TASK> [  547.862208] Modules linked in: nvkm(E) gsp_log(E) snd_seq_dummy(E) snd_hrtimer(E) snd_seq(E) snd_timer(E) snd_seq_device(E) snd(E) soundcore(E) rfkill(E) qrtr(E) vfat(E) fat(E) ipmi_ssif(E) amd_atl(E) intel_rapl_msr(E) intel_rapl_common(E) amd64_edac(E) mlx5_ib(E) edac_mce_amd(E) kvm_amd ---truncated---",
      "cve": "CVE-2024-58019",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58019",
          "value": "CVE-2024-58019",
          "url": "https://scout.docker.com/v/CVE-2024-58019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "703ef71b6cce25a54489c92d831573623da8832647ab4f33fc3ecd7e87e83bbe",
      "category": "container_scanning",
      "message": "CVE-2024-58054 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  staging: media: max96712: fix kernel oops when removing module  The following kernel oops is thrown when trying to remove the max96712 module:  Unable to handle kernel paging request at virtual address 00007375746174db Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 CM = 0, WnR = 0, TnD = 0, TagAccess = 0 GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 user pgtable: 4k pages, 48-bit VAs, pgdp=000000010af89000 [00007375746174db] pgd=0000000000000000, p4d=0000000000000000 Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP Modules linked in: crct10dif_ce polyval_ce mxc_jpeg_encdec flexcan snd_soc_fsl_sai snd_soc_fsl_asoc_card snd_soc_fsl_micfil dwc_mipi_csi2 imx_csi_formatter polyval_generic v4l2_jpeg imx_pcm_dma can_dev snd_soc_imx_audmux snd_soc_wm8962 snd_soc_imx_card snd_soc_fsl_utils max96712(C-) rpmsg_ctrl rpmsg_char pwm_fan fuse [last unloaded: imx8_isi] CPU: 0 UID: 0 PID: 754 Comm: rmmod Tainted: G         C    6.12.0-rc6-06364-g327fec852c31 #17 Tainted: [C]=CRAP Hardware name: NXP i.MX95 19X19 board (DT) pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : led_put+0x1c/0x40 lr : v4l2_subdev_put_privacy_led+0x48/0x58 sp : ffff80008699bbb0 x29: ffff80008699bbb0 x28: ffff00008ac233c0 x27: 0000000000000000 x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000 x23: ffff000080cf1170 x22: ffff00008b53bd00 x21: ffff8000822ad1c8 x20: ffff000080ff5c00 x19: ffff00008b53be40 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 x14: 0000000000000004 x13: ffff0000800f8010 x12: 0000000000000000 x11: ffff000082acf5c0 x10: ffff000082acf478 x9 : ffff0000800f8010 x8 : 0101010101010101 x7 : 7f7f7f7f7f7f7f7f x6 : fefefeff6364626d x5 : 8080808000000000 x4 : 0000000000000020 x3 : 00000000553a3dc1 x2 : ffff00008ac233c0 x1 : ffff00008ac233c0 x0 : ff00737574617473 Call trace: led_put+0x1c/0x40 v4l2_subdev_put_privacy_led+0x48/0x58 v4l2_async_unregister_subdev+0x2c/0x1a4 max96712_remove+0x1c/0x38 [max96712] i2c_device_remove+0x2c/0x9c device_remove+0x4c/0x80 device_release_driver_internal+0x1cc/0x228 driver_detach+0x4c/0x98 bus_remove_driver+0x6c/0xbc driver_unregister+0x30/0x60 i2c_del_driver+0x54/0x64 max96712_i2c_driver_exit+0x18/0x1d0 [max96712] __arm64_sys_delete_module+0x1a4/0x290 invoke_syscall+0x48/0x10c el0_svc_common.constprop.0+0xc0/0xe0 do_el0_svc+0x1c/0x28 el0_svc+0x34/0xd8 el0t_64_sync_handler+0x120/0x12c el0t_64_sync+0x190/0x194 Code: f9000bf3 aa0003f3 f9402800 f9402000 (f9403400) ---[ end trace 0000000000000000 ]---  This happens because in v4l2_i2c_subdev_init(), the i2c_set_cliendata() is called again and the data is overwritten to point to sd, instead of priv. So, in remove(), the wrong pointer is passed to v4l2_async_unregister_subdev(), leading to a crash.",
      "cve": "CVE-2024-58054",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58054",
          "value": "CVE-2024-58054",
          "url": "https://scout.docker.com/v/CVE-2024-58054?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58054?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "827cfb88e911e7708af1a249639196758b2392bec28465da8fa34bd97049b189",
      "category": "container_scanning",
      "message": "CVE-2024-58077 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: soc-pcm: don't use soc_pcm_ret() on .prepare callback  commit 1f5664351410 (\"ASoC: lower \"no backend DAIs enabled for ... Port\" log severity\") ignores -EINVAL error message on common soc_pcm_ret(). It is used from many functions, ignoring -EINVAL is over-kill.  The reason why -EINVAL was ignored was it really should only be used upon invalid parameters coming from userspace and in that case we don't want to log an error since we do not want to give userspace a way to do a denial-of-service attack on the syslog / diskspace.  So don't use soc_pcm_ret() on .prepare callback is better idea.",
      "cve": "CVE-2024-58077",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58077",
          "value": "CVE-2024-58077",
          "url": "https://scout.docker.com/v/CVE-2024-58077?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58077?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f04f9370b027ddbe700c51c4cbdcd03f0f388a24679ac21092764d8e25a250d",
      "category": "container_scanning",
      "message": "CVE-2024-58094 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: add check read-only before truncation in jfs_truncate_nolock()  Added a check for \"read-only\" mode in the `jfs_truncate_nolock` function to avoid errors related to writing to a read-only filesystem.  Call stack:  block_write_begin() { jfs_write_failed() { jfs_truncate() { jfs_truncate_nolock() { txEnd() { ... log = JFS_SBI(tblk->sb)->log; // (log == NULL)  If the `isReadOnly(ip)` condition is triggered in `jfs_truncate_nolock`, the function execution will stop, and no further data modification will occur. Instead, the `xtTruncate` function will be called with the \"COMMIT_WMAP\" flag, preventing modifications in \"read-only\" mode.",
      "cve": "CVE-2024-58094",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58094",
          "value": "CVE-2024-58094",
          "url": "https://scout.docker.com/v/CVE-2024-58094?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58094?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fa94001194605538c52e7a65d8c9dfe0196b8d070dcd42c379cf49ed7b26ab8f",
      "category": "container_scanning",
      "message": "CVE-2024-58095 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: add check read-only before txBeginAnon() call  Added a read-only check before calling `txBeginAnon` in `extAlloc` and `extRecord`. This prevents modification attempts on a read-only mounted filesystem, avoiding potential errors or crashes.  Call trace: txBeginAnon+0xac/0x154 extAlloc+0xe8/0xdec fs/jfs/jfs_extent.c:78 jfs_get_block+0x340/0xb98 fs/jfs/inode.c:248 __block_write_begin_int+0x580/0x166c fs/buffer.c:2128 __block_write_begin fs/buffer.c:2177 [inline] block_write_begin+0x98/0x11c fs/buffer.c:2236 jfs_write_begin+0x44/0x88 fs/jfs/inode.c:299",
      "cve": "CVE-2024-58095",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58095",
          "value": "CVE-2024-58095",
          "url": "https://scout.docker.com/v/CVE-2024-58095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1b945b312c7a227480ea49e2d269973a30a32d99b071b004900b9d80abeee920",
      "category": "container_scanning",
      "message": "CVE-2024-58096 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: add srng->lock for ath11k_hal_srng_* in monitor mode  ath11k_hal_srng_* should be used with srng->lock to protect srng data.  For ath11k_dp_rx_mon_dest_process() and ath11k_dp_full_mon_process_rx(), they use ath11k_hal_srng_* for many times but never call srng->lock.  So when running (full) monitor mode, warning will occur: RIP: 0010:ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k] Call Trace: ? ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k] ath11k_dp_rx_process_mon_status+0xc45/0x1190 [ath11k] ? idr_alloc_u32+0x97/0xd0 ath11k_dp_rx_process_mon_rings+0x32a/0x550 [ath11k] ath11k_dp_service_srng+0x289/0x5a0 [ath11k] ath11k_pcic_ext_grp_napi_poll+0x30/0xd0 [ath11k] __napi_poll+0x30/0x1f0 net_rx_action+0x198/0x320 __do_softirq+0xdd/0x319  So add srng->lock for them to avoid such warnings.  Inorder to fetch the srng->lock, should change srng's definition from 'void' to 'struct hal_srng'. And initialize them elsewhere to prevent one line of code from being too long. This is consistent with other ring process functions, such as ath11k_dp_process_rx().  Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30 Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2024-58096",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58096",
          "value": "CVE-2024-58096",
          "url": "https://scout.docker.com/v/CVE-2024-58096?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58096?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a8a1a81999e5b23e46b4401190e6e41cabfd3f4f3d648fa25cdefc38c4549cc2",
      "category": "container_scanning",
      "message": "CVE-2024-58098 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: track changes_pkt_data property for global functions  When processing calls to certain helpers, verifier invalidates all packet pointers in a current state. For example, consider the following program:  __attribute__((__noinline__)) long skb_pull_data(struct __sk_buff *sk, __u32 len) { return bpf_skb_pull_data(sk, len); }  SEC(\"tc\") int test_invalidate_checks(struct __sk_buff *sk) { int *p = (void *)(long)sk->data; if ((void *)(p + 1) > (void *)(long)sk->data_end) return TCX_DROP; skb_pull_data(sk, 0); *p = 42; return TCX_PASS; }  After a call to bpf_skb_pull_data() the pointer 'p' can't be used safely. See function filter.c:bpf_helper_changes_pkt_data() for a list of such helpers.  At the moment verifier invalidates packet pointers when processing helper function calls, and does not traverse global sub-programs when processing calls to global sub-programs. This means that calls to helpers done from global sub-programs do not invalidate pointers in the caller state. E.g. the program above is unsafe, but is not rejected by verifier.  This commit fixes the omission by computing field bpf_subprog_info->changes_pkt_data for each sub-program before main verification pass. changes_pkt_data should be set if: - subprogram calls helper for which bpf_helper_changes_pkt_data returns true; - subprogram calls a global function, for which bpf_subprog_info->changes_pkt_data should be set.  The verifier.c:check_cfg() pass is modified to compute this information. The commit relies on depth first instruction traversal done by check_cfg() and absence of recursive function calls: - check_cfg() would eventually visit every call to subprogram S in a state when S is fully explored; - when S is fully explored: - every direct helper call within S is explored (and thus changes_pkt_data is set if needed); - every call to subprogram S1 called by S was visited with S1 fully explored (and thus S inherits changes_pkt_data from S1).  The downside of such approach is that dead code elimination is not taken into account: if a helper call inside global function is dead because of current configuration, verifier would conservatively assume that the call occurs for the purpose of the changes_pkt_data computation.",
      "cve": "CVE-2024-58098",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58098",
          "value": "CVE-2024-58098",
          "url": "https://scout.docker.com/v/CVE-2024-58098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d7f519a85df6fe924be36bed58e8af7e0ff7a72ed877088f2bff4afb3cb2ff9a",
      "category": "container_scanning",
      "message": "CVE-2024-58100 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: check changes_pkt_data property for extension programs  When processing calls to global sub-programs, verifier decides whether to invalidate all packet pointers in current state depending on the changes_pkt_data property of the global sub-program.  Because of this, an extension program replacing a global sub-program must be compatible with changes_pkt_data property of the sub-program being replaced.  This commit: - adds changes_pkt_data flag to struct bpf_prog_aux: - this flag is set in check_cfg() for main sub-program; - in jit_subprogs() for other sub-programs; - modifies bpf_check_attach_btf_id() to check changes_pkt_data flag; - moves call to check_attach_btf_id() after the call to check_cfg(), because it needs changes_pkt_data flag to be set:  bpf_check: ...                             ... - check_attach_btf_id             resolve_pseudo_ldimm64 resolve_pseudo_ldimm64   -->    bpf_prog_is_offloaded bpf_prog_is_offloaded           check_cfg check_cfg                     + check_attach_btf_id ...                             ...  The following fields are set by check_attach_btf_id(): - env->ops - prog->aux->attach_btf_trace - prog->aux->attach_func_name - prog->aux->attach_func_proto - prog->aux->dst_trampoline - prog->aux->mod - prog->aux->saved_dst_attach_type - prog->aux->saved_dst_prog_type - prog->expected_attach_type  Neither of these fields are used by resolve_pseudo_ldimm64() or bpf_prog_offload_verifier_prep() (for netronome and netdevsim drivers), so the reordering is safe.",
      "cve": "CVE-2024-58100",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58100",
          "value": "CVE-2024-58100",
          "url": "https://scout.docker.com/v/CVE-2024-58100?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58100?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7b84691eff6c0ea49bbd96af9d96dfe963bd6bc223d53f27ba75f0c26e291d19",
      "category": "container_scanning",
      "message": "CVE-2024-58238 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: btnxpuart: Resolve TX timeout error in power save stress test  This fixes the tx timeout issue seen while running a stress test on btnxpuart for couple of hours, such that the interval between two HCI commands coincide with the power save timeout value of 2 seconds.  Test procedure using bash script: <load btnxpuart.ko> hciconfig hci0 up //Enable Power Save feature hcitool -i hci0 cmd 3f 23 02 00 00 while (true) do hciconfig hci0 leadv sleep 2 hciconfig hci0 noleadv sleep 2 done  Error log, after adding few more debug prints: Bluetooth: btnxpuart_queue_skb(): 01 0A 20 01 00 Bluetooth: hci0: Set UART break: on, status=0 Bluetooth: hci0: btnxpuart_tx_wakeup() tx_work scheduled Bluetooth: hci0: btnxpuart_tx_work() dequeue: 01 0A 20 01 00 Can't set advertise mode on hci0: Connection timed out (110) Bluetooth: hci0: command 0x200a tx timeout  When the power save mechanism turns on UART break, and btnxpuart_tx_work() is scheduled simultaneously, psdata->ps_state is read as PS_STATE_AWAKE, which prevents the psdata->work from being scheduled, which is responsible to turn OFF UART break.  This issue is fixed by adding a ps_lock mutex around UART break on/off as well as around ps_state read/write. btnxpuart_tx_wakeup() will now read updated ps_state value. If ps_state is PS_STATE_SLEEP, it will first schedule psdata->work, and then it will reschedule itself once UART break has been turned off and ps_state is PS_STATE_AWAKE.  Tested above script for 50,000 iterations and TX timeout error was not observed anymore.",
      "cve": "CVE-2024-58238",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58238",
          "value": "CVE-2024-58238",
          "url": "https://scout.docker.com/v/CVE-2024-58238?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58238?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "187735c783f7436570b7c12f9c8570759434afcf8e1a4d742ad248989120b181",
      "category": "container_scanning",
      "message": "CVE-2024-58241 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_core: Disable works on hci_unregister_dev  This make use of disable_work_* on hci_unregister_dev since the hci_dev is about to be freed new submissions are not disarable.",
      "cve": "CVE-2024-58241",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58241",
          "value": "CVE-2024-58241",
          "url": "https://scout.docker.com/v/CVE-2024-58241?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58241?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3c4de630db1aaa0bbdf43b58f0a3167034dcd90e317bc112e9190497df1e330",
      "category": "container_scanning",
      "message": "CVE-2025-0938 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "The Python standard library functions `urllib.parse.urlsplit` and `urlparse` accepted domain names that included square brackets which isn't valid according to RFC 3986. Square brackets are only meant to be used as delimiters for specifying IPv6 and IPvFuture hosts in URLs. This could result in differential parsing across the Python URL parser and other specification-compliant URL parsers.",
      "cve": "CVE-2025-0938",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-0938",
          "value": "CVE-2025-0938",
          "url": "https://scout.docker.com/v/CVE-2025-0938?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-0938?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2324830997f69864067ecb1a70e24c2b9e130685020476aec36a0689c622f2e",
      "category": "container_scanning",
      "message": "CVE-2025-21693 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: zswap: properly synchronize freeing resources during CPU hotunplug  In zswap_compress() and zswap_decompress(), the per-CPU acomp_ctx of the current CPU at the beginning of the operation is retrieved and used throughout.  However, since neither preemption nor migration are disabled, it is possible that the operation continues on a different CPU.  If the original CPU is hotunplugged while the acomp_ctx is still in use, we run into a UAF bug as some of the resources attached to the acomp_ctx are freed during hotunplug in zswap_cpu_comp_dead() (i.e. acomp_ctx.buffer, acomp_ctx.req, or acomp_ctx.acomp).  The problem was introduced in commit 1ec3b5fe6eec (\"mm/zswap: move to use crypto_acomp API for hardware acceleration\") when the switch to the crypto_acomp API was made.  Prior to that, the per-CPU crypto_comp was retrieved using get_cpu_ptr() which disables preemption and makes sure the CPU cannot go away from under us.  Preemption cannot be disabled with the crypto_acomp API as a sleepable context is needed.  Use the acomp_ctx.mutex to synchronize CPU hotplug callbacks allocating and freeing resources with compression/decompression paths.  Make sure that acomp_ctx.req is NULL when the resources are freed.  In the compression/decompression paths, check if acomp_ctx.req is NULL after acquiring the mutex (meaning the CPU was offlined) and retry on the new CPU.  The initialization of acomp_ctx.mutex is moved from the CPU hotplug callback to the pool initialization where it belongs (where the mutex is allocated).  In addition to adding clarity, this makes sure that CPU hotplug cannot reinitialize a mutex that is already locked by compression/decompression.  Previously a fix was attempted by holding cpus_read_lock() [1].  This would have caused a potential deadlock as it is possible for code already holding the lock to fall into reclaim and enter zswap (causing a deadlock).  A fix was also attempted using SRCU for synchronization, but Johannes pointed out that synchronize_srcu() cannot be used in CPU hotplug notifiers [2].  Alternative fixes that were considered/attempted and could have worked: - Refcounting the per-CPU acomp_ctx. This involves complexity in handling the race between the refcount dropping to zero in zswap_[de]compress() and the refcount being re-initialized when the CPU is onlined. - Disabling migration before getting the per-CPU acomp_ctx [3], but that's discouraged and is a much bigger hammer than needed, and could result in subtle performance issues.  [1]https://lkml.kernel.org/20241219212437.2714151-1-yosryahmed@google.com/ [2]https://lkml.kernel.org/20250107074724.1756696-2-yosryahmed@google.com/ [3]https://lkml.kernel.org/20250107222236.2715883-2-yosryahmed@google.com/  [yosryahmed@google.com: remove comment]",
      "cve": "CVE-2025-21693",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21693",
          "value": "CVE-2025-21693",
          "url": "https://scout.docker.com/v/CVE-2025-21693?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21693?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6127c86839a1f34a66eec24446210a8b9edbcdfc5cf725791d47e427ae7c61ac",
      "category": "container_scanning",
      "message": "CVE-2025-21732 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/mlx5: Fix a race for an ODP MR which leads to CQE with error  This patch addresses a race condition for an ODP MR that can result in a CQE with an error on the UMR QP.  During the __mlx5_ib_dereg_mr() flow, the following sequence of calls occurs:  mlx5_revoke_mr() mlx5r_umr_revoke_mr() mlx5r_umr_post_send_wait()  At this point, the lkey is freed from the hardware's perspective.  However, concurrently, mlx5_ib_invalidate_range() might be triggered by another task attempting to invalidate a range for the same freed lkey.  This task will: - Acquire the umem_odp->umem_mutex lock. - Call mlx5r_umr_update_xlt() on the UMR QP. - Since the lkey has already been freed, this can lead to a CQE error, causing the UMR QP to enter an error state [1].  To resolve this race condition, the umem_odp->umem_mutex lock is now also acquired as part of the mlx5_revoke_mr() scope.  Upon successful revoke, we set umem_odp->private which points to that MR to NULL, preventing any further invalidation attempts on its lkey.  [1] From dmesg:  infiniband rocep8s0f0: dump_cqe:277:(pid 0): WC error: 6, Message: memory bind operation error cqe_dump: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 cqe_dump: 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 cqe_dump: 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 cqe_dump: 00000030: 00 00 00 00 08 00 78 06 25 00 11 b9 00 0e dd d2  WARNING: CPU: 15 PID: 1506 at drivers/infiniband/hw/mlx5/umr.c:394 mlx5r_umr_post_send_wait+0x15a/0x2b0 [mlx5_ib] Modules linked in: ip6table_mangle ip6table_natip6table_filter ip6_tables iptable_mangle xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_umad ib_ipoib ib_cm mlx5_ib ib_uverbs ib_core fuse mlx5_core CPU: 15 UID: 0 PID: 1506 Comm: ibv_rc_pingpong Not tainted 6.12.0-rc7+ #1626 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:mlx5r_umr_post_send_wait+0x15a/0x2b0 [mlx5_ib] [..] Call Trace: <TASK> mlx5r_umr_update_xlt+0x23c/0x3e0 [mlx5_ib] mlx5_ib_invalidate_range+0x2e1/0x330 [mlx5_ib] __mmu_notifier_invalidate_range_start+0x1e1/0x240 zap_page_range_single+0xf1/0x1a0 madvise_vma_behavior+0x677/0x6e0 do_madvise+0x1a2/0x4b0 __x64_sys_madvise+0x25/0x30 do_syscall_64+0x6b/0x140 entry_SYSCALL_64_after_hwframe+0x76/0x7e",
      "cve": "CVE-2025-21732",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21732",
          "value": "CVE-2025-21732",
          "url": "https://scout.docker.com/v/CVE-2025-21732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "568b0163903b0ce14761750ad07acd7cd07356d6ca2e9a46ed2a255a2aac6fd3",
      "category": "container_scanning",
      "message": "CVE-2025-21734 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  misc: fastrpc: Fix copy buffer page size  For non-registered buffer, fastrpc driver copies the buffer and pass it to the remote subsystem. There is a problem with current implementation of page size calculation which is not considering the offset in the calculation. This might lead to passing of improper and out-of-bounds page size which could result in memory issue. Calculate page start and page end using the offset adjusted address instead of absolute address.",
      "cve": "CVE-2025-21734",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21734",
          "value": "CVE-2025-21734",
          "url": "https://scout.docker.com/v/CVE-2025-21734?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21734?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "59cf9ddc3b40b8fadcbfba099fe2cd0ce4f46349f109eb0e4e3226bcaa524c9a",
      "category": "container_scanning",
      "message": "CVE-2025-21738 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ata: libata-sff: Ensure that we cannot write outside the allocated buffer  reveliofuzzing reported that a SCSI_IOCTL_SEND_COMMAND ioctl with out_len set to 0xd42, SCSI command set to ATA_16 PASS-THROUGH, ATA command set to ATA_NOP, and protocol set to ATA_PROT_PIO, can cause ata_pio_sector() to write outside the allocated buffer, overwriting random memory.  While a ATA device is supposed to abort a ATA_NOP command, there does seem to be a bug either in libata-sff or QEMU, where either this status is not set, or the status is cleared before read by ata_sff_hsm_move(). Anyway, that is most likely a separate bug.  Looking at __atapi_pio_bytes(), it already has a safety check to ensure that __atapi_pio_bytes() cannot write outside the allocated buffer.  Add a similar check to ata_pio_sector(), such that also ata_pio_sector() cannot write outside the allocated buffer.",
      "cve": "CVE-2025-21738",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21738",
          "value": "CVE-2025-21738",
          "url": "https://scout.docker.com/v/CVE-2025-21738?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21738?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c3f9931a09251cf6943f3db4f372bff76124046932b50238cc536921ae92c050",
      "category": "container_scanning",
      "message": "CVE-2025-21739 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Fix use-after free in init error and remove paths  devm_blk_crypto_profile_init() registers a cleanup handler to run when the associated (platform-) device is being released. For UFS, the crypto private data and pointers are stored as part of the ufs_hba's data structure 'struct ufs_hba::crypto_profile'. This structure is allocated as part of the underlying ufshcd and therefore Scsi_host allocation.  During driver release or during error handling in ufshcd_pltfrm_init(), this structure is released as part of ufshcd_dealloc_host() before the (platform-) device associated with the crypto call above is released. Once this device is released, the crypto cleanup code will run, using the just-released 'struct ufs_hba::crypto_profile'. This causes a use-after-free situation:  Call trace: kfree+0x60/0x2d8 (P) kvfree+0x44/0x60 blk_crypto_profile_destroy_callback+0x28/0x70 devm_action_release+0x1c/0x30 release_nodes+0x6c/0x108 devres_release_all+0x98/0x100 device_unbind_cleanup+0x20/0x70 really_probe+0x218/0x2d0  In other words, the initialisation code flow is:  platform-device probe ufshcd_pltfrm_init() ufshcd_alloc_host() scsi_host_alloc() allocation of struct ufs_hba creation of scsi-host devices devm_blk_crypto_profile_init() devm registration of cleanup handler using platform-device  and during error handling of ufshcd_pltfrm_init() or during driver removal:  ufshcd_dealloc_host() scsi_host_put() put_device(scsi-host) release of struct ufs_hba put_device(platform-device) crypto cleanup handler  To fix this use-after free, change ufshcd_alloc_host() to register a devres action to automatically cleanup the underlying SCSI device on ufshcd destruction, without requiring explicit calls to ufshcd_dealloc_host(). This way:  * the crypto profile and all other ufs_hba-owned resources are destroyed before SCSI (as they've been registered after) * a memleak is plugged in tc-dwc-g210-pci.c remove() as a side-effect * EXPORT_SYMBOL_GPL(ufshcd_dealloc_host) can be removed fully as it's not needed anymore * no future drivers using ufshcd_alloc_host() could ever forget adding the cleanup",
      "cve": "CVE-2025-21739",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21739",
          "value": "CVE-2025-21739",
          "url": "https://scout.docker.com/v/CVE-2025-21739?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21739?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "af4932464630b02727a4d692403ebc890e94d8e21b4fd9818b399a6271550be0",
      "category": "container_scanning",
      "message": "CVE-2025-21750 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: brcmfmac: Check the return value of of_property_read_string_index()  Somewhen between 6.10 and 6.11 the driver started to crash on my MacBookPro14,3. The property doesn't exist and 'tmp' remains uninitialized, so we pass a random pointer to devm_kstrdup().  The crash I am getting looks like this:  BUG: unable to handle page fault for address: 00007f033c669379 PF: supervisor read access in kernel mode PF: error_code(0x0001) - permissions violation PGD 8000000101341067 P4D 8000000101341067 PUD 101340067 PMD 1013bb067 PTE 800000010aee9025 Oops: Oops: 0001 [#1] SMP PTI CPU: 4 UID: 0 PID: 827 Comm: (udev-worker) Not tainted 6.11.8-gentoo #1 Hardware name: Apple Inc. MacBookPro14,3/Mac-551B86E5744E2388, BIOS 529.140.2.0.0 06/23/2024 RIP: 0010:strlen+0x4/0x30 Code: f7 75 ec 31 c0 c3 cc cc cc cc 48 89 f8 c3 cc cc cc cc 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa <80> 3f 00 74 14 48 89 f8 48 83 c0 01 80 38 00 75 f7 48 29 f8 c3 cc RSP: 0018:ffffb4aac0683ad8 EFLAGS: 00010202 RAX: 00000000ffffffea RBX: 00007f033c669379 RCX: 0000000000000001 RDX: 0000000000000cc0 RSI: 00007f033c669379 RDI: 00007f033c669379 RBP: 00000000ffffffea R08: 0000000000000000 R09: 00000000c0ba916a R10: ffffffffffffffff R11: ffffffffb61ea260 R12: ffff91f7815b50c8 R13: 0000000000000cc0 R14: ffff91fafefffe30 R15: ffffb4aac0683b30 FS:  00007f033ccbe8c0(0000) GS:ffff91faeed00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f033c669379 CR3: 0000000107b1e004 CR4: 00000000003706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x149/0x4c0 ? raw_spin_rq_lock_nested+0xe/0x20 ? sched_balance_newidle+0x22b/0x3c0 ? update_load_avg+0x78/0x770 ? exc_page_fault+0x6f/0x150 ? asm_exc_page_fault+0x26/0x30 ? __pfx_pci_conf1_write+0x10/0x10 ? strlen+0x4/0x30 devm_kstrdup+0x25/0x70 brcmf_of_probe+0x273/0x350 [brcmfmac]",
      "cve": "CVE-2025-21750",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21750",
          "value": "CVE-2025-21750",
          "url": "https://scout.docker.com/v/CVE-2025-21750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "31acaf5a8daf9e731cf1cf3dc9402d53ccdba5ce60cee772dbc03da3d9582a64",
      "category": "container_scanning",
      "message": "CVE-2025-21751 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: HWS, change error flow on matcher disconnect  Currently, when firmware failure occurs during matcher disconnect flow, the error flow of the function reconnects the matcher back and returns an error, which continues running the calling function and eventually frees the matcher that is being disconnected. This leads to a case where we have a freed matcher on the matchers list, which in turn leads to use-after-free and eventual crash.  This patch fixes that by not trying to reconnect the matcher back when some FW command fails during disconnect.  Note that we're dealing here with FW error. We can't overcome this problem. This might lead to bad steering state (e.g. wrong connection between matchers), and will also lead to resource leakage, as it is the case with any other error handling during resource destruction.  However, the goal here is to allow the driver to continue and not crash the machine with use-after-free error.",
      "cve": "CVE-2025-21751",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21751",
          "value": "CVE-2025-21751",
          "url": "https://scout.docker.com/v/CVE-2025-21751?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21751?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "208c1eed51d5b164e6cab5bc8e2ac9bc6636761d37d02ad7c7ab43237c8e154d",
      "category": "container_scanning",
      "message": "CVE-2025-21752 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't use btrfs_set_item_key_safe on RAID stripe-extents  Don't use btrfs_set_item_key_safe() to modify the keys in the RAID stripe-tree, as this can lead to corruption of the tree, which is caught by the checks in btrfs_set_item_key_safe():  BTRFS info (device nvme1n1): leaf 49168384 gen 15 total ptrs 194 free space 8329 owner 12 BTRFS info (device nvme1n1): refs 2 lock_owner 1030 current 1030 [ snip ] item 105 key (354549760 230 20480) itemoff 14587 itemsize 16 stride 0 devid 5 physical 67502080 item 106 key (354631680 230 4096) itemoff 14571 itemsize 16 stride 0 devid 1 physical 88559616 item 107 key (354631680 230 32768) itemoff 14555 itemsize 16 stride 0 devid 1 physical 88555520 item 108 key (354717696 230 28672) itemoff 14539 itemsize 16 stride 0 devid 2 physical 67604480 [ snip ] BTRFS critical (device nvme1n1): slot 106 key (354631680 230 32768) new key (354635776 230 4096) ------------[ cut here ]------------ kernel BUG at fs/btrfs/ctree.c:2602! Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI CPU: 1 UID: 0 PID: 1055 Comm: fsstress Not tainted 6.13.0-rc1+ #1464 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 RIP: 0010:btrfs_set_item_key_safe+0xf7/0x270 Code: <snip> RSP: 0018:ffffc90001337ab0 EFLAGS: 00010287 RAX: 0000000000000000 RBX: ffff8881115fd000 RCX: 0000000000000000 RDX: 0000000000000001 RSI: 0000000000000001 RDI: 00000000ffffffff RBP: ffff888110ed6f50 R08: 00000000ffffefff R09: ffffffff8244c500 R10: 00000000ffffefff R11: 00000000ffffffff R12: ffff888100586000 R13: 00000000000000c9 R14: ffffc90001337b1f R15: ffff888110f23b58 FS:  00007f7d75c72740(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fa811652c60 CR3: 0000000111398001 CR4: 0000000000370eb0 Call Trace: <TASK> ? __die_body.cold+0x14/0x1a ? die+0x2e/0x50 ? do_trap+0xca/0x110 ? do_error_trap+0x65/0x80 ? btrfs_set_item_key_safe+0xf7/0x270 ? exc_invalid_op+0x50/0x70 ? btrfs_set_item_key_safe+0xf7/0x270 ? asm_exc_invalid_op+0x1a/0x20 ? btrfs_set_item_key_safe+0xf7/0x270 btrfs_partially_delete_raid_extent+0xc4/0xe0 btrfs_delete_raid_extent+0x227/0x240 __btrfs_free_extent.isra.0+0x57f/0x9c0 ? exc_coproc_segment_overrun+0x40/0x40 __btrfs_run_delayed_refs+0x2fa/0xe80 btrfs_run_delayed_refs+0x81/0xe0 btrfs_commit_transaction+0x2dd/0xbe0 ? preempt_count_add+0x52/0xb0 btrfs_sync_file+0x375/0x4c0 do_fsync+0x39/0x70 __x64_sys_fsync+0x13/0x20 do_syscall_64+0x54/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f7d7550ef90 Code: <snip> RSP: 002b:00007ffd70237248 EFLAGS: 00000202 ORIG_RAX: 000000000000004a RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f7d7550ef90 RDX: 000000000000013a RSI: 000000000040eb28 RDI: 0000000000000004 RBP: 000000000000001b R08: 0000000000000078 R09: 00007ffd7023725c R10: 00007f7d75400390 R11: 0000000000000202 R12: 028f5c28f5c28f5c R13: 8f5c28f5c28f5c29 R14: 000000000040b520 R15: 00007f7d75c726c8 </TASK>  While the root cause of the tree order corruption isn't clear, using btrfs_duplicate_item() to copy the item and then adjusting both the key and the per-device physical addresses is a safe way to counter this problem.",
      "cve": "CVE-2025-21752",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21752",
          "value": "CVE-2025-21752",
          "url": "https://scout.docker.com/v/CVE-2025-21752?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21752?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d4bb32fadc05dc1482467d470fa1a5b62fa3a4a457949683dc0996ce4f36d598",
      "category": "container_scanning",
      "message": "CVE-2025-21759 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipv6: mcast: extend RCU protection in igmp6_send()  igmp6_send() can be called without RTNL or RCU being held.  Extend RCU protection so that we can safely fetch the net pointer and avoid a potential UAF.  Note that we no longer can use sock_alloc_send_skb() because ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.  Instead use alloc_skb() and charge the net->ipv6.igmp_sk socket under RCU protection.",
      "cve": "CVE-2025-21759",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21759",
          "value": "CVE-2025-21759",
          "url": "https://scout.docker.com/v/CVE-2025-21759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "10e376cf64c1bf77405112c18d138116e806f0039ffcd860877d3abdfe832a1c",
      "category": "container_scanning",
      "message": "CVE-2025-21768 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ipv6: fix dst ref loops in rpl, seg6 and ioam6 lwtunnels  Some lwtunnels have a dst cache for post-transformation dst. If the packet destination did not change we may end up recording a reference to the lwtunnel in its own cache, and the lwtunnel state will never be freed.  Discovered by the ioam6.sh test, kmemleak was recently fixed to catch per-cpu memory leaks. I'm not sure if rpl and seg6 can actually hit this, but in principle I don't see why not.",
      "cve": "CVE-2025-21768",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21768",
          "value": "CVE-2025-21768",
          "url": "https://scout.docker.com/v/CVE-2025-21768?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21768?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2cb3d747cfc877d8212811b2c9fcd7dd8489a0c3a457d5ebe6cdd6f58732cd6",
      "category": "container_scanning",
      "message": "CVE-2025-21786 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  workqueue: Put the pwq after detaching the rescuer from the pool  The commit 68f83057b913(\"workqueue: Reap workers via kthread_stop() and remove detach_completion\") adds code to reap the normal workers but mistakenly does not handle the rescuer and also removes the code waiting for the rescuer in put_unbound_pool(), which caused a use-after-free bug reported by Cheung Wall.  To avoid the use-after-free bug, the pools reference must be held until the detachment is complete. Therefore, move the code that puts the pwq after detaching the rescuer from the pool.",
      "cve": "CVE-2025-21786",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21786",
          "value": "CVE-2025-21786",
          "url": "https://scout.docker.com/v/CVE-2025-21786?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21786?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0dbbad31c83b08cb93bc027f7a734d593ec39315c157bf5d5db68e8b74e9a2e4",
      "category": "container_scanning",
      "message": "CVE-2025-21801 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ravb: Fix missing rtnl lock in suspend/resume path  Fix the suspend/resume path by ensuring the rtnl lock is held where required. Calls to ravb_open, ravb_close and wol operations must be performed under the rtnl lock to prevent conflicts with ongoing ndo operations.  Without this fix, the following warning is triggered: [   39.032969] ============================= [   39.032983] WARNING: suspicious RCU usage [   39.033019] ----------------------------- [   39.033033] drivers/net/phy/phy_device.c:2004 suspicious rcu_dereference_protected() usage! ... [   39.033597] stack backtrace: [   39.033613] CPU: 0 UID: 0 PID: 174 Comm: python3 Not tainted 6.13.0-rc7-next-20250116-arm64-renesas-00002-g35245dfdc62c #7 [   39.033623] Hardware name: Renesas SMARC EVK version 2 based on r9a08g045s33 (DT) [   39.033628] Call trace: [   39.033633]  show_stack+0x14/0x1c (C) [   39.033652]  dump_stack_lvl+0xb4/0xc4 [   39.033664]  dump_stack+0x14/0x1c [   39.033671]  lockdep_rcu_suspicious+0x16c/0x22c [   39.033682]  phy_detach+0x160/0x190 [   39.033694]  phy_disconnect+0x40/0x54 [   39.033703]  ravb_close+0x6c/0x1cc [   39.033714]  ravb_suspend+0x48/0x120 [   39.033721]  dpm_run_callback+0x4c/0x14c [   39.033731]  device_suspend+0x11c/0x4dc [   39.033740]  dpm_suspend+0xdc/0x214 [   39.033748]  dpm_suspend_start+0x48/0x60 [   39.033758]  suspend_devices_and_enter+0x124/0x574 [   39.033769]  pm_suspend+0x1ac/0x274 [   39.033778]  state_store+0x88/0x124 [   39.033788]  kobj_attr_store+0x14/0x24 [   39.033798]  sysfs_kf_write+0x48/0x6c [   39.033808]  kernfs_fop_write_iter+0x118/0x1a8 [   39.033817]  vfs_write+0x27c/0x378 [   39.033825]  ksys_write+0x64/0xf4 [   39.033833]  __arm64_sys_write+0x18/0x20 [   39.033841]  invoke_syscall+0x44/0x104 [   39.033852]  el0_svc_common.constprop.0+0xb4/0xd4 [   39.033862]  do_el0_svc+0x18/0x20 [   39.033870]  el0_svc+0x3c/0xf0 [   39.033880]  el0t_64_sync_handler+0xc0/0xc4 [   39.033888]  el0t_64_sync+0x154/0x158 [   39.041274] ravb 11c30000.ethernet eth0: Link is Down",
      "cve": "CVE-2025-21801",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21801",
          "value": "CVE-2025-21801",
          "url": "https://scout.docker.com/v/CVE-2025-21801?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21801?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c664b0668f28cb9756aa8354dee869d310de5caedcefae864099d9d340aebb5b",
      "category": "container_scanning",
      "message": "CVE-2025-21812 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: rcu protect dev->ax25_ptr  syzbot found a lockdep issue [1].  We should remove ax25 RTNL dependency in ax25_setsockopt()  This should also fix a variety of possible UAF in ax25.  [1]  WARNING: possible circular locking dependency detected 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted ------------------------------------------------------ syz.5.1818/12806 is trying to acquire lock: ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680  but task is already holding lock: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #1 (sk_lock-AF_AX25){+.+.}-{0:0}: lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 lock_sock_nested+0x48/0x100 net/core/sock.c:3642 lock_sock include/net/sock.h:1618 [inline] ax25_kill_by_device net/ax25/af_ax25.c:101 [inline] ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146 notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85 __dev_notify_flags+0x207/0x400 dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026 dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563 dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820 sock_do_ioctl+0x240/0x460 net/socket.c:1234 sock_ioctl+0x626/0x8e0 net/socket.c:1339 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  -> #0 (rtnl_mutex){+.+.}-{4:4}: check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/locking/lockdep.c:3280 [inline] validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904 __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735 ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680 do_sock_setsockopt+0x3af/0x720 net/socket.c:2324 __sys_setsockopt net/socket.c:2349 [inline] __do_sys_setsockopt net/socket.c:2355 [inline] __se_sys_setsockopt net/socket.c:2352 [inline] __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  other info that might help us debug this:  Possible unsafe locking scenario:  CPU0                    CPU1 ----                    ---- lock(sk_lock-AF_AX25); lock(rtnl_mutex); lock(sk_lock-AF_AX25); lock(rtnl_mutex);  *** DEADLOCK ***  1 lock held by syz.5.1818/12806: #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574  stack backtrace: CPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074 check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206 check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/lockin ---truncated---",
      "cve": "CVE-2025-21812",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21812",
          "value": "CVE-2025-21812",
          "url": "https://scout.docker.com/v/CVE-2025-21812?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21812?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "78b625c96d3253e22887ca3d47f41d5e2e1dbe25e3b6180bb764151f38b6141a",
      "category": "container_scanning",
      "message": "CVE-2025-21825 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Cancel the running bpf_timer through kworker for PREEMPT_RT  During the update procedure, when overwrite element in a pre-allocated htab, the freeing of old_element is protected by the bucket lock. The reason why the bucket lock is necessary is that the old_element has already been stashed in htab->extra_elems after alloc_htab_elem() returns. If freeing the old_element after the bucket lock is unlocked, the stashed element may be reused by concurrent update procedure and the freeing of old_element will run concurrently with the reuse of the old_element. However, the invocation of check_and_free_fields() may acquire a spin-lock which violates the lockdep rule because its caller has already held a raw-spin-lock (bucket lock). The following warning will be reported when such race happens:  BUG: scheduling while atomic: test_progs/676/0x00000003 3 locks held by test_progs/676: #0: ffffffff864b0240 (rcu_read_lock_trace){....}-{0:0}, at: bpf_prog_test_run_syscall+0x2c0/0x830 #1: ffff88810e961188 (&htab->lockdep_key){....}-{2:2}, at: htab_map_update_elem+0x306/0x1500 #2: ffff8881f4eac1b8 (&base->softirq_expiry_lock){....}-{2:2}, at: hrtimer_cancel_wait_running+0xe9/0x1b0 Modules linked in: bpf_testmod(O) Preemption disabled at: [<ffffffff817837a3>] htab_map_update_elem+0x293/0x1500 CPU: 0 UID: 0 PID: 676 Comm: test_progs Tainted: G ... 6.12.0+ #11 Tainted: [W]=WARN, [O]=OOT_MODULE Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)... Call Trace: <TASK> dump_stack_lvl+0x57/0x70 dump_stack+0x10/0x20 __schedule_bug+0x120/0x170 __schedule+0x300c/0x4800 schedule_rtlock+0x37/0x60 rtlock_slowlock_locked+0x6d9/0x54c0 rt_spin_lock+0x168/0x230 hrtimer_cancel_wait_running+0xe9/0x1b0 hrtimer_cancel+0x24/0x30 bpf_timer_delete_work+0x1d/0x40 bpf_timer_cancel_and_free+0x5e/0x80 bpf_obj_free_fields+0x262/0x4a0 check_and_free_fields+0x1d0/0x280 htab_map_update_elem+0x7fc/0x1500 bpf_prog_9f90bc20768e0cb9_overwrite_cb+0x3f/0x43 bpf_prog_ea601c4649694dbd_overwrite_timer+0x5d/0x7e bpf_prog_test_run_syscall+0x322/0x830 __sys_bpf+0x135d/0x3ca0 __x64_sys_bpf+0x75/0xb0 x64_sys_call+0x1b5/0xa10 do_syscall_64+0x3b/0xc0 entry_SYSCALL_64_after_hwframe+0x4b/0x53 ... </TASK>  It seems feasible to break the reuse and refill of per-cpu extra_elems into two independent parts: reuse the per-cpu extra_elems with bucket lock being held and refill the old_element as per-cpu extra_elems after the bucket lock is unlocked. However, it will make the concurrent overwrite procedures on the same CPU return unexpected -E2BIG error when the map is full.  Therefore, the patch fixes the lock problem by breaking the cancelling of bpf_timer into two steps for PREEMPT_RT: 1) use hrtimer_try_to_cancel() and check its return value 2) if the timer is running, use hrtimer_cancel() through a kworker to cancel it again Considering that the current implementation of hrtimer_cancel() will try to acquire a being held softirq_expiry_lock when the current timer is running, these steps above are reasonable. However, it also has downside. When the timer is running, the cancelling of the timer is delayed when releasing the last map uref. The delay is also fixable (e.g., break the cancelling of bpf timer into two parts: one part in locked scope, another one in unlocked scope), it can be revised later if necessary.  It is a bit hard to decide the right fix tag. One reason is that the problem depends on PREEMPT_RT which is enabled in v6.12. Considering the softirq_expiry_lock lock exists since v5.4 and bpf_timer is introduced in v5.15, the bpf_timer commit is used in the fixes tag and an extra depends-on tag is added to state the dependency on PREEMPT_RT.  Depends-on: v6.12+ with PREEMPT_RT enabled",
      "cve": "CVE-2025-21825",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21825",
          "value": "CVE-2025-21825",
          "url": "https://scout.docker.com/v/CVE-2025-21825?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21825?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d685b9c5cc105bf703ec1e8783153eb3baec2c22a81069e98cf86a3bf4d37aa7",
      "category": "container_scanning",
      "message": "CVE-2025-21831 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: Avoid putting some root ports into D3 on TUXEDO Sirius Gen1  commit 9d26d3a8f1b0 (\"PCI: Put PCIe ports into D3 during suspend\") sets the policy that all PCIe ports are allowed to use D3.  When the system is suspended if the port is not power manageable by the platform and won't be used for wakeup via a PME this sets up the policy for these ports to go into D3hot.  This policy generally makes sense from an OSPM perspective but it leads to problems with wakeup from suspend on the TUXEDO Sirius 16 Gen 1 with a specific old BIOS. This manifests as a system hang.  On the affected Device + BIOS combination, add a quirk for the root port of the problematic controller to ensure that these root ports are not put into D3hot at suspend.  This patch is based on   https://lore.kernel.org/linux-pci/20230708214457.1229-2-mario.limonciello@amd.com  but with the added condition both in the documentation and in the code to apply only to the TUXEDO Sirius 16 Gen 1 with a specific old BIOS and only the affected root ports.",
      "cve": "CVE-2025-21831",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21831",
          "value": "CVE-2025-21831",
          "url": "https://scout.docker.com/v/CVE-2025-21831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0443504f93e276e96f628ba6a1313372c91310901db6d53bdcd2e6b8f2ec847e",
      "category": "container_scanning",
      "message": "CVE-2025-21832 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: don't revert iter for -EIOCBQUEUED  blkdev_read_iter() has a few odd checks, like gating the position and count adjustment on whether or not the result is bigger-than-or-equal to zero (where bigger than makes more sense), and not checking the return value of blkdev_direct_IO() before doing an iov_iter_revert(). The latter can lead to attempting to revert with a negative value, which when passed to iov_iter_revert() as an unsigned value will lead to throwing a WARN_ON() because unroll is bigger than MAX_RW_COUNT.  Be sane and don't revert for -EIOCBQUEUED, like what is done in other spots.",
      "cve": "CVE-2025-21832",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21832",
          "value": "CVE-2025-21832",
          "url": "https://scout.docker.com/v/CVE-2025-21832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ba99c0361a79a3fffbe5a347ed59a5b8243178e4be63d88be4ad426aba41613c",
      "category": "container_scanning",
      "message": "CVE-2025-21838 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: gadget: core: flush gadget workqueue after device removal  device_del() can lead to new work being scheduled in gadget->work workqueue. This is observed, for example, with the dwc3 driver with the following call stack: device_del() gadget_unbind_driver() usb_gadget_disconnect_locked() dwc3_gadget_pullup() dwc3_gadget_soft_disconnect() usb_gadget_set_state() schedule_work(&gadget->work)  Move flush_work() after device_del() to ensure the workqueue is cleaned up.",
      "cve": "CVE-2025-21838",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21838",
          "value": "CVE-2025-21838",
          "url": "https://scout.docker.com/v/CVE-2025-21838?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21838?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b5eaebea440d4c388ccfbd3d26102c10c2c91fe11dad1db879470ea9eb7adecc",
      "category": "container_scanning",
      "message": "CVE-2025-21872 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  efi: Don't map the entire mokvar table to determine its size  Currently, when validating the mokvar table, we (re)map the entire table on each iteration of the loop, adding space as we discover new entries. If the table grows over a certain size, this fails due to limitations of early_memmap(), and we get a failure and traceback:  ------------[ cut here ]------------ WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:139 __early_ioremap+0xef/0x220 ... Call Trace: <TASK> ? __early_ioremap+0xef/0x220 ? __warn.cold+0x93/0xfa ? __early_ioremap+0xef/0x220 ? report_bug+0xff/0x140 ? early_fixup_exception+0x5d/0xb0 ? early_idt_handler_common+0x2f/0x3a ? __early_ioremap+0xef/0x220 ? efi_mokvar_table_init+0xce/0x1d0 ? setup_arch+0x864/0xc10 ? start_kernel+0x6b/0xa10 ? x86_64_start_reservations+0x24/0x30 ? x86_64_start_kernel+0xed/0xf0 ? common_startup_64+0x13e/0x141 </TASK> ---[ end trace 0000000000000000 ]--- mokvar: Failed to map EFI MOKvar config table pa=0x7c4c3000, size=265187.  Mapping the entire structure isn't actually necessary, as we don't ever need more than one entry header mapped at once.  Changes efi_mokvar_table_init() to only map each entry header, not the entire table, when determining the table size.  Since we're not mapping any data past the variable name, it also changes the code to enforce that each variable name is NUL terminated, rather than attempting to verify it in place.",
      "cve": "CVE-2025-21872",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21872",
          "value": "CVE-2025-21872",
          "url": "https://scout.docker.com/v/CVE-2025-21872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ab7c8319842ed79daea328496ee7cda6c6b5843055790a19d3f05a9db777afd9",
      "category": "container_scanning",
      "message": "CVE-2025-21881 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  uprobes: Reject the shared zeropage in uprobe_write_opcode()  We triggered the following crash in syzkaller tests:  BUG: Bad page state in process syz.7.38  pfn:1eff3 page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1eff3 flags: 0x3fffff00004004(referenced|reserved|node=0|zone=1|lastcpupid=0x1fffff) raw: 003fffff00004004 ffffe6c6c07bfcc8 ffffe6c6c07bfcc8 0000000000000000 raw: 0000000000000000 0000000000000000 00000000fffffffe 0000000000000000 page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x32/0x50 bad_page+0x69/0xf0 free_unref_page_prepare+0x401/0x500 free_unref_page+0x6d/0x1b0 uprobe_write_opcode+0x460/0x8e0 install_breakpoint.part.0+0x51/0x80 register_for_each_vma+0x1d9/0x2b0 __uprobe_register+0x245/0x300 bpf_uprobe_multi_link_attach+0x29b/0x4f0 link_create+0x1e2/0x280 __sys_bpf+0x75f/0xac0 __x64_sys_bpf+0x1a/0x30 do_syscall_64+0x56/0x100 entry_SYSCALL_64_after_hwframe+0x78/0xe2  BUG: Bad rss-counter state mm:00000000452453e0 type:MM_FILEPAGES val:-1  The following syzkaller test case can be used to reproduce:  r2 = creat(&(0x7f0000000000)='./file0\\x00', 0x8) write$nbd(r2, &(0x7f0000000580)=ANY=[], 0x10) r4 = openat(0xffffffffffffff9c, &(0x7f0000000040)='./file0\\x00', 0x42, 0x0) mmap$IORING_OFF_SQ_RING(&(0x7f0000ffd000/0x3000)=nil, 0x3000, 0x0, 0x12, r4, 0x0) r5 = userfaultfd(0x80801) ioctl$UFFDIO_API(r5, 0xc018aa3f, &(0x7f0000000040)={0xaa, 0x20}) r6 = userfaultfd(0x80801) ioctl$UFFDIO_API(r6, 0xc018aa3f, &(0x7f0000000140)) ioctl$UFFDIO_REGISTER(r6, 0xc020aa00, &(0x7f0000000100)={{&(0x7f0000ffc000/0x4000)=nil, 0x4000}, 0x2}) ioctl$UFFDIO_ZEROPAGE(r5, 0xc020aa04, &(0x7f0000000000)={{&(0x7f0000ffd000/0x1000)=nil, 0x1000}}) r7 = bpf$PROG_LOAD(0x5, &(0x7f0000000140)={0x2, 0x3, &(0x7f0000000200)=ANY=[@ANYBLOB=\"1800000000120000000000000000000095\"], &(0x7f0000000000)='GPL\\x00', 0x7, 0x0, 0x0, 0x0, 0x0, '\\x00', 0x0, @fallback=0x30, 0xffffffffffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, @void, @value}, 0x94) bpf$BPF_LINK_CREATE_XDP(0x1c, &(0x7f0000000040)={r7, 0x0, 0x30, 0x1e, @val=@uprobe_multi={&(0x7f0000000080)='./file0\\x00', &(0x7f0000000100)=[0x2], 0x0, 0x0, 0x1}}, 0x40)  The cause is that zero pfn is set to the PTE without increasing the RSS count in mfill_atomic_pte_zeropage() and the refcount of zero folio does not increase accordingly. Then, the operation on the same pfn is performed in uprobe_write_opcode()->__replace_page() to unconditional decrease the RSS count and old_folio's refcount.  Therefore, two bugs are introduced:  1. The RSS count is incorrect, when process exit, the check_mm() report error \"Bad rss-count\".  2. The reserved folio (zero folio) is freed when folio->refcount is zero, then free_pages_prepare->free_page_is_bad() report error \"Bad page state\".  There is more, the following warning could also theoretically be triggered:  __replace_page() -> ... -> folio_remove_rmap_pte() -> VM_WARN_ON_FOLIO(is_zero_folio(folio), folio)  Considering that uprobe hit on the zero folio is a very rare case, just reject zero old folio immediately after get_user_page_vma_remote().  [ mingo: Cleaned up the changelog ]",
      "cve": "CVE-2025-21881",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21881",
          "value": "CVE-2025-21881",
          "url": "https://scout.docker.com/v/CVE-2025-21881?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21881?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d693a9fc01cc1780af53db155ed75d6450d5bb76bfd490385b1bec748a038c26",
      "category": "container_scanning",
      "message": "CVE-2025-21885 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/bnxt_re: Fix the page details for the srq created by kernel consumers  While using nvme target with use_srq on, below kernel panic is noticed.  [  549.698111] bnxt_en 0000:41:00.0 enp65s0np0: FEC autoneg off encoding: Clause 91 RS(544,514) [  566.393619] Oops: divide error: 0000 [#1] PREEMPT SMP NOPTI .. [  566.393799]  <TASK> [  566.393807]  ? __die_body+0x1a/0x60 [  566.393823]  ? die+0x38/0x60 [  566.393835]  ? do_trap+0xe4/0x110 [  566.393847]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re] [  566.393867]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re] [  566.393881]  ? do_error_trap+0x7c/0x120 [  566.393890]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re] [  566.393911]  ? exc_divide_error+0x34/0x50 [  566.393923]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re] [  566.393939]  ? asm_exc_divide_error+0x16/0x20 [  566.393966]  ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re] [  566.393997]  bnxt_qplib_create_srq+0xc9/0x340 [bnxt_re] [  566.394040]  bnxt_re_create_srq+0x335/0x3b0 [bnxt_re] [  566.394057]  ? srso_return_thunk+0x5/0x5f [  566.394068]  ? __init_swait_queue_head+0x4a/0x60 [  566.394090]  ib_create_srq_user+0xa7/0x150 [ib_core] [  566.394147]  nvmet_rdma_queue_connect+0x7d0/0xbe0 [nvmet_rdma] [  566.394174]  ? lock_release+0x22c/0x3f0 [  566.394187]  ? srso_return_thunk+0x5/0x5f  Page size and shift info is set only for the user space SRQs. Set page size and page shift for kernel space SRQs also.",
      "cve": "CVE-2025-21885",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21885",
          "value": "CVE-2025-21885",
          "url": "https://scout.docker.com/v/CVE-2025-21885?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21885?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aba8df720299c67cf2dd96b93bcb9c8931491e974a43676d64032de58f4ecc1d",
      "category": "container_scanning",
      "message": "CVE-2025-21894 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: enetc: VFs do not support HWTSTAMP_TX_ONESTEP_SYNC  Actually ENETC VFs do not support HWTSTAMP_TX_ONESTEP_SYNC because only ENETC PF can access PMa_SINGLE_STEP registers. And there will be a crash if VFs are used to test one-step timestamp, the crash log as follows.  [  129.110909] Unable to handle kernel paging request at virtual address 00000000000080c0 [  129.287769] Call trace: [  129.290219]  enetc_port_mac_wr+0x30/0xec (P) [  129.294504]  enetc_start_xmit+0xda4/0xe74 [  129.298525]  enetc_xmit+0x70/0xec [  129.301848]  dev_hard_start_xmit+0x98/0x118",
      "cve": "CVE-2025-21894",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21894",
          "value": "CVE-2025-21894",
          "url": "https://scout.docker.com/v/CVE-2025-21894?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21894?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "24ff1df2a89add3065152a6c78bad627574a190a7a2b14fd282333812361642a",
      "category": "container_scanning",
      "message": "CVE-2025-21899 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Fix bad hist from corrupting named_triggers list  The following commands causes a crash:  ~# cd /sys/kernel/tracing/events/rcu/rcu_callback ~# echo 'hist:name=bad:keys=common_pid:onmax(bogus).save(common_pid)' > trigger bash: echo: write error: Invalid argument ~# echo 'hist:name=bad:keys=common_pid' > trigger  Because the following occurs:  event_trigger_write() { trigger_process_regex() { event_hist_trigger_parse() {  data = event_trigger_alloc(..);  event_trigger_register(.., data) { cmd_ops->reg(.., data, ..) [hist_register_trigger()] { data->ops->init() [event_hist_trigger_init()] { save_named_trigger(name, data) { list_add(&data->named_list, &named_triggers); } } } }  ret = create_actions(); (return -EINVAL) if (ret) goto out_unreg; [..] ret = hist_trigger_enable(data, ...) { list_add_tail_rcu(&data->list, &file->triggers); <<<---- SKIPPED!!! (this is important!) [..] out_unreg: event_hist_unregister(.., data) { cmd_ops->unreg(.., data, ..) [hist_unregister_trigger()] { list_for_each_entry(iter, &file->triggers, list) { if (!hist_trigger_match(data, iter, named_data, false))   <- never matches continue; [..] test = iter; } if (test && test->ops->free) <<<-- test is NULL  test->ops->free(test) [event_hist_trigger_free()] { [..] if (data->name) del_named_trigger(data) { list_del(&data->named_list);  <<<<-- NEVER gets removed! } } } }  [..] kfree(data); <<<-- frees item but it is still on list  The next time a hist with name is registered, it causes an u-a-f bug and the kernel can crash.  Move the code around such that if event_trigger_register() succeeds, the next thing called is hist_trigger_enable() which adds it to the list.  A bunch of actions is called if get_named_trigger_data() returns false. But that doesn't need to be called after event_trigger_register(), so it can be moved up, allowing event_trigger_register() to be called just before hist_trigger_enable() keeping them together and allowing the file->triggers to be properly populated.",
      "cve": "CVE-2025-21899",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21899",
          "value": "CVE-2025-21899",
          "url": "https://scout.docker.com/v/CVE-2025-21899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3dade422ca2cb005961171390503e54e81e1e1e0a1781248924eb3b850589e82",
      "category": "container_scanning",
      "message": "CVE-2025-21931 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hwpoison, memory_hotplug: lock folio before unmap hwpoisoned folio  Commit b15c87263a69 (\"hwpoison, memory_hotplug: allow hwpoisoned pages to be offlined) add page poison checks in do_migrate_range in order to make offline hwpoisoned page possible by introducing isolate_lru_page and try_to_unmap for hwpoisoned page.  However folio lock must be held before calling try_to_unmap.  Add it to fix this problem.  Warning will be produced if folio is not locked during unmap:  ------------[ cut here ]------------ kernel BUG at ./include/linux/swapops.h:400! Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP Modules linked in: CPU: 4 UID: 0 PID: 411 Comm: bash Tainted: G        W 6.13.0-rc1-00016-g3c434c7ee82a-dirty #41 Tainted: [W]=WARN Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015 pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : try_to_unmap_one+0xb08/0xd3c lr : try_to_unmap_one+0x3dc/0xd3c Call trace: try_to_unmap_one+0xb08/0xd3c (P) try_to_unmap_one+0x3dc/0xd3c (L) rmap_walk_anon+0xdc/0x1f8 rmap_walk+0x3c/0x58 try_to_unmap+0x88/0x90 unmap_poisoned_folio+0x30/0xa8 do_migrate_range+0x4a0/0x568 offline_pages+0x5a4/0x670 memory_block_action+0x17c/0x374 memory_subsys_offline+0x3c/0x78 device_offline+0xa4/0xd0 state_store+0x8c/0xf0 dev_attr_store+0x18/0x2c sysfs_kf_write+0x44/0x54 kernfs_fop_write_iter+0x118/0x1a8 vfs_write+0x3a8/0x4bc ksys_write+0x6c/0xf8 __arm64_sys_write+0x1c/0x28 invoke_syscall+0x44/0x100 el0_svc_common.constprop.0+0x40/0xe0 do_el0_svc+0x1c/0x28 el0_svc+0x30/0xd0 el0t_64_sync_handler+0xc8/0xcc el0t_64_sync+0x198/0x19c Code: f9407be0 b5fff320 d4210000 17ffff97 (d4210000) ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2025-21931",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21931",
          "value": "CVE-2025-21931",
          "url": "https://scout.docker.com/v/CVE-2025-21931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b25452d33ebf50f3d3e5ba191e6f6f693fb11e370a837820429c5205801bf86e",
      "category": "container_scanning",
      "message": "CVE-2025-21944 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix bug on trap in smb2_lock  If lock count is greater than 1, flags could be old value. It should be checked with flags of smb_lock, not flags. It will cause bug-on trap from locks_free_lock in error handling routine.",
      "cve": "CVE-2025-21944",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21944",
          "value": "CVE-2025-21944",
          "url": "https://scout.docker.com/v/CVE-2025-21944?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21944?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b65f548e588f8226b9d0e3d3bc7726534ec8bc7a22a36f8f0fd59936fc4634a9",
      "category": "container_scanning",
      "message": "CVE-2025-21946 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix out-of-bounds in parse_sec_desc()  If osidoffset, gsidoffset and dacloffset could be greater than smb_ntsd struct size. If it is smaller, It could cause slab-out-of-bounds. And when validating sid, It need to check it included subauth array size.",
      "cve": "CVE-2025-21946",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21946",
          "value": "CVE-2025-21946",
          "url": "https://scout.docker.com/v/CVE-2025-21946?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21946?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e99abfd6ad088fd8f065442f5ed7d0b99577125609420a8cb090b24bfeb11e30",
      "category": "container_scanning",
      "message": "CVE-2025-21955 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: prevent connection release during oplock break notification  ksmbd_work could be freed when after connection release. Increment r_count of ksmbd_conn to indicate that requests are not finished yet and to not release the connection.",
      "cve": "CVE-2025-21955",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21955",
          "value": "CVE-2025-21955",
          "url": "https://scout.docker.com/v/CVE-2025-21955?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21955?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a8c061f9266b0c660fa15dd7b7f6bf6ab148e763d91ecbf8cfb71046d02d365",
      "category": "container_scanning",
      "message": "CVE-2025-21972 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: mctp: unshare packets when reassembling  Ensure that the frag_list used for reassembly isn't shared with other packets. This avoids incorrect reassembly when packets are cloned, and prevents a memory leak due to circular references between fragments and their skb_shared_info.  The upcoming MCTP-over-USB driver uses skb_clone which can trigger the problem - other MCTP drivers don't share SKBs.  A kunit test is added to reproduce the issue.",
      "cve": "CVE-2025-21972",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21972",
          "value": "CVE-2025-21972",
          "url": "https://scout.docker.com/v/CVE-2025-21972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "103a343056ea1376ea6825ecc7a99af244e4897c62a3d0c112c0822ae3c50161",
      "category": "container_scanning",
      "message": "CVE-2025-21976 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbdev: hyperv_fb: Allow graceful removal of framebuffer  When a Hyper-V framebuffer device is unbind, hyperv_fb driver tries to release the framebuffer forcefully. If this framebuffer is in use it produce the following WARN and hence this framebuffer is never released.  [   44.111220] WARNING: CPU: 35 PID: 1882 at drivers/video/fbdev/core/fb_info.c:70 framebuffer_release+0x2c/0x40 < snip > [   44.111289] Call Trace: [   44.111290]  <TASK> [   44.111291]  ? show_regs+0x6c/0x80 [   44.111295]  ? __warn+0x8d/0x150 [   44.111298]  ? framebuffer_release+0x2c/0x40 [   44.111300]  ? report_bug+0x182/0x1b0 [   44.111303]  ? handle_bug+0x6e/0xb0 [   44.111306]  ? exc_invalid_op+0x18/0x80 [   44.111308]  ? asm_exc_invalid_op+0x1b/0x20 [   44.111311]  ? framebuffer_release+0x2c/0x40 [   44.111313]  ? hvfb_remove+0x86/0xa0 [hyperv_fb] [   44.111315]  vmbus_remove+0x24/0x40 [hv_vmbus] [   44.111323]  device_remove+0x40/0x80 [   44.111325]  device_release_driver_internal+0x20b/0x270 [   44.111327]  ? bus_find_device+0xb3/0xf0  Fix this by moving the release of framebuffer and assosiated memory to fb_ops.fb_destroy function, so that framebuffer framework handles it gracefully.  While we fix this, also replace manual registrations/unregistration of framebuffer with devm_register_framebuffer.",
      "cve": "CVE-2025-21976",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21976",
          "value": "CVE-2025-21976",
          "url": "https://scout.docker.com/v/CVE-2025-21976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ae8774ff651e3cbdda8173fad4688d598d8b75c11fcef5e1e92cc09eb77a609b",
      "category": "container_scanning",
      "message": "CVE-2025-21985 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix out-of-bound accesses  [WHAT & HOW] hpo_stream_to_link_encoder_mapping has size MAX_HPO_DP2_ENCODERS(=4), but location can have size up to 6. As a result, it is necessary to check location against MAX_HPO_DP2_ENCODERS.  Similiarly, disp_cfg_stream_location can be used as an array index which should be 0..5, so the ASSERT's conditions should be less without equal.",
      "cve": "CVE-2025-21985",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21985",
          "value": "CVE-2025-21985",
          "url": "https://scout.docker.com/v/CVE-2025-21985?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21985?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5d899f5dd8ebba301596effc9b93ae55990fdd774c97e868b47c3adc2350a14",
      "category": "container_scanning",
      "message": "CVE-2025-21986 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: switchdev: Convert blocking notification chain to a raw one  A blocking notification chain uses a read-write semaphore to protect the integrity of the chain. The semaphore is acquired for writing when adding / removing notifiers to / from the chain and acquired for reading when traversing the chain and informing notifiers about an event.  In case of the blocking switchdev notification chain, recursive notifications are possible which leads to the semaphore being acquired twice for reading and to lockdep warnings being generated [1].  Specifically, this can happen when the bridge driver processes a SWITCHDEV_BRPORT_UNOFFLOADED event which causes it to emit notifications about deferred events when calling switchdev_deferred_process().  Fix this by converting the notification chain to a raw notification chain in a similar fashion to the netdev notification chain. Protect the chain using the RTNL mutex by acquiring it when modifying the chain. Events are always informed under the RTNL mutex, but add an assertion in call_switchdev_blocking_notifiers() to make sure this is not violated in the future.  Maintain the \"blocking\" prefix as events are always emitted from process context and listeners are allowed to block.  [1]: WARNING: possible recursive locking detected 6.14.0-rc4-custom-g079270089484 #1 Not tainted -------------------------------------------- ip/52731 is trying to acquire lock: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0  but task is already holding lock: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0  other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock((switchdev_blocking_notif_chain).rwsem); lock((switchdev_blocking_notif_chain).rwsem);  *** DEADLOCK *** May be due to missing lock nesting notation 3 locks held by ip/52731: #0: ffffffff84f795b0 (rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x727/0x1dc0 #1: ffffffff8731f628 (&net->rtnl_mutex){+.+.}-{4:4}, at: rtnl_newlink+0x790/0x1dc0 #2: ffffffff850918d8 ((switchdev_blocking_notif_chain).rwsem){++++}-{4:4}, at: blocking_notifier_call_chain+0x58/0xa0  stack backtrace: ... ? __pfx_down_read+0x10/0x10 ? __pfx_mark_lock+0x10/0x10 ? __pfx_switchdev_port_attr_set_deferred+0x10/0x10 blocking_notifier_call_chain+0x58/0xa0 switchdev_port_attr_notify.constprop.0+0xb3/0x1b0 ? __pfx_switchdev_port_attr_notify.constprop.0+0x10/0x10 ? mark_held_locks+0x94/0xe0 ? switchdev_deferred_process+0x11a/0x340 switchdev_port_attr_set_deferred+0x27/0xd0 switchdev_deferred_process+0x164/0x340 br_switchdev_port_unoffload+0xc8/0x100 [bridge] br_switchdev_blocking_event+0x29f/0x580 [bridge] notifier_call_chain+0xa2/0x440 blocking_notifier_call_chain+0x6e/0xa0 switchdev_bridge_port_unoffload+0xde/0x1a0 ...",
      "cve": "CVE-2025-21986",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21986",
          "value": "CVE-2025-21986",
          "url": "https://scout.docker.com/v/CVE-2025-21986?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21986?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "496977ecc28e209758023481210d63cc34f51d091319b6335c95f41b755cf1ff",
      "category": "container_scanning",
      "message": "CVE-2025-22019 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bcachefs: bch2_ioctl_subvolume_destroy() fixes  bch2_evict_subvolume_inodes() was getting stuck - due to incorrectly pruning the dcache.  Also, fix missing permissions checks.",
      "cve": "CVE-2025-22019",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22019",
          "value": "CVE-2025-22019",
          "url": "https://scout.docker.com/v/CVE-2025-22019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "620d0e5de4acbc0e4ceb00fbed2fa9ad8f5956bafeefc51bccf86b0719e35598",
      "category": "container_scanning",
      "message": "CVE-2025-22022 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: xhci: Apply the link chain quirk on NEC isoc endpoints  Two clearly different specimens of NEC uPD720200 (one with start/stop bug, one without) were seen to cause IOMMU faults after some Missed Service Errors. Faulting address is immediately after a transfer ring segment and patched dynamic debug messages revealed that the MSE was received when waiting for a TD near the end of that segment:  [ 1.041954] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ffa08fe0 [ 1.042120] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09000 flags=0x0000] [ 1.042146] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09040 flags=0x0000]  It gets even funnier if the next page is a ring segment accessible to the HC. Below, it reports MSE in segment at ff1e8000, plows through a zero-filled page at ff1e9000 and starts reporting events for TRBs in page at ff1ea000 every microframe, instead of jumping to seg ff1e6000.  [ 7.041671] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0 [ 7.041999] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0 [ 7.042011] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint [ 7.042028] xhci_hcd: All TDs skipped for slot 1 ep 2. Clear skip flag. [ 7.042134] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint [ 7.042138] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31 [ 7.042144] xhci_hcd: Looking for event-dma 00000000ff1ea040 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.042259] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpoint [ 7.042262] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31 [ 7.042266] xhci_hcd: Looking for event-dma 00000000ff1ea050 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820  At some point completion events change from Isoch Buffer Overrun to Short Packet and the HC finally finds cycle bit mismatch in ff1ec000.  [ 7.098130] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13 [ 7.098132] xhci_hcd: Looking for event-dma 00000000ff1ecc50 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.098254] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13 [ 7.098256] xhci_hcd: Looking for event-dma 00000000ff1ecc60 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820 [ 7.098379] xhci_hcd: Overrun event on slot 1 ep 2  It's possible that data from the isochronous device were written to random buffers of pending TDs on other endpoints (either IN or OUT), other devices or even other HCs in the same IOMMU domain.  Lastly, an error from a different USB device on another HC. Was it caused by the above? I don't know, but it may have been. The disk was working without any other issues and generated PCIe traffic to starve the NEC of upstream BW and trigger those MSEs. The two HCs shared one x1 slot by means of a commercial \"PCIe splitter\" board.  [ 7.162604] usb 10-2: reset SuperSpeed USB device number 3 using xhci_hcd [ 7.178990] sd 9:0:0:0: [sdb] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x07 driverbyte=DRIVER_OK cmd_age=0s [ 7.179001] sd 9:0:0:0: [sdb] tag#0 CDB: opcode=0x28 28 00 04 02 ae 00 00 02 00 00 [ 7.179004] I/O error, dev sdb, sector 67284480 op 0x0:(READ) flags 0x80700 phys_seg 5 prio class 0  Fortunately, it appears that this ridiculous bug is avoided by setting the chain bit of Link TRBs on isochronous rings. Other ancient HCs are known which also expect the bit to be set and they ignore Link TRBs if it's not. Reportedly, 0.95 spec guaranteed that the bit is set.  The bandwidth-starved NEC HC running a 32KB/uframe UVC endpoint reports tens of MSEs per second and runs into the bug within seconds. Chaining Link TRBs allows the same workload to run for many minutes, many times.  No ne ---truncated---",
      "cve": "CVE-2025-22022",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22022",
          "value": "CVE-2025-22022",
          "url": "https://scout.docker.com/v/CVE-2025-22022?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22022?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8b83ec16e32eb183f0a60e4632452acbb4247d72e9d5858947224ec58ab4c072",
      "category": "container_scanning",
      "message": "CVE-2025-22026 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nfsd: don't ignore the return code of svc_proc_register()  Currently, nfsd_proc_stat_init() ignores the return value of svc_proc_register(). If the procfile creation fails, then the kernel will WARN when it tries to remove the entry later.  Fix nfsd_proc_stat_init() to return the same type of pointer as svc_proc_register(), and fix up nfsd_net_init() to check that and fail the nfsd_net construction if it occurs.  svc_proc_register() can fail if the dentry can't be allocated, or if an identical dentry already exists. The second case is pretty unlikely in the nfsd_net construction codepath, so if this happens, return -ENOMEM.",
      "cve": "CVE-2025-22026",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22026",
          "value": "CVE-2025-22026",
          "url": "https://scout.docker.com/v/CVE-2025-22026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f9a1ad9e3418e30b9ff6df02d495e3015d4bf738f95710df6bd39703a2d05039",
      "category": "container_scanning",
      "message": "CVE-2025-22028 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: vimc: skip .s_stream() for stopped entities  Syzbot reported [1] a warning prompted by a check in call_s_stream() that checks whether .s_stream() operation is warranted for unstarted or stopped subdevs.  Add a simple fix in vimc_streamer_pipeline_terminate() ensuring that entities skip a call to .s_stream() unless they have been previously properly started.  [1] Syzbot report: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 5933 at drivers/media/v4l2-core/v4l2-subdev.c:460 call_s_stream+0x2df/0x350 drivers/media/v4l2-core/v4l2-subdev.c:460 Modules linked in: CPU: 0 UID: 0 PID: 5933 Comm: syz-executor330 Not tainted 6.13.0-rc2-syzkaller-00362-g2d8308bf5b67 #0 ... Call Trace: <TASK> vimc_streamer_pipeline_terminate+0x218/0x320 drivers/media/test-drivers/vimc/vimc-streamer.c:62 vimc_streamer_pipeline_init drivers/media/test-drivers/vimc/vimc-streamer.c:101 [inline] vimc_streamer_s_stream+0x650/0x9a0 drivers/media/test-drivers/vimc/vimc-streamer.c:203 vimc_capture_start_streaming+0xa1/0x130 drivers/media/test-drivers/vimc/vimc-capture.c:256 vb2_start_streaming+0x15f/0x5a0 drivers/media/common/videobuf2/videobuf2-core.c:1789 vb2_core_streamon+0x2a7/0x450 drivers/media/common/videobuf2/videobuf2-core.c:2348 vb2_streamon drivers/media/common/videobuf2/videobuf2-v4l2.c:875 [inline] vb2_ioctl_streamon+0xf4/0x170 drivers/media/common/videobuf2/videobuf2-v4l2.c:1118 __video_do_ioctl+0xaf0/0xf00 drivers/media/v4l2-core/v4l2-ioctl.c:3122 video_usercopy+0x4d2/0x1620 drivers/media/v4l2-core/v4l2-ioctl.c:3463 v4l2_ioctl+0x1ba/0x250 drivers/media/v4l2-core/v4l2-dev.c:366 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl fs/ioctl.c:892 [inline] __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f2b85c01b19 ...",
      "cve": "CVE-2025-22028",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22028",
          "value": "CVE-2025-22028",
          "url": "https://scout.docker.com/v/CVE-2025-22028?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22028?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0f81798d91ac01ddd790e40c0898edea169e99c4676e64edff84954e5b303467",
      "category": "container_scanning",
      "message": "CVE-2025-22039 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix overflow in dacloffset bounds check  The dacloffset field was originally typed as int and used in an unchecked addition, which could overflow and bypass the existing bounds check in both smb_check_perm_dacl() and smb_inherit_dacl().  This could result in out-of-bounds memory access and a kernel crash when dereferencing the DACL pointer.  This patch converts dacloffset to unsigned int and uses check_add_overflow() to validate access to the DACL.",
      "cve": "CVE-2025-22039",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22039",
          "value": "CVE-2025-22039",
          "url": "https://scout.docker.com/v/CVE-2025-22039?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22039?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a26f8b877528c4a7b708ca4fab97ccdd098897b7df6745eb10136d8799aba16",
      "category": "container_scanning",
      "message": "CVE-2025-22040 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix session use-after-free in multichannel connection  There is a race condition between session setup and ksmbd_sessions_deregister. The session can be freed before the connection is added to channel list of session. This patch check reference count of session before freeing it.",
      "cve": "CVE-2025-22040",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22040",
          "value": "CVE-2025-22040",
          "url": "https://scout.docker.com/v/CVE-2025-22040?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22040?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7cc937078112441353adca5678e629254bbc42ab9afb9f0d746da2f6e56aac4b",
      "category": "container_scanning",
      "message": "CVE-2025-22041 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in ksmbd_sessions_deregister()  In multichannel mode, UAF issue can occur in session_deregister when the second channel sets up a session through the connection of the first channel. session that is freed through the global session table can be accessed again through ->sessions of connection.",
      "cve": "CVE-2025-22041",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22041",
          "value": "CVE-2025-22041",
          "url": "https://scout.docker.com/v/CVE-2025-22041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "97733a68d9a36a7483dc7977de3222621a40ba1b10b41d0275a70c3fd228a42d",
      "category": "container_scanning",
      "message": "CVE-2025-22042 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: add bounds check for create lease context  Add missing bounds check for create lease context.",
      "cve": "CVE-2025-22042",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22042",
          "value": "CVE-2025-22042",
          "url": "https://scout.docker.com/v/CVE-2025-22042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b7f406785f3fff602f13bef50f89e78911d65de466e1724ef49afdef5bbad7fd",
      "category": "container_scanning",
      "message": "CVE-2025-22043 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: add bounds check for durable handle context  Add missing bounds check for durable handle context.",
      "cve": "CVE-2025-22043",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22043",
          "value": "CVE-2025-22043",
          "url": "https://scout.docker.com/v/CVE-2025-22043?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22043?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "66c943c8f05c0b73ae931f4523bad61c94f79b258a5a7953a4bed911d6299aef",
      "category": "container_scanning",
      "message": "CVE-2025-22053 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ibmveth: make veth_pool_store stop hanging  v2: - Created a single error handling unlock and exit in veth_pool_store - Greatly expanded commit message with previous explanatory-only text  Summary: Use rtnl_mutex to synchronize veth_pool_store with itself, ibmveth_close and ibmveth_open, preventing multiple calls in a row to napi_disable.  Background: Two (or more) threads could call veth_pool_store through writing to /sys/devices/vio/30000002/pool*/*. You can do this easily with a little shell script. This causes a hang.  I configured LOCKDEP, compiled ibmveth.c with DEBUG, and built a new kernel. I ran this test again and saw:  Setting pool0/active to 0 Setting pool1/active to 1 [   73.911067][ T4365] ibmveth 30000002 eth0: close starting Setting pool1/active to 1 Setting pool1/active to 0 [   73.911367][ T4366] ibmveth 30000002 eth0: close starting [   73.916056][ T4365] ibmveth 30000002 eth0: close complete [   73.916064][ T4365] ibmveth 30000002 eth0: open starting [  110.808564][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification. [  230.808495][  T712] systemd-journald[712]: Sent WATCHDOG=1 notification. [  243.683786][  T123] INFO: task stress.sh:4365 blocked for more than 122 seconds. [  243.683827][  T123]       Not tainted 6.14.0-01103-g2df0c02dab82-dirty #8 [  243.683833][  T123] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [  243.683838][  T123] task:stress.sh       state:D stack:28096 pid:4365  tgid:4365  ppid:4364   task_flags:0x400040 flags:0x00042000 [  243.683852][  T123] Call Trace: [  243.683857][  T123] [c00000000c38f690] [0000000000000001] 0x1 (unreliable) [  243.683868][  T123] [c00000000c38f840] [c00000000001f908] __switch_to+0x318/0x4e0 [  243.683878][  T123] [c00000000c38f8a0] [c000000001549a70] __schedule+0x500/0x12a0 [  243.683888][  T123] [c00000000c38f9a0] [c00000000154a878] schedule+0x68/0x210 [  243.683896][  T123] [c00000000c38f9d0] [c00000000154ac80] schedule_preempt_disabled+0x30/0x50 [  243.683904][  T123] [c00000000c38fa00] [c00000000154dbb0] __mutex_lock+0x730/0x10f0 [  243.683913][  T123] [c00000000c38fb10] [c000000001154d40] napi_enable+0x30/0x60 [  243.683921][  T123] [c00000000c38fb40] [c000000000f4ae94] ibmveth_open+0x68/0x5dc [  243.683928][  T123] [c00000000c38fbe0] [c000000000f4aa20] veth_pool_store+0x220/0x270 [  243.683936][  T123] [c00000000c38fc70] [c000000000826278] sysfs_kf_write+0x68/0xb0 [  243.683944][  T123] [c00000000c38fcb0] [c0000000008240b8] kernfs_fop_write_iter+0x198/0x2d0 [  243.683951][  T123] [c00000000c38fd00] [c00000000071b9ac] vfs_write+0x34c/0x650 [  243.683958][  T123] [c00000000c38fdc0] [c00000000071bea8] ksys_write+0x88/0x150 [  243.683966][  T123] [c00000000c38fe10] [c0000000000317f4] system_call_exception+0x124/0x340 [  243.683973][  T123] [c00000000c38fe50] [c00000000000d05c] system_call_vectored_common+0x15c/0x2ec ... [  243.684087][  T123] Showing all locks held in the system: [  243.684095][  T123] 1 lock held by khungtaskd/123: [  243.684099][  T123]  #0: c00000000278e370 (rcu_read_lock){....}-{1:2}, at: debug_show_all_locks+0x50/0x248 [  243.684114][  T123] 4 locks held by stress.sh/4365: [  243.684119][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150 [  243.684132][  T123]  #1: c000000041aea888 (&of->mutex#2){+.+.}-{3:3}, at: kernfs_fop_write_iter+0x154/0x2d0 [  243.684143][  T123]  #2: c0000000366fb9a8 (kn->active#64){.+.+}-{0:0}, at: kernfs_fop_write_iter+0x160/0x2d0 [  243.684155][  T123]  #3: c000000035ff4cb8 (&dev->lock){+.+.}-{3:3}, at: napi_enable+0x30/0x60 [  243.684166][  T123] 5 locks held by stress.sh/4366: [  243.684170][  T123]  #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0}, at: ksys_write+0x88/0x150 [  243. ---truncated---",
      "cve": "CVE-2025-22053",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22053",
          "value": "CVE-2025-22053",
          "url": "https://scout.docker.com/v/CVE-2025-22053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "94e53030542ac2c9b3d5c905a5b3387b4fa0d631891e94843816cf4fd8c5904d",
      "category": "container_scanning",
      "message": "CVE-2025-22057 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: decrease cached dst counters in dst_release  Upstream fix ac888d58869b (\"net: do not delay dst_entries_add() in dst_release()\") moved decrementing the dst count from dst_destroy to dst_release to avoid accessing already freed data in case of netns dismantle. However in case CONFIG_DST_CACHE is enabled and OvS+tunnels are used, this fix is incomplete as the same issue will be seen for cached dsts:  Unable to handle kernel paging request at virtual address ffff5aabf6b5c000 Call trace: percpu_counter_add_batch+0x3c/0x160 (P) dst_release+0xec/0x108 dst_cache_destroy+0x68/0xd8 dst_destroy+0x13c/0x168 dst_destroy_rcu+0x1c/0xb0 rcu_do_batch+0x18c/0x7d0 rcu_core+0x174/0x378 rcu_core_si+0x18/0x30  Fix this by invalidating the cache, and thus decrementing cached dst counters, in dst_release too.",
      "cve": "CVE-2025-22057",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22057",
          "value": "CVE-2025-22057",
          "url": "https://scout.docker.com/v/CVE-2025-22057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c3d771be2fd53d4119a86dcbed705e06eda283fa916c3b22aadbabbaa3fda771",
      "category": "container_scanning",
      "message": "CVE-2025-22058 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  udp: Fix memory accounting leak.  Matt Dowling reported a weird UDP memory usage issue.  Under normal operation, the UDP memory usage reported in /proc/net/sockstat remains close to zero.  However, it occasionally spiked to 524,288 pages and never dropped.  Moreover, the value doubled when the application was terminated.  Finally, it caused intermittent packet drops.  We can reproduce the issue with the script below [0]:  1. /proc/net/sockstat reports 0 pages  # cat /proc/net/sockstat | grep UDP: UDP: inuse 1 mem 0  2. Run the script till the report reaches 524,288  # python3 test.py & sleep 5 # cat /proc/net/sockstat | grep UDP: UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> PAGE_SHIFT  3. Kill the socket and confirm the number never drops  # pkill python3 && sleep 5 # cat /proc/net/sockstat | grep UDP: UDP: inuse 1 mem 524288  4. (necessary since v6.0) Trigger proto_memory_pcpu_drain()  # python3 test.py & sleep 1 && pkill python3  5. The number doubles  # cat /proc/net/sockstat | grep UDP: UDP: inuse 1 mem 1048577  The application set INT_MAX to SO_RCVBUF, which triggered an integer overflow in udp_rmem_release().  When a socket is close()d, udp_destruct_common() purges its receive queue and sums up skb->truesize in the queue.  This total is calculated and stored in a local unsigned integer variable.  The total size is then passed to udp_rmem_release() to adjust memory accounting.  However, because the function takes a signed integer argument, the total size can wrap around, causing an overflow.  Then, the released amount is calculated as follows:  1) Add size to sk->sk_forward_alloc. 2) Round down sk->sk_forward_alloc to the nearest lower multiple of PAGE_SIZE and assign it to amount. 3) Subtract amount from sk->sk_forward_alloc. 4) Pass amount >> PAGE_SHIFT to __sk_mem_reduce_allocated().  When the issue occurred, the total in udp_destruct_common() was 2147484480 (INT_MAX + 833), which was cast to -2147482816 in udp_rmem_release().  At 1) sk->sk_forward_alloc is changed from 3264 to -2147479552, and 2) sets -2147479552 to amount.  3) reverts the wraparound, so we don't see a warning in inet_sock_destruct().  However, udp_memory_allocated ends up doubling at 4).  Since commit 3cd3399dd7a8 (\"net: implement per-cpu reserves for memory_allocated\"), memory usage no longer doubles immediately after a socket is close()d because __sk_mem_reduce_allocated() caches the amount in udp_memory_per_cpu_fw_alloc.  However, the next time a UDP socket receives a packet, the subtraction takes effect, causing UDP memory usage to double.  This issue makes further memory allocation fail once the socket's sk->sk_rmem_alloc exceeds net.ipv4.udp_rmem_min, resulting in packet drops.  To prevent this issue, let's use unsigned int for the calculation and call sk_forward_alloc_add() only once for the small delta.  Note that first_packet_length() also potentially has the same problem.  [0]: from socket import *  SO_RCVBUFFORCE = 33 INT_MAX = (2 ** 31) - 1  s = socket(AF_INET, SOCK_DGRAM) s.bind(('', 0)) s.setsockopt(SOL_SOCKET, SO_RCVBUFFORCE, INT_MAX)  c = socket(AF_INET, SOCK_DGRAM) c.connect(s.getsockname())  data = b'a' * 100  while True: c.send(data)",
      "cve": "CVE-2025-22058",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22058",
          "value": "CVE-2025-22058",
          "url": "https://scout.docker.com/v/CVE-2025-22058?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22058?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "efd862832dab5811c5c9140c0074f69ba068db49a43257b09a005ada1b9d5c20",
      "category": "container_scanning",
      "message": "CVE-2025-22072 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spufs: fix gang directory lifetimes  prior to \"[POWERPC] spufs: Fix gang destroy leaks\" we used to have a problem with gang lifetimes - creation of a gang returns opened gang directory, which normally gets removed when that gets closed, but if somebody has created a context belonging to that gang and kept it alive until the gang got closed, removal failed and we ended up with a leak.  Unfortunately, it had been fixed the wrong way.  Dentry of gang directory was no longer pinned, and rmdir on close was gone. One problem was that failure of open kept calling simple_rmdir() as cleanup, which meant an unbalanced dput().  Another bug was in the success case - gang creation incremented link count on root directory, but that was no longer undone when gang got destroyed.  Fix consists of * reverting the commit in question * adding a counter to gang, protected by ->i_rwsem of gang directory inode. * having it set to 1 at creation time, dropped in both spufs_dir_close() and spufs_gang_close() and bumped in spufs_create_context(), provided that it's not 0. * using simple_recursive_removal() to take the gang directory out when counter reaches zero.",
      "cve": "CVE-2025-22072",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22072",
          "value": "CVE-2025-22072",
          "url": "https://scout.docker.com/v/CVE-2025-22072?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22072?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "003ad9ea703992f53388034a3d6c2fb98bfe08e54ee1b57541157752633eec7c",
      "category": "container_scanning",
      "message": "CVE-2025-22083 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vhost-scsi: Fix handling of multiple calls to vhost_scsi_set_endpoint  If vhost_scsi_set_endpoint is called multiple times without a vhost_scsi_clear_endpoint between them, we can hit multiple bugs found by Haoran Zhang:  1. Use-after-free when no tpgs are found:  This fixes a use after free that occurs when vhost_scsi_set_endpoint is called more than once and calls after the first call do not find any tpgs to add to the vs_tpg. When vhost_scsi_set_endpoint first finds tpgs to add to the vs_tpg array match=true, so we will do:  vhost_vq_set_backend(vq, vs_tpg); ...  kfree(vs->vs_tpg); vs->vs_tpg = vs_tpg;  If vhost_scsi_set_endpoint is called again and no tpgs are found match=false so we skip the vhost_vq_set_backend call leaving the pointer to the vs_tpg we then free via:  kfree(vs->vs_tpg); vs->vs_tpg = vs_tpg;  If a scsi request is then sent we do:  vhost_scsi_handle_vq -> vhost_scsi_get_req -> vhost_vq_get_backend  which sees the vs_tpg we just did a kfree on.  2. Tpg dir removal hang:  This patch fixes an issue where we cannot remove a LIO/target layer tpg (and structs above it like the target) dir due to the refcount dropping to -1.  The problem is that if vhost_scsi_set_endpoint detects a tpg is already in the vs->vs_tpg array or if the tpg has been removed so target_depend_item fails, the undepend goto handler will do target_undepend_item on all tpgs in the vs_tpg array dropping their refcount to 0. At this time vs_tpg contains both the tpgs we have added in the current vhost_scsi_set_endpoint call as well as tpgs we added in previous calls which are also in vs->vs_tpg.  Later, when vhost_scsi_clear_endpoint runs it will do target_undepend_item on all the tpgs in the vs->vs_tpg which will drop their refcount to -1. Userspace will then not be able to remove the tpg and will hang when it tries to do rmdir on the tpg dir.  3. Tpg leak:  This fixes a bug where we can leak tpgs and cause them to be un-removable because the target name is overwritten when vhost_scsi_set_endpoint is called multiple times but with different target names.  The bug occurs if a user has called VHOST_SCSI_SET_ENDPOINT and setup a vhost-scsi device to target/tpg mapping, then calls VHOST_SCSI_SET_ENDPOINT again with a new target name that has tpgs we haven't seen before (target1 has tpg1 but target2 has tpg2). When this happens we don't teardown the old target tpg mapping and just overwrite the target name and the vs->vs_tpg array. Later when we do vhost_scsi_clear_endpoint, we are passed in either target1 or target2's name and we will only match that target's tpgs when we loop over the vs->vs_tpg. We will then return from the function without doing target_undepend_item on the tpgs.  Because of all these bugs, it looks like being able to call vhost_scsi_set_endpoint multiple times was never supported. The major user, QEMU, already has checks to prevent this use case. So to fix the issues, this patch prevents vhost_scsi_set_endpoint from being called if it's already successfully added tpgs. To add, remove or change the tpg config or target name, you must do a vhost_scsi_clear_endpoint first.",
      "cve": "CVE-2025-22083",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22083",
          "value": "CVE-2025-22083",
          "url": "https://scout.docker.com/v/CVE-2025-22083?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22083?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9a3b7267117c14671087037c317c1e617d4a62ec36b5f25f35d01f01fefa51a3",
      "category": "container_scanning",
      "message": "CVE-2025-22090 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mm/pat: Fix VM_PAT handling when fork() fails in copy_page_range()  If track_pfn_copy() fails, we already added the dst VMA to the maple tree. As fork() fails, we'll cleanup the maple tree, and stumble over the dst VMA for which we neither performed any reservation nor copied any page tables.  Consequently untrack_pfn() will see VM_PAT and try obtaining the PAT information from the page table -- which fails because the page table was not copied.  The easiest fix would be to simply clear the VM_PAT flag of the dst VMA if track_pfn_copy() fails. However, the whole thing is about \"simply\" clearing the VM_PAT flag is shaky as well: if we passed track_pfn_copy() and performed a reservation, but copying the page tables fails, we'll simply clear the VM_PAT flag, not properly undoing the reservation ... which is also wrong.  So let's fix it properly: set the VM_PAT flag only if the reservation succeeded (leaving it clear initially), and undo the reservation if anything goes wrong while copying the page tables: clearing the VM_PAT flag after undoing the reservation.  Note that any copied page table entries will get zapped when the VMA will get removed later, after copy_page_range() succeeded; as VM_PAT is not set then, we won't try cleaning VM_PAT up once more and untrack_pfn() will be happy. Note that leaving these page tables in place without a reservation is not a problem, as we are aborting fork(); this process will never run.  A reproducer can trigger this usually at the first try:   https://gitlab.com/davidhildenbrand/scratchspace/-/raw/main/reproducers/pat_fork.c  WARNING: CPU: 26 PID: 11650 at arch/x86/mm/pat/memtype.c:983 get_pat_info+0xf6/0x110 Modules linked in: ... CPU: 26 UID: 0 PID: 11650 Comm: repro3 Not tainted 6.12.0-rc5+ #92 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:get_pat_info+0xf6/0x110 ... Call Trace: <TASK> ... untrack_pfn+0x52/0x110 unmap_single_vma+0xa6/0xe0 unmap_vmas+0x105/0x1f0 exit_mmap+0xf6/0x460 __mmput+0x4b/0x120 copy_process+0x1bf6/0x2aa0 kernel_clone+0xab/0x440 __do_sys_clone+0x66/0x90 do_syscall_64+0x95/0x180  Likely this case was missed in:  d155df53f310 (\"x86/mm/pat: clear VM_PAT if copy_p4d_range failed\")  ... and instead of undoing the reservation we simply cleared the VM_PAT flag.  Keep the documentation of these functions in include/linux/pgtable.h, one place is more than sufficient -- we should clean that up for the other functions like track_pfn_remap/untrack_pfn separately.",
      "cve": "CVE-2025-22090",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22090",
          "value": "CVE-2025-22090",
          "url": "https://scout.docker.com/v/CVE-2025-22090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "708c956479757e816ad2bbc2203ca822d3bc8f3691f2163fe93184e2005ac88b",
      "category": "container_scanning",
      "message": "CVE-2025-22103 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: fix NULL pointer dereference in l3mdev_l3_rcv  When delete l3s ipvlan:  ip link del link eth0 ipvlan1 type ipvlan mode l3s  This may cause a null pointer dereference:  Call trace: ip_rcv_finish+0x48/0xd0 ip_rcv+0x5c/0x100 __netif_receive_skb_one_core+0x64/0xb0 __netif_receive_skb+0x20/0x80 process_backlog+0xb4/0x204 napi_poll+0xe8/0x294 net_rx_action+0xd8/0x22c __do_softirq+0x12c/0x354  This is because l3mdev_l3_rcv() visit dev->l3mdev_ops after ipvlan_l3s_unregister() assign the dev->l3mdev_ops to NULL. The process like this:  (CPU1)                     | (CPU2) l3mdev_l3_rcv()            | check dev->priv_flags:   | master = skb->dev;     | | | ipvlan_l3s_unregister() |   set dev->priv_flags |   dev->l3mdev_ops = NULL; | visit master->l3mdev_ops |  To avoid this by do not set dev->l3mdev_ops when unregister l3s ipvlan.",
      "cve": "CVE-2025-22103",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22103",
          "value": "CVE-2025-22103",
          "url": "https://scout.docker.com/v/CVE-2025-22103?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22103?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5bf906dda410711aad6460474ce14afa82a04e916dddc4db092cdfa55ac4be80",
      "category": "container_scanning",
      "message": "CVE-2025-22104 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ibmvnic: Use kernel helpers for hex dumps  Previously, when the driver was printing hex dumps, the buffer was cast to an 8 byte long and printed using string formatters. If the buffer size was not a multiple of 8 then a read buffer overflow was possible.  Therefore, create a new ibmvnic function that loops over a buffer and calls hex_dump_to_buffer instead.  This patch address KASAN reports like the one below: ibmvnic 30000003 env3: Login Buffer: ibmvnic 30000003 env3: 01000000af000000 <...> ibmvnic 30000003 env3: 2e6d62692e736261 ibmvnic 30000003 env3: 65050003006d6f63 ================================================================== BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic] Read of size 8 at addr c0000001331a9aa8 by task ip/17681 <...> Allocated by task 17681: <...> ibmvnic_login+0x2f0/0xffc [ibmvnic] ibmvnic_open+0x148/0x308 [ibmvnic] __dev_open+0x1ac/0x304 <...> The buggy address is located 168 bytes inside of allocated 175-byte region [c0000001331a9a00, c0000001331a9aaf) <...> ================================================================= ibmvnic 30000003 env3: 000000000033766e",
      "cve": "CVE-2025-22104",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22104",
          "value": "CVE-2025-22104",
          "url": "https://scout.docker.com/v/CVE-2025-22104?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22104?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "19e0571dd295bb7190abf45bfabff6bc8ed19fea27f2b2f42a64b91e5715371d",
      "category": "container_scanning",
      "message": "CVE-2025-22105 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bonding: check xdp prog when set bond mode  Following operations can trigger a warning[1]:  ip netns add ns1 ip netns exec ns1 ip link add bond0 type bond mode balance-rr ip netns exec ns1 ip link set dev bond0 xdp obj af_xdp_kern.o sec xdp ip netns exec ns1 ip link set bond0 type bond mode broadcast ip netns del ns1  When delete the namespace, dev_xdp_uninstall() is called to remove xdp program on bond dev, and bond_xdp_set() will check the bond mode. If bond mode is changed after attaching xdp program, the warning may occur.  Some bond modes (broadcast, etc.) do not support native xdp. Set bond mode with xdp program attached is not good. Add check for xdp program when set bond mode.  [1] ------------[ cut here ]------------ WARNING: CPU: 0 PID: 11 at net/core/dev.c:9912 unregister_netdevice_many_notify+0x8d9/0x930 Modules linked in: CPU: 0 UID: 0 PID: 11 Comm: kworker/u4:0 Not tainted 6.14.0-rc4 #107 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014 Workqueue: netns cleanup_net RIP: 0010:unregister_netdevice_many_notify+0x8d9/0x930 Code: 00 00 48 c7 c6 6f e3 a2 82 48 c7 c7 d0 b3 96 82 e8 9c 10 3e ... RSP: 0018:ffffc90000063d80 EFLAGS: 00000282 RAX: 00000000ffffffa1 RBX: ffff888004959000 RCX: 00000000ffffdfff RDX: 0000000000000000 RSI: 00000000ffffffea RDI: ffffc90000063b48 RBP: ffffc90000063e28 R08: ffffffff82d39b28 R09: 0000000000009ffb R10: 0000000000000175 R11: ffffffff82d09b40 R12: ffff8880049598e8 R13: 0000000000000001 R14: dead000000000100 R15: ffffc90000045000 FS:  0000000000000000(0000) GS:ffff888007a00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000000d406b60 CR3: 000000000483e000 CR4: 00000000000006f0 Call Trace: <TASK> ? __warn+0x83/0x130 ? unregister_netdevice_many_notify+0x8d9/0x930 ? report_bug+0x18e/0x1a0 ? handle_bug+0x54/0x90 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? unregister_netdevice_many_notify+0x8d9/0x930 ? bond_net_exit_batch_rtnl+0x5c/0x90 cleanup_net+0x237/0x3d0 process_one_work+0x163/0x390 worker_thread+0x293/0x3b0 ? __pfx_worker_thread+0x10/0x10 kthread+0xec/0x1e0 ? __pfx_kthread+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2025-22105",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22105",
          "value": "CVE-2025-22105",
          "url": "https://scout.docker.com/v/CVE-2025-22105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "183b89f1e6cfd9499674726854bf2fa111bcb9156fe4d43ad89c9562ea1f7426",
      "category": "container_scanning",
      "message": "CVE-2025-22107 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: dsa: sja1105: fix kasan out-of-bounds warning in sja1105_table_delete_entry()  There are actually 2 problems: - deleting the last element doesn't require the memmove of elements [i + 1, end) over it. Actually, element i+1 is out of bounds. - The memmove itself should move size - i - 1 elements, because the last element is out of bounds.  The out-of-bounds element still remains out of bounds after being accessed, so the problem is only that we touch it, not that it becomes in active use. But I suppose it can lead to issues if the out-of-bounds element is part of an unmapped page.",
      "cve": "CVE-2025-22107",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22107",
          "value": "CVE-2025-22107",
          "url": "https://scout.docker.com/v/CVE-2025-22107?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22107?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8668fd08b0a8a7ce16712464aedc5fa858c35552801e2c456597db998621cc19",
      "category": "container_scanning",
      "message": "CVE-2025-22109 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: Remove broken autobind  Binding AX25 socket by using the autobind feature leads to memory leaks in ax25_connect() and also refcount leaks in ax25_release(). Memory leak was detected with kmemleak:  ================================================================ unreferenced object 0xffff8880253cd680 (size 96): backtrace: __kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h:43) kmemdup_noprof (mm/util.c:136) ax25_rt_autobind (net/ax25/ax25_route.c:428) ax25_connect (net/ax25/af_ax25.c:1282) __sys_connect_file (net/socket.c:2045) __sys_connect (net/socket.c:2064) __x64_sys_connect (net/socket.c:2067) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130) ================================================================  When socket is bound, refcounts must be incremented the way it is done in ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case of autobind, the refcounts are not incremented.  This bug leads to the following issue reported by Syzkaller:  ================================================================ ax25_connect(): syz-executor318 uses autobind, please contact jreuter@yaina.de ------------[ cut here ]------------ refcount_t: decrement hit 0; leaking memory. WARNING: CPU: 0 PID: 5317 at lib/refcount.c:31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31 Modules linked in: CPU: 0 UID: 0 PID: 5317 Comm: syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31 ... Call Trace: <TASK> __refcount_dec include/linux/refcount.h:336 [inline] refcount_dec include/linux/refcount.h:351 [inline] ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c:236 netdev_tracker_free include/linux/netdevice.h:4302 [inline] netdev_put include/linux/netdevice.h:4319 [inline] ax25_release+0x368/0x960 net/ax25/af_ax25.c:1080 __sock_release net/socket.c:647 [inline] sock_close+0xbc/0x240 net/socket.c:1398 __fput+0x3e9/0x9f0 fs/file_table.c:464 __do_sys_close fs/open.c:1580 [inline] __se_sys_close fs/open.c:1565 [inline] __x64_sys_close+0x7f/0x110 fs/open.c:1565 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... </TASK> ================================================================  Considering the issues above and the comments left in the code that say: \"check if we can remove this feature. It is broken.\"; \"autobinding in this may or may not work\"; - it is better to completely remove this feature than to fix it because it is broken and leads to various kinds of memory bugs.  Now calling connect() without first binding socket will result in an error (-EINVAL). Userspace software that relies on the autobind feature might get broken. However, this feature does not seem widely used with this specific driver as it was not reliable at any point of time, and it is already broken anyway. E.g. ax25-tools and ax25-apps packages for popular distributions do not use the autobind feature for AF_AX25.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "cve": "CVE-2025-22109",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22109",
          "value": "CVE-2025-22109",
          "url": "https://scout.docker.com/v/CVE-2025-22109?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22109?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "83495c734bbcde62ded62349fdda43ef305f0c189d2ed57a3ea5f8d8491755f6",
      "category": "container_scanning",
      "message": "CVE-2025-22111 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: Remove RTNL dance for SIOCBRADDIF and SIOCBRDELIF.  SIOCBRDELIF is passed to dev_ioctl() first and later forwarded to br_ioctl_call(), which causes unnecessary RTNL dance and the splat below [0] under RTNL pressure.  Let's say Thread A is trying to detach a device from a bridge and Thread B is trying to remove the bridge.  In dev_ioctl(), Thread A bumps the bridge device's refcnt by netdev_hold() and releases RTNL because the following br_ioctl_call() also re-acquires RTNL.  In the race window, Thread B could acquire RTNL and try to remove the bridge device.  Then, rtnl_unlock() by Thread B will release RTNL and wait for netdev_put() by Thread A.  Thread A, however, must hold RTNL after the unlock in dev_ifsioc(), which may take long under RTNL pressure, resulting in the splat by Thread B.  Thread A (SIOCBRDELIF)           Thread B (SIOCBRDELBR) ----------------------           ---------------------- sock_ioctl                       sock_ioctl `- sock_do_ioctl                 `- br_ioctl_call `- dev_ioctl                     `- br_ioctl_stub |- rtnl_lock                     | |- dev_ifsioc                    ' '  |- dev = __dev_get_by_name(...) |- netdev_hold(dev, ...)      . /   |- rtnl_unlock  ------.       | |   |- br_ioctl_call       `--->  |- rtnl_lock Race |   |  `- br_ioctl_stub           |- br_del_bridge Window   |     |                       |  |- dev = __dev_get_by_name(...) |   |     |  May take long        |  `- br_dev_delete(dev, ...) |   |     |  under RTNL pressure  |     `- unregister_netdevice_queue(dev, ...) |   |     |               |       `- rtnl_unlock \\   |     |- rtnl_lock  <-'          `- netdev_run_todo |     |- ...                        `- netdev_run_todo |     `- rtnl_unlock                   |- __rtnl_unlock |                                      |- netdev_wait_allrefs_any |- netdev_put(dev, ...)  <----------------' Wait refcnt decrement and log splat below  To avoid blocking SIOCBRDELBR unnecessarily, let's not call dev_ioctl() for SIOCBRADDIF and SIOCBRDELIF.  In the dev_ioctl() path, we do the following:  1. Copy struct ifreq by get_user_ifreq in sock_do_ioctl() 2. Check CAP_NET_ADMIN in dev_ioctl() 3. Call dev_load() in dev_ioctl() 4. Fetch the master dev from ifr.ifr_name in dev_ifsioc()  3. can be done by request_module() in br_ioctl_call(), so we move 1., 2., and 4. to br_ioctl_stub().  Note that 2. is also checked later in add_del_if(), but it's better performed before RTNL.  SIOCBRADDIF and SIOCBRDELIF have been processed in dev_ioctl() since the pre-git era, and there seems to be no specific reason to process them there.  [0]: unregister_netdevice: waiting for wpan3 to become free. Usage count = 2 ref_tracker: wpan3@ffff8880662d8608 has 1/1 users at __netdev_tracker_alloc include/linux/netdevice.h:4282 [inline] netdev_hold include/linux/netdevice.h:4311 [inline] dev_ifsioc+0xc6a/0x1160 net/core/dev_ioctl.c:624 dev_ioctl+0x255/0x10c0 net/core/dev_ioctl.c:826 sock_do_ioctl+0x1ca/0x260 net/socket.c:1213 sock_ioctl+0x23a/0x6c0 net/socket.c:1318 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl fs/ioctl.c:892 [inline] __x64_sys_ioctl+0x1a4/0x210 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcb/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "cve": "CVE-2025-22111",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22111",
          "value": "CVE-2025-22111",
          "url": "https://scout.docker.com/v/CVE-2025-22111?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22111?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8c58f5a7d3dfe536da53886b1ec0525dd06e4611dcd8fd9a42914a1fa78bc5e9",
      "category": "container_scanning",
      "message": "CVE-2025-22113 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: avoid journaling sb update on error if journal is destroying  Presently we always BUG_ON if trying to start a transaction on a journal marked with JBD2_UNMOUNT, since this should never happen. However, while ltp running stress tests, it was observed that in case of some error handling paths, it is possible for update_super_work to start a transaction after the journal is destroyed eg:  (umount) ext4_kill_sb kill_block_super generic_shutdown_super sync_filesystem /* commits all txns */ evict_inodes /* might start a new txn */ ext4_put_super flush_work(&sbi->s_sb_upd_work) /* flush the workqueue */ jbd2_journal_destroy journal_kill_thread journal->j_flags |= JBD2_UNMOUNT; jbd2_journal_commit_transaction jbd2_journal_get_descriptor_buffer jbd2_journal_bmap ext4_journal_bmap ext4_map_blocks ... ext4_inode_error ext4_handle_error schedule_work(&sbi->s_sb_upd_work)  /* work queue kicks in */ update_super_work jbd2_journal_start start_this_handle  BUG_ON(journal->j_flags & JBD2_UNMOUNT)  Hence, introduce a new mount flag to indicate journal is destroying and only do a journaled (and deferred) update of sb if this flag is not set. Otherwise, just fallback to an un-journaled commit.  Further, in the journal destroy path, we have the following sequence:  1. Set mount flag indicating journal is destroying 2. force a commit and wait for it 3. flush pending sb updates  This sequence is important as it ensures that, after this point, there is no sb update that might be journaled so it is safe to update the sb outside the journal. (To avoid race discussed in 2d01ddc86606)  Also, we don't need a similar check in ext4_grp_locked_error since it is only called from mballoc and AFAICT it would be always valid to schedule work here.",
      "cve": "CVE-2025-22113",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22113",
          "value": "CVE-2025-22113",
          "url": "https://scout.docker.com/v/CVE-2025-22113?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22113?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d885c8eecc3a68acc9341b15a311d2541842caf63030ecd4939197a5fd36424",
      "category": "container_scanning",
      "message": "CVE-2025-22121 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()  There's issue as follows: BUG: KASAN: use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790 Read of size 4 at addr ffff88807b003000 by task syz-executor.0/15172  CPU: 3 PID: 15172 Comm: syz-executor.0 Call Trace: __dump_stack lib/dump_stack.c:82 [inline] dump_stack+0xbe/0xfd lib/dump_stack.c:123 print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c:400 __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560 kasan_report+0x3a/0x50 mm/kasan/report.c:585 ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c:1137 ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c:2896 ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c:323 evict+0x39f/0x880 fs/inode.c:622 iput_final fs/inode.c:1746 [inline] iput fs/inode.c:1772 [inline] iput+0x525/0x6c0 fs/inode.c:1758 ext4_orphan_cleanup fs/ext4/super.c:3298 [inline] ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c:5300 mount_bdev+0x355/0x410 fs/super.c:1446 legacy_get_tree+0xfe/0x220 fs/fs_context.c:611 vfs_get_tree+0x8d/0x2f0 fs/super.c:1576 do_new_mount fs/namespace.c:2983 [inline] path_mount+0x119a/0x1ad0 fs/namespace.c:3316 do_mount+0xfc/0x110 fs/namespace.c:3329 __do_sys_mount fs/namespace.c:3540 [inline] __se_sys_mount+0x219/0x2e0 fs/namespace.c:3514 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1  Memory state around the buggy address: ffff88807b002f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff88807b002f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff88807b003000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ^ ffff88807b003080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffff88807b003100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff  Above issue happens as ext4_xattr_delete_inode() isn't check xattr is valid if xattr is in inode. To solve above issue call xattr_check_inode() check if xattr if valid in inode. In fact, we can directly verify in ext4_iget_extra_inode(), so that there is no divergent verification.",
      "cve": "CVE-2025-22121",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22121",
          "value": "CVE-2025-22121",
          "url": "https://scout.docker.com/v/CVE-2025-22121?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22121?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8592d47eeb58cec5d0648e5afa3aa12a54df48d1815788c2951af20cbb851ad8",
      "category": "container_scanning",
      "message": "CVE-2025-22124 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md/md-bitmap: fix wrong bitmap_limit for clustermd when write sb  In clustermd, separate write-intent-bitmaps are used for each cluster node:  0                    4k                     8k                    12k ------------------------------------------------------------------- | idle                | md super            | bm super [0] + bits | | bm bits[0, contd]   | bm super[1] + bits  | bm bits[1, contd]   | | bm super[2] + bits  | bm bits [2, contd]  | bm super[3] + bits  | | bm bits [3, contd]  |                     |                     |  So in node 1, pg_index in __write_sb_page() could equal to bitmap->storage.file_pages. Then bitmap_limit will be calculated to 0. md_super_write() will be called with 0 size. That means the first 4k sb area of node 1 will never be updated through filemap_write_page(). This bug causes hang of mdadm/clustermd_tests/01r1_Grow_resize.  Here use (pg_index % bitmap->storage.file_pages) to make calculation of bitmap_limit correct.",
      "cve": "CVE-2025-22124",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22124",
          "value": "CVE-2025-22124",
          "url": "https://scout.docker.com/v/CVE-2025-22124?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22124?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "262ad457e0eea00eb6bc101da89671d629ae48f294dc385803b73c9f692d17b3",
      "category": "container_scanning",
      "message": "CVE-2025-22125 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md/raid1,raid10: don't ignore IO flags  If blk-wbt is enabled by default, it's found that raid write performance is quite bad because all IO are throttled by wbt of underlying disks, due to flag REQ_IDLE is ignored. And turns out this behaviour exist since blk-wbt is introduced.  Other than REQ_IDLE, other flags should not be ignored as well, for example REQ_META can be set for filesystems, clearing it can cause priority reverse problems; And REQ_NOWAIT should not be cleared as well, because io will wait instead of failing directly in underlying disks.  Fix those problems by keep IO flags from master bio.  Fises: f51d46d0e7cb (\"md: add support for REQ_NOWAIT\")",
      "cve": "CVE-2025-22125",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22125",
          "value": "CVE-2025-22125",
          "url": "https://scout.docker.com/v/CVE-2025-22125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cd628c5920c5e7c9b5cbf5e323cc34f837cf7b33fbbeaef6685ccdb1d28476f2",
      "category": "container_scanning",
      "message": "CVE-2025-22127 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix potential deadloop in prepare_compress_overwrite()  Jan Prusakowski reported a kernel hang issue as below:  When running xfstests on linux-next kernel (6.14.0-rc3, 6.12) I encountered a problem in generic/475 test where fsstress process gets blocked in __f2fs_write_data_pages() and the test hangs. The options I used are:  MKFS_OPTIONS  -- -O compression -O extra_attr -O project_quota -O quota /dev/vdc MOUNT_OPTIONS -- -o acl,user_xattr -o discard,compress_extension=* /dev/vdc /vdc  INFO: task kworker/u8:0:11 blocked for more than 122 seconds. Not tainted 6.14.0-rc3-xfstests-lockdep #1 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:kworker/u8:0    state:D stack:0     pid:11    tgid:11    ppid:2 task_flags:0x4208160 flags:0x00004000 Workqueue: writeback wb_workfn (flush-253:0) Call Trace: <TASK> __schedule+0x309/0x8e0 schedule+0x3a/0x100 schedule_preempt_disabled+0x15/0x30 __mutex_lock+0x59a/0xdb0 __f2fs_write_data_pages+0x3ac/0x400 do_writepages+0xe8/0x290 __writeback_single_inode+0x5c/0x360 writeback_sb_inodes+0x22f/0x570 wb_writeback+0xb0/0x410 wb_do_writeback+0x47/0x2f0 wb_workfn+0x5a/0x1c0 process_one_work+0x223/0x5b0 worker_thread+0x1d5/0x3c0 kthread+0xfd/0x230 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1a/0x30 </TASK>  The root cause is: once generic/475 starts toload error table to dm device, f2fs_prepare_compress_overwrite() will loop reading compressed cluster pages due to IO error, meanwhile it has held .writepages lock, it can block all other writeback tasks.  Let's fix this issue w/ below changes: - add f2fs_handle_page_eio() in prepare_compress_overwrite() to detect IO error. - detect cp_error earler in f2fs_read_multi_pages().",
      "cve": "CVE-2025-22127",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22127",
          "value": "CVE-2025-22127",
          "url": "https://scout.docker.com/v/CVE-2025-22127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b2a9877e0e3302e8e73c15c6cafc9bf115b235aa06f848a654045b577056421d",
      "category": "container_scanning",
      "message": "CVE-2025-23130 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to avoid panic once fallocation fails for pinfile  syzbot reports a f2fs bug as below:  ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2746! CPU: 0 UID: 0 PID: 5323 Comm: syz.0.0 Not tainted 6.13.0-rc2-syzkaller-00018-g7cb1b4663150 #0 RIP: 0010:get_new_segment fs/f2fs/segment.c:2746 [inline] RIP: 0010:new_curseg+0x1f52/0x1f70 fs/f2fs/segment.c:2876 Call Trace: <TASK> __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3210 f2fs_allocate_new_section fs/f2fs/segment.c:3224 [inline] f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3238 f2fs_expand_inode_data+0x696/0xca0 fs/f2fs/file.c:1830 f2fs_fallocate+0x537/0xa10 fs/f2fs/file.c:1940 vfs_fallocate+0x569/0x6e0 fs/open.c:327 do_vfs_ioctl+0x258c/0x2e40 fs/ioctl.c:885 __do_sys_ioctl fs/ioctl.c:904 [inline] __se_sys_ioctl+0x80/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Concurrent pinfile allocation may run out of free section, result in panic in get_new_segment(), let's expand pin_sem lock coverage to include f2fs_gc(), so that we can make sure to reclaim enough free space for following allocation.  In addition, do below changes to enhance error path handling: - call f2fs_bug_on() only in non-pinfile allocation path in get_new_segment(). - call reset_curseg_fields() to reset all fields of curseg in new_curseg()",
      "cve": "CVE-2025-23130",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23130",
          "value": "CVE-2025-23130",
          "url": "https://scout.docker.com/v/CVE-2025-23130?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23130?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "655711f3c69646c73ec29a5ac3687ce1fa7fcf5852297b95abd11d554aad7e13",
      "category": "container_scanning",
      "message": "CVE-2025-23131 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dlm: prevent NPD when writing a positive value to event_done  do_uevent returns the value written to event_done. In case it is a positive value, new_lockspace would undo all the work, and lockspace would not be set. __dlm_new_lockspace, however, would treat that positive value as a success due to commit 8511a2728ab8 (\"dlm: fix use count with multiple joins\").  Down the line, device_create_lockspace would pass that NULL lockspace to dlm_find_lockspace_local, leading to a NULL pointer dereference.  Treating such positive values as successes prevents the problem. Given this has been broken for so long, this is unlikely to break userspace expectations.",
      "cve": "CVE-2025-23131",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23131",
          "value": "CVE-2025-23131",
          "url": "https://scout.docker.com/v/CVE-2025-23131?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23131?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b297a7b31a2166ee6490f6d1b6a3996bcfcefab29867cd1aa835264b53c9cd98",
      "category": "container_scanning",
      "message": "CVE-2025-23132 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: quota: fix to avoid warning in dquot_writeback_dquots()  F2FS-fs (dm-59): checkpoint=enable has some unwritten data.  ------------[ cut here ]------------ WARNING: CPU: 6 PID: 8013 at fs/quota/dquot.c:691 dquot_writeback_dquots+0x2fc/0x308 pc : dquot_writeback_dquots+0x2fc/0x308 lr : f2fs_quota_sync+0xcc/0x1c4 Call trace: dquot_writeback_dquots+0x2fc/0x308 f2fs_quota_sync+0xcc/0x1c4 f2fs_write_checkpoint+0x3d4/0x9b0 f2fs_issue_checkpoint+0x1bc/0x2c0 f2fs_sync_fs+0x54/0x150 f2fs_do_sync_file+0x2f8/0x814 __f2fs_ioctl+0x1960/0x3244 f2fs_ioctl+0x54/0xe0 __arm64_sys_ioctl+0xa8/0xe4 invoke_syscall+0x58/0x114  checkpoint and f2fs_remount may race as below, resulting triggering warning in dquot_writeback_dquots().  atomic write                                    remount - do_remount - down_write(&sb->s_umount); - f2fs_remount - ioctl - f2fs_do_sync_file - f2fs_sync_fs - f2fs_write_checkpoint - block_operations - locked = down_read_trylock(&sbi->sb->s_umount) : fail to lock due to the write lock was held by remount - up_write(&sb->s_umount); - f2fs_quota_sync - dquot_writeback_dquots - WARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount)) : trigger warning because s_umount lock was unlocked by remount  If checkpoint comes from mount/umount/remount/freeze/quotactl, caller of checkpoint has already held s_umount lock, calling dquot_writeback_dquots() in the context should be safe.  So let's record task to sbi->umount_lock_holder, so that checkpoint can know whether the lock has held in the context or not by checking current w/ it.  In addition, in order to not misrepresent caller of checkpoint, we should not allow to trigger async checkpoint for those callers: mount/umount/remount/ freeze/quotactl.",
      "cve": "CVE-2025-23132",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23132",
          "value": "CVE-2025-23132",
          "url": "https://scout.docker.com/v/CVE-2025-23132?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23132?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "55a93b7293c22dd4d220fa908cdaf280041f56d8b8d3c11841498d9cf08b1c26",
      "category": "container_scanning",
      "message": "CVE-2025-23133 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: update channel list in reg notifier instead reg worker  Currently when ath11k gets a new channel list, it will be processed according to the following steps: 1. update new channel list to cfg80211 and queue reg_work. 2. cfg80211 handles new channel list during reg_work. 3. update cfg80211's handled channel list to firmware by ath11k_reg_update_chan_list().  But ath11k will immediately execute step 3 after reg_work is just queued. Since step 2 is asynchronous, cfg80211 may not have completed handling the new channel list, which may leading to an out-of-bounds write error: BUG: KASAN: slab-out-of-bounds in ath11k_reg_update_chan_list Call Trace: ath11k_reg_update_chan_list+0xbfe/0xfe0 [ath11k] kfree+0x109/0x3a0 ath11k_regd_update+0x1cf/0x350 [ath11k] ath11k_regd_update_work+0x14/0x20 [ath11k] process_one_work+0xe35/0x14c0  Should ensure step 2 is completely done before executing step 3. Thus Wen raised patch[1]. When flag NL80211_REGDOM_SET_BY_DRIVER is set, cfg80211 will notify ath11k after step 2 is done.  So enable the flag NL80211_REGDOM_SET_BY_DRIVER then cfg80211 will notify ath11k after step 2 is done. At this time, there will be no KASAN bug during the execution of the step 3.  [1] https://patchwork.kernel.org/project/linux-wireless/patch/20230201065313.27203-1-quic_wgong@quicinc.com/  Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3",
      "cve": "CVE-2025-23133",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23133",
          "value": "CVE-2025-23133",
          "url": "https://scout.docker.com/v/CVE-2025-23133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9e0b5a576f4a1065162ae6e2c19437e984f82d3a5613ead548b10f1246acefc1",
      "category": "container_scanning",
      "message": "CVE-2025-23141 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86: Acquire SRCU in KVM_GET_MP_STATE to protect guest memory accesses  Acquire a lock on kvm->srcu when userspace is getting MP state to handle a rather extreme edge case where \"accepting\" APIC events, i.e. processing pending INIT or SIPI, can trigger accesses to guest memory.  If the vCPU is in L2 with INIT *and* a TRIPLE_FAULT request pending, then getting MP state will trigger a nested VM-Exit by way of ->check_nested_events(), and emuating the nested VM-Exit can access guest memory.  The splat was originally hit by syzkaller on a Google-internal kernel, and reproduced on an upstream kernel by hacking the triple_fault_event_test selftest to stuff a pending INIT, store an MSR on VM-Exit (to generate a memory access on VMX), and do vcpu_mp_state_get() to trigger the scenario.  ============================= WARNING: suspicious RCU usage 6.14.0-rc3-b112d356288b-vmx/pi_lockdep_false_pos-lock #3 Not tainted ----------------------------- include/linux/kvm_host.h:1058 suspicious rcu_dereference_check() usage!  other info that might help us debug this:  rcu_scheduler_active = 2, debug_locks = 1 1 lock held by triple_fault_ev/1256: #0: ffff88810df5a330 (&vcpu->mutex){+.+.}-{4:4}, at: kvm_vcpu_ioctl+0x8b/0x9a0 [kvm]  stack backtrace: CPU: 11 UID: 1000 PID: 1256 Comm: triple_fault_ev Not tainted 6.14.0-rc3-b112d356288b-vmx #3 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Call Trace: <TASK> dump_stack_lvl+0x7f/0x90 lockdep_rcu_suspicious+0x144/0x190 kvm_vcpu_gfn_to_memslot+0x156/0x180 [kvm] kvm_vcpu_read_guest+0x3e/0x90 [kvm] read_and_check_msr_entry+0x2e/0x180 [kvm_intel] __nested_vmx_vmexit+0x550/0xde0 [kvm_intel] kvm_check_nested_events+0x1b/0x30 [kvm] kvm_apic_accept_events+0x33/0x100 [kvm] kvm_arch_vcpu_ioctl_get_mpstate+0x30/0x1d0 [kvm] kvm_vcpu_ioctl+0x33e/0x9a0 [kvm] __x64_sys_ioctl+0x8b/0xb0 do_syscall_64+0x6c/0x170 entry_SYSCALL_64_after_hwframe+0x4b/0x53 </TASK>",
      "cve": "CVE-2025-23141",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23141",
          "value": "CVE-2025-23141",
          "url": "https://scout.docker.com/v/CVE-2025-23141?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23141?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e06e897a2d0ee27580dda0c4424153246d2b4c61747912e99fe46170baeb6f8a",
      "category": "container_scanning",
      "message": "CVE-2025-23155 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: stmmac: Fix accessing freed irq affinity_hint  In stmmac_request_irq_multi_msi(), a pointer to the stack variable cpu_mask is passed to irq_set_affinity_hint(). This value is stored in irq_desc->affinity_hint, but once stmmac_request_irq_multi_msi() returns, the pointer becomes dangling.  The affinity_hint is exposed via procfs with S_IRUGO permissions, allowing any unprivileged process to read it. Accessing this stale pointer can lead to:  - a kernel oops or panic if the referenced memory has been released and unmapped, or - leakage of kernel data into userspace if the memory is re-used for other purposes.  All platforms that use stmmac with PCI MSI (Intel, Loongson, etc) are affected.",
      "cve": "CVE-2025-23155",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23155",
          "value": "CVE-2025-23155",
          "url": "https://scout.docker.com/v/CVE-2025-23155?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23155?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c098aa6c467d33a8197d3d9dabb751c01fbd64631096289ccdae257b2712e12c",
      "category": "container_scanning",
      "message": "CVE-2025-23160 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: Fix a resource leak related to the scp device in FW initialization  On Mediatek devices with a system companion processor (SCP) the mtk_scp structure has to be removed explicitly to avoid a resource leak. Free the structure in case the allocation of the firmware structure fails during the firmware initialization.",
      "cve": "CVE-2025-23160",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23160",
          "value": "CVE-2025-23160",
          "url": "https://scout.docker.com/v/CVE-2025-23160?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23160?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "99418385a4b1c6f2e93451a98722d4829635792771beb66ef2ab6b43a009a342",
      "category": "container_scanning",
      "message": "CVE-2025-23162 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/vf: Don't try to trigger a full GT reset if VF  VFs don't have access to the GDRST(0x941c) register that driver uses to reset a GT. Attempt to trigger a reset using debugfs:  $ cat /sys/kernel/debug/dri/0000:00:02.1/gt0/force_reset  or due to a hang condition detected by the driver leads to:  [ ] xe 0000:00:02.1: [drm] GT0: trying reset from force_reset [xe] [ ] xe 0000:00:02.1: [drm] GT0: reset queued [ ] xe 0000:00:02.1: [drm] GT0: reset started [ ] ------------[ cut here ]------------ [ ] xe 0000:00:02.1: [drm] GT0: VF is trying to write 0x1 to an inaccessible register 0x941c+0x0 [ ] WARNING: CPU: 3 PID: 3069 at drivers/gpu/drm/xe/xe_gt_sriov_vf.c:996 xe_gt_sriov_vf_write32+0xc6/0x580 [xe] [ ] RIP: 0010:xe_gt_sriov_vf_write32+0xc6/0x580 [xe] [ ] Call Trace: [ ]  <TASK> [ ]  ? show_regs+0x6c/0x80 [ ]  ? __warn+0x93/0x1c0 [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe] [ ]  ? report_bug+0x182/0x1b0 [ ]  ? handle_bug+0x6e/0xb0 [ ]  ? exc_invalid_op+0x18/0x80 [ ]  ? asm_exc_invalid_op+0x1b/0x20 [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe] [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe] [ ]  ? xe_gt_tlb_invalidation_reset+0xef/0x110 [xe] [ ]  ? __mutex_unlock_slowpath+0x41/0x2e0 [ ]  xe_mmio_write32+0x64/0x150 [xe] [ ]  do_gt_reset+0x2f/0xa0 [xe] [ ]  gt_reset_worker+0x14e/0x1e0 [xe] [ ]  process_one_work+0x21c/0x740 [ ]  worker_thread+0x1db/0x3c0  Fix that by sending H2G VF_RESET(0x5507) action instead.",
      "cve": "CVE-2025-23162",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-23162",
          "value": "CVE-2025-23162",
          "url": "https://scout.docker.com/v/CVE-2025-23162?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-23162?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "70fc96821ab7ede33ce0aa58d6259f9ada65b41b10ee50fd52539fe9661ca478",
      "category": "container_scanning",
      "message": "CVE-2025-37743 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Avoid memory leak while enabling statistics  Driver uses monitor destination rings for extended statistics mode and standalone monitor mode. In extended statistics mode, TLVs are parsed from the buffer received from the monitor destination ring and assigned to the ppdu_info structure to update per-packet statistics. In standalone monitor mode, along with per-packet statistics, the packet data (payload) is captured, and the driver updates per MSDU to mac80211.  When the AP interface is enabled, only extended statistics mode is activated. As part of enabling monitor rings for collecting statistics, the driver subscribes to HAL_RX_MPDU_START TLV in the filter configuration. This TLV is received from the monitor destination ring, and kzalloc for the mon_mpdu object occurs, which is not freed, leading to a memory leak. The kzalloc for the mon_mpdu object is only required while enabling the standalone monitor interface. This causes a memory leak while enabling extended statistics mode in the driver.  Fix this memory leak by removing the kzalloc for the mon_mpdu object in the HAL_RX_MPDU_START TLV handling. Additionally, remove the standalone monitor mode handlings in the HAL_MON_BUF_ADDR and HAL_RX_MSDU_END TLVs. These TLV tags will be handled properly when enabling standalone monitor mode in the future.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",
      "cve": "CVE-2025-37743",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37743",
          "value": "CVE-2025-37743",
          "url": "https://scout.docker.com/v/CVE-2025-37743?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37743?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8418f2c113bb0f8c2f69cd02a40f4470d4ed5b51e1c60545a095fec6d7cdda44",
      "category": "container_scanning",
      "message": "CVE-2025-37744 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix memory leak in ath12k_pci_remove()  Kmemleak reported this error:  unreferenced object 0xffff1c165cec3060 (size 32): comm \"insmod\", pid 560, jiffies 4296964570 (age 235.596s) backtrace: [<000000005434db68>] __kmem_cache_alloc_node+0x1f4/0x2c0 [<000000001203b155>] kmalloc_trace+0x40/0x88 [<0000000028adc9c8>] _request_firmware+0xb8/0x608 [<00000000cad1aef7>] firmware_request_nowarn+0x50/0x80 [<000000005011a682>] local_pci_probe+0x48/0xd0 [<00000000077cd295>] pci_device_probe+0xb4/0x200 [<0000000087184c94>] really_probe+0x150/0x2c0  The firmware memory was allocated in ath12k_pci_probe(), but not freed in ath12k_pci_remove() in case ATH12K_FLAG_QMI_FAIL bit is set. So call ath12k_fw_unmap() to free the memory.  Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.2.0-02280-QCAHMTSWPL_V1.0_V2.0_SILICONZ-1",
      "cve": "CVE-2025-37744",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37744",
          "value": "CVE-2025-37744",
          "url": "https://scout.docker.com/v/CVE-2025-37744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "49b88e8446e8aac18cb106b9741e1a857398fd1374291549b5a48aa37fad39f9",
      "category": "container_scanning",
      "message": "CVE-2025-37745 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PM: hibernate: Avoid deadlock in hibernate_compressor_param_set()  syzbot reported a deadlock in lock_system_sleep() (see below).  The write operation to \"/sys/module/hibernate/parameters/compressor\" conflicts with the registration of ieee80211 device, resulting in a deadlock when attempting to acquire system_transition_mutex under param_lock.  To avoid this deadlock, change hibernate_compressor_param_set() to use mutex_trylock() for attempting to acquire system_transition_mutex and return -EBUSY when it fails.  Task flags need not be saved or adjusted before calling mutex_trylock(&system_transition_mutex) because the caller is not going to end up waiting for this mutex and if it runs concurrently with system suspend in progress, it will be frozen properly when it returns to user space.  syzbot report:  syz-executor895/5833 is trying to acquire lock: ffffffff8e0828c8 (system_transition_mutex){+.+.}-{4:4}, at: lock_system_sleep+0x87/0xa0 kernel/power/main.c:56  but task is already holding lock: ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: kernel_param_lock kernel/params.c:607 [inline] ffffffff8e07dc68 (param_lock){+.+.}-{4:4}, at: param_attr_store+0xe6/0x300 kernel/params.c:586  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #3 (param_lock){+.+.}-{4:4}: __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730 ieee80211_rate_control_ops_get net/mac80211/rate.c:220 [inline] rate_control_alloc net/mac80211/rate.c:266 [inline] ieee80211_init_rate_ctrl_alg+0x18d/0x6b0 net/mac80211/rate.c:1015 ieee80211_register_hw+0x20cd/0x4060 net/mac80211/main.c:1531 mac80211_hwsim_new_radio+0x304e/0x54e0 drivers/net/wireless/virtual/mac80211_hwsim.c:5558 init_mac80211_hwsim+0x432/0x8c0 drivers/net/wireless/virtual/mac80211_hwsim.c:6910 do_one_initcall+0x128/0x700 init/main.c:1257 do_initcall_level init/main.c:1319 [inline] do_initcalls init/main.c:1335 [inline] do_basic_setup init/main.c:1354 [inline] kernel_init_freeable+0x5c7/0x900 init/main.c:1568 kernel_init+0x1c/0x2b0 init/main.c:1457 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  -> #2 (rtnl_mutex){+.+.}-{4:4}: __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730 wg_pm_notification drivers/net/wireguard/device.c:80 [inline] wg_pm_notification+0x49/0x180 drivers/net/wireguard/device.c:64 notifier_call_chain+0xb7/0x410 kernel/notifier.c:85 notifier_call_chain_robust kernel/notifier.c:120 [inline] blocking_notifier_call_chain_robust kernel/notifier.c:345 [inline] blocking_notifier_call_chain_robust+0xc9/0x170 kernel/notifier.c:333 pm_notifier_call_chain_robust+0x27/0x60 kernel/power/main.c:102 snapshot_open+0x189/0x2b0 kernel/power/user.c:77 misc_open+0x35a/0x420 drivers/char/misc.c:179 chrdev_open+0x237/0x6a0 fs/char_dev.c:414 do_dentry_open+0x735/0x1c40 fs/open.c:956 vfs_open+0x82/0x3f0 fs/open.c:1086 do_open fs/namei.c:3830 [inline] path_openat+0x1e88/0x2d80 fs/namei.c:3989 do_filp_open+0x20c/0x470 fs/namei.c:4016 do_sys_openat2+0x17a/0x1e0 fs/open.c:1428 do_sys_open fs/open.c:1443 [inline] __do_sys_openat fs/open.c:1459 [inline] __se_sys_openat fs/open.c:1454 [inline] __x64_sys_openat+0x175/0x210 fs/open.c:1454 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  -> #1 ((pm_chain_head).rwsem){++++}-{4:4}: down_read+0x9a/0x330 kernel/locking/rwsem.c:1524 blocking_notifier_call_chain_robust kerne ---truncated---",
      "cve": "CVE-2025-37745",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37745",
          "value": "CVE-2025-37745",
          "url": "https://scout.docker.com/v/CVE-2025-37745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fc67cfd57d1ce29b2ac740bfed9727e17a8443afb690c10970c5ceb26d5c8a99",
      "category": "container_scanning",
      "message": "CVE-2025-37746 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  perf/dwc_pcie: fix duplicate pci_dev devices  During platform_device_register, wrongly using struct device pci_dev as platform_data caused a kmemdup copy of pci_dev. Worse still, accessing the duplicated device leads to list corruption as its mutex content (e.g., list, magic) remains the same as the original.",
      "cve": "CVE-2025-37746",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37746",
          "value": "CVE-2025-37746",
          "url": "https://scout.docker.com/v/CVE-2025-37746?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37746?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9ed8e368b0a432cc827c98d41f747649201abb2771d9e46aadf7ad338fef742e",
      "category": "container_scanning",
      "message": "CVE-2025-37747 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  perf: Fix hang while freeing sigtrap event  Perf can hang while freeing a sigtrap event if a related deferred signal hadn't managed to be sent before the file got closed:  perf_event_overflow() task_work_add(perf_pending_task)  fput() task_work_add(____fput())  task_work_run() ____fput() perf_release() perf_event_release_kernel() _free_event() perf_pending_task_sync() task_work_cancel() -> FAILED rcuwait_wait_event()  Once task_work_run() is running, the list of pending callbacks is removed from the task_struct and from this point on task_work_cancel() can't remove any pending and not yet started work items, hence the task_work_cancel() failure and the hang on rcuwait_wait_event().  Task work could be changed to remove one work at a time, so a work running on the current task can always cancel a pending one, however the wait / wake design is still subject to inverted dependencies when remote targets are involved, as pictured by Oleg:  T1                                                      T2  fd = perf_event_open(pid => T2->pid);                  fd = perf_event_open(pid => T1->pid); close(fd)                                              close(fd) <IRQ>                                                  <IRQ> perf_event_overflow() perf_event_overflow() task_work_add(perf_pending_task) task_work_add(perf_pending_task) </IRQ>                                                 </IRQ> fput()                                                 fput() task_work_add(____fput()) task_work_add(____fput())  task_work_run()                                        task_work_run() ____fput()                                             ____fput() perf_release() perf_release() perf_event_release_kernel() perf_event_release_kernel() _free_event() _free_event() perf_pending_task_sync() perf_pending_task_sync() rcuwait_wait_event() rcuwait_wait_event()  Therefore the only option left is to acquire the event reference count upon queueing the perf task work and release it from the task work, just like it was done before 3a5465418f5f (\"perf: Fix event leak upon exec and file release\") but without the leaks it fixed.  Some adjustments are necessary to make it work:  * A child event might dereference its parent upon freeing. Care must be taken to release the parent last.  * Some places assuming the event doesn't have any reference held and therefore can be freed right away must instead put the reference and let the reference counting to its job.",
      "cve": "CVE-2025-37747",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37747",
          "value": "CVE-2025-37747",
          "url": "https://scout.docker.com/v/CVE-2025-37747?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37747?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c771effb404b8602029c4f7fb8a7bd26d41306a3bcc7965129a7204a42c13a63",
      "category": "container_scanning",
      "message": "CVE-2025-37775 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix the warning from __kernel_write_iter  [ 2110.972290] ------------[ cut here ]------------ [ 2110.972301] WARNING: CPU: 3 PID: 735 at fs/read_write.c:599 __kernel_write_iter+0x21b/0x280  This patch doesn't allow writing to directory.",
      "cve": "CVE-2025-37775",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37775",
          "value": "CVE-2025-37775",
          "url": "https://scout.docker.com/v/CVE-2025-37775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dc13a025554f5b3d478261d7707241e059c008f21dc31c5d181ea542ecfb43c8",
      "category": "container_scanning",
      "message": "CVE-2025-37776 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in smb_break_all_levII_oplock()  There is a room in smb_break_all_levII_oplock that can cause racy issues when unlocking in the middle of the loop. This patch use read lock to protect whole loop.",
      "cve": "CVE-2025-37776",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37776",
          "value": "CVE-2025-37776",
          "url": "https://scout.docker.com/v/CVE-2025-37776?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37776?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2caf595292cad6f4725f84898394c6c0d1f1864ef5eb4bacac2b5313ed9f8449",
      "category": "container_scanning",
      "message": "CVE-2025-37777 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in __smb2_lease_break_noti()  Move tcp_transport free to ksmbd_conn_free. If ksmbd connection is referenced when ksmbd server thread terminates, It will not be freed, but conn->tcp_transport is freed. __smb2_lease_break_noti can be performed asynchronously when the connection is disconnected. __smb2_lease_break_noti calls ksmbd_conn_write, which can cause use-after-free when conn->ksmbd_transport is already freed.",
      "cve": "CVE-2025-37777",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37777",
          "value": "CVE-2025-37777",
          "url": "https://scout.docker.com/v/CVE-2025-37777?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37777?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b1ca5f2f853a88952caea3d8f01d799f5bb9f10b958bd7747f3b4cf5a0c90f87",
      "category": "container_scanning",
      "message": "CVE-2025-37778 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: Fix dangling pointer in krb_authenticate  krb_authenticate frees sess->user and does not set the pointer to NULL. It calls ksmbd_krb5_authenticate to reinitialise sess->user but that function may return without doing so. If that happens then smb2_sess_setup, which calls krb_authenticate, will be accessing free'd memory when it later uses sess->user.",
      "cve": "CVE-2025-37778",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37778",
          "value": "CVE-2025-37778",
          "url": "https://scout.docker.com/v/CVE-2025-37778?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37778?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f0d5683a9596b8d3112c0b68f5daf4d6e54d2359f9b7556add00eaa67fedc27a",
      "category": "container_scanning",
      "message": "CVE-2025-37786 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: dsa: free routing table on probe failure  If complete = true in dsa_tree_setup(), it means that we are the last switch of the tree which is successfully probing, and we should be setting up all switches from our probe path.  After \"complete\" becomes true, dsa_tree_setup_cpu_ports() or any subsequent function may fail. If that happens, the entire tree setup is in limbo: the first N-1 switches have successfully finished probing (doing nothing but having allocated persistent memory in the tree's dst->ports, and maybe dst->rtable), and switch N failed to probe, ending the tree setup process before anything is tangible from the user's PoV.  If switch N fails to probe, its memory (ports) will be freed and removed from dst->ports. However, the dst->rtable elements pointing to its ports, as created by dsa_link_touch(), will remain there, and will lead to use-after-free if dereferenced.  If dsa_tree_setup_switches() returns -EPROBE_DEFER, which is entirely possible because that is where ds->ops->setup() is, we get a kasan report like this:  ================================================================== BUG: KASAN: slab-use-after-free in mv88e6xxx_setup_upstream_port+0x240/0x568 Read of size 8 at addr ffff000004f56020 by task kworker/u8:3/42  Call trace: __asan_report_load8_noabort+0x20/0x30 mv88e6xxx_setup_upstream_port+0x240/0x568 mv88e6xxx_setup+0xebc/0x1eb0 dsa_register_switch+0x1af4/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350  Allocated by task 42: __kasan_kmalloc+0x84/0xa0 __kmalloc_cache_noprof+0x298/0x490 dsa_switch_touch_ports+0x174/0x3d8 dsa_register_switch+0x800/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350  Freed by task 42: __kasan_slab_free+0x48/0x68 kfree+0x138/0x418 dsa_register_switch+0x2694/0x2ae0 mv88e6xxx_register_switch+0x1b8/0x2a8 mv88e6xxx_probe+0xc4c/0xf60 mdio_probe+0x78/0xb8 really_probe+0x2b8/0x5a8 __driver_probe_device+0x164/0x298 driver_probe_device+0x78/0x258 __device_attach_driver+0x274/0x350  The simplest way to fix the bug is to delete the routing table in its entirety. dsa_tree_setup_routing_table() has no problem in regenerating it even if we deleted links between ports other than those of switch N, because dsa_link_touch() first checks whether the port pair already exists in dst->rtable, allocating if not.  The deletion of the routing table in its entirety already exists in dsa_tree_teardown(), so refactor that into a function that can also be called from the tree setup error path.  In my analysis of the commit to blame, it is the one which added dsa_link elements to dst->rtable. Prior to that, each switch had its own ds->rtable which is freed when the switch fails to probe. But the tree is potentially persistent memory.",
      "cve": "CVE-2025-37786",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37786",
          "value": "CVE-2025-37786",
          "url": "https://scout.docker.com/v/CVE-2025-37786?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37786?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7d403d4fe35fd44f372bfc8c0aa50ea97363de59434d5aefe94cf2e9063349fb",
      "category": "container_scanning",
      "message": "CVE-2025-37806 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/ntfs3: Keep write operations atomic  syzbot reported a NULL pointer dereference in __generic_file_write_iter. [1]  Before the write operation is completed, the user executes ioctl[2] to clear the compress flag of the file, which causes the is_compressed() judgment to return 0, further causing the program to enter the wrong process and call the wrong ops ntfs_aops_cmpr, which triggers the null pointer dereference of write_begin.  Use inode lock to synchronize ioctl and write to avoid this case.  [1] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Mem abort info: ESR = 0x0000000086000006 EC = 0x21: IABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x06: level 2 translation fault user pgtable: 4k pages, 48-bit VAs, pgdp=000000011896d000 [0000000000000000] pgd=0800000118b44403, p4d=0800000118b44403, pud=0800000117517403, pmd=0000000000000000 Internal error: Oops: 0000000086000006 [#1] PREEMPT SMP Modules linked in: CPU: 0 UID: 0 PID: 6427 Comm: syz-executor347 Not tainted 6.13.0-rc3-syzkaller-g573067a5a685 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : 0x0 lr : generic_perform_write+0x29c/0x868 mm/filemap.c:4055 sp : ffff80009d4978a0 x29: ffff80009d4979c0 x28: dfff800000000000 x27: ffff80009d497bc8 x26: 0000000000000000 x25: ffff80009d497960 x24: ffff80008ba71c68 x23: 0000000000000000 x22: ffff0000c655dac0 x21: 0000000000001000 x20: 000000000000000c x19: 1ffff00013a92f2c x18: ffff0000e183aa1c x17: 0004060000000014 x16: ffff800083275834 x15: 0000000000000001 x14: 0000000000000000 x13: 0000000000000001 x12: ffff0000c655dac0 x11: 0000000000ff0100 x10: 0000000000ff0100 x9 : 0000000000000000 x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000 x5 : ffff80009d497980 x4 : ffff80009d497960 x3 : 0000000000001000 x2 : 0000000000000000 x1 : ffff0000e183a928 x0 : ffff0000d60b0fc0 Call trace: 0x0 (P) __generic_file_write_iter+0xfc/0x204 mm/filemap.c:4156 ntfs_file_write_iter+0x54c/0x630 fs/ntfs3/file.c:1267 new_sync_write fs/read_write.c:586 [inline] vfs_write+0x920/0xcf4 fs/read_write.c:679 ksys_write+0x15c/0x26c fs/read_write.c:731 __do_sys_write fs/read_write.c:742 [inline] __se_sys_write fs/read_write.c:739 [inline] __arm64_sys_write+0x7c/0x90 fs/read_write.c:739 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762  [2] ioctl$FS_IOC_SETFLAGS(r0, 0x40086602, &(0x7f00000000c0)=0x20)",
      "cve": "CVE-2025-37806",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37806",
          "value": "CVE-2025-37806",
          "url": "https://scout.docker.com/v/CVE-2025-37806?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37806?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f185d2e4b50d38edcaf5789ca1cd007dc6647b9ef5d0782bfcea32fe80755f8f",
      "category": "container_scanning",
      "message": "CVE-2025-37807 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix kmemleak warning for percpu hashmap  Vlad Poenaru reported the following kmemleak issue:  unreferenced object 0x606fd7c44ac8 (size 32): backtrace (crc 0): pcpu_alloc_noprof+0x730/0xeb0 bpf_map_alloc_percpu+0x69/0xc0 prealloc_init+0x9d/0x1b0 htab_map_alloc+0x363/0x510 map_create+0x215/0x3a0 __sys_bpf+0x16b/0x3e0 __x64_sys_bpf+0x18/0x20 do_syscall_64+0x7b/0x150 entry_SYSCALL_64_after_hwframe+0x4b/0x53  Further investigation shows the reason is due to not 8-byte aligned store of percpu pointer in htab_elem_set_ptr(): *(void __percpu **)(l->key + key_size) = pptr;  Note that the whole htab_elem alignment is 8 (for x86_64). If the key_size is 4, that means pptr is stored in a location which is 4 byte aligned but not 8 byte aligned. In mm/kmemleak.c, scan_block() scans the memory based on 8 byte stride, so it won't detect above pptr, hence reporting the memory leak.  In htab_map_alloc(), we already have  htab->elem_size = sizeof(struct htab_elem) + round_up(htab->map.key_size, 8); if (percpu) htab->elem_size += sizeof(void *); else htab->elem_size += round_up(htab->map.value_size, 8);  So storing pptr with 8-byte alignment won't cause any problem and can fix kmemleak too.  The issue can be reproduced with bpf selftest as well: 1. Enable CONFIG_DEBUG_KMEMLEAK config 2. Add a getchar() before skel destroy in test_hash_map() in prog_tests/for_each.c. The purpose is to keep map available so kmemleak can be detected. 3. run './test_progs -t for_each/hash_map &' and a kmemleak should be reported.",
      "cve": "CVE-2025-37807",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37807",
          "value": "CVE-2025-37807",
          "url": "https://scout.docker.com/v/CVE-2025-37807?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37807?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1635c747cf51e72e328f1da69059a3ce3125865dfb8ff78636b1900285df39d3",
      "category": "container_scanning",
      "message": "CVE-2025-37820 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xen-netfront: handle NULL returned by xdp_convert_buff_to_frame()  The function xdp_convert_buff_to_frame() may return NULL if it fails to correctly convert the XDP buffer into an XDP frame due to memory constraints, internal errors, or invalid data. Failing to check for NULL may lead to a NULL pointer dereference if the result is used later in processing, potentially causing crashes, data corruption, or undefined behavior.  On XDP redirect failure, the associated page must be released explicitly if it was previously retained via get_page(). Failing to do so may result in a memory leak, as the pages reference count is not decremented.",
      "cve": "CVE-2025-37820",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37820",
          "value": "CVE-2025-37820",
          "url": "https://scout.docker.com/v/CVE-2025-37820?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37820?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1a578d1a86bdd58180e7866c04b3ae0c3fe871ffa49987b3023c9ab46b921690",
      "category": "container_scanning",
      "message": "CVE-2025-37822 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: uprobes: Add missing fence.i after building the XOL buffer  The XOL (execute out-of-line) buffer is used to single-step the replaced instruction(s) for uprobes. The RISC-V port was missing a proper fence.i (i$ flushing) after constructing the XOL buffer, which can result in incorrect execution of stale/broken instructions.  This was found running the BPF selftests \"test_progs: uprobe_autoattach, attach_probe\" on the Spacemit K1/X60, where the uprobes tests randomly blew up.",
      "cve": "CVE-2025-37822",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37822",
          "value": "CVE-2025-37822",
          "url": "https://scout.docker.com/v/CVE-2025-37822?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37822?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "70fd2d9b59019b6a50033a83c8fe2b4486fdc227e1a363f8b1605d056cf83908",
      "category": "container_scanning",
      "message": "CVE-2025-37833 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/niu: Niu requires MSIX ENTRY_DATA fields touch before entry reads  Fix niu_try_msix() to not cause a fatal trap on sparc systems.  Set PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST on the struct pci_dev to work around a bug in the hardware or firmware.  For each vector entry in the msix table, niu chips will cause a fatal trap if any registers in that entry are read before that entries' ENTRY_DATA register is written to. Testing indicates writes to other registers are not sufficient to prevent the fatal trap, however the value does not appear to matter. This only needs to happen once after power up, so simply rebooting into a kernel lacking this fix will NOT cause the trap.  NON-RESUMABLE ERROR: Reporting on cpu 64 NON-RESUMABLE ERROR: TPC [0x00000000005f6900] <msix_prepare_msi_desc+0x90/0xa0> NON-RESUMABLE ERROR: RAW [4010000000000016:00000e37f93e32ff:0000000202000080:ffffffffffffffff NON-RESUMABLE ERROR: 0000000800000000:0000000000000000:0000000000000000:0000000000000000] NON-RESUMABLE ERROR: handle [0x4010000000000016] stick [0x00000e37f93e32ff] NON-RESUMABLE ERROR: type [precise nonresumable] NON-RESUMABLE ERROR: attrs [0x02000080] < ASI sp-faulted priv > NON-RESUMABLE ERROR: raddr [0xffffffffffffffff] NON-RESUMABLE ERROR: insn effective address [0x000000c50020000c] NON-RESUMABLE ERROR: size [0x8] NON-RESUMABLE ERROR: asi [0x00] CPU: 64 UID: 0 PID: 745 Comm: kworker/64:1 Not tainted 6.11.5 #63 Workqueue: events work_for_cpu_fn TSTATE: 0000000011001602 TPC: 00000000005f6900 TNPC: 00000000005f6904 Y: 00000000    Not tainted TPC: <msix_prepare_msi_desc+0x90/0xa0> g0: 00000000000002e9 g1: 000000000000000c g2: 000000c50020000c g3: 0000000000000100 g4: ffff8000470307c0 g5: ffff800fec5be000 g6: ffff800047a08000 g7: 0000000000000000 o0: ffff800014feb000 o1: ffff800047a0b620 o2: 0000000000000011 o3: ffff800047a0b620 o4: 0000000000000080 o5: 0000000000000011 sp: ffff800047a0ad51 ret_pc: 00000000005f7128 RPC: <__pci_enable_msix_range+0x3cc/0x460> l0: 000000000000000d l1: 000000000000c01f l2: ffff800014feb0a8 l3: 0000000000000020 l4: 000000000000c000 l5: 0000000000000001 l6: 0000000020000000 l7: ffff800047a0b734 i0: ffff800014feb000 i1: ffff800047a0b730 i2: 0000000000000001 i3: 000000000000000d i4: 0000000000000000 i5: 0000000000000000 i6: ffff800047a0ae81 i7: 00000000101888b0 I7: <niu_try_msix.constprop.0+0xc0/0x130 [niu]> Call Trace: [<00000000101888b0>] niu_try_msix.constprop.0+0xc0/0x130 [niu] [<000000001018f840>] niu_get_invariants+0x183c/0x207c [niu] [<00000000101902fc>] niu_pci_init_one+0x27c/0x2fc [niu] [<00000000005ef3e4>] local_pci_probe+0x28/0x74 [<0000000000469240>] work_for_cpu_fn+0x8/0x1c [<000000000046b008>] process_scheduled_works+0x144/0x210 [<000000000046b518>] worker_thread+0x13c/0x1c0 [<00000000004710e0>] kthread+0xb8/0xc8 [<00000000004060c8>] ret_from_fork+0x1c/0x2c [<0000000000000000>] 0x0 Kernel panic - not syncing: Non-resumable error.",
      "cve": "CVE-2025-37833",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37833",
          "value": "CVE-2025-37833",
          "url": "https://scout.docker.com/v/CVE-2025-37833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c5cf62b0c96f606944443afc87f80aeb28e92cf62f7866686cef39d86bdd3b0b",
      "category": "container_scanning",
      "message": "CVE-2025-37834 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/vmscan: don't try to reclaim hwpoison folio  Syzkaller reports a bug as follows:  Injecting memory failure for pfn 0x18b00e at process virtual address 0x20ffd000 Memory failure: 0x18b00e: dirty swapcache page still referenced by 2 users Memory failure: 0x18b00e: recovery action for dirty swapcache page: Failed page: refcount:2 mapcount:0 mapping:0000000000000000 index:0x20ffd pfn:0x18b00e memcg:ffff0000dd6d9000 anon flags: 0x5ffffe00482011(locked|dirty|arch_1|swapbacked|hwpoison|node=0|zone=2|lastcpupid=0xfffff) raw: 005ffffe00482011 dead000000000100 dead000000000122 ffff0000e232a7c9 raw: 0000000000020ffd 0000000000000000 00000002ffffffff ffff0000dd6d9000 page dumped because: VM_BUG_ON_FOLIO(!folio_test_uptodate(folio)) ------------[ cut here ]------------ kernel BUG at mm/swap_state.c:184! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP Modules linked in: CPU: 0 PID: 60 Comm: kswapd0 Not tainted 6.6.0-gcb097e7de84e #3 Hardware name: linux,dummy-virt (DT) pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : add_to_swap+0xbc/0x158 lr : add_to_swap+0xbc/0x158 sp : ffff800087f37340 x29: ffff800087f37340 x28: fffffc00052c0380 x27: ffff800087f37780 x26: ffff800087f37490 x25: ffff800087f37c78 x24: ffff800087f377a0 x23: ffff800087f37c50 x22: 0000000000000000 x21: fffffc00052c03b4 x20: 0000000000000000 x19: fffffc00052c0380 x18: 0000000000000000 x17: 296f696c6f662865 x16: 7461646f7470755f x15: 747365745f6f696c x14: 6f6621284f494c4f x13: 0000000000000001 x12: ffff600036d8b97b x11: 1fffe00036d8b97a x10: ffff600036d8b97a x9 : dfff800000000000 x8 : 00009fffc9274686 x7 : ffff0001b6c5cbd3 x6 : 0000000000000001 x5 : ffff0000c25896c0 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000000 x1 : ffff0000c25896c0 x0 : 0000000000000000 Call trace: add_to_swap+0xbc/0x158 shrink_folio_list+0x12ac/0x2648 shrink_inactive_list+0x318/0x948 shrink_lruvec+0x450/0x720 shrink_node_memcgs+0x280/0x4a8 shrink_node+0x128/0x978 balance_pgdat+0x4f0/0xb20 kswapd+0x228/0x438 kthread+0x214/0x230 ret_from_fork+0x10/0x20  I can reproduce this issue with the following steps:  1) When a dirty swapcache page is isolated by reclaim process and the page isn't locked, inject memory failure for the page. me_swapcache_dirty() clears uptodate flag and tries to delete from lru, but fails.  Reclaim process will put the hwpoisoned page back to lru.  2) The process that maps the hwpoisoned page exits, the page is deleted the page will never be freed and will be in the lru forever.  3) If we trigger a reclaim again and tries to reclaim the page, add_to_swap() will trigger VM_BUG_ON_FOLIO due to the uptodate flag is cleared.  To fix it, skip the hwpoisoned page in shrink_folio_list().  Besides, the hwpoison folio may not be unmapped by hwpoison_user_mappings() yet, unmap it in shrink_folio_list(), otherwise the folio will fail to be unmaped by hwpoison_user_mappings() since the folio isn't in lru list.",
      "cve": "CVE-2025-37834",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37834",
          "value": "CVE-2025-37834",
          "url": "https://scout.docker.com/v/CVE-2025-37834?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37834?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "187883ac63f690ed9fb5468961547a2a10c6ef69a3ca96e21af8af4cb4a5fafe",
      "category": "container_scanning",
      "message": "CVE-2025-37842 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: fsl-qspi: use devm function instead of driver remove  Driver use devm APIs to manage clk/irq/resources and register the spi controller, but the legacy remove function will be called first during device detach and trigger kernel panic. Drop the remove function and use devm_add_action_or_reset() for driver cleanup to ensure the release sequence.  Trigger kernel panic on i.MX8MQ by echo 30bb0000.spi >/sys/bus/platform/drivers/fsl-quadspi/unbind",
      "cve": "CVE-2025-37842",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37842",
          "value": "CVE-2025-37842",
          "url": "https://scout.docker.com/v/CVE-2025-37842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c52d70e65b18133cbea0a0afe8d3b2680700fe4c849c3225aaa5a53fb68e53c5",
      "category": "container_scanning",
      "message": "CVE-2025-37849 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Tear down vGIC on failed vCPU creation  If kvm_arch_vcpu_create() fails to share the vCPU page with the hypervisor, we propagate the error back to the ioctl but leave the vGIC vCPU data initialised. Note only does this leak the corresponding memory when the vCPU is destroyed but it can also lead to use-after-free if the redistributor device handling tries to walk into the vCPU.  Add the missing cleanup to kvm_arch_vcpu_create(), ensuring that the vGIC vCPU structures are destroyed on error.",
      "cve": "CVE-2025-37849",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37849",
          "value": "CVE-2025-37849",
          "url": "https://scout.docker.com/v/CVE-2025-37849?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37849?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b51267b5a1b95ba751e600afdc7c8c89ba114656df3df7120a2f8123eb30ce7f",
      "category": "container_scanning",
      "message": "CVE-2025-37852 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: handle amdgpu_cgs_create_device() errors in amd_powerplay_create()  Add error handling to propagate amdgpu_cgs_create_device() failures to the caller. When amdgpu_cgs_create_device() fails, release hwmgr and return -ENOMEM to prevent null pointer dereference.  [v1]->[v2]: Change error code from -EINVAL to -ENOMEM. Free hwmgr.",
      "cve": "CVE-2025-37852",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37852",
          "value": "CVE-2025-37852",
          "url": "https://scout.docker.com/v/CVE-2025-37852?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37852?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cbd536e5ffcae98b6a0a24f43bf808f1c7d7d7f0aaf50e173cb7b702980ff3f7",
      "category": "container_scanning",
      "message": "CVE-2025-37853 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: debugfs hang_hws skip GPU with MES  debugfs hang_hws is used by GPU reset test with HWS, for MES this crash the kernel with NULL pointer access because dqm->packet_mgr is not setup for MES path.  Skip GPU with MES for now, MES hang_hws debugfs interface will be supported later.",
      "cve": "CVE-2025-37853",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37853",
          "value": "CVE-2025-37853",
          "url": "https://scout.docker.com/v/CVE-2025-37853?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37853?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0a56ad146e545437787c4cfadd5f90f018c195767f1c0fce977a0fdb16c19926",
      "category": "container_scanning",
      "message": "CVE-2025-37854 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Fix mode1 reset crash issue  If HW scheduler hangs and mode1 reset is used to recover GPU, KFD signal user space to abort the processes. After process abort exit, user queues still use the GPU to access system memory before h/w is reset while KFD cleanup worker free system memory and free VRAM.  There is use-after-free race bug that KFD allocate and reuse the freed system memory, and user queue write to the same system memory to corrupt the data structure and cause driver crash.  To fix this race, KFD cleanup worker terminate user queues, then flush reset_domain wq to wait for any GPU ongoing reset complete, and then free outstanding BOs.",
      "cve": "CVE-2025-37854",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37854",
          "value": "CVE-2025-37854",
          "url": "https://scout.docker.com/v/CVE-2025-37854?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37854?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "03b2faf4f72444294377ffd6cd79904d0d853f51079b32c61b4b3b336f171f60",
      "category": "container_scanning",
      "message": "CVE-2025-37855 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Guard Possible Null Pointer Dereference  [WHY] In some situations, dc->res_pool may be null.  [HOW] Check if pointer is null before dereference.",
      "cve": "CVE-2025-37855",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37855",
          "value": "CVE-2025-37855",
          "url": "https://scout.docker.com/v/CVE-2025-37855?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37855?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9ad15d86952dc2ceaf94122c4fb2d5ca04a77f6ab95c1409dab80d981cb31f1",
      "category": "container_scanning",
      "message": "CVE-2025-37856 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: harden block_group::bg_list against list_del() races  As far as I can tell, these calls of list_del_init() on bg_list cannot run concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim(), as they are in transaction error paths and situations where the block group is readonly.  However, if there is any chance at all of racing with mark_bg_unused(), or a different future user of bg_list, better to be safe than sorry.  Otherwise we risk the following interleaving (bg_list refcount in parens)  T1 (some random op)                       T2 (btrfs_mark_bg_unused) !list_empty(&bg->bg_list); (1) list_del_init(&bg->bg_list); (1) list_move_tail (1) btrfs_put_block_group (0) btrfs_delete_unused_bgs bg = list_first_entry list_del_init(&bg->bg_list); btrfs_put_block_group(bg); (-1)  Ultimately, this results in a broken ref count that hits zero one deref early and the real final deref underflows the refcount, resulting in a WARNING.",
      "cve": "CVE-2025-37856",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37856",
          "value": "CVE-2025-37856",
          "url": "https://scout.docker.com/v/CVE-2025-37856?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37856?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5faa42411d25bc4af371fe2ee64630386fae7644c0c5e9073ae9cc147f7fa87",
      "category": "container_scanning",
      "message": "CVE-2025-37861 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Synchronous access b/w reset and tm thread for reply queue  When the task management thread processes reply queues while the reset thread resets them, the task management thread accesses an invalid queue ID (0xFFFF), set by the reset thread, which points to unallocated memory, causing a crash.  Add flag 'io_admin_reset_sync' to synchronize access between the reset, I/O, and admin threads. Before a reset, the reset handler sets this flag to block I/O and admin processing threads. If any thread bypasses the initial check, the reset thread waits up to 10 seconds for processing to finish. If the wait exceeds 10 seconds, the controller is marked as unrecoverable.",
      "cve": "CVE-2025-37861",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37861",
          "value": "CVE-2025-37861",
          "url": "https://scout.docker.com/v/CVE-2025-37861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "435802258e7efe4d22b2435538e81513b6c298104a910f15fd5880e3a7b4c0b5",
      "category": "container_scanning",
      "message": "CVE-2025-37870 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: prevent hang on link training fail  [Why] When link training fails, the phy clock will be disabled. However, in enable_streams, it is assumed that link training succeeded and the mux selects the phy clock, causing a hang when a register write is made.  [How] When enable_stream is hit, check if link training failed. If it did, fall back to the ref clock to avoid a hang and keep the system in a recoverable state.",
      "cve": "CVE-2025-37870",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37870",
          "value": "CVE-2025-37870",
          "url": "https://scout.docker.com/v/CVE-2025-37870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "14e8ebf93cc503fcf988bf7eb220c0cf618202d9fe239f257645367a0bb0826f",
      "category": "container_scanning",
      "message": "CVE-2025-37876 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfs: Only create /proc/fs/netfs with CONFIG_PROC_FS  When testing a special config:  CONFIG_NETFS_SUPPORTS=y CONFIG_PROC_FS=n  The system crashes with something like:  [    3.766197] ------------[ cut here ]------------ [    3.766484] kernel BUG at mm/mempool.c:560! [    3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTI [    3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G        W [    3.767777] Tainted: [W]=WARN [    3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), [    3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19 [    3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00 [    3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286 [    3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000 [    3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffff [    3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828 [    3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0 [    3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40 [    3.772554] FS:  0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000 [    3.773061] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [    3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0 [    3.773884] PKRU: 55555554 [    3.774058] Call Trace: [    3.774232]  <TASK> [    3.774371]  mempool_alloc_noprof+0x6a/0x190 [    3.774649]  ? _printk+0x57/0x80 [    3.774862]  netfs_alloc_request+0x85/0x2ce [    3.775147]  netfs_readahead+0x28/0x170 [    3.775395]  read_pages+0x6c/0x350 [    3.775623]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.775928]  page_cache_ra_unbounded+0x1bd/0x2a0 [    3.776247]  filemap_get_pages+0x139/0x970 [    3.776510]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.776820]  filemap_read+0xf9/0x580 [    3.777054]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.777368]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.777674]  ? find_held_lock+0x32/0x90 [    3.777929]  ? netfs_start_io_read+0x19/0x70 [    3.778221]  ? netfs_start_io_read+0x19/0x70 [    3.778489]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.778800]  ? lock_acquired+0x1e6/0x450 [    3.779054]  ? srso_alias_return_thunk+0x5/0xfbef5 [    3.779379]  netfs_buffered_read_iter+0x57/0x80 [    3.779670]  __kernel_read+0x158/0x2c0 [    3.779927]  bprm_execve+0x300/0x7a0 [    3.780185]  kernel_execve+0x10c/0x140 [    3.780423]  ? __pfx_kernel_init+0x10/0x10 [    3.780690]  kernel_init+0xd5/0x150 [    3.780910]  ret_from_fork+0x2d/0x50 [    3.781156]  ? __pfx_kernel_init+0x10/0x10 [    3.781414]  ret_from_fork_asm+0x1a/0x30 [    3.781677]  </TASK> [    3.781823] Modules linked in: [    3.782065] ---[ end trace 0000000000000000 ]---  This is caused by the following error path in netfs_init():  if (!proc_mkdir(\"fs/netfs\", NULL)) goto error_proc;  Fix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only created with CONFIG_PROC_FS.",
      "cve": "CVE-2025-37876",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37876",
          "value": "CVE-2025-37876",
          "url": "https://scout.docker.com/v/CVE-2025-37876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f87a98aa432ad283dfa781ec13bb7689468090f0d30c1ed098cd9f7e744581ab",
      "category": "container_scanning",
      "message": "CVE-2025-37877 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu: Clear iommu-dma ops on cleanup  If iommu_device_register() encounters an error, it can end up tearing down already-configured groups and default domains, however this currently still leaves devices hooked up to iommu-dma (and even historically the behaviour in this area was at best inconsistent across architectures/drivers...) Although in the case that an IOMMU is present whose driver has failed to probe, users cannot necessarily expect DMA to work anyway, it's still arguable that we should do our best to put things back as if the IOMMU driver was never there at all, and certainly the potential for crashing in iommu-dma itself is undesirable. Make sure we clean up the dev->dma_iommu flag along with everything else.",
      "cve": "CVE-2025-37877",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37877",
          "value": "CVE-2025-37877",
          "url": "https://scout.docker.com/v/CVE-2025-37877?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37877?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2be0e562339046806d37269db3958b70a31e3ff3c34da8182f3d78ede8e9b7f5",
      "category": "container_scanning",
      "message": "CVE-2025-37878 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  perf/core: Fix WARN_ON(!ctx) in __free_event() for partial init  Move the get_ctx(child_ctx) call and the child_event->ctx assignment to occur immediately after the child event is allocated. Ensure that child_event->ctx is non-NULL before any subsequent error path within inherit_event calls free_event(), satisfying the assumptions of the cleanup code.  Details:  There's no clear Fixes tag, because this bug is a side-effect of multiple interacting commits over time (up to 15 years old), not a single regression.  The code initially incremented refcount then assigned context immediately after the child_event was created. Later, an early validity check for child_event was added before the refcount/assignment. Even later, a WARN_ON_ONCE() cleanup check was added, assuming event->ctx is valid if the pmu_ctx is valid. The problem is that the WARN_ON_ONCE() could trigger after the initial check passed but before child_event->ctx was assigned, violating its precondition. The solution is to assign child_event->ctx right after its initial validation. This ensures the context exists for any subsequent checks or cleanup routines, resolving the WARN_ON_ONCE().  To resolve it, defer the refcount update and child_event->ctx assignment directly after child_event->pmu_ctx is set but before checking if the parent event is orphaned. The cleanup routine depends on event->pmu_ctx being non-NULL before it verifies event->ctx is non-NULL. This also maintains the author's original intent of passing in child_ctx to find_get_pmu_context before its refcount/assignment.  [ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ]",
      "cve": "CVE-2025-37878",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37878",
          "value": "CVE-2025-37878",
          "url": "https://scout.docker.com/v/CVE-2025-37878?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37878?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d7c775e41978b4e132302e01807089e347ff1183fdd75ee3b65b80eb6a8aa08",
      "category": "container_scanning",
      "message": "CVE-2025-37879 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  9p/net: fix improper handling of bogus negative read/write replies  In p9_client_write() and p9_client_read_once(), if the server incorrectly replies with success but a negative write/read count then we would consider written (negative) <= rsize (positive) because both variables were signed.  Make variables unsigned to avoid this problem.  The reproducer linked below now fails with the following error instead of a null pointer deref: 9pnet: bogus RWRITE count (4294967295 > 3)",
      "cve": "CVE-2025-37879",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37879",
          "value": "CVE-2025-37879",
          "url": "https://scout.docker.com/v/CVE-2025-37879?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37879?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "48316b302d3c6a4baa4df37cf3036ead7fc236068d33bd3a940b2d3ccb2b37ea",
      "category": "container_scanning",
      "message": "CVE-2025-37880 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  um: work around sched_yield not yielding in time-travel mode  sched_yield by a userspace may not actually cause scheduling in time-travel mode as no time has passed. In the case seen it appears to be a badly implemented userspace spinlock in ASAN. Unfortunately, with time-travel it causes an extreme slowdown or even deadlock depending on the kernel configuration (CONFIG_UML_MAX_USERSPACE_ITERATIONS).  Work around it by accounting time to the process whenever it executes a sched_yield syscall.",
      "cve": "CVE-2025-37880",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37880",
          "value": "CVE-2025-37880",
          "url": "https://scout.docker.com/v/CVE-2025-37880?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37880?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cb4ba26c2faf37dade6c7302779170839523bd46ef2caa2de3e33fab71aaa7e7",
      "category": "container_scanning",
      "message": "CVE-2025-37882 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: xhci: Fix isochronous Ring Underrun/Overrun event handling  The TRB pointer of these events points at enqueue at the time of error occurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we are handling the event, a new TD may be queued at this ring position.  I can trigger this race by rising interrupt moderation to increase IRQ handling delay. Similar delay may occur naturally due to system load.  If this ever happens after a Missed Service Error, missed TDs will be skipped and the new TD processed as if it matched the event. It could be given back prematurely, risking data loss or buffer UAF by the xHC.  Don't complete TDs on xrun events and don't warn if queued TDs don't match the event's TRB pointer, which can be NULL or a link/no-op TRB. Don't warn if there are no queued TDs at all.  Now that it's safe, also handle xrun events if the skip flag is clear. This ensures completion of any TD stuck in 'error mid TD' state right before the xrun event, which could happen if a driver submits a finite number of URBs to a buggy HC and then an error occurs on the last TD.",
      "cve": "CVE-2025-37882",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37882",
          "value": "CVE-2025-37882",
          "url": "https://scout.docker.com/v/CVE-2025-37882?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37882?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "295f70f2f323ca6a9a3bfddd8d3c15cf008c701563cdfed7f3f71a8b7963e6ab",
      "category": "container_scanning",
      "message": "CVE-2025-37884 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix deadlock between rcu_tasks_trace and event_mutex.  Fix the following deadlock: CPU A _free_event() perf_kprobe_destroy() mutex_lock(&event_mutex) perf_trace_event_unreg() synchronize_rcu_tasks_trace()  There are several paths where _free_event() grabs event_mutex and calls sync_rcu_tasks_trace. Above is one such case.  CPU B bpf_prog_test_run_syscall() rcu_read_lock_trace() bpf_prog_run_pin_on_cpu() bpf_prog_load() bpf_tracing_func_proto() trace_set_clr_event() mutex_lock(&event_mutex)  Delegate trace_set_clr_event() to workqueue to avoid such lock dependency.",
      "cve": "CVE-2025-37884",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37884",
          "value": "CVE-2025-37884",
          "url": "https://scout.docker.com/v/CVE-2025-37884?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37884?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fc510b97dbe90236dd2803e3958fbf54a33a2596f3f8c353d463debe39699f24",
      "category": "container_scanning",
      "message": "CVE-2025-37899 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in session logoff  The sess->user object can currently be in use by another thread, for example if another connection has sent a session setup request to bind to the session being free'd. The handler for that connection could be in the smb2_sess_setup function which makes use of sess->user.",
      "cve": "CVE-2025-37899",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37899",
          "value": "CVE-2025-37899",
          "url": "https://scout.docker.com/v/CVE-2025-37899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4061bdd5a7d04edf3eb4821106bdc24879c709d6c5134f90e0dc57fc7855df01",
      "category": "container_scanning",
      "message": "CVE-2025-37903 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix slab-use-after-free in hdcp  The HDCP code in amdgpu_dm_hdcp.c copies pointers to amdgpu_dm_connector objects without incrementing the kref reference counts. When using a USB-C dock, and the dock is unplugged, the corresponding amdgpu_dm_connector objects are freed, creating dangling pointers in the HDCP code. When the dock is plugged back, the dangling pointers are dereferenced, resulting in a slab-use-after-free:  [   66.775837] BUG: KASAN: slab-use-after-free in event_property_validate+0x42f/0x6c0 [amdgpu] [   66.776171] Read of size 4 at addr ffff888127804120 by task kworker/0:1/10  [   66.776179] CPU: 0 UID: 0 PID: 10 Comm: kworker/0:1 Not tainted 6.14.0-rc7-00180-g54505f727a38-dirty #233 [   66.776183] Hardware name: HP HP Pavilion Aero Laptop 13-be0xxx/8916, BIOS F.17 12/18/2024 [   66.776186] Workqueue: events event_property_validate [amdgpu] [   66.776494] Call Trace: [   66.776496]  <TASK> [   66.776497]  dump_stack_lvl+0x70/0xa0 [   66.776504]  print_report+0x175/0x555 [   66.776507]  ? __virt_addr_valid+0x243/0x450 [   66.776510]  ? kasan_complete_mode_report_info+0x66/0x1c0 [   66.776515]  kasan_report+0xeb/0x1c0 [   66.776518]  ? event_property_validate+0x42f/0x6c0 [amdgpu] [   66.776819]  ? event_property_validate+0x42f/0x6c0 [amdgpu] [   66.777121]  __asan_report_load4_noabort+0x14/0x20 [   66.777124]  event_property_validate+0x42f/0x6c0 [amdgpu] [   66.777342]  ? __lock_acquire+0x6b40/0x6b40 [   66.777347]  ? enable_assr+0x250/0x250 [amdgpu] [   66.777571]  process_one_work+0x86b/0x1510 [   66.777575]  ? pwq_dec_nr_in_flight+0xcf0/0xcf0 [   66.777578]  ? assign_work+0x16b/0x280 [   66.777580]  ? lock_is_held_type+0xa3/0x130 [   66.777583]  worker_thread+0x5c0/0xfa0 [   66.777587]  ? process_one_work+0x1510/0x1510 [   66.777588]  kthread+0x3a2/0x840 [   66.777591]  ? kthread_is_per_cpu+0xd0/0xd0 [   66.777594]  ? trace_hardirqs_on+0x4f/0x60 [   66.777597]  ? _raw_spin_unlock_irq+0x27/0x60 [   66.777599]  ? calculate_sigpending+0x77/0xa0 [   66.777602]  ? kthread_is_per_cpu+0xd0/0xd0 [   66.777605]  ret_from_fork+0x40/0x90 [   66.777607]  ? kthread_is_per_cpu+0xd0/0xd0 [   66.777609]  ret_from_fork_asm+0x11/0x20 [   66.777614]  </TASK>  [   66.777643] Allocated by task 10: [   66.777646]  kasan_save_stack+0x39/0x60 [   66.777649]  kasan_save_track+0x14/0x40 [   66.777652]  kasan_save_alloc_info+0x37/0x50 [   66.777655]  __kasan_kmalloc+0xbb/0xc0 [   66.777658]  __kmalloc_cache_noprof+0x1c8/0x4b0 [   66.777661]  dm_dp_add_mst_connector+0xdd/0x5c0 [amdgpu] [   66.777880]  drm_dp_mst_port_add_connector+0x47e/0x770 [drm_display_helper] [   66.777892]  drm_dp_send_link_address+0x1554/0x2bf0 [drm_display_helper] [   66.777901]  drm_dp_check_and_send_link_address+0x187/0x1f0 [drm_display_helper] [   66.777909]  drm_dp_mst_link_probe_work+0x2b8/0x410 [drm_display_helper] [   66.777917]  process_one_work+0x86b/0x1510 [   66.777919]  worker_thread+0x5c0/0xfa0 [   66.777922]  kthread+0x3a2/0x840 [   66.777925]  ret_from_fork+0x40/0x90 [   66.777927]  ret_from_fork_asm+0x11/0x20  [   66.777932] Freed by task 1713: [   66.777935]  kasan_save_stack+0x39/0x60 [   66.777938]  kasan_save_track+0x14/0x40 [   66.777940]  kasan_save_free_info+0x3b/0x60 [   66.777944]  __kasan_slab_free+0x52/0x70 [   66.777946]  kfree+0x13f/0x4b0 [   66.777949]  dm_dp_mst_connector_destroy+0xfa/0x150 [amdgpu] [   66.778179]  drm_connector_free+0x7d/0xb0 [   66.778184]  drm_mode_object_put.part.0+0xee/0x160 [   66.778188]  drm_mode_object_put+0x37/0x50 [   66.778191]  drm_atomic_state_default_clear+0x220/0xd60 [   66.778194]  __drm_atomic_state_free+0x16e/0x2a0 [   66.778197]  drm_mode_atomic_ioctl+0x15ed/0x2ba0 [   66.778200]  drm_ioctl_kernel+0x17a/0x310 [   66.778203]  drm_ioctl+0x584/0xd10 [   66.778206]  amdgpu_drm_ioctl+0xd2/0x1c0 [amdgpu] [   66.778375]  __x64_sys_ioctl+0x139/0x1a0 [   66.778378]  x64_sys_call+0xee7/0xfb0 [   66.778381] ---truncated---",
      "cve": "CVE-2025-37903",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37903",
          "value": "CVE-2025-37903",
          "url": "https://scout.docker.com/v/CVE-2025-37903?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37903?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c8f508c99b9c17d3e85eee8f2fbd19e7d5195a27d7822a3290d9564a36a16583",
      "category": "container_scanning",
      "message": "CVE-2025-37907 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  accel/ivpu: Fix locking order in ivpu_job_submit  Fix deadlock in job submission and abort handling. When a thread aborts currently executing jobs due to a fault, it first locks the global lock protecting submitted_jobs (#1).  After the last job is destroyed, it proceeds to release the related context and locks file_priv (#2). Meanwhile, in the job submission thread, the file_priv lock (#2) is taken first, and then the submitted_jobs lock (#1) is obtained when a job is added to the submitted jobs list.  CPU0                            CPU1 ----                    \t       ---- (for example due to a fault)         (jobs submissions keep coming)  lock(&vdev->submitted_jobs_lock) #1 ivpu_jobs_abort_all() job_destroy() lock(&file_priv->lock)           #2 lock(&vdev->submitted_jobs_lock) #1 file_priv_release() lock(&vdev->context_list_lock) lock(&file_priv->lock)           #2  This order of locking causes a deadlock. To resolve this issue, change the order of locking in ivpu_job_submit().",
      "cve": "CVE-2025-37907",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37907",
          "value": "CVE-2025-37907",
          "url": "https://scout.docker.com/v/CVE-2025-37907?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37907?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d56394c25fa5a4abf78afea062ead7bcdc23976d601d66491d84a53239909043",
      "category": "container_scanning",
      "message": "CVE-2025-37920 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xsk: Fix race condition in AF_XDP generic RX path  Move rx_lock from xsk_socket to xsk_buff_pool. Fix synchronization for shared umem mode in generic RX path where multiple sockets share single xsk_buff_pool.  RX queue is exclusive to xsk_socket, while FILL queue can be shared between multiple sockets. This could result in race condition where two CPU cores access RX path of two different sockets sharing the same umem.  Protect both queues by acquiring spinlock in shared xsk_buff_pool.  Lock contention may be minimized in the future by some per-thread FQ buffering.  It's safe and necessary to move spin_lock_bh(rx_lock) after xsk_rcv_check(): * xs->pool and spinlock_init is synchronized by xsk_bind() -> xsk_is_bound() memory barriers. * xsk_rcv_check() may return true at the moment of xsk_release() or xsk_unbind_dev(), however this will not cause any data races or race conditions. xsk_unbind_dev() removes xdp socket from all maps and waits for completion of all outstanding rx operations. Packets in RX path will either complete safely or drop.",
      "cve": "CVE-2025-37920",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37920",
          "value": "CVE-2025-37920",
          "url": "https://scout.docker.com/v/CVE-2025-37920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aa4344a6b3771da6b77a57aa89c99c4a9d11cf4319135d67f311224fabd536e8",
      "category": "container_scanning",
      "message": "CVE-2025-37924 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in kerberos authentication  Setting sess->user = NULL was introduced to fix the dangling pointer created by ksmbd_free_user. However, it is possible another thread could be operating on the session and make use of sess->user after it has been passed to ksmbd_free_user but before sess->user is set to NULL.",
      "cve": "CVE-2025-37924",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37924",
          "value": "CVE-2025-37924",
          "url": "https://scout.docker.com/v/CVE-2025-37924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "12fd154e7960360860e76b42cd17e8df756fccaa2681294ecd31a6f5baef56c4",
      "category": "container_scanning",
      "message": "CVE-2025-37926 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in ksmbd_session_rpc_open  A UAF issue can occur due to a race condition between ksmbd_session_rpc_open() and __session_rpc_close(). Add rpc_lock to the session to protect it.",
      "cve": "CVE-2025-37926",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37926",
          "value": "CVE-2025-37926",
          "url": "https://scout.docker.com/v/CVE-2025-37926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7fdb91e3fb3dc62bdfb571b4a9dd1caec2acc69beac5e7ef54233f3637d0efca",
      "category": "container_scanning",
      "message": "CVE-2025-37928 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm-bufio: don't schedule in atomic context  A BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and try_verify_in_tasklet are enabled. [  129.444685][  T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421 [  129.444723][  T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4 [  129.444740][  T934] preempt_count: 201, expected: 0 [  129.444756][  T934] RCU nest depth: 0, expected: 0 [  129.444781][  T934] Preemption disabled at: [  129.444789][  T934] [<ffffffd816231900>] shrink_work+0x21c/0x248 [  129.445167][  T934] kernel BUG at kernel/sched/walt/walt_debug.c:16! [  129.445183][  T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP [  129.445204][  T934] Skip md ftrace buffer dump for: 0x1609e0 [  129.447348][  T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G W  OE      6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8 [  129.447362][  T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT) [  129.447373][  T934] Workqueue: dm_bufio_cache shrink_work [  129.447394][  T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  129.447406][  T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug] [  129.447435][  T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c [  129.447451][  T934] sp : ffffffc0843dbc90 [  129.447459][  T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b [  129.447479][  T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68 [  129.447497][  T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900 [  129.447517][  T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030 [  129.447535][  T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358 [  129.447554][  T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003 [  129.447572][  T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400 [  129.447591][  T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8 [  129.447610][  T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0 [  129.447629][  T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000 [  129.447647][  T934] Call trace: [  129.447655][  T934]  android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6] [  129.447681][  T934]  __might_resched+0x190/0x1a8 [  129.447694][  T934]  shrink_work+0x180/0x248 [  129.447706][  T934]  process_one_work+0x260/0x624 [  129.447718][  T934]  worker_thread+0x28c/0x454 [  129.447729][  T934]  kthread+0x118/0x158 [  129.447742][  T934]  ret_from_fork+0x10/0x20 [  129.447761][  T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000) [  129.447772][  T934] ---[ end trace 0000000000000000 ]---  dm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet is enabled, and __scan will be called in atomic context.",
      "cve": "CVE-2025-37928",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37928",
          "value": "CVE-2025-37928",
          "url": "https://scout.docker.com/v/CVE-2025-37928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "06a3e70a82c4eabd9173fc1a0f3be2a9eaa168ec3ca5762194dfc8c698a7a792",
      "category": "container_scanning",
      "message": "CVE-2025-37931 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: adjust subpage bit start based on sectorsize  When running machines with 64k page size and a 16k nodesize we started seeing tree log corruption in production.  This turned out to be because we were not writing out dirty blocks sometimes, so this in fact affects all metadata writes.  When writing out a subpage EB we scan the subpage bitmap for a dirty range.  If the range isn't dirty we do  bit_start++;  to move onto the next bit.  The problem is the bitmap is based on the number of sectors that an EB has.  So in this case, we have a 64k pagesize, 16k nodesize, but a 4k sectorsize.  This means our bitmap is 4 bits for every node.  With a 64k page size we end up with 4 nodes per page.  To make this easier this is how everything looks  [0         16k       32k       48k     ] logical address [0         4         8         12      ] radix tree offset [               64k page               ] folio [ 16k eb ][ 16k eb ][ 16k eb ][ 16k eb ] extent buffers [ | | | |  | | | |   | | | |   | | | | ] bitmap  Now we use all of our addressing based on fs_info->sectorsize_bits, so as you can see the above our 16k eb->start turns into radix entry 4.  When we find a dirty range for our eb, we correctly do bit_start += sectors_per_node, because if we start at bit 0, the next bit for the next eb is 4, to correspond to eb->start 16k.  However if our range is clean, we will do bit_start++, which will now put us offset from our radix tree entries.  In our case, assume that the first time we check the bitmap the block is not dirty, we increment bit_start so now it == 1, and then we loop around and check again.  This time it is dirty, and we go to find that start using the following equation  start = folio_start + bit_start * fs_info->sectorsize;  so in the case above, eb->start 0 is now dirty, and we calculate start as  0 + 1 * fs_info->sectorsize = 4096 4096 >> 12 = 1  Now we're looking up the radix tree for 1, and we won't find an eb. What's worse is now we're using bit_start == 1, so we do bit_start += sectors_per_node, which is now 5.  If that eb is dirty we will run into the same thing, we will look at an offset that is not populated in the radix tree, and now we're skipping the writeout of dirty extent buffers.  The best fix for this is to not use sectorsize_bits to address nodes, but that's a larger change.  Since this is a fs corruption problem fix it simply by always using sectors_per_node to increment the start bit.",
      "cve": "CVE-2025-37931",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37931",
          "value": "CVE-2025-37931",
          "url": "https://scout.docker.com/v/CVE-2025-37931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "50a584cfd1c41de4b2c6f44890e48d0f86b61662cec461104455f9e37c2f3c9c",
      "category": "container_scanning",
      "message": "CVE-2025-37938 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Verify event formats that have \"%*p..\"  The trace event verifier checks the formats of trace events to make sure that they do not point at memory that is not in the trace event itself or in data that will never be freed. If an event references data that was allocated when the event triggered and that same data is freed before the event is read, then the kernel can crash by reading freed memory.  The verifier runs at boot up (or module load) and scans the print formats of the events and checks their arguments to make sure that dereferenced pointers are safe. If the format uses \"%*p..\" the verifier will ignore it, and that could be dangerous. Cover this case as well.  Also add to the sample code a use case of \"%*pbl\".",
      "cve": "CVE-2025-37938",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37938",
          "value": "CVE-2025-37938",
          "url": "https://scout.docker.com/v/CVE-2025-37938?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37938?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "765603aa99f49e156a88273b817217117e106f9cd3edc543861ae37ee2bc251b",
      "category": "container_scanning",
      "message": "CVE-2025-37942 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: pidff: Make sure to fetch pool before checking SIMULTANEOUS_MAX  As noted by Anssi some 20 years ago, pool report is sometimes messed up. This worked fine on many devices but casued oops on VRS DirectForce PRO.  Here, we're making sure pool report is refetched before trying to access any of it's fields. While loop was replaced with a for loop + exit conditions were moved aroud to decrease the possibility of creating an infinite loop scenario.",
      "cve": "CVE-2025-37942",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37942",
          "value": "CVE-2025-37942",
          "url": "https://scout.docker.com/v/CVE-2025-37942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1a430b8b3f391fb7d95be22ad1eed5f69dd7b213eeca06fc694c2fc111acd3c0",
      "category": "container_scanning",
      "message": "CVE-2025-37943 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Fix invalid data access in ath12k_dp_rx_h_undecap_nwifi  In certain cases, hardware might provide packets with a length greater than the maximum native Wi-Fi header length. This can lead to accessing and modifying fields in the header within the ath12k_dp_rx_h_undecap_nwifi function for DP_RX_DECAP_TYPE_NATIVE_WIFI decap type and potentially resulting in invalid data access and memory corruption.  Add a sanity check before processing the SKB to prevent invalid data access in the undecap native Wi-Fi function for the DP_RX_DECAP_TYPE_NATIVE_WIFI decap type.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2025-37943",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37943",
          "value": "CVE-2025-37943",
          "url": "https://scout.docker.com/v/CVE-2025-37943?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37943?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e5e66d6f5ce05404ab25deb9375c0fcc6ad535e5820519cf52145bbd20701453",
      "category": "container_scanning",
      "message": "CVE-2025-37944 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Fix invalid entry fetch in ath12k_dp_mon_srng_process  Currently, ath12k_dp_mon_srng_process uses ath12k_hal_srng_src_get_next_entry to fetch the next entry from the destination ring. This is incorrect because ath12k_hal_srng_src_get_next_entry is intended for source rings, not destination rings. This leads to invalid entry fetches, causing potential data corruption or crashes due to accessing incorrect memory locations. This happens because the source ring and destination ring have different handling mechanisms and using the wrong function results in incorrect pointer arithmetic and ring management.  To fix this issue, replace the call to ath12k_hal_srng_src_get_next_entry with ath12k_hal_srng_dst_get_next_entry in ath12k_dp_mon_srng_process. This ensures that the correct function is used for fetching entries from the destination ring, preventing invalid memory accesses.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",
      "cve": "CVE-2025-37944",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37944",
          "value": "CVE-2025-37944",
          "url": "https://scout.docker.com/v/CVE-2025-37944?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37944?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "059dcafc24c795bd5afeb1ce3157984132e4e2f7713d901b3cd6cb7fe9c1b428",
      "category": "container_scanning",
      "message": "CVE-2025-37945 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: phy: allow MDIO bus PM ops to start/stop state machine for phylink-controlled PHY  DSA has 2 kinds of drivers:  1. Those who call dsa_switch_suspend() and dsa_switch_resume() from their device PM ops: qca8k-8xxx, bcm_sf2, microchip ksz 2. Those who don't: all others. The above methods should be optional.  For type 1, dsa_switch_suspend() calls dsa_user_suspend() -> phylink_stop(), and dsa_switch_resume() calls dsa_user_resume() -> phylink_start(). These seem good candidates for setting mac_managed_pm = true because that is essentially its definition [1], but that does not seem to be the biggest problem for now, and is not what this change focuses on.  Talking strictly about the 2nd category of DSA drivers here (which do not have MAC managed PM, meaning that for their attached PHYs, mdio_bus_phy_suspend() and mdio_bus_phy_resume() should run in full), I have noticed that the following warning from mdio_bus_phy_resume() is triggered:  WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY && phydev->state != PHY_UP);  because the PHY state machine is running.  It's running as a result of a previous dsa_user_open() -> ... -> phylink_start() -> phy_start() having been initiated by the user.  The previous mdio_bus_phy_suspend() was supposed to have called phy_stop_machine(), but it didn't. So this is why the PHY is in state PHY_NOLINK by the time mdio_bus_phy_resume() runs.  mdio_bus_phy_suspend() did not call phy_stop_machine() because for phylink, the phydev->adjust_link function pointer is NULL. This seems a technicality introduced by commit fddd91016d16 (\"phylib: fix PAL state machine restart on resume\"). That commit was written before phylink existed, and was intended to avoid crashing with consumer drivers which don't use the PHY state machine - phylink always does, when using a PHY. But phylink itself has historically not been developed with suspend/resume in mind, and apparently not tested too much in that scenario, allowing this bug to exist unnoticed for so long. Plus, prior to the WARN_ON(), it would have likely been invisible.  This issue is not in fact restricted to type 2 DSA drivers (according to the above ad-hoc classification), but can be extrapolated to any MAC driver with phylink and MDIO-bus-managed PHY PM ops. DSA is just where the issue was reported. Assuming mac_managed_pm is set correctly, a quick search indicates the following other drivers might be affected:  $ grep -Zlr PHYLINK_NETDEV drivers/ | xargs -0 grep -L mac_managed_pm drivers/net/ethernet/atheros/ag71xx.c drivers/net/ethernet/microchip/sparx5/sparx5_main.c drivers/net/ethernet/microchip/lan966x/lan966x_main.c drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c drivers/net/ethernet/freescale/dpaa/dpaa_eth.c drivers/net/ethernet/freescale/ucc_geth.c drivers/net/ethernet/freescale/enetc/enetc_pf_common.c drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c drivers/net/ethernet/marvell/mvneta.c drivers/net/ethernet/marvell/prestera/prestera_main.c drivers/net/ethernet/mediatek/mtk_eth_soc.c drivers/net/ethernet/altera/altera_tse_main.c drivers/net/ethernet/wangxun/txgbe/txgbe_phy.c drivers/net/ethernet/meta/fbnic/fbnic_phylink.c drivers/net/ethernet/tehuti/tn40_phy.c drivers/net/ethernet/mscc/ocelot_net.c  Make the existing conditions dependent on the PHY device having a phydev->phy_link_change() implementation equal to the default phy_link_change() provided by phylib. Otherwise, we implicitly know that the phydev has the phylink-provided phylink_phy_change() callback, and when phylink is used, the PHY state machine always needs to be stopped/ started on the suspend/resume path. The code is structured as such that if phydev->phy_link_change() is absent, it is a matter of time until the kernel will crash - no need to further complicate the test.  Thus, for the situation where the PM is not managed b ---truncated---",
      "cve": "CVE-2025-37945",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37945",
          "value": "CVE-2025-37945",
          "url": "https://scout.docker.com/v/CVE-2025-37945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "41946cdc2a595a4b10bca1fbeee5f609c30f819f59ca5a64af1eb11b734047cb",
      "category": "container_scanning",
      "message": "CVE-2025-37947 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: prevent out-of-bounds stream writes by validating *pos  ksmbd_vfs_stream_write() did not validate whether the write offset (*pos) was within the bounds of the existing stream data length (v_len). If *pos was greater than or equal to v_len, this could lead to an out-of-bounds memory write.  This patch adds a check to ensure *pos is less than v_len before proceeding. If the condition fails, -EINVAL is returned.",
      "cve": "CVE-2025-37947",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37947",
          "value": "CVE-2025-37947",
          "url": "https://scout.docker.com/v/CVE-2025-37947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4e2249191cc30611c9ce112464df56b33706323c8dae4e8fb2f98732da63fffd",
      "category": "container_scanning",
      "message": "CVE-2025-37951 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/v3d: Add job to pending list if the reset was skipped  When a CL/CSD job times out, we check if the GPU has made any progress since the last timeout. If so, instead of resetting the hardware, we skip the reset and let the timer get rearmed. This gives long-running jobs a chance to complete.  However, when `timedout_job()` is called, the job in question is removed from the pending list, which means it won't be automatically freed through `free_job()`. Consequently, when we skip the reset and keep the job running, the job won't be freed when it finally completes.  This situation leads to a memory leak, as exposed in [1] and [2].  Similarly to commit 704d3d60fec4 (\"drm/etnaviv: don't block scheduler when GPU is still active\"), this patch ensures the job is put back on the pending list when extending the timeout.",
      "cve": "CVE-2025-37951",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37951",
          "value": "CVE-2025-37951",
          "url": "https://scout.docker.com/v/CVE-2025-37951?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37951?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9f37c8bcb6f2413c0eeb2e258baf5fb2375ad193965fb1c8fb5255b17e8b3207",
      "category": "container_scanning",
      "message": "CVE-2025-37952 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: Fix UAF in __close_file_table_ids  A use-after-free is possible if one thread destroys the file via __ksmbd_close_fd while another thread holds a reference to it. The existing checks on fp->refcount are not sufficient to prevent this.  The fix takes ft->lock around the section which removes the file from the file table. This prevents two threads acquiring the same file pointer via __close_file_table_ids, as well as the other functions which retrieve a file from the IDR and which already use this same lock.",
      "cve": "CVE-2025-37952",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37952",
          "value": "CVE-2025-37952",
          "url": "https://scout.docker.com/v/CVE-2025-37952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eb6614068f7bb22309cf20b1eb64bdfb2cc767558bdf1c8b8fa543da153637d1",
      "category": "container_scanning",
      "message": "CVE-2025-37954 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: Avoid race in open_cached_dir with lease breaks  A pre-existing valid cfid returned from find_or_create_cached_dir might race with a lease break, meaning open_cached_dir doesn't consider it valid, and thinks it's newly-constructed. This leaks a dentry reference if the allocation occurs before the queued lease break work runs.  Avoid the race by extending holding the cfid_list_lock across find_or_create_cached_dir and when the result is checked.",
      "cve": "CVE-2025-37954",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37954",
          "value": "CVE-2025-37954",
          "url": "https://scout.docker.com/v/CVE-2025-37954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c226b55fd351135029cc728a98953945058f98ee4618fc82b4cffa9928f23c8f",
      "category": "container_scanning",
      "message": "CVE-2025-37956 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: prevent rename with empty string  Client can send empty newname string to ksmbd server. It will cause a kernel oops from d_alloc. This patch return the error when attempting to rename a file or directory with an empty new name string.",
      "cve": "CVE-2025-37956",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37956",
          "value": "CVE-2025-37956",
          "url": "https://scout.docker.com/v/CVE-2025-37956?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37956?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b52d3d64e5a881f9fc34f5a03adb800525b3414c2d459689d6390715bcb67135",
      "category": "container_scanning",
      "message": "CVE-2025-37957 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: SVM: Forcibly leave SMM mode on SHUTDOWN interception  Previously, commit ed129ec9057f (\"KVM: x86: forcibly leave nested mode on vCPU reset\") addressed an issue where a triple fault occurring in nested mode could lead to use-after-free scenarios. However, the commit did not handle the analogous situation for System Management Mode (SMM).  This omission results in triggering a WARN when KVM forces a vCPU INIT after SHUTDOWN interception while the vCPU is in SMM. This situation was reprodused using Syzkaller by:  1) Creating a KVM VM and vCPU 2) Sending a KVM_SMI ioctl to explicitly enter SMM 3) Executing invalid instructions causing consecutive exceptions and eventually a triple fault  The issue manifests as follows:  WARNING: CPU: 0 PID: 25506 at arch/x86/kvm/x86.c:12112 kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112 Modules linked in: CPU: 0 PID: 25506 Comm: syz-executor.0 Not tainted 6.1.130-syzkaller-00157-g164fe5dde9b6 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:kvm_vcpu_reset+0x1d2/0x1530 arch/x86/kvm/x86.c:12112 Call Trace: <TASK> shutdown_interception+0x66/0xb0 arch/x86/kvm/svm/svm.c:2136 svm_invoke_exit_handler+0x110/0x530 arch/x86/kvm/svm/svm.c:3395 svm_handle_exit+0x424/0x920 arch/x86/kvm/svm/svm.c:3457 vcpu_enter_guest arch/x86/kvm/x86.c:10959 [inline] vcpu_run+0x2c43/0x5a90 arch/x86/kvm/x86.c:11062 kvm_arch_vcpu_ioctl_run+0x50f/0x1cf0 arch/x86/kvm/x86.c:11283 kvm_vcpu_ioctl+0x570/0xf00 arch/x86/kvm/../../../virt/kvm/kvm_main.c:4122 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:870 [inline] __se_sys_ioctl fs/ioctl.c:856 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:856 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8  Architecturally, INIT is blocked when the CPU is in SMM, hence KVM's WARN() in kvm_vcpu_reset() to guard against KVM bugs, e.g. to detect improper emulation of INIT.  SHUTDOWN on SVM is a weird edge case where KVM needs to do _something_ sane with the VMCB, since it's technically undefined, and INIT is the least awful choice given KVM's ABI.  So, double down on stuffing INIT on SHUTDOWN, and force the vCPU out of SMM to avoid any weirdness (and the WARN).  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.  [sean: massage changelog, make it clear this isn't architectural behavior]",
      "cve": "CVE-2025-37957",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37957",
          "value": "CVE-2025-37957",
          "url": "https://scout.docker.com/v/CVE-2025-37957?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37957?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "74c33fbb560f290051da4f6590d1023d219ddb1e4bd4e6c3cc50a61dd80ac411",
      "category": "container_scanning",
      "message": "CVE-2025-37959 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Scrub packet on bpf_redirect_peer  When bpf_redirect_peer is used to redirect packets to a device in another network namespace, the skb isn't scrubbed. That can lead skb information from one namespace to be \"misused\" in another namespace.  As one example, this is causing Cilium to drop traffic when using bpf_redirect_peer to redirect packets that just went through IPsec decryption to a container namespace. The following pwru trace shows (1) the packet path from the host's XFRM layer to the container's XFRM layer where it's dropped and (2) the number of active skb extensions at each function.  NETNS       MARK  IFACE  TUPLE                                FUNC 4026533547  d00   eth0   10.244.3.124:35473->10.244.2.158:53 xfrm_rcv_cb .active_extensions = (__u8)2, 4026533547  d00   eth0   10.244.3.124:35473->10.244.2.158:53 xfrm4_rcv_cb .active_extensions = (__u8)2, 4026533547  d00   eth0   10.244.3.124:35473->10.244.2.158:53 gro_cells_receive .active_extensions = (__u8)2, [...] 4026533547  0     eth0   10.244.3.124:35473->10.244.2.158:53 skb_do_redirect .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53  ip_rcv .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 ip_rcv_core .active_extensions = (__u8)2, [...] 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 udp_queue_rcv_one_skb .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 __xfrm_policy_check .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 __xfrm_decode_session .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 security_xfrm_decode_session .active_extensions = (__u8)2, 4026534999  0     eth0   10.244.3.124:35473->10.244.2.158:53 kfree_skb_reason(SKB_DROP_REASON_XFRM_POLICY) .active_extensions = (__u8)2,  In this case, there are no XFRM policies in the container's network namespace so the drop is unexpected. When we decrypt the IPsec packet, the XFRM state used for decryption is set in the skb extensions. This information is preserved across the netns switch. When we reach the XFRM policy check in the container's netns, __xfrm_policy_check drops the packet with LINUX_MIB_XFRMINNOPOLS because a (container-side) XFRM policy can't be found that matches the (host-side) XFRM state used for decryption.  This patch fixes this by scrubbing the packet when using bpf_redirect_peer, as is done on typical netns switches via veth devices except skb->mark and skb->tstamp are not zeroed.",
      "cve": "CVE-2025-37959",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37959",
          "value": "CVE-2025-37959",
          "url": "https://scout.docker.com/v/CVE-2025-37959?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37959?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "14f9cd4d4213fd6af6869fd840de74cf7a0d3bf4b75b5c9028760b738464f9e6",
      "category": "container_scanning",
      "message": "CVE-2025-37961 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipvs: fix uninit-value for saddr in do_output_route4  syzbot reports for uninit-value for the saddr argument [1]. commit 4754957f04f5 (\"ipvs: do not use random local source address for tunnels\") already implies that the input value of saddr should be ignored but the code is still reading it which can prevent to connect the route. Fix it by changing the argument to ret_saddr.  [1] BUG: KMSAN: uninit-value in do_output_route4+0x42c/0x4d0 net/netfilter/ipvs/ip_vs_xmit.c:147 do_output_route4+0x42c/0x4d0 net/netfilter/ipvs/ip_vs_xmit.c:147 __ip_vs_get_out_rt+0x403/0x21d0 net/netfilter/ipvs/ip_vs_xmit.c:330 ip_vs_tunnel_xmit+0x205/0x2380 net/netfilter/ipvs/ip_vs_xmit.c:1136 ip_vs_in_hook+0x1aa5/0x35b0 net/netfilter/ipvs/ip_vs_core.c:2063 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf7/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] __ip_local_out+0x758/0x7e0 net/ipv4/ip_output.c:118 ip_local_out net/ipv4/ip_output.c:127 [inline] ip_send_skb+0x6a/0x3c0 net/ipv4/ip_output.c:1501 udp_send_skb+0xfda/0x1b70 net/ipv4/udp.c:1195 udp_sendmsg+0x2fe3/0x33c0 net/ipv4/udp.c:1483 inet_sendmsg+0x1fc/0x280 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x267/0x380 net/socket.c:727 ____sys_sendmsg+0x91b/0xda0 net/socket.c:2566 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2620 __sys_sendmmsg+0x41d/0x880 net/socket.c:2702 __compat_sys_sendmmsg net/compat.c:360 [inline] __do_compat_sys_sendmmsg net/compat.c:367 [inline] __se_compat_sys_sendmmsg net/compat.c:364 [inline] __ia32_compat_sys_sendmmsg+0xc8/0x140 net/compat.c:364 ia32_sys_call+0x3ffa/0x41f0 arch/x86/include/generated/asm/syscalls_32.h:346 do_syscall_32_irqs_on arch/x86/entry/syscall_32.c:83 [inline] __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/syscall_32.c:306 do_fast_syscall_32+0x38/0x80 arch/x86/entry/syscall_32.c:331 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/syscall_32.c:369 entry_SYSENTER_compat_after_hwframe+0x84/0x8e  Uninit was created at: slab_post_alloc_hook mm/slub.c:4167 [inline] slab_alloc_node mm/slub.c:4210 [inline] __kmalloc_cache_noprof+0x8fa/0xe00 mm/slub.c:4367 kmalloc_noprof include/linux/slab.h:905 [inline] ip_vs_dest_dst_alloc net/netfilter/ipvs/ip_vs_xmit.c:61 [inline] __ip_vs_get_out_rt+0x35d/0x21d0 net/netfilter/ipvs/ip_vs_xmit.c:323 ip_vs_tunnel_xmit+0x205/0x2380 net/netfilter/ipvs/ip_vs_xmit.c:1136 ip_vs_in_hook+0x1aa5/0x35b0 net/netfilter/ipvs/ip_vs_core.c:2063 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xf7/0x400 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] __ip_local_out+0x758/0x7e0 net/ipv4/ip_output.c:118 ip_local_out net/ipv4/ip_output.c:127 [inline] ip_send_skb+0x6a/0x3c0 net/ipv4/ip_output.c:1501 udp_send_skb+0xfda/0x1b70 net/ipv4/udp.c:1195 udp_sendmsg+0x2fe3/0x33c0 net/ipv4/udp.c:1483 inet_sendmsg+0x1fc/0x280 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x267/0x380 net/socket.c:727 ____sys_sendmsg+0x91b/0xda0 net/socket.c:2566 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2620 __sys_sendmmsg+0x41d/0x880 net/socket.c:2702 __compat_sys_sendmmsg net/compat.c:360 [inline] __do_compat_sys_sendmmsg net/compat.c:367 [inline] __se_compat_sys_sendmmsg net/compat.c:364 [inline] __ia32_compat_sys_sendmmsg+0xc8/0x140 net/compat.c:364 ia32_sys_call+0x3ffa/0x41f0 arch/x86/include/generated/asm/syscalls_32.h:346 do_syscall_32_irqs_on arch/x86/entry/syscall_32.c:83 [inline] __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/syscall_32.c:306 do_fast_syscall_32+0x38/0x80 arch/x86/entry/syscall_32.c:331 do_SYSENTER_32+0x1f/0x30 arch/x86/entry/syscall_32.c:369 entry_SYSENTER_compat_after_hwframe+0x84/0x8e  CPU: 0 UID: 0 PID: 22408 Comm: syz.4.5165 Not tainted 6.15.0-rc3-syzkaller-00019-gbc3372351d0c #0 PREEMPT(undef) Hardware name: Google Google Compute Engi ---truncated---",
      "cve": "CVE-2025-37961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37961",
          "value": "CVE-2025-37961",
          "url": "https://scout.docker.com/v/CVE-2025-37961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e175223f6341f24ccbeb6b022379078c077bca92eb3a5c3005ec1aba0d56134",
      "category": "container_scanning",
      "message": "CVE-2025-37980 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: fix resource leak in blk_register_queue() error path  When registering a queue fails after blk_mq_sysfs_register() is successful but the function later encounters an error, we need to clean up the blk_mq_sysfs resources.  Add the missing blk_mq_sysfs_unregister() call in the error path to properly clean up these resources and prevent a memory leak.",
      "cve": "CVE-2025-37980",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37980",
          "value": "CVE-2025-37980",
          "url": "https://scout.docker.com/v/CVE-2025-37980?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37980?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dd160602ea459b4035b8e40062be94d36d794fd9d77d94e577b12d8c0c1e3765",
      "category": "container_scanning",
      "message": "CVE-2025-37984 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: ecdsa - Harden against integer overflows in DIV_ROUND_UP()  Herbert notes that DIV_ROUND_UP() may overflow unnecessarily if an ecdsa implementation's ->key_size() callback returns an unusually large value. Herbert instead suggests (for a division by 8):  X / 8 + !!(X & 7)  Based on this formula, introduce a generic DIV_ROUND_UP_POW2() macro and use it in lieu of DIV_ROUND_UP() for ->key_size() return values.  Additionally, use the macro in ecc_digits_from_bytes(), whose \"nbytes\" parameter is a ->key_size() return value in some instances, or a user-specified ASN.1 length in the case of ecdsa_get_signature_rs().",
      "cve": "CVE-2025-37984",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37984",
          "value": "CVE-2025-37984",
          "url": "https://scout.docker.com/v/CVE-2025-37984?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37984?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b69ee2840c911ca1731863b3237b8349d31a86e0b35a342b5227b0b3f24a11fe",
      "category": "container_scanning",
      "message": "CVE-2025-38006 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: mctp: Don't access ifa_index when missing  In mctp_dump_addrinfo, ifa_index can be used to filter interfaces, but only when the struct ifaddrmsg is provided. Otherwise it will be comparing to uninitialised memory - reproducible in the syzkaller case from dhcpd, or busybox \"ip addr show\".  The kernel MCTP implementation has always filtered by ifa_index, so existing userspace programs expecting to dump MCTP addresses must already be passing a valid ifa_index value (either 0 or a real index).  BUG: KMSAN: uninit-value in mctp_dump_addrinfo+0x208/0xac0 net/mctp/device.c:128 mctp_dump_addrinfo+0x208/0xac0 net/mctp/device.c:128 rtnl_dump_all+0x3ec/0x5b0 net/core/rtnetlink.c:4380 rtnl_dumpit+0xd5/0x2f0 net/core/rtnetlink.c:6824 netlink_dump+0x97b/0x1690 net/netlink/af_netlink.c:2309",
      "cve": "CVE-2025-38006",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38006",
          "value": "CVE-2025-38006",
          "url": "https://scout.docker.com/v/CVE-2025-38006?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38006?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "615e95ea0497ec4ce0f61f23af440ac9a12646781f42d453025b9e435f53dc0f",
      "category": "container_scanning",
      "message": "CVE-2025-38011 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: csa unmap use uninterruptible lock  After process exit to unmap csa and free GPU vm, if signal is accepted and then waiting to take vm lock is interrupted and return, it causes memory leaking and below warning backtrace.  Change to use uninterruptible wait lock fix the issue.  WARNING: CPU: 69 PID: 167800 at amd/amdgpu/amdgpu_kms.c:1525 amdgpu_driver_postclose_kms+0x294/0x2a0 [amdgpu] Call Trace: <TASK> drm_file_free.part.0+0x1da/0x230 [drm] drm_close_helper.isra.0+0x65/0x70 [drm] drm_release+0x6a/0x120 [drm] amdgpu_drm_release+0x51/0x60 [amdgpu] __fput+0x9f/0x280 ____fput+0xe/0x20 task_work_run+0x67/0xa0 do_exit+0x217/0x3c0 do_group_exit+0x3b/0xb0 get_signal+0x14a/0x8d0 arch_do_signal_or_restart+0xde/0x100 exit_to_user_mode_loop+0xc1/0x1a0 exit_to_user_mode_prepare+0xf4/0x100 syscall_exit_to_user_mode+0x17/0x40 do_syscall_64+0x69/0xc0  (cherry picked from commit 7dbbfb3c171a6f63b01165958629c9c26abf38ab)",
      "cve": "CVE-2025-38011",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38011",
          "value": "CVE-2025-38011",
          "url": "https://scout.docker.com/v/CVE-2025-38011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2efc5face84cfa1aea7059e6b20e120d92372758355292149f8a3cb3d0f88d05",
      "category": "container_scanning",
      "message": "CVE-2025-38014 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: idxd: Refactor remove call with idxd_cleanup() helper  The idxd_cleanup() helper cleans up perfmon, interrupts, internals and so on. Refactor remove call with the idxd_cleanup() helper to avoid code duplication. Note, this also fixes the missing put_device() for idxd groups, enginces and wqs.",
      "cve": "CVE-2025-38014",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38014",
          "value": "CVE-2025-38014",
          "url": "https://scout.docker.com/v/CVE-2025-38014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0db53ba726a5d5bbdec4fe46ef286d831c22c6f94d0f627fe555d0ec22309be5",
      "category": "container_scanning",
      "message": "CVE-2025-38015 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: idxd: fix memory leak in error handling path of idxd_alloc  Memory allocated for idxd is not freed if an error occurs during idxd_alloc(). To fix it, free the allocated memory in the reverse order of allocation before exiting the function in case of an error.",
      "cve": "CVE-2025-38015",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38015",
          "value": "CVE-2025-38015",
          "url": "https://scout.docker.com/v/CVE-2025-38015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2a766057e9164d823c0522efb94313008a2f061f2ff88780046da258a021ad6f",
      "category": "container_scanning",
      "message": "CVE-2025-38020 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Disable MACsec offload for uplink representor profile  MACsec offload is not supported in switchdev mode for uplink representors. When switching to the uplink representor profile, the MACsec offload feature must be cleared from the netdevice's features.  If left enabled, attempts to add offloads result in a null pointer dereference, as the uplink representor does not support MACsec offload even though the feature bit remains set.  Clear NETIF_F_HW_MACSEC in mlx5e_fix_uplink_rep_features().  Kernel log:  Oops: general protection fault, probably for non-canonical address 0xdffffc000000000f: 0000 [#1] SMP KASAN KASAN: null-ptr-deref in range [0x0000000000000078-0x000000000000007f] CPU: 29 UID: 0 PID: 4714 Comm: ip Not tainted 6.14.0-rc4_for_upstream_debug_2025_03_02_17_35 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 RIP: 0010:__mutex_lock+0x128/0x1dd0 Code: d0 7c 08 84 d2 0f 85 ad 15 00 00 8b 35 91 5c fe 03 85 f6 75 29 49 8d 7e 60 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 a6 15 00 00 4d 3b 76 60 0f 85 fd 0b 00 00 65 ff RSP: 0018:ffff888147a4f160 EFLAGS: 00010206 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000001 RDX: 000000000000000f RSI: 0000000000000000 RDI: 0000000000000078 RBP: ffff888147a4f2e0 R08: ffffffffa05d2c19 R09: 0000000000000000 R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000 R13: dffffc0000000000 R14: 0000000000000018 R15: ffff888152de0000 FS:  00007f855e27d800(0000) GS:ffff88881ee80000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00000000004e5768 CR3: 000000013ae7c005 CR4: 0000000000372eb0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400 Call Trace: <TASK> ? die_addr+0x3d/0xa0 ? exc_general_protection+0x144/0x220 ? asm_exc_general_protection+0x22/0x30 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? __mutex_lock+0x128/0x1dd0 ? lockdep_set_lock_cmp_fn+0x190/0x190 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? mutex_lock_io_nested+0x1ae0/0x1ae0 ? lock_acquire+0x1c2/0x530 ? macsec_upd_offload+0x145/0x380 ? lockdep_hardirqs_on_prepare+0x400/0x400 ? kasan_save_stack+0x30/0x40 ? kasan_save_stack+0x20/0x40 ? kasan_save_track+0x10/0x30 ? __kasan_kmalloc+0x77/0x90 ? __kmalloc_noprof+0x249/0x6b0 ? genl_family_rcv_msg_attrs_parse.constprop.0+0xb5/0x240 ? mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] mlx5e_macsec_add_secy+0xf9/0x700 [mlx5_core] ? mlx5e_macsec_add_rxsa+0x11a0/0x11a0 [mlx5_core] macsec_update_offload+0x26c/0x820 ? macsec_set_mac_address+0x4b0/0x4b0 ? lockdep_hardirqs_on_prepare+0x284/0x400 ? _raw_spin_unlock_irqrestore+0x47/0x50 macsec_upd_offload+0x2c8/0x380 ? macsec_update_offload+0x820/0x820 ? __nla_parse+0x22/0x30 ? genl_family_rcv_msg_attrs_parse.constprop.0+0x15e/0x240 genl_family_rcv_msg_doit+0x1cc/0x2a0 ? genl_family_rcv_msg_attrs_parse.constprop.0+0x240/0x240 ? cap_capable+0xd4/0x330 genl_rcv_msg+0x3ea/0x670 ? genl_family_rcv_msg_dumpit+0x2a0/0x2a0 ? lockdep_set_lock_cmp_fn+0x190/0x190 ? macsec_update_offload+0x820/0x820 netlink_rcv_skb+0x12b/0x390 ? genl_family_rcv_msg_dumpit+0x2a0/0x2a0 ? netlink_ack+0xd80/0xd80 ? rwsem_down_read_slowpath+0xf90/0xf90 ? netlink_deliver_tap+0xcd/0xac0 ? netlink_deliver_tap+0x155/0xac0 ? _copy_from_iter+0x1bb/0x12c0 genl_rcv+0x24/0x40 netlink_unicast+0x440/0x700 ? netlink_attachskb+0x760/0x760 ? lock_acquire+0x1c2/0x530 ? __might_fault+0xbb/0x170 netlink_sendmsg+0x749/0xc10 ? netlink_unicast+0x700/0x700 ? __might_fault+0xbb/0x170 ? netlink_unicast+0x700/0x700 __sock_sendmsg+0xc5/0x190 ____sys_sendmsg+0x53f/0x760 ? import_iovec+0x7/0x10 ? kernel_sendmsg+0x30/0x30 ? __copy_msghdr+0x3c0/0x3c0 ? filter_irq_stacks+0x90/0x90 ? stack_depot_save_flags+0x28/0xa30 ___sys_sen ---truncated---",
      "cve": "CVE-2025-38020",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38020",
          "value": "CVE-2025-38020",
          "url": "https://scout.docker.com/v/CVE-2025-38020?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38020?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b621bf59b2f1f9a6d13b209ce5cdeb8a97b27c506d21fedc12b9cf22adee5c7a",
      "category": "container_scanning",
      "message": "CVE-2025-38022 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/core: Fix \"KASAN: slab-use-after-free Read in ib_register_device\" problem  Call Trace:  __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xc3/0x670 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 strlen+0x93/0xa0 lib/string.c:420 __fortify_strlen include/linux/fortify-string.h:268 [inline] get_kobj_path_length lib/kobject.c:118 [inline] kobject_get_path+0x3f/0x2a0 lib/kobject.c:158 kobject_uevent_env+0x289/0x1870 lib/kobject_uevent.c:545 ib_register_device drivers/infiniband/core/device.c:1472 [inline] ib_register_device+0x8cf/0xe00 drivers/infiniband/core/device.c:1393 rxe_register_device+0x275/0x320 drivers/infiniband/sw/rxe/rxe_verbs.c:1552 rxe_net_add+0x8e/0xe0 drivers/infiniband/sw/rxe/rxe_net.c:550 rxe_newlink+0x70/0x190 drivers/infiniband/sw/rxe/rxe.c:225 nldev_newlink+0x3a3/0x680 drivers/infiniband/core/nldev.c:1796 rdma_nl_rcv_msg+0x387/0x6e0 drivers/infiniband/core/netlink.c:195 rdma_nl_rcv_skb.constprop.0.isra.0+0x2e5/0x450 netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline] netlink_unicast+0x53a/0x7f0 net/netlink/af_netlink.c:1339 netlink_sendmsg+0x8d1/0xdd0 net/netlink/af_netlink.c:1883 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] ____sys_sendmsg+0xa95/0xc70 net/socket.c:2566 ___sys_sendmsg+0x134/0x1d0 net/socket.c:2620 __sys_sendmsg+0x16d/0x220 net/socket.c:2652 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x260 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f  This problem is similar to the problem that the commit 1d6a9e7449e2 (\"RDMA/core: Fix use-after-free when rename device name\") fixes.  The root cause is: the function ib_device_rename() renames the name with lock. But in the function kobject_uevent(), this name is accessed without lock protection at the same time.  The solution is to add the lock protection when this name is accessed in the function kobject_uevent().",
      "cve": "CVE-2025-38022",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38022",
          "value": "CVE-2025-38022",
          "url": "https://scout.docker.com/v/CVE-2025-38022?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38022?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "70884921e9e17dcdeb66257feba1a2a4b46a72dae58808c20a7036eb7dbaddbd",
      "category": "container_scanning",
      "message": "CVE-2025-38029 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  kasan: avoid sleepable page allocation from atomic context  apply_to_pte_range() enters the lazy MMU mode and then invokes kasan_populate_vmalloc_pte() callback on each page table walk iteration. However, the callback can go into sleep when trying to allocate a single page, e.g.  if an architecutre disables preemption on lazy MMU mode enter.  On s390 if make arch_enter_lazy_mmu_mode() -> preempt_enable() and arch_leave_lazy_mmu_mode() -> preempt_disable(), such crash occurs:  [    0.663336] BUG: sleeping function called from invalid context at ./include/linux/sched/mm.h:321 [    0.663348] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2, name: kthreadd [    0.663358] preempt_count: 1, expected: 0 [    0.663366] RCU nest depth: 0, expected: 0 [    0.663375] no locks held by kthreadd/2. [    0.663383] Preemption disabled at: [    0.663386] [<0002f3284cbb4eda>] apply_to_pte_range+0xfa/0x4a0 [    0.663405] CPU: 0 UID: 0 PID: 2 Comm: kthreadd Not tainted 6.15.0-rc5-gcc-kasan-00043-gd76bb1ebb558-dirty #162 PREEMPT [    0.663408] Hardware name: IBM 3931 A01 701 (KVM/Linux) [    0.663409] Call Trace: [    0.663410]  [<0002f3284c385f58>] dump_stack_lvl+0xe8/0x140 [    0.663413]  [<0002f3284c507b9e>] __might_resched+0x66e/0x700 [    0.663415]  [<0002f3284cc4f6c0>] __alloc_frozen_pages_noprof+0x370/0x4b0 [    0.663419]  [<0002f3284ccc73c0>] alloc_pages_mpol+0x1a0/0x4a0 [    0.663421]  [<0002f3284ccc8518>] alloc_frozen_pages_noprof+0x88/0xc0 [    0.663424]  [<0002f3284ccc8572>] alloc_pages_noprof+0x22/0x120 [    0.663427]  [<0002f3284cc341ac>] get_free_pages_noprof+0x2c/0xc0 [    0.663429]  [<0002f3284cceba70>] kasan_populate_vmalloc_pte+0x50/0x120 [    0.663433]  [<0002f3284cbb4ef8>] apply_to_pte_range+0x118/0x4a0 [    0.663435]  [<0002f3284cbc7c14>] apply_to_pmd_range+0x194/0x3e0 [    0.663437]  [<0002f3284cbc99be>] __apply_to_page_range+0x2fe/0x7a0 [    0.663440]  [<0002f3284cbc9e88>] apply_to_page_range+0x28/0x40 [    0.663442]  [<0002f3284ccebf12>] kasan_populate_vmalloc+0x82/0xa0 [    0.663445]  [<0002f3284cc1578c>] alloc_vmap_area+0x34c/0xc10 [    0.663448]  [<0002f3284cc1c2a6>] __get_vm_area_node+0x186/0x2a0 [    0.663451]  [<0002f3284cc1e696>] __vmalloc_node_range_noprof+0x116/0x310 [    0.663454]  [<0002f3284cc1d950>] __vmalloc_node_noprof+0xd0/0x110 [    0.663457]  [<0002f3284c454b88>] alloc_thread_stack_node+0xf8/0x330 [    0.663460]  [<0002f3284c458d56>] dup_task_struct+0x66/0x4d0 [    0.663463]  [<0002f3284c45be90>] copy_process+0x280/0x4b90 [    0.663465]  [<0002f3284c460940>] kernel_clone+0xd0/0x4b0 [    0.663467]  [<0002f3284c46115e>] kernel_thread+0xbe/0xe0 [    0.663469]  [<0002f3284c4e440e>] kthreadd+0x50e/0x7f0 [    0.663472]  [<0002f3284c38c04a>] __ret_from_fork+0x8a/0xf0 [    0.663475]  [<0002f3284ed57ff2>] ret_from_fork+0xa/0x38  Instead of allocating single pages per-PTE, bulk-allocate the shadow memory prior to applying kasan_populate_vmalloc_pte() callback on a page range.",
      "cve": "CVE-2025-38029",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38029",
          "value": "CVE-2025-38029",
          "url": "https://scout.docker.com/v/CVE-2025-38029?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38029?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a1ae2ab836fd0ffde6c6b720a785586d12335298fe100324892407e80d2e510f",
      "category": "container_scanning",
      "message": "CVE-2025-38033 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/Kconfig: make CFI_AUTO_DEFAULT depend on !RUST or Rust >= 1.88  Calling core::fmt::write() from rust code while FineIBT is enabled results in a kernel panic:  [ 4614.199779] kernel BUG at arch/x86/kernel/cet.c:132! [ 4614.205343] Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI [ 4614.211781] CPU: 2 UID: 0 PID: 6057 Comm: dmabuf_dump Tainted: G     U O       6.12.17-android16-0-g6ab38c534a43 #1 9da040f27673ec3945e23b998a0f8bd64c846599 [ 4614.227832] Tainted: [U]=USER, [O]=OOT_MODULE [ 4614.241247] RIP: 0010:do_kernel_cp_fault+0xea/0xf0 ... [ 4614.398144] RIP: 0010:_RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x0/0x20 [ 4614.407792] Code: 48 f7 df 48 0f 48 f9 48 89 f2 89 c6 5d e9 18 fd ff ff 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 41 81 ea 14 61 af 2c 74 03 0f 0b 90 <66> 0f 1f 00 55 48 89 e5 48 89 f2 48 8b 3f be 01 00 00 00 5d e9 e7 [ 4614.428775] RSP: 0018:ffffb95acfa4ba68 EFLAGS: 00010246 [ 4614.434609] RAX: 0000000000000000 RBX: 0000000000000010 RCX: 0000000000000000 [ 4614.442587] RDX: 0000000000000007 RSI: ffffb95acfa4ba70 RDI: ffffb95acfa4bc88 [ 4614.450557] RBP: ffffb95acfa4bae0 R08: ffff0a00ffffff05 R09: 0000000000000070 [ 4614.458527] R10: 0000000000000000 R11: ffffffffab67eaf0 R12: ffffb95acfa4bcc8 [ 4614.466493] R13: ffffffffac5d50f0 R14: 0000000000000000 R15: 0000000000000000 [ 4614.474473]  ? __cfi__RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x10/0x10 [ 4614.484118]  ? _RNvNtCs3o2tGsuHyou_4core3fmt5write+0x1d2/0x250  This happens because core::fmt::write() calls core::fmt::rt::Argument::fmt(), which currently has CFI disabled:  library/core/src/fmt/rt.rs: 171     // FIXME: Transmuting formatter in new and indirectly branching to/calling 172     // it here is an explicit CFI violation. 173     #[allow(inline_no_sanitize)] 174     #[no_sanitize(cfi, kcfi)] 175     #[inline] 176     pub(super) unsafe fn fmt(&self, f: &mut Formatter<'_>) -> Result {  This causes a Control Protection exception, because FineIBT has sealed off the original function's endbr64.  This makes rust currently incompatible with FineIBT. Add a Kconfig dependency that prevents FineIBT from getting turned on by default if rust is enabled.  [ Rust 1.88.0 (scheduled for 2025-06-26) should have this fixed [1], and thus we relaxed the condition with Rust >= 1.88.  When `objtool` lands checking for this with e.g. [2], the plan is to ideally run that in upstream Rust's CI to prevent regressions early [3], since we do not control `core`'s source code.  Alice tested the Rust PR backported to an older compiler.  Peter would like that Rust provides a stable `core` which can be pulled into the kernel: \"Relying on that much out of tree code is 'unfortunate'\".  - Miguel ]  [ Reduced splat. - Miguel ]",
      "cve": "CVE-2025-38033",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38033",
          "value": "CVE-2025-38033",
          "url": "https://scout.docker.com/v/CVE-2025-38033?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38033?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2f7ff3ba219eda81d5b0b614335bf542c7ea64f107fb7b8666dc14910efa963c",
      "category": "container_scanning",
      "message": "CVE-2025-38036 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/vf: Perform early GT MMIO initialization to read GMDID  VFs need to communicate with the GuC to obtain the GMDID value and existing GuC functions used for that assume that the GT has it's MMIO members already setup. However, due to recent refactoring the gt->mmio is initialized later, and any attempt by the VF to use xe_mmio_read|write() from GuC functions will lead to NPD crash due to unset MMIO register address:  [] xe 0000:00:02.1: [drm] Running in SR-IOV VF mode [] xe 0000:00:02.1: [drm] GT0: sending H2G MMIO 0x5507 [] BUG: unable to handle page fault for address: 0000000000190240  Since we are already tweaking the id and type of the primary GT to mimic it's a Media GT before initializing the GuC communication, we can also call xe_gt_mmio_init() to perform early setup of the gt->mmio which will make those GuC functions work again.",
      "cve": "CVE-2025-38036",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38036",
          "value": "CVE-2025-38036",
          "url": "https://scout.docker.com/v/CVE-2025-38036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3efa1d5095434524c004c3422e059af3666a7d29861712c97d7f1b1bb22a8c0",
      "category": "container_scanning",
      "message": "CVE-2025-38038 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpufreq: amd-pstate: Remove unnecessary driver_lock in set_boost  set_boost is a per-policy function call, hence a driver wide lock is unnecessary. Also this mutex_acquire can collide with the mutex_acquire from the mode-switch path in status_store(), which can lead to a deadlock. So, remove it.",
      "cve": "CVE-2025-38038",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38038",
          "value": "CVE-2025-38038",
          "url": "https://scout.docker.com/v/CVE-2025-38038?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38038?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "44d8ec5c8b5a34ac44c5067590fc29eb0f95a5d697a1707a60f0cc5ab086756d",
      "category": "container_scanning",
      "message": "CVE-2025-38039 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Avoid WARN_ON when configuring MQPRIO with HTB offload enabled  When attempting to enable MQPRIO while HTB offload is already configured, the driver currently returns `-EINVAL` and triggers a `WARN_ON`, leading to an unnecessary call trace.  Update the code to handle this case more gracefully by returning `-EOPNOTSUPP` instead, while also providing a helpful user message.",
      "cve": "CVE-2025-38039",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38039",
          "value": "CVE-2025-38039",
          "url": "https://scout.docker.com/v/CVE-2025-38039?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38039?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "52aab056faf5bd4d0264921b1f55c696fd624df70b515575eb1e3daff13f3005",
      "category": "container_scanning",
      "message": "CVE-2025-38040 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: mctrl_gpio: split disable_ms into sync and no_sync APIs  The following splat has been observed on a SAMA5D27 platform using atmel_serial:  BUG: sleeping function called from invalid context at kernel/irq/manage.c:738 in_atomic(): 1, irqs_disabled(): 128, non_block: 0, pid: 27, name: kworker/u5:0 preempt_count: 1, expected: 0 INFO: lockdep is turned off. irq event stamp: 0 hardirqs last  enabled at (0): [<00000000>] 0x0 hardirqs last disabled at (0): [<c01588f0>] copy_process+0x1c4c/0x7bec softirqs last  enabled at (0): [<c0158944>] copy_process+0x1ca0/0x7bec softirqs last disabled at (0): [<00000000>] 0x0 CPU: 0 UID: 0 PID: 27 Comm: kworker/u5:0 Not tainted 6.13.0-rc7+ #74 Hardware name: Atmel SAMA5 Workqueue: hci0 hci_power_on [bluetooth] Call trace: unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x44/0x70 dump_stack_lvl from __might_resched+0x38c/0x598 __might_resched from disable_irq+0x1c/0x48 disable_irq from mctrl_gpio_disable_ms+0x74/0xc0 mctrl_gpio_disable_ms from atmel_disable_ms.part.0+0x80/0x1f4 atmel_disable_ms.part.0 from atmel_set_termios+0x764/0x11e8 atmel_set_termios from uart_change_line_settings+0x15c/0x994 uart_change_line_settings from uart_set_termios+0x2b0/0x668 uart_set_termios from tty_set_termios+0x600/0x8ec tty_set_termios from ttyport_set_flow_control+0x188/0x1e0 ttyport_set_flow_control from wilc_setup+0xd0/0x524 [hci_wilc] wilc_setup [hci_wilc] from hci_dev_open_sync+0x330/0x203c [bluetooth] hci_dev_open_sync [bluetooth] from hci_dev_do_open+0x40/0xb0 [bluetooth] hci_dev_do_open [bluetooth] from hci_power_on+0x12c/0x664 [bluetooth] hci_power_on [bluetooth] from process_one_work+0x998/0x1a38 process_one_work from worker_thread+0x6e0/0xfb4 worker_thread from kthread+0x3d4/0x484 kthread from ret_from_fork+0x14/0x28  This warning is emitted when trying to toggle, at the highest level, some flow control (with serdev_device_set_flow_control) in a device driver. At the lowest level, the atmel_serial driver is using serial_mctrl_gpio lib to enable/disable the corresponding IRQs accordingly.  The warning emitted by CONFIG_DEBUG_ATOMIC_SLEEP is due to disable_irq (called in mctrl_gpio_disable_ms) being possibly called in some atomic context (some tty drivers perform modem lines configuration in regions protected by port lock).  Split mctrl_gpio_disable_ms into two differents APIs, a non-blocking one and a blocking one. Replace mctrl_gpio_disable_ms calls with the relevant version depending on whether the call is protected by some port lock.",
      "cve": "CVE-2025-38040",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38040",
          "value": "CVE-2025-38040",
          "url": "https://scout.docker.com/v/CVE-2025-38040?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38040?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "334c1d570afda03bfd26f7c7c93e5615282dca6f46e60bb27cc95455c62989d1",
      "category": "container_scanning",
      "message": "CVE-2025-38041 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  clk: sunxi-ng: h616: Reparent GPU clock during frequency changes  The H616 manual does not state that the GPU PLL supports dynamic frequency configuration, so we must take extra care when changing the frequency. Currently any attempt to do device DVFS on the GPU lead to panfrost various ooops, and GPU hangs.  The manual describes the algorithm for changing the PLL frequency, which the CPU PLL notifier code already support, so we reuse that to reparent the GPU clock to GPU1 clock during frequency changes.",
      "cve": "CVE-2025-38041",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38041",
          "value": "CVE-2025-38041",
          "url": "https://scout.docker.com/v/CVE-2025-38041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38041?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "32a05b1f9a94fc7348ca6726be65602415a57794a6a10faf78a96d01ed8c48ea",
      "category": "container_scanning",
      "message": "CVE-2025-38042 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: ti: k3-udma-glue: Drop skip_fdq argument from k3_udma_glue_reset_rx_chn  The user of k3_udma_glue_reset_rx_chn() e.g. ti_am65_cpsw_nuss can run on multiple platforms having different DMA architectures. On some platforms there can be one FDQ for all flows in the RX channel while for others there is a separate FDQ for each flow in the RX channel.  So far we have been relying on the skip_fdq argument of k3_udma_glue_reset_rx_chn().  Instead of relying on the user to provide this information, infer it based on DMA architecture during k3_udma_glue_request_rx_chn() and save it in an internal flag 'single_fdq'. Use that flag at k3_udma_glue_reset_rx_chn() to deicide if the FDQ needs to be cleared for every flow or just for flow 0.  Fixes the below issue on ti_am65_cpsw_nuss driver on AM62-SK.  > ip link set eth1 down > ip link set eth0 down > ethtool -L eth0 rx 8 > ip link set eth0 up > modprobe -r ti_am65_cpsw_nuss  [  103.045726] ------------[ cut here ]------------ [  103.050505] k3_knav_desc_pool size 512000 != avail 64000 [  103.050703] WARNING: CPU: 1 PID: 450 at drivers/net/ethernet/ti/k3-cppi-desc-pool.c:33 k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [  103.068810] Modules linked in: ti_am65_cpsw_nuss(-) k3_cppi_desc_pool snd_soc_hdmi_codec crct10dif_ce snd_soc_simple_card snd_soc_simple_card_utils display_connector rtc_ti_k3 k3_j72xx_bandgap tidss drm_client_lib snd_soc_davinci_mcas p drm_dma_helper tps6598x phylink snd_soc_ti_udma rti_wdt drm_display_helper snd_soc_tlv320aic3x_i2c typec at24 phy_gmii_sel snd_soc_ti_edma snd_soc_tlv320aic3x sii902x snd_soc_ti_sdma sa2ul omap_mailbox drm_kms_helper authenc cfg80211 r fkill fuse drm drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [last unloaded: k3_cppi_desc_pool] [  103.119950] CPU: 1 UID: 0 PID: 450 Comm: modprobe Not tainted 6.13.0-rc7-00001-g9c5e3435fa66 #1011 [  103.119968] Hardware name: Texas Instruments AM625 SK (DT) [  103.119974] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  103.119983] pc : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [  103.148007] lr : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] [  103.154709] sp : ffff8000826ebbc0 [  103.158015] x29: ffff8000826ebbc0 x28: ffff0000090b6300 x27: 0000000000000000 [  103.165145] x26: 0000000000000000 x25: 0000000000000000 x24: ffff0000019df6b0 [  103.172271] x23: ffff0000019df6b8 x22: ffff0000019df410 x21: ffff8000826ebc88 [  103.179397] x20: 000000000007d000 x19: ffff00000a3b3000 x18: 0000000000000000 [  103.186522] x17: 0000000000000000 x16: 0000000000000000 x15: 000001e8c35e1cde [  103.193647] x14: 0000000000000396 x13: 000000000000035c x12: 0000000000000000 [  103.200772] x11: 000000000000003a x10: 00000000000009c0 x9 : ffff8000826eba20 [  103.207897] x8 : ffff0000090b6d20 x7 : ffff00007728c180 x6 : ffff00007728c100 [  103.215022] x5 : 0000000000000001 x4 : ffff000000508a50 x3 : ffff7ffff6146000 [  103.222147] x2 : 0000000000000000 x1 : e300b4173ee6b200 x0 : 0000000000000000 [  103.229274] Call trace: [  103.231714]  k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] (P) [  103.238408]  am65_cpsw_nuss_free_rx_chns+0x28/0x4c [ti_am65_cpsw_nuss] [  103.244942]  devm_action_release+0x14/0x20 [  103.249040]  release_nodes+0x3c/0x68 [  103.252610]  devres_release_all+0x8c/0xdc [  103.256614]  device_unbind_cleanup+0x18/0x60 [  103.260876]  device_release_driver_internal+0xf8/0x178 [  103.266004]  driver_detach+0x50/0x9c [  103.269571]  bus_remove_driver+0x6c/0xbc [  103.273485]  driver_unregister+0x30/0x60 [  103.277401]  platform_driver_unregister+0x14/0x20 [  103.282096]  am65_cpsw_nuss_driver_exit+0x18/0xff4 [ti_am65_cpsw_nuss] [  103.288620]  __arm64_sys_delete_module+0x17c/0x25c [  103.293404]  invoke_syscall+0x44/0x100 [  103.297149]  el0_svc_common.constprop.0+0xc0/0xe0 [  103.301845]  do_el0_svc+0x1c/0x28 [  103.305155]  el0_svc+0x28/0x98 ---truncated---",
      "cve": "CVE-2025-38042",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38042",
          "value": "CVE-2025-38042",
          "url": "https://scout.docker.com/v/CVE-2025-38042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38042?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a5991ea42975b054325588a5b25a7ce071d9b5e57c8fb9e95fbd34a72bba593",
      "category": "container_scanning",
      "message": "CVE-2025-38045 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: fix debug actions order  The order of actions taken for debug was implemented incorrectly. Now we implemented the dump split and do the FW reset only in the middle of the dump (rather than the FW killing itself on error.) As a result, some of the actions taken when applying the config will now crash the device, so we need to fix the order.",
      "cve": "CVE-2025-38045",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38045",
          "value": "CVE-2025-38045",
          "url": "https://scout.docker.com/v/CVE-2025-38045?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38045?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4aab004304707cb3a6ac98d1e2c10bd5761febda8bcf696242eb6a26ce89d065",
      "category": "container_scanning",
      "message": "CVE-2025-38047 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/fred: Fix system hang during S4 resume with FRED enabled  Upon a wakeup from S4, the restore kernel starts and initializes the FRED MSRs as needed from its perspective.  It then loads a hibernation image, including the image kernel, and attempts to load image pages directly into their original page frames used before hibernation unless those frames are currently in use.  Once all pages are moved to their original locations, it jumps to a \"trampoline\" page in the image kernel.  At this point, the image kernel takes control, but the FRED MSRs still contain values set by the restore kernel, which may differ from those set by the image kernel before hibernation.  Therefore, the image kernel must ensure the FRED MSRs have the same values as before hibernation. Since these values depend only on the location of the kernel text and data, they can be recomputed from scratch.",
      "cve": "CVE-2025-38047",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38047",
          "value": "CVE-2025-38047",
          "url": "https://scout.docker.com/v/CVE-2025-38047?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38047?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "35f7087bd73aadc5c2baddd17ac90f57d3d981119358b449eecf3ab0483a6f77",
      "category": "container_scanning",
      "message": "CVE-2025-38057 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  espintcp: fix skb leaks  A few error paths are missing a kfree_skb.",
      "cve": "CVE-2025-38057",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38057",
          "value": "CVE-2025-38057",
          "url": "https://scout.docker.com/v/CVE-2025-38057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4d3562f3b71651c2f6139f75de072b94ef0b550ef4c8e872b12ea912d7440135",
      "category": "container_scanning",
      "message": "CVE-2025-38059 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: avoid NULL pointer dereference if no valid csum tree  [BUG] When trying read-only scrub on a btrfs with rescue=idatacsums mount option, it will crash with the following call trace:  BUG: kernel NULL pointer dereference, address: 0000000000000208 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page CPU: 1 UID: 0 PID: 835 Comm: btrfs Tainted: G           O 6.15.0-rc3-custom+ #236 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022 RIP: 0010:btrfs_lookup_csums_bitmap+0x49/0x480 [btrfs] Call Trace: <TASK> scrub_find_fill_first_stripe+0x35b/0x3d0 [btrfs] scrub_simple_mirror+0x175/0x290 [btrfs] scrub_stripe+0x5f7/0x6f0 [btrfs] scrub_chunk+0x9a/0x150 [btrfs] scrub_enumerate_chunks+0x333/0x660 [btrfs] btrfs_scrub_dev+0x23e/0x600 [btrfs] btrfs_ioctl+0x1dcf/0x2f80 [btrfs] __x64_sys_ioctl+0x97/0xc0 do_syscall_64+0x4f/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e  [CAUSE] Mount option \"rescue=idatacsums\" will completely skip loading the csum tree, so that any data read will not find any data csum thus we will ignore data checksum verification.  Normally call sites utilizing csum tree will check the fs state flag NO_DATA_CSUMS bit, but unfortunately scrub does not check that bit at all.  This results in scrub to call btrfs_search_slot() on a NULL pointer and triggered above crash.  [FIX] Check both extent and csum tree root before doing any tree search.",
      "cve": "CVE-2025-38059",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38059",
          "value": "CVE-2025-38059",
          "url": "https://scout.docker.com/v/CVE-2025-38059?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38059?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "24ead55cd9b311fe1197919c1130eb611b06459f2e285fc2f66268d199da7700",
      "category": "container_scanning",
      "message": "CVE-2025-38060 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: copy_verifier_state() should copy 'loop_entry' field  The bpf_verifier_state.loop_entry state should be copied by copy_verifier_state(). Otherwise, .loop_entry values from unrelated states would poison env->cur_state.  Additionally, env->stack should not contain any states with .loop_entry != NULL. The states in env->stack are yet to be verified, while .loop_entry is set for states that reached an equivalent state. This means that env->cur_state->loop_entry should always be NULL after pop_stack().  See the selftest in the next commit for an example of the program that is not safe yet is accepted by verifier w/o this fix.  This change has some verification performance impact for selftests:  File                                Program                       Insns (A) Insns (B)  Insns   (DIFF)  States (A)  States (B)  States (DIFF) ----------------------------------  ----------------------------  --------- ---------  --------------  ----------  ----------  ------------- arena_htab.bpf.o                    arena_htab_llvm                     717 426  -291 (-40.59%)          57          37  -20 (-35.09%) arena_htab_asm.bpf.o                arena_htab_asm                      597 445  -152 (-25.46%)          47          37  -10 (-21.28%) arena_list.bpf.o                    arena_list_del                      309 279    -30 (-9.71%)          23          14   -9 (-39.13%) iters.bpf.o                         iter_subprog_check_stacksafe        155 141    -14 (-9.03%)          15          14    -1 (-6.67%) iters.bpf.o                         iter_subprog_iters                 1094 1003    -91 (-8.32%)          88          83    -5 (-5.68%) iters.bpf.o                         loop_state_deps2                    479 725  +246 (+51.36%)          46          63  +17 (+36.96%) kmem_cache_iter.bpf.o               open_coded_iter                      63 59     -4 (-6.35%)           7           6   -1 (-14.29%) verifier_bits_iter.bpf.o            max_words                            92 84     -8 (-8.70%)           8           7   -1 (-12.50%) verifier_iterating_callbacks.bpf.o  cond_break2                         113 107     -6 (-5.31%)          12          12    +0 (+0.00%)  And significant negative impact for sched_ext:  File               Program                 Insns (A)  Insns (B)  Insns (DIFF)  States (A)  States (B)  States      (DIFF) -----------------  ----------------------  ---------  --------- --------------------  ----------  ----------  ------------------ bpf.bpf.o          lavd_init                    7039      14723      +7684 (+109.16%)         490        1139     +649 (+132.45%) bpf.bpf.o          layered_dispatch            11485      10548 -937 (-8.16%)         848         762       -86 (-10.14%) bpf.bpf.o          layered_dump                 7422    1000001  +992579 (+13373.47%)         681       31178  +30497 (+4478.27%) bpf.bpf.o          layered_enqueue             16854      71127     +54273 (+322.02%)        1611        6450    +4839 (+300.37%) bpf.bpf.o          p2dq_dispatch                 665        791        +126 (+18.95%)          68          78       +10 (+14.71%) bpf.bpf.o          p2dq_init                    2343       2980        +637 (+27.19%)         201         237       +36 (+17.91%) bpf.bpf.o          refresh_layer_cpumasks      16487     674760   +658273 (+3992.68%)        1770       65370  +63600 (+3593.22%) bpf.bpf.o          rusty_select_cpu             1937      40872    +38935 (+2010.07%)         177        3210   +3033 (+1713.56%) scx_central.bpf.o  central_dispatch              636       2687      +2051 (+322.48%)          63         227     +164 (+260.32%) scx_nest.bpf.o     nest_init                     636        815        +179 (+28.14%)          60          73       +13 (+21.67%) scx_qmap.bpf.o     qmap_dispatch ---truncated---",
      "cve": "CVE-2025-38060",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38060",
          "value": "CVE-2025-38060",
          "url": "https://scout.docker.com/v/CVE-2025-38060?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38060?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8250c861e0d9d62f46d823fc08fc16b3289ad1349537a96ed9e00a532367aa0e",
      "category": "container_scanning",
      "message": "CVE-2025-38062 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  genirq/msi: Store the IOMMU IOVA directly in msi_desc instead of iommu_cookie  The IOMMU translation for MSI message addresses has been a 2-step process, separated in time:  1) iommu_dma_prepare_msi(): A cookie pointer containing the IOVA address is stored in the MSI descriptor when an MSI interrupt is allocated.  2) iommu_dma_compose_msi_msg(): this cookie pointer is used to compute a translated message address.  This has an inherent lifetime problem for the pointer stored in the cookie that must remain valid between the two steps. However, there is no locking at the irq layer that helps protect the lifetime. Today, this works under the assumption that the iommu domain is not changed while MSI interrupts being programmed. This is true for normal DMA API users within the kernel, as the iommu domain is attached before the driver is probed and cannot be changed while a driver is attached.  Classic VFIO type1 also prevented changing the iommu domain while VFIO was running as it does not support changing the \"container\" after starting up.  However, iommufd has improved this so that the iommu domain can be changed during VFIO operation. This potentially allows userspace to directly race VFIO_DEVICE_ATTACH_IOMMUFD_PT (which calls iommu_attach_group()) and VFIO_DEVICE_SET_IRQS (which calls into iommu_dma_compose_msi_msg()).  This potentially causes both the cookie pointer and the unlocked call to iommu_get_domain_for_dev() on the MSI translation path to become UAFs.  Fix the MSI cookie UAF by removing the cookie pointer. The translated IOVA address is already known during iommu_dma_prepare_msi() and cannot change. Thus, it can simply be stored as an integer in the MSI descriptor.  The other UAF related to iommu_get_domain_for_dev() will be addressed in patch \"iommu: Make iommu_dma_prepare_msi() into a generic operation\" by using the IOMMU group mutex.",
      "cve": "CVE-2025-38062",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38062",
          "value": "CVE-2025-38062",
          "url": "https://scout.docker.com/v/CVE-2025-38062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6a0834d2e0bc18ef38b744123fb1702a19d729e6d3287eecb6254afb8f197b86",
      "category": "container_scanning",
      "message": "CVE-2025-38063 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm: fix unconditional IO throttle caused by REQ_PREFLUSH  When a bio with REQ_PREFLUSH is submitted to dm, __send_empty_flush() generates a flush_bio with REQ_OP_WRITE | REQ_PREFLUSH | REQ_SYNC, which causes the flush_bio to be throttled by wbt_wait().  An example from v5.4, similar problem also exists in upstream:  crash> bt 2091206 PID: 2091206  TASK: ffff2050df92a300  CPU: 109  COMMAND: \"kworker/u260:0\" #0 [ffff800084a2f7f0] __switch_to at ffff80004008aeb8 #1 [ffff800084a2f820] __schedule at ffff800040bfa0c4 #2 [ffff800084a2f880] schedule at ffff800040bfa4b4 #3 [ffff800084a2f8a0] io_schedule at ffff800040bfa9c4 #4 [ffff800084a2f8c0] rq_qos_wait at ffff8000405925bc #5 [ffff800084a2f940] wbt_wait at ffff8000405bb3a0 #6 [ffff800084a2f9a0] __rq_qos_throttle at ffff800040592254 #7 [ffff800084a2f9c0] blk_mq_make_request at ffff80004057cf38 #8 [ffff800084a2fa60] generic_make_request at ffff800040570138 #9 [ffff800084a2fae0] submit_bio at ffff8000405703b4 #10 [ffff800084a2fb50] xlog_write_iclog at ffff800001280834 [xfs] #11 [ffff800084a2fbb0] xlog_sync at ffff800001280c3c [xfs] #12 [ffff800084a2fbf0] xlog_state_release_iclog at ffff800001280df4 [xfs] #13 [ffff800084a2fc10] xlog_write at ffff80000128203c [xfs] #14 [ffff800084a2fcd0] xlog_cil_push at ffff8000012846dc [xfs] #15 [ffff800084a2fda0] xlog_cil_push_work at ffff800001284a2c [xfs] #16 [ffff800084a2fdb0] process_one_work at ffff800040111d08 #17 [ffff800084a2fe00] worker_thread at ffff8000401121cc #18 [ffff800084a2fe70] kthread at ffff800040118de4  After commit 2def2845cc33 (\"xfs: don't allow log IO to be throttled\"), the metadata submitted by xlog_write_iclog() should not be throttled. But due to the existence of the dm layer, throttling flush_bio indirectly causes the metadata bio to be throttled.  Fix this by conditionally adding REQ_IDLE to flush_bio.bi_opf, which makes wbt_should_throttle() return false to avoid wbt_wait().",
      "cve": "CVE-2025-38063",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38063",
          "value": "CVE-2025-38063",
          "url": "https://scout.docker.com/v/CVE-2025-38063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "390fcec3419ff3678f9c46147e151dcbe476d4dee31203afe073f64b00317ad9",
      "category": "container_scanning",
      "message": "CVE-2025-38064 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  virtio: break and reset virtio devices on device_shutdown()  Hongyu reported a hang on kexec in a VM. QEMU reported invalid memory accesses during the hang.  Invalid read at addr 0x102877002, size 2, region '(null)', reason: rejected Invalid write at addr 0x102877A44, size 2, region '(null)', reason: rejected ...  It was traced down to virtio-console. Kexec works fine if virtio-console is not in use.  The issue is that virtio-console continues to write to the MMIO even after underlying virtio-pci device is reset.  Additionally, Eric noticed that IOMMUs are reset before devices, if devices are not reset on shutdown they continue to poke at guest memory and get errors from the IOMMU. Some devices get wedged then.  The problem can be solved by breaking all virtio devices on virtio bus shutdown, then resetting them.",
      "cve": "CVE-2025-38064",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38064",
          "value": "CVE-2025-38064",
          "url": "https://scout.docker.com/v/CVE-2025-38064?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38064?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c140b8bebb5bcb2de0db63ad83609f35bb9d04080eb5e4c69ae214fc0ca59746",
      "category": "container_scanning",
      "message": "CVE-2025-38069 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: endpoint: pci-epf-test: Fix double free that causes kernel to oops  Fix a kernel oops found while testing the stm32_pcie Endpoint driver with handling of PERST# deassertion:  During EP initialization, pci_epf_test_alloc_space() allocates all BARs, which are further freed if epc_set_bar() fails (for instance, due to no free inbound window).  However, when pci_epc_set_bar() fails, the error path:  pci_epc_set_bar() -> pci_epf_free_space()  does not clear the previous assignment to epf_test->reg[bar].  Then, if the host reboots, the PERST# deassertion restarts the BAR allocation sequence with the same allocation failure (no free inbound window), creating a double free situation since epf_test->reg[bar] was deallocated and is still non-NULL.  Thus, make sure that pci_epf_alloc_space() and pci_epf_free_space() invocations are symmetric, and as such, set epf_test->reg[bar] to NULL when memory is freed.  [kwilczynski: commit log]",
      "cve": "CVE-2025-38069",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38069",
          "value": "CVE-2025-38069",
          "url": "https://scout.docker.com/v/CVE-2025-38069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d518439370c0d6cddbdbbc0ee93b8917eb14c9b0cf7a462179801b21d6b871bb",
      "category": "container_scanning",
      "message": "CVE-2025-38070 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: sma1307: Add NULL check in sma1307_setting_loaded()  All varibale allocated by kzalloc and devm_kzalloc could be NULL. Multiple pointer checks and their cleanup are added.  This issue is found by our static analysis tool",
      "cve": "CVE-2025-38070",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38070",
          "value": "CVE-2025-38070",
          "url": "https://scout.docker.com/v/CVE-2025-38070?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38070?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dafeb41982065a753f1d4d675659e39b867ab2fbddc9427ed2457407b1b787b9",
      "category": "container_scanning",
      "message": "CVE-2025-38071 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mm: Check return value from memblock_phys_alloc_range()  At least with CONFIG_PHYSICAL_START=0x100000, if there is < 4 MiB of contiguous free memory available at this point, the kernel will crash and burn because memblock_phys_alloc_range() returns 0 on failure, which leads memblock_phys_free() to throw the first 4 MiB of physical memory to the wolves.  At a minimum it should fail gracefully with a meaningful diagnostic, but in fact everything seems to work fine without the weird reserve allocation.",
      "cve": "CVE-2025-38071",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38071",
          "value": "CVE-2025-38071",
          "url": "https://scout.docker.com/v/CVE-2025-38071?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38071?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6045b3653ce561b171f00eefc90c7b9ba5c3e43431adffb580d6028a52b4b16",
      "category": "container_scanning",
      "message": "CVE-2025-38073 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: fix race between set_blocksize and read paths  With the new large sector size support, it's now the case that set_blocksize can change i_blksize and the folio order in a manner that conflicts with a concurrent reader and causes a kernel crash.  Specifically, let's say that udev-worker calls libblkid to detect the labels on a block device.  The read call can create an order-0 folio to read the first 4096 bytes from the disk.  But then udev is preempted.  Next, someone tries to mount an 8k-sectorsize filesystem from the same block device.  The filesystem calls set_blksize, which sets i_blksize to 8192 and the minimum folio order to 1.  Now udev resumes, still holding the order-0 folio it allocated.  It then tries to schedule a read bio and do_mpage_readahead tries to create bufferheads for the folio.  Unfortunately, blocks_per_folio == 0 because the page size is 4096 but the blocksize is 8192 so no bufferheads are attached and the bh walk never sets bdev.  We then submit the bio with a NULL block device and crash.  Therefore, truncate the page cache after flushing but before updating i_blksize.  However, that's not enough -- we also need to lock out file IO and page faults during the update.  Take both the i_rwsem and the invalidate_lock in exclusive mode for invalidations, and in shared mode for read/write operations.  I don't know if this is the correct fix, but xfs/259 found it.",
      "cve": "CVE-2025-38073",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38073",
          "value": "CVE-2025-38073",
          "url": "https://scout.docker.com/v/CVE-2025-38073?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38073?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dbf35933ff5fbade5d6f8eb35a1fa24206739b2b2f3e527bd3c1220ad26be5f2",
      "category": "container_scanning",
      "message": "CVE-2025-38080 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Increase block_sequence array size  [Why] It's possible to generate more than 50 steps in hwss_build_fast_sequence, for example with a 6-pipe asic where all pipes are in one MPC chain. This overflows the block_sequence buffer and corrupts block_sequence_steps, causing a crash.  [How] Expand block_sequence to 100 items. A naive upper bound on the possible number of steps for a 6-pipe asic, ignoring the potential for steps to be mutually exclusive, is 91 with current code, therefore 100 is sufficient.",
      "cve": "CVE-2025-38080",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38080",
          "value": "CVE-2025-38080",
          "url": "https://scout.docker.com/v/CVE-2025-38080?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38080?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0b8c9d7ddb3c852d4547bcf129cdc4b1a06cccc7d880397dad5aa29c9ac1d378",
      "category": "container_scanning",
      "message": "CVE-2025-38081 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi-rockchip: Fix register out of bounds access  Do not write native chip select stuff for GPIO chip selects. GPIOs can be numbered much higher than native CS. Also, it makes no sense.",
      "cve": "CVE-2025-38081",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38081",
          "value": "CVE-2025-38081",
          "url": "https://scout.docker.com/v/CVE-2025-38081?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38081?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9ab53ed134a5cf3be1ba6d4a76d8d4479175e3ce1e919adc355f8e4750b787bb",
      "category": "container_scanning",
      "message": "CVE-2025-38082 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gpio: virtuser: fix potential out-of-bound write  If the caller wrote more characters, count is truncated to the max available space in \"simple_write_to_buffer\". Check that the input size does not exceed the buffer size. Write a zero termination afterwards.",
      "cve": "CVE-2025-38082",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38082",
          "value": "CVE-2025-38082",
          "url": "https://scout.docker.com/v/CVE-2025-38082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c330661d40f11dd0c1f11e529b19053f85cca1654b5f4ed7a05235200cc12a12",
      "category": "container_scanning",
      "message": "CVE-2025-38091 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: check stream id dml21 wrapper to get plane_id  [Why & How] Fix a false positive warning which occurs due to lack of correct checks when querying plane_id in DML21. This fixes the warning when performing a mode1 reset (cat /sys/kernel/debug/dri/1/amdgpu_gpu_recover):  [   35.751250] WARNING: CPU: 11 PID: 326 at /tmp/amd.PHpyAl7v/amd/amdgpu/../display/dc/dml2/dml2_dc_resource_mgmt.c:91 dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [   35.751434] Modules linked in: amdgpu(OE) amddrm_ttm_helper(OE) amdttm(OE) amddrm_buddy(OE) amdxcp(OE) amddrm_exec(OE) amd_sched(OE) amdkcl(OE) drm_suballoc_helper drm_ttm_helper ttm drm_display_helper cec rc_core i2c_algo_bit rfcomm qrtr cmac algif_hash algif_skcipher af_alg bnep amd_atl intel_rapl_msr intel_rapl_common snd_hda_codec_hdmi snd_hda_intel edac_mce_amd snd_intel_dspcfg snd_intel_sdw_acpi snd_hda_codec kvm_amd snd_hda_core snd_hwdep snd_pcm kvm snd_seq_midi snd_seq_midi_event snd_rawmidi crct10dif_pclmul polyval_clmulni polyval_generic btusb ghash_clmulni_intel sha256_ssse3 btrtl sha1_ssse3 snd_seq btintel aesni_intel btbcm btmtk snd_seq_device crypto_simd sunrpc cryptd bluetooth snd_timer ccp binfmt_misc rapl snd i2c_piix4 wmi_bmof gigabyte_wmi k10temp i2c_smbus soundcore gpio_amdpt mac_hid sch_fq_codel msr parport_pc ppdev lp parport efi_pstore nfnetlink dmi_sysfs ip_tables x_tables autofs4 hid_generic usbhid hid crc32_pclmul igc ahci xhci_pci libahci xhci_pci_renesas video wmi [   35.751501] CPU: 11 UID: 0 PID: 326 Comm: kworker/u64:9 Tainted: G OE      6.11.0-21-generic #21~24.04.1-Ubuntu [   35.751504] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE [   35.751505] Hardware name: Gigabyte Technology Co., Ltd. X670E AORUS PRO X/X670E AORUS PRO X, BIOS F30 05/22/2024 [   35.751506] Workqueue: amdgpu-reset-dev amdgpu_debugfs_reset_work [amdgpu] [   35.751638] RIP: 0010:dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [   35.751794] Code: 6d 0c 00 00 8b 84 24 88 00 00 00 41 3b 44 9c 20 0f 84 fc 07 00 00 48 83 c3 01 48 83 fb 06 75 b3 4c 8b 64 24 68 4c 8b 6c 24 40 <0f> 0b b8 06 00 00 00 49 8b 94 24 a0 49 00 00 89 c3 83 f8 07 0f 87 [   35.751796] RSP: 0018:ffffbfa3805d7680 EFLAGS: 00010246 [   35.751798] RAX: 0000000000010000 RBX: 0000000000000006 RCX: 0000000000000000 [   35.751799] RDX: 0000000000000000 RSI: 0000000000000005 RDI: 0000000000000000 [   35.751800] RBP: ffffbfa3805d78f0 R08: 0000000000000000 R09: 0000000000000000 [   35.751801] R10: 0000000000000000 R11: 0000000000000000 R12: ffffbfa383249000 [   35.751802] R13: ffffa0e68f280000 R14: ffffbfa383249658 R15: 0000000000000000 [   35.751803] FS:  0000000000000000(0000) GS:ffffa0edbe580000(0000) knlGS:0000000000000000 [   35.751804] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [   35.751805] CR2: 00005d847ef96c58 CR3: 000000041de3e000 CR4: 0000000000f50ef0 [   35.751806] PKRU: 55555554 [   35.751807] Call Trace: [   35.751810]  <TASK> [   35.751816]  ? show_regs+0x6c/0x80 [   35.751820]  ? __warn+0x88/0x140 [   35.751822]  ? dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [   35.751964]  ? report_bug+0x182/0x1b0 [   35.751969]  ? handle_bug+0x6e/0xb0 [   35.751972]  ? exc_invalid_op+0x18/0x80 [   35.751974]  ? asm_exc_invalid_op+0x1b/0x20 [   35.751978]  ? dml2_map_dc_pipes+0x243d/0x3f40 [amdgpu] [   35.752117]  ? math_pow+0x48/0xa0 [amdgpu] [   35.752256]  ? srso_alias_return_thunk+0x5/0xfbef5 [   35.752260]  ? math_pow+0x48/0xa0 [amdgpu] [   35.752400]  ? srso_alias_return_thunk+0x5/0xfbef5 [   35.752403]  ? math_pow+0x11/0xa0 [amdgpu] [   35.752524]  ? srso_alias_return_thunk+0x5/0xfbef5 [   35.752526]  ? core_dcn4_mode_programming+0xe4d/0x20d0 [amdgpu] [   35.752663]  ? srso_alias_return_thunk+0x5/0xfbef5 [   35.752669]  dml21_validate+0x3d4/0x980 [amdgpu]  (cherry picked from commit f8ad62c0a93e5dd94243e10f1b742232e4d6411e)",
      "cve": "CVE-2025-38091",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38091",
          "value": "CVE-2025-38091",
          "url": "https://scout.docker.com/v/CVE-2025-38091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c592d299da581bcf14b77d3a44f4d2f33d721dc4f9df876b2ab71203d4705e8d",
      "category": "container_scanning",
      "message": "CVE-2025-38092 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: use list_first_entry_or_null for opinfo_get_list()  The list_first_entry() macro never returns NULL.  If the list is empty then it returns an invalid pointer.  Use list_first_entry_or_null() to check if the list is empty.",
      "cve": "CVE-2025-38092",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38092",
          "value": "CVE-2025-38092",
          "url": "https://scout.docker.com/v/CVE-2025-38092?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38092?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ea1075721e8282076aeee1e1a7cf4bacce1f18c88eae48e9d1ada13cd670f482",
      "category": "container_scanning",
      "message": "CVE-2025-38096 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: don't warn when if there is a FW error  iwl_trans_reclaim is warning if it is called when the FW is not alive. But if it is called when there is a pending restart, i.e. after a FW error, there is no need to warn, instead - return silently.",
      "cve": "CVE-2025-38096",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38096",
          "value": "CVE-2025-38096",
          "url": "https://scout.docker.com/v/CVE-2025-38096?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38096?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f3e2a2359948dc9750e8f3c6149c46f8b68efd3f3ca33bc786f7e6cef4faaf3f",
      "category": "container_scanning",
      "message": "CVE-2025-38097 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  espintcp: remove encap socket caching to avoid reference leak  The current scheme for caching the encap socket can lead to reference leaks when we try to delete the netns.  The reference chain is: xfrm_state -> enacp_sk -> netns  Since the encap socket is a userspace socket, it holds a reference on the netns. If we delete the espintcp state (through flush or individual delete) before removing the netns, the reference on the socket is dropped and the netns is correctly deleted. Otherwise, the netns may not be reachable anymore (if all processes within the ns have terminated), so we cannot delete the xfrm state to drop its reference on the socket.  This patch results in a small (~2% in my tests) performance regression.  A GC-type mechanism could be added for the socket cache, to clear references if the state hasn't been used \"recently\", but it's a lot more complex than just not caching the socket.",
      "cve": "CVE-2025-38097",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38097",
          "value": "CVE-2025-38097",
          "url": "https://scout.docker.com/v/CVE-2025-38097?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38097?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fc6fdeb79b38b55c980cae2c395c74d1f3b878abdac6435fa8a2dcb644467662",
      "category": "container_scanning",
      "message": "CVE-2025-38098 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Don't treat wb connector as physical in create_validate_stream_for_sink  Don't try to operate on a drm_wb_connector as an amdgpu_dm_connector. While dereferencing aconnector->base will \"work\" it's wrong and might lead to unknown bad things. Just... don't.",
      "cve": "CVE-2025-38098",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38098",
          "value": "CVE-2025-38098",
          "url": "https://scout.docker.com/v/CVE-2025-38098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "04e8ba08958f5ef0566736c7469f9c4ad2a6b17dee371f6b70a527bdf9b5d570",
      "category": "container_scanning",
      "message": "CVE-2025-38099 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: Disable SCO support if READ_VOICE_SETTING is unsupported/broken  A SCO connection without the proper voice_setting can cause the controller to lock up.",
      "cve": "CVE-2025-38099",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38099",
          "value": "CVE-2025-38099",
          "url": "https://scout.docker.com/v/CVE-2025-38099?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38099?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fbb4185e79d40b8ebb68ef9d742060836c75ec212b8b36c48cd5ac95a9e3a7dd",
      "category": "container_scanning",
      "message": "CVE-2025-38105 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: usb-audio: Kill timer properly at removal  The USB-audio MIDI code initializes the timer, but in a rare case, the driver might be freed without the disconnect call.  This leaves the timer in an active state while the assigned object is released via snd_usbmidi_free(), which ends up with a kernel warning when the debug configuration is enabled, as spotted by fuzzer.  For avoiding the problem, put timer_shutdown_sync() at snd_usbmidi_free(), so that the timer can be killed properly. While we're at it, replace the existing timer_delete_sync() at the disconnect callback with timer_shutdown_sync(), too.",
      "cve": "CVE-2025-38105",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38105",
          "value": "CVE-2025-38105",
          "url": "https://scout.docker.com/v/CVE-2025-38105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38105?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ef7f0d8e3f05cf8241d2e293d6e1efd54f43bae536ed978cd28a8149ba66f657",
      "category": "container_scanning",
      "message": "CVE-2025-38109 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Fix ECVF vports unload on shutdown flow  Fix shutdown flow UAF when a virtual function is created on the embedded chip (ECVF) of a BlueField device. In such case the vport acl ingress table is not properly destroyed.  ECVF functionality is independent of ecpf_vport_exists capability and thus functions mlx5_eswitch_(enable|disable)_pf_vf_vports() should not test it when enabling/disabling ECVF vports.  kernel log: [] refcount_t: underflow; use-after-free. [] WARNING: CPU: 3 PID: 1 at lib/refcount.c:28 refcount_warn_saturate+0x124/0x220 ---------------- [] Call trace: [] refcount_warn_saturate+0x124/0x220 [] tree_put_node+0x164/0x1e0 [mlx5_core] [] mlx5_destroy_flow_table+0x98/0x2c0 [mlx5_core] [] esw_acl_ingress_table_destroy+0x28/0x40 [mlx5_core] [] esw_acl_ingress_lgcy_cleanup+0x80/0xf4 [mlx5_core] [] esw_legacy_vport_acl_cleanup+0x44/0x60 [mlx5_core] [] esw_vport_cleanup+0x64/0x90 [mlx5_core] [] mlx5_esw_vport_disable+0xc0/0x1d0 [mlx5_core] [] mlx5_eswitch_unload_ec_vf_vports+0xcc/0x150 [mlx5_core] [] mlx5_eswitch_disable_sriov+0x198/0x2a0 [mlx5_core] [] mlx5_device_disable_sriov+0xb8/0x1e0 [mlx5_core] [] mlx5_sriov_detach+0x40/0x50 [mlx5_core] [] mlx5_unload+0x40/0xc4 [mlx5_core] [] mlx5_unload_one_devl_locked+0x6c/0xe4 [mlx5_core] [] mlx5_unload_one+0x3c/0x60 [mlx5_core] [] shutdown+0x7c/0xa4 [mlx5_core] [] pci_device_shutdown+0x3c/0xa0 [] device_shutdown+0x170/0x340 [] __do_sys_reboot+0x1f4/0x2a0 [] __arm64_sys_reboot+0x2c/0x40 [] invoke_syscall+0x78/0x100 [] el0_svc_common.constprop.0+0x54/0x184 [] do_el0_svc+0x30/0xac [] el0_svc+0x48/0x160 [] el0t_64_sync_handler+0xa4/0x12c [] el0t_64_sync+0x1a4/0x1a8 [] --[ end trace 9c4601d68c70030e ]---",
      "cve": "CVE-2025-38109",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38109",
          "value": "CVE-2025-38109",
          "url": "https://scout.docker.com/v/CVE-2025-38109?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38109?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e642f239c0b01a7d68cdbb95e903f27701de360945fe2937d4437f8e13b844c5",
      "category": "container_scanning",
      "message": "CVE-2025-38117 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: MGMT: Protect mgmt_pending list with its own lock  This uses a mutex to protect from concurrent access of mgmt_pending list which can cause crashes like:  ================================================================== BUG: KASAN: slab-use-after-free in hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91 Read of size 2 at addr ffff0000c48885b2 by task syz.4.334/7318  CPU: 0 UID: 0 PID: 7318 Comm: syz.4.334 Not tainted 6.15.0-rc7-syzkaller-g187899f4124a #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call trace: show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C) __dump_stack+0x30/0x40 lib/dump_stack.c:94 dump_stack_lvl+0xd8/0x12c lib/dump_stack.c:120 print_address_description+0xa8/0x254 mm/kasan/report.c:408 print_report+0x68/0x84 mm/kasan/report.c:521 kasan_report+0xb0/0x110 mm/kasan/report.c:634 __asan_report_load2_noabort+0x20/0x2c mm/kasan/report_generic.c:379 hci_sock_get_channel+0x60/0x68 net/bluetooth/hci_sock.c:91 mgmt_pending_find+0x7c/0x140 net/bluetooth/mgmt_util.c:223 pending_find net/bluetooth/mgmt.c:947 [inline] remove_adv_monitor+0x44/0x1a4 net/bluetooth/mgmt.c:5445 hci_mgmt_cmd+0x780/0xc00 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x544/0xbb0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg net/socket.c:727 [inline] sock_write_iter+0x25c/0x378 net/socket.c:1131 new_sync_write fs/read_write.c:591 [inline] vfs_write+0x62c/0x97c fs/read_write.c:684 ksys_write+0x120/0x210 fs/read_write.c:736 __do_sys_write fs/read_write.c:747 [inline] __se_sys_write fs/read_write.c:744 [inline] __arm64_sys_write+0x7c/0x90 fs/read_write.c:744 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600  Allocated by task 7037: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_alloc_info+0x44/0x54 mm/kasan/generic.c:562 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x9c/0xb4 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4327 [inline] __kmalloc_noprof+0x2fc/0x4c8 mm/slub.c:4339 kmalloc_noprof include/linux/slab.h:909 [inline] sk_prot_alloc+0xc4/0x1f0 net/core/sock.c:2198 sk_alloc+0x44/0x3ac net/core/sock.c:2254 bt_sock_alloc+0x4c/0x300 net/bluetooth/af_bluetooth.c:148 hci_sock_create+0xa8/0x194 net/bluetooth/hci_sock.c:2202 bt_sock_create+0x14c/0x24c net/bluetooth/af_bluetooth.c:132 __sock_create+0x43c/0x91c net/socket.c:1541 sock_create net/socket.c:1599 [inline] __sys_socket_create net/socket.c:1636 [inline] __sys_socket+0xd4/0x1c0 net/socket.c:1683 __do_sys_socket net/socket.c:1697 [inline] __se_sys_socket net/socket.c:1695 [inline] __arm64_sys_socket+0x7c/0x94 net/socket.c:1695 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600  Freed by task 6607: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_free_info+0x58/0x70 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x68/0x88 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline ---truncated---",
      "cve": "CVE-2025-38117",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38117",
          "value": "CVE-2025-38117",
          "url": "https://scout.docker.com/v/CVE-2025-38117?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38117?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eb975371f7e6a8a1edde4b4615cb199f5c7fb6e6a061315d9712be501407104d",
      "category": "container_scanning",
      "message": "CVE-2025-38125 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: stmmac: make sure that ptp_rate is not 0 before configuring EST  If the ptp_rate recorded earlier in the driver happens to be 0, this bogus value will propagate up to EST configuration, where it will trigger a division by 0.  Prevent this division by 0 by adding the corresponding check and error code.",
      "cve": "CVE-2025-38125",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38125",
          "value": "CVE-2025-38125",
          "url": "https://scout.docker.com/v/CVE-2025-38125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "13c2a30420e3f20e6f4dfbdc07886686ff3c2da567b52276136de4984294c50b",
      "category": "container_scanning",
      "message": "CVE-2025-38126 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: stmmac: make sure that ptp_rate is not 0 before configuring timestamping  The stmmac platform drivers that do not open-code the clk_ptp_rate value after having retrieved the default one from the device-tree can end up with 0 in clk_ptp_rate (as clk_get_rate can return 0). It will eventually propagate up to PTP initialization when bringing up the interface, leading to a divide by 0:  Division by zero in kernel. CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.30-00001-g48313bd5768a #22 Hardware name: STM32 (Device Tree Support) Call trace: unwind_backtrace from show_stack+0x18/0x1c show_stack from dump_stack_lvl+0x6c/0x8c dump_stack_lvl from Ldiv0_64+0x8/0x18 Ldiv0_64 from stmmac_init_tstamp_counter+0x190/0x1a4 stmmac_init_tstamp_counter from stmmac_hw_setup+0xc1c/0x111c stmmac_hw_setup from __stmmac_open+0x18c/0x434 __stmmac_open from stmmac_open+0x3c/0xbc stmmac_open from __dev_open+0xf4/0x1ac __dev_open from __dev_change_flags+0x1cc/0x224 __dev_change_flags from dev_change_flags+0x24/0x60 dev_change_flags from ip_auto_config+0x2e8/0x11a0 ip_auto_config from do_one_initcall+0x84/0x33c do_one_initcall from kernel_init_freeable+0x1b8/0x214 kernel_init_freeable from kernel_init+0x24/0x140 kernel_init from ret_from_fork+0x14/0x28 Exception stack(0xe0815fb0 to 0xe0815ff8)  Prevent this division by 0 by adding an explicit check and error log about the actual issue. While at it, remove the same check from stmmac_ptp_register, which then becomes duplicate",
      "cve": "CVE-2025-38126",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38126",
          "value": "CVE-2025-38126",
          "url": "https://scout.docker.com/v/CVE-2025-38126?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38126?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2d093976f9c91fc716d2349687784f2ce90afdf7dfc3856fbe3f44d6f1d0fb55",
      "category": "container_scanning",
      "message": "CVE-2025-38127 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: fix Tx scheduler error handling in XDP callback  When the XDP program is loaded, the XDP callback adds new Tx queues. This means that the callback must update the Tx scheduler with the new queue number. In the event of a Tx scheduler failure, the XDP callback should also fail and roll back any changes previously made for XDP preparation.  The previous implementation had a bug that not all changes made by the XDP callback were rolled back. This caused the crash with the following call trace:  [  +9.549584] ice 0000:ca:00.0: Failed VSI LAN queue config for XDP, error: -5 [  +0.382335] Oops: general protection fault, probably for non-canonical address 0x50a2250a90495525: 0000 [#1] SMP NOPTI [  +0.010710] CPU: 103 UID: 0 PID: 0 Comm: swapper/103 Not tainted 6.14.0-net-next-mar-31+ #14 PREEMPT(voluntary) [  +0.010175] Hardware name: Intel Corporation M50CYP2SBSTD/M50CYP2SBSTD, BIOS SE5C620.86B.01.01.0005.2202160810 02/16/2022 [  +0.010946] RIP: 0010:__ice_update_sample+0x39/0xe0 [ice]  [...]  [  +0.002715] Call Trace: [  +0.002452]  <IRQ> [  +0.002021]  ? __die_body.cold+0x19/0x29 [  +0.003922]  ? die_addr+0x3c/0x60 [  +0.003319]  ? exc_general_protection+0x17c/0x400 [  +0.004707]  ? asm_exc_general_protection+0x26/0x30 [  +0.004879]  ? __ice_update_sample+0x39/0xe0 [ice] [  +0.004835]  ice_napi_poll+0x665/0x680 [ice] [  +0.004320]  __napi_poll+0x28/0x190 [  +0.003500]  net_rx_action+0x198/0x360 [  +0.003752]  ? update_rq_clock+0x39/0x220 [  +0.004013]  handle_softirqs+0xf1/0x340 [  +0.003840]  ? sched_clock_cpu+0xf/0x1f0 [  +0.003925]  __irq_exit_rcu+0xc2/0xe0 [  +0.003665]  common_interrupt+0x85/0xa0 [  +0.003839]  </IRQ> [  +0.002098]  <TASK> [  +0.002106]  asm_common_interrupt+0x26/0x40 [  +0.004184] RIP: 0010:cpuidle_enter_state+0xd3/0x690  Fix this by performing the missing unmapping of XDP queues from q_vectors and setting the XDP rings pointer back to NULL after all those queues are released. Also, add an immediate exit from the XDP callback in case of ring preparation failure.",
      "cve": "CVE-2025-38127",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38127",
          "value": "CVE-2025-38127",
          "url": "https://scout.docker.com/v/CVE-2025-38127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38127?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "13f5bd321231c057416f606e3a8b1a04cb882a10f84a97118e36fdb990508300",
      "category": "container_scanning",
      "message": "CVE-2025-38129 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  page_pool: Fix use-after-free in page_pool_recycle_in_ring  syzbot reported a uaf in page_pool_recycle_in_ring:  BUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862 Read of size 8 at addr ffff8880286045a0 by task syz.0.284/6943  CPU: 0 UID: 0 PID: 6943 Comm: syz.0.284 Not tainted 6.13.0-rc3-syzkaller-gdfa94ce54f41 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 lock_release+0x151/0xa30 kernel/locking/lockdep.c:5862 __raw_spin_unlock_bh include/linux/spinlock_api_smp.h:165 [inline] _raw_spin_unlock_bh+0x1b/0x40 kernel/locking/spinlock.c:210 spin_unlock_bh include/linux/spinlock.h:396 [inline] ptr_ring_produce_bh include/linux/ptr_ring.h:164 [inline] page_pool_recycle_in_ring net/core/page_pool.c:707 [inline] page_pool_put_unrefed_netmem+0x748/0xb00 net/core/page_pool.c:826 page_pool_put_netmem include/net/page_pool/helpers.h:323 [inline] page_pool_put_full_netmem include/net/page_pool/helpers.h:353 [inline] napi_pp_put_page+0x149/0x2b0 net/core/skbuff.c:1036 skb_pp_recycle net/core/skbuff.c:1047 [inline] skb_free_head net/core/skbuff.c:1094 [inline] skb_release_data+0x6c4/0x8a0 net/core/skbuff.c:1125 skb_release_all net/core/skbuff.c:1190 [inline] __kfree_skb net/core/skbuff.c:1204 [inline] sk_skb_reason_drop+0x1c9/0x380 net/core/skbuff.c:1242 kfree_skb_reason include/linux/skbuff.h:1263 [inline] __skb_queue_purge_reason include/linux/skbuff.h:3343 [inline]  root cause is:  page_pool_recycle_in_ring ptr_ring_produce spin_lock(&r->producer_lock); WRITE_ONCE(r->queue[r->producer++], ptr) //recycle last page to pool page_pool_release page_pool_scrub page_pool_empty_ring ptr_ring_consume page_pool_return_page  //release all page __page_pool_destroy free_percpu(pool->recycle_stats); free(pool) //free  spin_unlock(&r->producer_lock); //pool->ring uaf read recycle_stat_inc(pool, ring);  page_pool can be free while page pool recycle the last page in ring. Add producer-lock barrier to page_pool_release to prevent the page pool from being free before all pages have been recycled.  recycle_stat_inc() is empty when CONFIG_PAGE_POOL_STATS is not enabled, which will trigger Wempty-body build warning. Add definition for pool stat macro to fix warning.",
      "cve": "CVE-2025-38129",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38129",
          "value": "CVE-2025-38129",
          "url": "https://scout.docker.com/v/CVE-2025-38129?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38129?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "686cad92811286f1f165f8d008421f167dee4ec2bd59f410948b0624f39d3b9e",
      "category": "container_scanning",
      "message": "CVE-2025-38131 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  coresight: prevent deactivate active config while enabling the config  While enable active config via cscfg_csdev_enable_active_config(), active config could be deactivated via configfs' sysfs interface. This could make UAF issue in below scenario:  CPU0                                          CPU1 (sysfs enable)                                load module cscfg_load_config_sets() activate config. // sysfs (sys_active_cnt == 1) ... cscfg_csdev_enable_active_config() lock(csdev->cscfg_csdev_lock) // here load config activate by CPU1 unlock(csdev->cscfg_csdev_lock)  deactivate config // sysfs (sys_activec_cnt == 0) cscfg_unload_config_sets() unload module  // access to config_desc which freed // while unloading module. cscfg_csdev_enable_config  To address this, use cscfg_config_desc's active_cnt as a reference count which will be holded when - activate the config. - enable the activated config. and put the module reference when config_active_cnt == 0.",
      "cve": "CVE-2025-38131",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38131",
          "value": "CVE-2025-38131",
          "url": "https://scout.docker.com/v/CVE-2025-38131?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38131?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a8d56c01a4e31f4c50c1851c220ebba1a28bc528db289e5f37d11af61826c68",
      "category": "container_scanning",
      "message": "CVE-2025-38140 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm: limit swapping tables for devices with zone write plugs  dm_revalidate_zones() only allowed new or previously unzoned devices to call blk_revalidate_disk_zones(). If the device was already zoned, disk->nr_zones would always equal md->nr_zones, so dm_revalidate_zones() returned without doing any work. This would make the zoned settings for the device not match the new table. If the device had zone write plug resources, it could run into errors like bdev_zone_is_seq() reading invalid memory because disk->conv_zones_bitmap was the wrong size.  If the device doesn't have any zone write plug resources, calling blk_revalidate_disk_zones() will always correctly update device.  If blk_revalidate_disk_zones() fails, it can still overwrite or clear the current disk->nr_zones value. In this case, DM must restore the previous value of disk->nr_zones, so that the zoned settings will continue to match the previous value that it fell back to.  If the device already has zone write plug resources, blk_revalidate_disk_zones() will not correctly update them, if it is called for arbitrary zoned device changes.  Since there is not much need for this ability, the easiest solution is to disallow any table reloads that change the zoned settings, for devices that already have zone plug resources.  Specifically, if a device already has zone plug resources allocated, it can only switch to another zoned table that also emulates zone append.  Also, it cannot change the device size or the zone size. A device can switch to an error target.",
      "cve": "CVE-2025-38140",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38140",
          "value": "CVE-2025-38140",
          "url": "https://scout.docker.com/v/CVE-2025-38140?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38140?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "38a749ed2c4b84f3058ffbcdd8fe3dea64401836d3d59477dd4207f308ddb000",
      "category": "container_scanning",
      "message": "CVE-2025-38162 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nft_set_pipapo: prevent overflow in lookup table allocation  When calculating the lookup table size, ensure the following multiplication does not overflow:  - desc->field_len[] maximum value is U8_MAX multiplied by NFT_PIPAPO_GROUPS_PER_BYTE(f) that can be 2, worst case. - NFT_PIPAPO_BUCKETS(f->bb) is 2^8, worst case. - sizeof(unsigned long), from sizeof(*f->lt), lt in struct nft_pipapo_field.  Then, use check_mul_overflow() to multiply by bucket size and then use check_add_overflow() to the alignment for avx2 (if needed). Finally, add lt_size_check_overflow() helper and use it to consolidate this.  While at it, replace leftover allocation using the GFP_KERNEL to GFP_KERNEL_ACCOUNT for consistency, in pipapo_resize().",
      "cve": "CVE-2025-38162",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38162",
          "value": "CVE-2025-38162",
          "url": "https://scout.docker.com/v/CVE-2025-38162?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38162?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "578bd847e40486cb47c9b3b10da010bbf7aca6ad4d04a3f43421e143058ae495",
      "category": "container_scanning",
      "message": "CVE-2025-38166 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: fix ktls panic with sockmap  [ 2172.936997] ------------[ cut here ]------------ [ 2172.936999] kernel BUG at lib/iov_iter.c:629! ...... [ 2172.944996] PKRU: 55555554 [ 2172.945155] Call Trace: [ 2172.945299]  <TASK> [ 2172.945428]  ? die+0x36/0x90 [ 2172.945601]  ? do_trap+0xdd/0x100 [ 2172.945795]  ? iov_iter_revert+0x178/0x180 [ 2172.946031]  ? iov_iter_revert+0x178/0x180 [ 2172.946267]  ? do_error_trap+0x7d/0x110 [ 2172.946499]  ? iov_iter_revert+0x178/0x180 [ 2172.946736]  ? exc_invalid_op+0x50/0x70 [ 2172.946961]  ? iov_iter_revert+0x178/0x180 [ 2172.947197]  ? asm_exc_invalid_op+0x1a/0x20 [ 2172.947446]  ? iov_iter_revert+0x178/0x180 [ 2172.947683]  ? iov_iter_revert+0x5c/0x180 [ 2172.947913]  tls_sw_sendmsg_locked.isra.0+0x794/0x840 [ 2172.948206]  tls_sw_sendmsg+0x52/0x80 [ 2172.948420]  ? inet_sendmsg+0x1f/0x70 [ 2172.948634]  __sys_sendto+0x1cd/0x200 [ 2172.948848]  ? find_held_lock+0x2b/0x80 [ 2172.949072]  ? syscall_trace_enter+0x140/0x270 [ 2172.949330]  ? __lock_release.isra.0+0x5e/0x170 [ 2172.949595]  ? find_held_lock+0x2b/0x80 [ 2172.949817]  ? syscall_trace_enter+0x140/0x270 [ 2172.950211]  ? lockdep_hardirqs_on_prepare+0xda/0x190 [ 2172.950632]  ? ktime_get_coarse_real_ts64+0xc2/0xd0 [ 2172.951036]  __x64_sys_sendto+0x24/0x30 [ 2172.951382]  do_syscall_64+0x90/0x170 ......  After calling bpf_exec_tx_verdict(), the size of msg_pl->sg may increase, e.g., when the BPF program executes bpf_msg_push_data().  If the BPF program sets cork_bytes and sg.size is smaller than cork_bytes, it will return -ENOSPC and attempt to roll back to the non-zero copy logic. However, during rollback, msg->msg_iter is reset, but since msg_pl->sg.size has been increased, subsequent executions will exceed the actual size of msg_iter. ''' iov_iter_revert(&msg->msg_iter, msg_pl->sg.size - orig_size); '''  The changes in this commit are based on the following considerations:  1. When cork_bytes is set, rolling back to non-zero copy logic is pointless and can directly go to zero-copy logic.  2. We can not calculate the correct number of bytes to revert msg_iter.  Assume the original data is \"abcdefgh\" (8 bytes), and after 3 pushes by the BPF program, it becomes 11-byte data: \"abc?de?fgh?\". Then, we set cork_bytes to 6, which means the first 6 bytes have been processed, and the remaining 5 bytes \"?fgh?\" will be cached until the length meets the cork_bytes requirement.  However, some data in \"?fgh?\" is not within 'sg->msg_iter' (but in msg_pl instead), especially the data \"?\" we pushed.  So it doesn't seem as simple as just reverting through an offset of msg_iter.  3. For non-TLS sockets in tcp_bpf_sendmsg, when a \"cork\" situation occurs, the user-space send() doesn't return an error, and the returned length is the same as the input length parameter, even if some data is cached.  Additionally, I saw that the current non-zero-copy logic for handling corking is written as: ''' line 1177 else if (ret != -EAGAIN) { if (ret == -ENOSPC) ret = 0; goto send_end; '''  So it's ok to just return 'copied' without error when a \"cork\" situation occurs.",
      "cve": "CVE-2025-38166",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38166",
          "value": "CVE-2025-38166",
          "url": "https://scout.docker.com/v/CVE-2025-38166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a33cbc74cd408941fb08a5ac63e887dc89673ce15196c7b33223595ceb38d526",
      "category": "container_scanning",
      "message": "CVE-2025-38168 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  perf: arm-ni: Unregister PMUs on probe failure  When a resource allocation fails in one clock domain of an NI device, we need to properly roll back all previously registered perf PMUs in other clock domains of the same device.  Otherwise, it can lead to kernel panics.  Calling arm_ni_init+0x0/0xff8 [arm_ni] @ 2374 arm-ni ARMHCB70:00: Failed to request PMU region 0x1f3c13000 arm-ni ARMHCB70:00: probe with driver arm-ni failed with error -16 list_add corruption: next->prev should be prev (fffffd01e9698a18), but was 0000000000000000. (next=ffff10001a0decc8). pstate: 6340009 (nZCv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--) pc : list_add_valid_or_report+0x7c/0xb8 lr : list_add_valid_or_report+0x7c/0xb8 Call trace: __list_add_valid_or_report+0x7c/0xb8 perf_pmu_register+0x22c/0x3a0 arm_ni_probe+0x554/0x70c [arm_ni] platform_probe+0x70/0xe8 really_probe+0xc6/0x4d8 driver_probe_device+0x48/0x170 __driver_attach+0x8e/0x1c0 bus_for_each_dev+0x64/0xf0 driver_add+0x138/0x260 bus_add_driver+0x68/0x138 __platform_driver_register+0x2c/0x40 arm_ni_init+0x14/0x2a [arm_ni] do_init_module+0x36/0x298 ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops - BUG: Fatal exception SMP: stopping secondary CPUs",
      "cve": "CVE-2025-38168",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38168",
          "value": "CVE-2025-38168",
          "url": "https://scout.docker.com/v/CVE-2025-38168?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38168?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "437479fad4233f56419a5827354e50b4b5effd5b4eceecd0a9837458aabf8dc1",
      "category": "container_scanning",
      "message": "CVE-2025-38180 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: atm: fix /proc/net/atm/lec handling  /proc/net/atm/lec must ensure safety against dev_lec[] changes.  It appears it had dev_put() calls without prior dev_hold(), leading to imbalance and UAF.",
      "cve": "CVE-2025-38180",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38180",
          "value": "CVE-2025-38180",
          "url": "https://scout.docker.com/v/CVE-2025-38180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38180?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2f25f982ef4115009f7080beebded47e0d27f6b8d1d3711f0449a929e5469da",
      "category": "container_scanning",
      "message": "CVE-2025-38185 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  atm: atmtcp: Free invalid length skb in atmtcp_c_send().  syzbot reported the splat below. [0]  vcc_sendmsg() copies data passed from userspace to skb and passes it to vcc->dev->ops->send().  atmtcp_c_send() accesses skb->data as struct atmtcp_hdr after checking if skb->len is 0, but it's not enough.  Also, when skb->len == 0, skb and sk (vcc) were leaked because dev_kfree_skb() is not called and sk_wmem_alloc adjustment is missing to revert atm_account_tx() in vcc_sendmsg(), which is expected to be done in atm_pop_raw().  Let's properly free skb with an invalid length in atmtcp_c_send().  [0]: BUG: KMSAN: uninit-value in atmtcp_c_send+0x255/0xed0 drivers/atm/atmtcp.c:294 atmtcp_c_send+0x255/0xed0 drivers/atm/atmtcp.c:294 vcc_sendmsg+0xd7c/0xff0 net/atm/common.c:644 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x7e0/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmsg net/socket.c:2652 [inline] __do_sys_sendmsg net/socket.c:2657 [inline] __se_sys_sendmsg net/socket.c:2655 [inline] __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2655 x64_sys_call+0x32fb/0x3db0 arch/x86/include/generated/asm/syscalls_64.h:47 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Uninit was created at: slab_post_alloc_hook mm/slub.c:4154 [inline] slab_alloc_node mm/slub.c:4197 [inline] kmem_cache_alloc_node_noprof+0x818/0xf00 mm/slub.c:4249 kmalloc_reserve+0x13c/0x4b0 net/core/skbuff.c:579 __alloc_skb+0x347/0x7d0 net/core/skbuff.c:670 alloc_skb include/linux/skbuff.h:1336 [inline] vcc_sendmsg+0xb40/0xff0 net/atm/common.c:628 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x7e0/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmsg net/socket.c:2652 [inline] __do_sys_sendmsg net/socket.c:2657 [inline] __se_sys_sendmsg net/socket.c:2655 [inline] __x64_sys_sendmsg+0x211/0x3e0 net/socket.c:2655 x64_sys_call+0x32fb/0x3db0 arch/x86/include/generated/asm/syscalls_64.h:47 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f  CPU: 1 UID: 0 PID: 5798 Comm: syz-executor192 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(undef) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025",
      "cve": "CVE-2025-38185",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38185",
          "value": "CVE-2025-38185",
          "url": "https://scout.docker.com/v/CVE-2025-38185?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38185?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d84dc285414dde13f3a6bd6690b4a2a2c74a63d079152ce9a5fe555e4e9cb382",
      "category": "container_scanning",
      "message": "CVE-2025-38189 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/v3d: Avoid NULL pointer dereference in `v3d_job_update_stats()`  The following kernel Oops was recently reported by Mesa CI:  [  800.139824] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000588 [  800.148619] Mem abort info: [  800.151402]   ESR = 0x0000000096000005 [  800.155141]   EC = 0x25: DABT (current EL), IL = 32 bits [  800.160444]   SET = 0, FnV = 0 [  800.163488]   EA = 0, S1PTW = 0 [  800.166619]   FSC = 0x05: level 1 translation fault [  800.171487] Data abort info: [  800.174357]   ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000 [  800.179832]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [  800.184873]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [  800.190176] user pgtable: 4k pages, 39-bit VAs, pgdp=00000001014c2000 [  800.196607] [0000000000000588] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000 [  800.205305] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP [  800.211564] Modules linked in: vc4 snd_soc_hdmi_codec drm_display_helper v3d cec gpu_sched drm_dma_helper drm_shmem_helper drm_kms_helper drm drm_panel_orientation_quirks snd_soc_core snd_compress snd_pcm_dmaengine snd_pcm i2c_brcmstb snd_timer snd backlight [  800.234448] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.25+rpt-rpi-v8 #1  Debian 1:6.12.25-1+rpt1 [  800.244182] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT) [  800.250005] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  800.256959] pc : v3d_job_update_stats+0x60/0x130 [v3d] [  800.262112] lr : v3d_job_update_stats+0x48/0x130 [v3d] [  800.267251] sp : ffffffc080003e60 [  800.270555] x29: ffffffc080003e60 x28: ffffffd842784980 x27: 0224012000000000 [  800.277687] x26: ffffffd84277f630 x25: ffffff81012fd800 x24: 0000000000000020 [  800.284818] x23: ffffff8040238b08 x22: 0000000000000570 x21: 0000000000000158 [  800.291948] x20: 0000000000000000 x19: ffffff8040238000 x18: 0000000000000000 [  800.299078] x17: ffffffa8c1bd2000 x16: ffffffc080000000 x15: 0000000000000000 [  800.306208] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000 [  800.313338] x11: 0000000000000040 x10: 0000000000001a40 x9 : ffffffd83b39757c [  800.320468] x8 : ffffffd842786420 x7 : 7fffffffffffffff x6 : 0000000000ef32b0 [  800.327598] x5 : 00ffffffffffffff x4 : 0000000000000015 x3 : ffffffd842784980 [  800.334728] x2 : 0000000000000004 x1 : 0000000000010002 x0 : 000000ba4c0ca382 [  800.341859] Call trace: [  800.344294]  v3d_job_update_stats+0x60/0x130 [v3d] [  800.349086]  v3d_irq+0x124/0x2e0 [v3d] [  800.352835]  __handle_irq_event_percpu+0x58/0x218 [  800.357539]  handle_irq_event+0x54/0xb8 [  800.361369]  handle_fasteoi_irq+0xac/0x240 [  800.365458]  handle_irq_desc+0x48/0x68 [  800.369200]  generic_handle_domain_irq+0x24/0x38 [  800.373810]  gic_handle_irq+0x48/0xd8 [  800.377464]  call_on_irq_stack+0x24/0x58 [  800.381379]  do_interrupt_handler+0x88/0x98 [  800.385554]  el1_interrupt+0x34/0x68 [  800.389123]  el1h_64_irq_handler+0x18/0x28 [  800.393211]  el1h_64_irq+0x64/0x68 [  800.396603]  default_idle_call+0x3c/0x168 [  800.400606]  do_idle+0x1fc/0x230 [  800.403827]  cpu_startup_entry+0x40/0x50 [  800.407742]  rest_init+0xe4/0xf0 [  800.410962]  start_kernel+0x5e8/0x790 [  800.414616]  __primary_switched+0x80/0x90 [  800.418622] Code: 8b170277 8b160296 11000421 b9000861 (b9401ac1) [  800.424707] ---[ end trace 0000000000000000 ]--- [  800.457313] ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---  This issue happens when the file descriptor is closed before the jobs submitted by it are completed. When the job completes, we update the global GPU stats and the per-fd GPU stats, which are exposed through fdinfo. If the file descriptor was closed, then the struct `v3d_file_priv` and its stats were already freed and we can't update the per-fd stats.  Therefore, if the file descriptor was already closed, don't u ---truncated---",
      "cve": "CVE-2025-38189",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38189",
          "value": "CVE-2025-38189",
          "url": "https://scout.docker.com/v/CVE-2025-38189?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38189?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6b4ad0b0f1e368e76494ef8dfec21eba7d53ae064d06ce5efaeee95efcb4c78d",
      "category": "container_scanning",
      "message": "CVE-2025-38190 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  atm: Revert atm_account_tx() if copy_from_iter_full() fails.  In vcc_sendmsg(), we account skb->truesize to sk->sk_wmem_alloc by atm_account_tx().  It is expected to be reverted by atm_pop_raw() later called by vcc->dev->ops->send(vcc, skb).  However, vcc_sendmsg() misses the same revert when copy_from_iter_full() fails, and then we will leak a socket.  Let's factorise the revert part as atm_return_tx() and call it in the failure path.  Note that the corresponding sk_wmem_alloc operation can be found in alloc_tx() as of the blamed commit.  $ git blame -L:alloc_tx net/atm/common.c c55fa3cccbc2c~",
      "cve": "CVE-2025-38190",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38190",
          "value": "CVE-2025-38190",
          "url": "https://scout.docker.com/v/CVE-2025-38190?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38190?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "59559ba0d63a76984421dc04912e7cf08a8dbdb810c224dd9ae956f8a957d6f9",
      "category": "container_scanning",
      "message": "CVE-2025-38191 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix null pointer dereference in destroy_previous_session  If client set ->PreviousSessionId on kerberos session setup stage, NULL pointer dereference error will happen. Since sess->user is not set yet, It can pass the user argument as NULL to destroy_previous_session. sess->user will be set in ksmbd_krb5_authenticate(). So this patch move calling destroy_previous_session() after ksmbd_krb5_authenticate().",
      "cve": "CVE-2025-38191",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38191",
          "value": "CVE-2025-38191",
          "url": "https://scout.docker.com/v/CVE-2025-38191?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38191?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4a9078b591f29508ecedb99005727884c34b6ae81e167828282208db2c27f62a",
      "category": "container_scanning",
      "message": "CVE-2025-38192 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: clear the dst when changing skb protocol  A not-so-careful NAT46 BPF program can crash the kernel if it indiscriminately flips ingress packets from v4 to v6:  BUG: kernel NULL pointer dereference, address: 0000000000000000 ip6_rcv_core (net/ipv6/ip6_input.c:190:20) ipv6_rcv (net/ipv6/ip6_input.c:306:8) process_backlog (net/core/dev.c:6186:4) napi_poll (net/core/dev.c:6906:9) net_rx_action (net/core/dev.c:7028:13) do_softirq (kernel/softirq.c:462:3) netif_rx (net/core/dev.c:5326:3) dev_loopback_xmit (net/core/dev.c:4015:2) ip_mc_finish_output (net/ipv4/ip_output.c:363:8) NF_HOOK (./include/linux/netfilter.h:314:9) ip_mc_output (net/ipv4/ip_output.c:400:5) dst_output (./include/net/dst.h:459:9) ip_local_out (net/ipv4/ip_output.c:130:9) ip_send_skb (net/ipv4/ip_output.c:1496:8) udp_send_skb (net/ipv4/udp.c:1040:8) udp_sendmsg (net/ipv4/udp.c:1328:10)  The output interface has a 4->6 program attached at ingress. We try to loop the multicast skb back to the sending socket. Ingress BPF runs as part of netif_rx(), pushes a valid v6 hdr and changes skb->protocol to v6. We enter ip6_rcv_core which tries to use skb_dst(). But the dst is still an IPv4 one left after IPv4 mcast output.  Clear the dst in all BPF helpers which change the protocol. Try to preserve metadata dsts, those may carry non-routing metadata.",
      "cve": "CVE-2025-38192",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38192",
          "value": "CVE-2025-38192",
          "url": "https://scout.docker.com/v/CVE-2025-38192?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38192?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dddfd196e0243ec54a6084903e93657a6cadd7a414fc16b57330c05c1cd647ff",
      "category": "container_scanning",
      "message": "CVE-2025-38193 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net_sched: sch_sfq: reject invalid perturb period  Gerrard Tai reported that SFQ perturb_period has no range check yet, and this can be used to trigger a race condition fixed in a separate patch.  We want to make sure ctl->perturb_period * HZ will not overflow and is positive.   tc qd add dev lo root sfq perturb -10   # negative value : error Error: sch_sfq: invalid perturb period.  tc qd add dev lo root sfq perturb 1000000000 # too big : error Error: sch_sfq: invalid perturb period.  tc qd add dev lo root sfq perturb 2000000 # acceptable value tc -s -d qd sh dev lo qdisc sfq 8005: root refcnt 2 limit 127p quantum 64Kb depth 127 flows 128 divisor 1024 perturb 2000000sec Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0) backlog 0b 0p requeues 0",
      "cve": "CVE-2025-38193",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38193",
          "value": "CVE-2025-38193",
          "url": "https://scout.docker.com/v/CVE-2025-38193?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38193?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e60e339ae3e7f088161d371ea0a10ee6dca0862734fd983da285a9af6fd154b5",
      "category": "container_scanning",
      "message": "CVE-2025-38198 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbcon: Make sure modelist not set on unregistered console  It looks like attempting to write to the \"store_modes\" sysfs node will run afoul of unregistered consoles:  UBSAN: array-index-out-of-bounds in drivers/video/fbdev/core/fbcon.c:122:28 index -1 is out of range for type 'fb_info *[32]' ... fbcon_info_from_console+0x192/0x1a0 drivers/video/fbdev/core/fbcon.c:122 fbcon_new_modelist+0xbf/0x2d0 drivers/video/fbdev/core/fbcon.c:3048 fb_new_modelist+0x328/0x440 drivers/video/fbdev/core/fbmem.c:673 store_modes+0x1c9/0x3e0 drivers/video/fbdev/core/fbsysfs.c:113 dev_attr_store+0x55/0x80 drivers/base/core.c:2439  static struct fb_info *fbcon_registered_fb[FB_MAX]; ... static signed char con2fb_map[MAX_NR_CONSOLES]; ... static struct fb_info *fbcon_info_from_console(int console) ... return fbcon_registered_fb[con2fb_map[console]];  If con2fb_map contains a -1 things go wrong here. Instead, return NULL, as callers of fbcon_info_from_console() are trying to compare against existing \"info\" pointers, so error handling should kick in correctly.",
      "cve": "CVE-2025-38198",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38198",
          "value": "CVE-2025-38198",
          "url": "https://scout.docker.com/v/CVE-2025-38198?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38198?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aad8235dc8defcfb1e7dbe94e2a23cfa4afad2b0015ece9442497118af11d3e1",
      "category": "container_scanning",
      "message": "CVE-2025-38199 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Fix memory leak due to multiple rx_stats allocation  rx_stats for each arsta is allocated when adding a station. arsta->rx_stats will be freed when a station is removed.  Redundant allocations are occurring when the same station is added multiple times. This causes ath12k_mac_station_add() to be called multiple times, and rx_stats is allocated each time. As a result there is memory leaks.  Prevent multiple allocations of rx_stats when ath12k_mac_station_add() is called repeatedly by checking if rx_stats is already allocated before allocating again. Allocate arsta->rx_stats if arsta->rx_stats is NULL respectively.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3",
      "cve": "CVE-2025-38199",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38199",
          "value": "CVE-2025-38199",
          "url": "https://scout.docker.com/v/CVE-2025-38199?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38199?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1146cfb66d939b0e8903c332c8bf80bef75ae8574d583f7809c93b22079611f",
      "category": "container_scanning",
      "message": "CVE-2025-38201 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: nft_set_pipapo: clamp maximum map bucket size to INT_MAX  Otherwise, it is possible to hit WARN_ON_ONCE in __kvmalloc_node_noprof() when resizing hashtable because __GFP_NOWARN is unset.  Similar to:  b541ba7d1f5a (\"netfilter: conntrack: clamp maximum hashtable size to INT_MAX\")",
      "cve": "CVE-2025-38201",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38201",
          "value": "CVE-2025-38201",
          "url": "https://scout.docker.com/v/CVE-2025-38201?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38201?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "926fb14bff2107b82c50e9e9eabb521bcd4a68c0737b6a0313e599f14b0c60fb",
      "category": "container_scanning",
      "message": "CVE-2025-38202 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Check rcu_read_lock_trace_held() in bpf_map_lookup_percpu_elem()  bpf_map_lookup_percpu_elem() helper is also available for sleepable bpf program. When BPF JIT is disabled or under 32-bit host, bpf_map_lookup_percpu_elem() will not be inlined. Using it in a sleepable bpf program will trigger the warning in bpf_map_lookup_percpu_elem(), because the bpf program only holds rcu_read_lock_trace lock. Therefore, add the missed check.",
      "cve": "CVE-2025-38202",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38202",
          "value": "CVE-2025-38202",
          "url": "https://scout.docker.com/v/CVE-2025-38202?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38202?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "678c2ccb1d2db36eea3101742e9c1ae76450a78fd10a8e48246a081fd9702f42",
      "category": "container_scanning",
      "message": "CVE-2025-38205 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Avoid divide by zero by initializing dummy pitch to 1  [Why] If the dummy values in `populate_dummy_dml_surface_cfg()` aren't updated then they can lead to a divide by zero in downstream callers like CalculateVMAndRowBytes()  [How] Initialize dummy value to a value to avoid divide by zero.",
      "cve": "CVE-2025-38205",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38205",
          "value": "CVE-2025-38205",
          "url": "https://scout.docker.com/v/CVE-2025-38205?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38205?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b6db9ce5ab1cda75d63a51cc5221dea817326f616e04930f0597c0f472886a9a",
      "category": "container_scanning",
      "message": "CVE-2025-38207 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: fix uprobe pte be overwritten when expanding vma  Patch series \"Fix uprobe pte be overwritten when expanding vma\".   This patch (of 4):  We encountered a BUG alert triggered by Syzkaller as follows: BUG: Bad rss-counter state mm:00000000b4a60fca type:MM_ANONPAGES val:1  And we can reproduce it with the following steps: 1. register uprobe on file at zero offset 2. mmap the file at zero offset: addr1 = mmap(NULL, 2 * 4096, PROT_NONE, MAP_PRIVATE, fd, 0); 3. mremap part of vma1 to new vma2: addr2 = mremap(addr1, 4096, 2 * 4096, MREMAP_MAYMOVE); 4. mremap back to orig addr1: mremap(addr2, 4096, 4096, MREMAP_MAYMOVE | MREMAP_FIXED, addr1);  In step 3, the vma1 range [addr1, addr1 + 4096] will be remap to new vma2 with range [addr2, addr2 + 8192], and remap uprobe anon page from the vma1 to vma2, then unmap the vma1 range [addr1, addr1 + 4096].  In step 4, the vma2 range [addr2, addr2 + 4096] will be remap back to the addr range [addr1, addr1 + 4096].  Since the addr range [addr1 + 4096, addr1 + 8192] still maps the file, it will take vma_merge_new_range to expand the range, and then do uprobe_mmap in vma_complete.  Since the merged vma pgoff is also zero offset, it will install uprobe anon page to the merged vma.  However, the upcomming move_page_tables step, which use set_pte_at to remap the vma2 uprobe pte to the merged vma, will overwrite the newly uprobe pte in the merged vma, and lead that pte to be orphan.  Since the uprobe pte will be remapped to the merged vma, we can remove the unnecessary uprobe_mmap upon merged vma.  This problem was first found in linux-6.6.y and also exists in the community syzkaller: https://lore.kernel.org/all/000000000000ada39605a5e71711@google.com/T/",
      "cve": "CVE-2025-38207",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38207",
          "value": "CVE-2025-38207",
          "url": "https://scout.docker.com/v/CVE-2025-38207?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38207?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7643b39d6f2eec125f51664ac10da420b5d9c9fc0bf0cb226d427917ea845e48",
      "category": "container_scanning",
      "message": "CVE-2025-38208 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: add NULL check in automount_fullpath  page is checked for null in __build_path_from_dentry_optional_prefix when tcon->origin_fullpath is not set. However, the check is missing when it is set. Add a check to prevent a potential NULL pointer dereference.",
      "cve": "CVE-2025-38208",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38208",
          "value": "CVE-2025-38208",
          "url": "https://scout.docker.com/v/CVE-2025-38208?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38208?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2cfa9fd20a636d111b0b14481e34e677f46b52af322823bd7e8b2f46a96f7fd4",
      "category": "container_scanning",
      "message": "CVE-2025-38213 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vgacon: Add check for vc_origin address range in vgacon_scroll()  Our in-house Syzkaller reported the following BUG (twice), which we believed was the same issue with [1]:  ================================================================== BUG: KASAN: slab-out-of-bounds in vcs_scr_readw+0xc2/0xd0 drivers/tty/vt/vt.c:4740 Read of size 2 at addr ffff88800f5bef60 by task syz.7.2620/12393 ... Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x72/0xa0 lib/dump_stack.c:106 print_address_description.constprop.0+0x6b/0x3d0 mm/kasan/report.c:364 print_report+0xba/0x280 mm/kasan/report.c:475 kasan_report+0xa9/0xe0 mm/kasan/report.c:588 vcs_scr_readw+0xc2/0xd0 drivers/tty/vt/vt.c:4740 vcs_write_buf_noattr drivers/tty/vt/vc_screen.c:493 [inline] vcs_write+0x586/0x840 drivers/tty/vt/vc_screen.c:690 vfs_write+0x219/0x960 fs/read_write.c:584 ksys_write+0x12e/0x260 fs/read_write.c:639 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x59/0x110 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x78/0xe2 ... </TASK>  Allocated by task 5614: kasan_save_stack+0x20/0x40 mm/kasan/common.c:45 kasan_set_track+0x25/0x30 mm/kasan/common.c:52 ____kasan_kmalloc mm/kasan/common.c:374 [inline] __kasan_kmalloc+0x8f/0xa0 mm/kasan/common.c:383 kasan_kmalloc include/linux/kasan.h:201 [inline] __do_kmalloc_node mm/slab_common.c:1007 [inline] __kmalloc+0x62/0x140 mm/slab_common.c:1020 kmalloc include/linux/slab.h:604 [inline] kzalloc include/linux/slab.h:721 [inline] vc_do_resize+0x235/0xf40 drivers/tty/vt/vt.c:1193 vgacon_adjust_height+0x2d4/0x350 drivers/video/console/vgacon.c:1007 vgacon_font_set+0x1f7/0x240 drivers/video/console/vgacon.c:1031 con_font_set drivers/tty/vt/vt.c:4628 [inline] con_font_op+0x4da/0xa20 drivers/tty/vt/vt.c:4675 vt_k_ioctl+0xa10/0xb30 drivers/tty/vt/vt_ioctl.c:474 vt_ioctl+0x14c/0x1870 drivers/tty/vt/vt_ioctl.c:752 tty_ioctl+0x655/0x1510 drivers/tty/tty_io.c:2779 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:871 [inline] __se_sys_ioctl+0x12d/0x190 fs/ioctl.c:857 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x59/0x110 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x78/0xe2  Last potentially related work creation: kasan_save_stack+0x20/0x40 mm/kasan/common.c:45 __kasan_record_aux_stack+0x94/0xa0 mm/kasan/generic.c:492 __call_rcu_common.constprop.0+0xc3/0xa10 kernel/rcu/tree.c:2713 netlink_release+0x620/0xc20 net/netlink/af_netlink.c:802 __sock_release+0xb5/0x270 net/socket.c:663 sock_close+0x1e/0x30 net/socket.c:1425 __fput+0x408/0xab0 fs/file_table.c:384 __fput_sync+0x4c/0x60 fs/file_table.c:465 __do_sys_close fs/open.c:1580 [inline] __se_sys_close+0x68/0xd0 fs/open.c:1565 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x59/0x110 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x78/0xe2  Second to last potentially related work creation: kasan_save_stack+0x20/0x40 mm/kasan/common.c:45 __kasan_record_aux_stack+0x94/0xa0 mm/kasan/generic.c:492 __call_rcu_common.constprop.0+0xc3/0xa10 kernel/rcu/tree.c:2713 netlink_release+0x620/0xc20 net/netlink/af_netlink.c:802 __sock_release+0xb5/0x270 net/socket.c:663 sock_close+0x1e/0x30 net/socket.c:1425 __fput+0x408/0xab0 fs/file_table.c:384 task_work_run+0x154/0x240 kernel/task_work.c:239 exit_task_work include/linux/task_work.h:45 [inline] do_exit+0x8e5/0x1320 kernel/exit.c:874 do_group_exit+0xcd/0x280 kernel/exit.c:1023 get_signal+0x1675/0x1850 kernel/signal.c:2905 arch_do_signal_or_restart+0x80/0x3b0 arch/x86/kernel/signal.c:310 exit_to_user_mode_loop kernel/entry/common.c:111 [inline] exit_to_user_mode_prepare include/linux/entry-common.h:328 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline] syscall_exit_to_user_mode+0x1b3/0x1e0 kernel/entry/common.c:218 do_syscall_64+0x66/0x110 arch/x86/ent ---truncated---",
      "cve": "CVE-2025-38213",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38213",
          "value": "CVE-2025-38213",
          "url": "https://scout.docker.com/v/CVE-2025-38213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38213?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0fe1be180b7825e420b1262fd5950bdbef5bd9279a1e8fe277a71d24a5b9f4b5",
      "category": "container_scanning",
      "message": "CVE-2025-38214 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbdev: Fix fb_set_var to prevent null-ptr-deref in fb_videomode_to_var  If fb_add_videomode() in fb_set_var() fails to allocate memory for fb_videomode, later it may lead to a null-ptr dereference in fb_videomode_to_var(), as the fb_info is registered while not having the mode in modelist that is expected to be there, i.e. the one that is described in fb_info->var.  ================================================================ general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 PID: 30371 Comm: syz-executor.1 Not tainted 5.10.226-syzkaller #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:fb_videomode_to_var+0x24/0x610 drivers/video/fbdev/core/modedb.c:901 Call Trace: display_to_var+0x3a/0x7c0 drivers/video/fbdev/core/fbcon.c:929 fbcon_resize+0x3e2/0x8f0 drivers/video/fbdev/core/fbcon.c:2071 resize_screen drivers/tty/vt/vt.c:1176 [inline] vc_do_resize+0x53a/0x1170 drivers/tty/vt/vt.c:1263 fbcon_modechanged+0x3ac/0x6e0 drivers/video/fbdev/core/fbcon.c:2720 fbcon_update_vcs+0x43/0x60 drivers/video/fbdev/core/fbcon.c:2776 do_fb_ioctl+0x6d2/0x740 drivers/video/fbdev/core/fbmem.c:1128 fb_ioctl+0xe7/0x150 drivers/video/fbdev/core/fbmem.c:1203 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:739 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 ================================================================  The reason is that fb_info->var is being modified in fb_set_var(), and then fb_videomode_to_var() is called. If it fails to add the mode to fb_info->modelist, fb_set_var() returns error, but does not restore the old value of fb_info->var. Restore fb_info->var on failure the same way it is done earlier in the function.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "cve": "CVE-2025-38214",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38214",
          "value": "CVE-2025-38214",
          "url": "https://scout.docker.com/v/CVE-2025-38214?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38214?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9cfb6e29e27ef7750ccb1edb54114f7fa388ef118dd995ec72fd469caee4ccc2",
      "category": "container_scanning",
      "message": "CVE-2025-38215 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbdev: Fix do_register_framebuffer to prevent null-ptr-deref in fb_videomode_to_var  If fb_add_videomode() in do_register_framebuffer() fails to allocate memory for fb_videomode, it will later lead to a null-ptr dereference in fb_videomode_to_var(), as the fb_info is registered while not having the mode in modelist that is expected to be there, i.e. the one that is described in fb_info->var.  ================================================================ general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 PID: 30371 Comm: syz-executor.1 Not tainted 5.10.226-syzkaller #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:fb_videomode_to_var+0x24/0x610 drivers/video/fbdev/core/modedb.c:901 Call Trace: display_to_var+0x3a/0x7c0 drivers/video/fbdev/core/fbcon.c:929 fbcon_resize+0x3e2/0x8f0 drivers/video/fbdev/core/fbcon.c:2071 resize_screen drivers/tty/vt/vt.c:1176 [inline] vc_do_resize+0x53a/0x1170 drivers/tty/vt/vt.c:1263 fbcon_modechanged+0x3ac/0x6e0 drivers/video/fbdev/core/fbcon.c:2720 fbcon_update_vcs+0x43/0x60 drivers/video/fbdev/core/fbcon.c:2776 do_fb_ioctl+0x6d2/0x740 drivers/video/fbdev/core/fbmem.c:1128 fb_ioctl+0xe7/0x150 drivers/video/fbdev/core/fbmem.c:1203 vfs_ioctl fs/ioctl.c:48 [inline] __do_sys_ioctl fs/ioctl.c:753 [inline] __se_sys_ioctl fs/ioctl.c:739 [inline] __x64_sys_ioctl+0x19a/0x210 fs/ioctl.c:739 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x67/0xd1 ================================================================  Even though fbcon_init() checks beforehand if fb_match_mode() in var_to_display() fails, it can not prevent the panic because fbcon_init() does not return error code. Considering this and the comment in the code about fb_match_mode() returning NULL - \"This should not happen\" - it is better to prevent registering the fb_info if its mode was not set successfully. Also move fb_add_videomode() closer to the beginning of do_register_framebuffer() to avoid having to do the cleanup on fail.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "cve": "CVE-2025-38215",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38215",
          "value": "CVE-2025-38215",
          "url": "https://scout.docker.com/v/CVE-2025-38215?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38215?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1324c34aae29a907666f515460f28dd481ebd50818fca39fd6a39d2cc79f0b9",
      "category": "container_scanning",
      "message": "CVE-2025-38225 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: imx-jpeg: Cleanup after an allocation error  When allocation failures are not cleaned up by the driver, further allocation errors will be false-positives, which will cause buffers to remain uninitialized and cause NULL pointer dereferences. Ensure proper cleanup of failed allocations to prevent these issues.",
      "cve": "CVE-2025-38225",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38225",
          "value": "CVE-2025-38225",
          "url": "https://scout.docker.com/v/CVE-2025-38225?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38225?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0a8f1752abf4e7704b92ddea4bdce0f72c6a1d5bc9cd36eed29fda88f143f378",
      "category": "container_scanning",
      "message": "CVE-2025-38230 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  jfs: validate AG parameters in dbMount() to prevent crashes  Validate db_agheight, db_agwidth, and db_agstart in dbMount to catch corrupted metadata early and avoid undefined behavior in dbAllocAG. Limits are derived from L2LPERCTL, LPERCTL/MAXAG, and CTLTREESIZE:  - agheight: 0 to L2LPERCTL/2 (0 to 5) ensures shift (L2LPERCTL - 2*agheight) >= 0. - agwidth: 1 to min(LPERCTL/MAXAG, 2^(L2LPERCTL - 2*agheight)) ensures agperlev >= 1. - Ranges: 1-8 (agheight 0-3), 1-4 (agheight 4), 1 (agheight 5). - LPERCTL/MAXAG = 1024/128 = 8 limits leaves per AG; 2^(10 - 2*agheight) prevents division to 0. - agstart: 0 to CTLTREESIZE-1 - agwidth*(MAXAG-1) keeps ti within stree (size 1365). - Ranges: 0-1237 (agwidth 1), 0-348 (agwidth 8).  UBSAN: shift-out-of-bounds in fs/jfs/jfs_dmap.c:1400:9 shift exponent -335544310 is negative CPU: 0 UID: 0 PID: 5822 Comm: syz-executor130 Not tainted 6.14.0-rc5-syzkaller #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 ubsan_epilogue lib/ubsan.c:231 [inline] __ubsan_handle_shift_out_of_bounds+0x3c8/0x420 lib/ubsan.c:468 dbAllocAG+0x1087/0x10b0 fs/jfs/jfs_dmap.c:1400 dbDiscardAG+0x352/0xa20 fs/jfs/jfs_dmap.c:1613 jfs_ioc_trim+0x45a/0x6b0 fs/jfs/jfs_discard.c:105 jfs_ioctl+0x2cd/0x3e0 fs/jfs/ioctl.c:131 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "cve": "CVE-2025-38230",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38230",
          "value": "CVE-2025-38230",
          "url": "https://scout.docker.com/v/CVE-2025-38230?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38230?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9211b6fb5c4c496e87e05387c5395d95a561fac1014b14dc3a6f75a4e81cecaa",
      "category": "container_scanning",
      "message": "CVE-2025-38232 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  NFSD: fix race between nfsd registration and exports_proc  As of now nfsd calls create_proc_exports_entry() at start of init_nfsd and cleanup by remove_proc_entry() at last of exit_nfsd.  Which causes kernel OOPs if there is race between below 2 operations: (i) exportfs -r (ii) mount -t nfsd none /proc/fs/nfsd  for 5.4 kernel ARM64:  CPU 1: el1_irq+0xbc/0x180 arch_counter_get_cntvct+0x14/0x18 running_clock+0xc/0x18 preempt_count_add+0x88/0x110 prep_new_page+0xb0/0x220 get_page_from_freelist+0x2d8/0x1778 __alloc_pages_nodemask+0x15c/0xef0 __vmalloc_node_range+0x28c/0x478 __vmalloc_node_flags_caller+0x8c/0xb0 kvmalloc_node+0x88/0xe0 nfsd_init_net+0x6c/0x108 [nfsd] ops_init+0x44/0x170 register_pernet_operations+0x114/0x270 register_pernet_subsys+0x34/0x50 init_nfsd+0xa8/0x718 [nfsd] do_one_initcall+0x54/0x2e0  CPU 2 : Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010  PC is at : exports_net_open+0x50/0x68 [nfsd]  Call trace: exports_net_open+0x50/0x68 [nfsd] exports_proc_open+0x2c/0x38 [nfsd] proc_reg_open+0xb8/0x198 do_dentry_open+0x1c4/0x418 vfs_open+0x38/0x48 path_openat+0x28c/0xf18 do_filp_open+0x70/0xe8 do_sys_open+0x154/0x248  Sometimes it crashes at exports_net_open() and sometimes cache_seq_next_rcu().  and same is happening on latest 6.14 kernel as well:  [    0.000000] Linux version 6.14.0-rc5-next-20250304-dirty ... [  285.455918] Unable to handle kernel paging request at virtual address 00001f4800001f48 ... [  285.464902] pc : cache_seq_next_rcu+0x78/0xa4 ... [  285.469695] Call trace: [  285.470083]  cache_seq_next_rcu+0x78/0xa4 (P) [  285.470488]  seq_read+0xe0/0x11c [  285.470675]  proc_reg_read+0x9c/0xf0 [  285.470874]  vfs_read+0xc4/0x2fc [  285.471057]  ksys_read+0x6c/0xf4 [  285.471231]  __arm64_sys_read+0x1c/0x28 [  285.471428]  invoke_syscall+0x44/0x100 [  285.471633]  el0_svc_common.constprop.0+0x40/0xe0 [  285.471870]  do_el0_svc_compat+0x1c/0x34 [  285.472073]  el0_svc_compat+0x2c/0x80 [  285.472265]  el0t_32_sync_handler+0x90/0x140 [  285.472473]  el0t_32_sync+0x19c/0x1a0 [  285.472887] Code: f9400885 93407c23 937d7c27 11000421 (f86378a3) [  285.473422] ---[ end trace 0000000000000000 ]---  It reproduced simply with below script: while [ 1 ] do /exportfs -r done &  while [ 1 ] do insmod /nfsd.ko mount -t nfsd none /proc/fs/nfsd umount /proc/fs/nfsd rmmod nfsd done &  So exporting interfaces to user space shall be done at last and cleanup at first place.  With change there is no Kernel OOPs.",
      "cve": "CVE-2025-38232",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38232",
          "value": "CVE-2025-38232",
          "url": "https://scout.docker.com/v/CVE-2025-38232?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38232?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "162a67bdd4c239b5021ea81cf3f562240ce5dc903a8adee9cc9001aa2482b7b4",
      "category": "container_scanning",
      "message": "CVE-2025-38234 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  sched/rt: Fix race in push_rt_task  Overview ======== When a CPU chooses to call push_rt_task and picks a task to push to another CPU's runqueue then it will call find_lock_lowest_rq method which would take a double lock on both CPUs' runqueues. If one of the locks aren't readily available, it may lead to dropping the current runqueue lock and reacquiring both the locks at once. During this window it is possible that the task is already migrated and is running on some other CPU. These cases are already handled. However, if the task is migrated and has already been executed and another CPU is now trying to wake it up (ttwu) such that it is queued again on the runqeue (on_rq is 1) and also if the task was run by the same CPU, then the current checks will pass even though the task was migrated out and is no longer in the pushable tasks list.  Crashes ======= This bug resulted in quite a few flavors of crashes triggering kernel panics with various crash signatures such as assert failures, page faults, null pointer dereferences, and queue corruption errors all coming from scheduler itself.  Some of the crashes: -> kernel BUG at kernel/sched/rt.c:1616! BUG_ON(idx >= MAX_RT_PRIO) Call Trace: ? __die_body+0x1a/0x60 ? die+0x2a/0x50 ? do_trap+0x85/0x100 ? pick_next_task_rt+0x6e/0x1d0 ? do_error_trap+0x64/0xa0 ? pick_next_task_rt+0x6e/0x1d0 ? exc_invalid_op+0x4c/0x60 ? pick_next_task_rt+0x6e/0x1d0 ? asm_exc_invalid_op+0x12/0x20 ? pick_next_task_rt+0x6e/0x1d0 __schedule+0x5cb/0x790 ? update_ts_time_stats+0x55/0x70 schedule_idle+0x1e/0x40 do_idle+0x15e/0x200 cpu_startup_entry+0x19/0x20 start_secondary+0x117/0x160 secondary_startup_64_no_verify+0xb0/0xbb  -> BUG: kernel NULL pointer dereference, address: 00000000000000c0 Call Trace: ? __die_body+0x1a/0x60 ? no_context+0x183/0x350 ? __warn+0x8a/0xe0 ? exc_page_fault+0x3d6/0x520 ? asm_exc_page_fault+0x1e/0x30 ? pick_next_task_rt+0xb5/0x1d0 ? pick_next_task_rt+0x8c/0x1d0 __schedule+0x583/0x7e0 ? update_ts_time_stats+0x55/0x70 schedule_idle+0x1e/0x40 do_idle+0x15e/0x200 cpu_startup_entry+0x19/0x20 start_secondary+0x117/0x160 secondary_startup_64_no_verify+0xb0/0xbb  -> BUG: unable to handle page fault for address: ffff9464daea5900 kernel BUG at kernel/sched/rt.c:1861! BUG_ON(rq->cpu != task_cpu(p))  -> kernel BUG at kernel/sched/rt.c:1055! BUG_ON(!rq->nr_running) Call Trace: ? __die_body+0x1a/0x60 ? die+0x2a/0x50 ? do_trap+0x85/0x100 ? dequeue_top_rt_rq+0xa2/0xb0 ? do_error_trap+0x64/0xa0 ? dequeue_top_rt_rq+0xa2/0xb0 ? exc_invalid_op+0x4c/0x60 ? dequeue_top_rt_rq+0xa2/0xb0 ? asm_exc_invalid_op+0x12/0x20 ? dequeue_top_rt_rq+0xa2/0xb0 dequeue_rt_entity+0x1f/0x70 dequeue_task_rt+0x2d/0x70 __schedule+0x1a8/0x7e0 ? blk_finish_plug+0x25/0x40 schedule+0x3c/0xb0 futex_wait_queue_me+0xb6/0x120 futex_wait+0xd9/0x240 do_futex+0x344/0xa90 ? get_mm_exe_file+0x30/0x60 ? audit_exe_compare+0x58/0x70 ? audit_filter_rules.constprop.26+0x65e/0x1220 __x64_sys_futex+0x148/0x1f0 do_syscall_64+0x30/0x80 entry_SYSCALL_64_after_hwframe+0x62/0xc7  -> BUG: unable to handle page fault for address: ffff8cf3608bc2c0 Call Trace: ? __die_body+0x1a/0x60 ? no_context+0x183/0x350 ? spurious_kernel_fault+0x171/0x1c0 ? exc_page_fault+0x3b6/0x520 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? asm_exc_page_fault+0x1e/0x30 ? _cond_resched+0x15/0x30 ? futex_wait_queue_me+0xc8/0x120 ? futex_wait+0xd9/0x240 ? try_to_wake_up+0x1b8/0x490 ? futex_wake+0x78/0x160 ? do_futex+0xcd/0xa90 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? plist_del+0x6a/0xd0 ? plist_check_list+0x15/0x40 ? plist_check_list+0x2e/0x40 ? dequeue_pushable_task+0x20/0x70 ? __schedule+0x382/0x7e0 ? asm_sysvec_reschedule_i ---truncated---",
      "cve": "CVE-2025-38234",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38234",
          "value": "CVE-2025-38234",
          "url": "https://scout.docker.com/v/CVE-2025-38234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e9b31135992b853b243c70ce780fb2ce8c1b19d0b95045885f25a80acf8818f4",
      "category": "container_scanning",
      "message": "CVE-2025-38239 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: megaraid_sas: Fix invalid node index  On a system with DRAM interleave enabled, out-of-bound access is detected:  megaraid_sas 0000:3f:00.0: requested/available msix 128/128 poll_queue 0 ------------[ cut here ]------------ UBSAN: array-index-out-of-bounds in ./arch/x86/include/asm/topology.h:72:28 index -1 is out of range for type 'cpumask *[1024]' dump_stack_lvl+0x5d/0x80 ubsan_epilogue+0x5/0x2b __ubsan_handle_out_of_bounds.cold+0x46/0x4b megasas_alloc_irq_vectors+0x149/0x190 [megaraid_sas] megasas_probe_one.cold+0xa4d/0x189c [megaraid_sas] local_pci_probe+0x42/0x90 pci_device_probe+0xdc/0x290 really_probe+0xdb/0x340 __driver_probe_device+0x78/0x110 driver_probe_device+0x1f/0xa0 __driver_attach+0xba/0x1c0 bus_for_each_dev+0x8b/0xe0 bus_add_driver+0x142/0x220 driver_register+0x72/0xd0 megasas_init+0xdf/0xff0 [megaraid_sas] do_one_initcall+0x57/0x310 do_init_module+0x90/0x250 init_module_from_file+0x85/0xc0 idempotent_init_module+0x114/0x310 __x64_sys_finit_module+0x65/0xc0 do_syscall_64+0x82/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Fix it accordingly.",
      "cve": "CVE-2025-38239",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38239",
          "value": "CVE-2025-38239",
          "url": "https://scout.docker.com/v/CVE-2025-38239?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38239?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "51939f48142c9404433afaeadccf8939c187377107986f2ab2f2fbd869646b33",
      "category": "container_scanning",
      "message": "CVE-2025-38244 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential deadlock when reconnecting channels  Fix cifs_signal_cifsd_for_reconnect() to take the correct lock order and prevent the following deadlock from happening  ====================================================== WARNING: possible circular locking dependency detected 6.16.0-rc3-build2+ #1301 Tainted: G S      W ------------------------------------------------------ cifsd/6055 is trying to acquire lock: ffff88810ad56038 (&tcp_ses->srv_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x134/0x200  but task is already holding lock: ffff888119c64330 (&ret_buf->chan_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0xcf/0x200  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #2 (&ret_buf->chan_lock){+.+.}-{3:3}: validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_setup_session+0x81/0x4b0 cifs_get_smb_ses+0x771/0x900 cifs_mount_get_session+0x7e/0x170 cifs_mount+0x92/0x2d0 cifs_smb3_do_mount+0x161/0x460 smb3_get_tree+0x55/0x90 vfs_get_tree+0x46/0x180 do_new_mount+0x1b0/0x2e0 path_mount+0x6ee/0x740 do_mount+0x98/0xe0 __do_sys_mount+0x148/0x180 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x76/0x7e  -> #1 (&ret_buf->ses_lock){+.+.}-{3:3}: validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_match_super+0x101/0x320 sget+0xab/0x270 cifs_smb3_do_mount+0x1e0/0x460 smb3_get_tree+0x55/0x90 vfs_get_tree+0x46/0x180 do_new_mount+0x1b0/0x2e0 path_mount+0x6ee/0x740 do_mount+0x98/0xe0 __do_sys_mount+0x148/0x180 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x76/0x7e  -> #0 (&tcp_ses->srv_lock){+.+.}-{3:3}: check_noncircular+0x95/0xc0 check_prev_add+0x115/0x2f0 validate_chain+0x1cf/0x270 __lock_acquire+0x60e/0x780 lock_acquire.part.0+0xb4/0x1f0 _raw_spin_lock+0x2f/0x40 cifs_signal_cifsd_for_reconnect+0x134/0x200 __cifs_reconnect+0x8f/0x500 cifs_handle_standard+0x112/0x280 cifs_demultiplex_thread+0x64d/0xbc0 kthread+0x2f7/0x310 ret_from_fork+0x2a/0x230 ret_from_fork_asm+0x1a/0x30  other info that might help us debug this:  Chain exists of: &tcp_ses->srv_lock --> &ret_buf->ses_lock --> &ret_buf->chan_lock  Possible unsafe locking scenario:  CPU0                    CPU1 ----                    ---- lock(&ret_buf->chan_lock); lock(&ret_buf->ses_lock); lock(&ret_buf->chan_lock); lock(&tcp_ses->srv_lock);  *** DEADLOCK ***  3 locks held by cifsd/6055: #0: ffffffff857de398 (&cifs_tcp_ses_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x7b/0x200 #1: ffff888119c64060 (&ret_buf->ses_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0x9c/0x200 #2: ffff888119c64330 (&ret_buf->chan_lock){+.+.}-{3:3}, at: cifs_signal_cifsd_for_reconnect+0xcf/0x200",
      "cve": "CVE-2025-38244",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38244",
          "value": "CVE-2025-38244",
          "url": "https://scout.docker.com/v/CVE-2025-38244?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38244?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a2f8942b2229a142dbb105d4399949a16a2765988565d6c57afa6e213939373b",
      "category": "container_scanning",
      "message": "CVE-2025-38248 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bridge: mcast: Fix use-after-free during router port configuration  The bridge maintains a global list of ports behind which a multicast router resides. The list is consulted during forwarding to ensure multicast packets are forwarded to these ports even if the ports are not member in the matching MDB entry.  When per-VLAN multicast snooping is enabled, the per-port multicast context is disabled on each port and the port is removed from the global router port list:  # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 # ip link add name dummy1 up master br1 type dummy # ip link set dev dummy1 type bridge_slave mcast_router 2 $ bridge -d mdb show | grep router router ports on br1: dummy1 # ip link set dev br1 type bridge mcast_vlan_snooping 1 $ bridge -d mdb show | grep router  However, the port can be re-added to the global list even when per-VLAN multicast snooping is enabled:  # ip link set dev dummy1 type bridge_slave mcast_router 0 # ip link set dev dummy1 type bridge_slave mcast_router 2 $ bridge -d mdb show | grep router router ports on br1: dummy1  Since commit 4b30ae9adb04 (\"net: bridge: mcast: re-implement br_multicast_{enable, disable}_port functions\"), when per-VLAN multicast snooping is enabled, multicast disablement on a port will disable the per-{port, VLAN} multicast contexts and not the per-port one. As a result, a port will remain in the global router port list even after it is deleted. This will lead to a use-after-free [1] when the list is traversed (when adding a new port to the list, for example):  # ip link del dev dummy1 # ip link add name dummy2 up master br1 type dummy # ip link set dev dummy2 type bridge_slave mcast_router 2  Similarly, stale entries can also be found in the per-VLAN router port list. When per-VLAN multicast snooping is disabled, the per-{port, VLAN} contexts are disabled on each port and the port is removed from the per-VLAN router port list:  # ip link add name br1 up type bridge vlan_filtering 1 mcast_snooping 1 mcast_vlan_snooping 1 # ip link add name dummy1 up master br1 type dummy # bridge vlan add vid 2 dev dummy1 # bridge vlan global set vid 2 dev br1 mcast_snooping 1 # bridge vlan set vid 2 dev dummy1 mcast_router 2 $ bridge vlan global show dev br1 vid 2 | grep router router ports: dummy1 # ip link set dev br1 type bridge mcast_vlan_snooping 0 $ bridge vlan global show dev br1 vid 2 | grep router  However, the port can be re-added to the per-VLAN list even when per-VLAN multicast snooping is disabled:  # bridge vlan set vid 2 dev dummy1 mcast_router 0 # bridge vlan set vid 2 dev dummy1 mcast_router 2 $ bridge vlan global show dev br1 vid 2 | grep router router ports: dummy1  When the VLAN is deleted from the port, the per-{port, VLAN} multicast context will not be disabled since multicast snooping is not enabled on the VLAN. As a result, the port will remain in the per-VLAN router port list even after it is no longer member in the VLAN. This will lead to a use-after-free [2] when the list is traversed (when adding a new port to the list, for example):  # ip link add name dummy2 up master br1 type dummy # bridge vlan add vid 2 dev dummy2 # bridge vlan del vid 2 dev dummy1 # bridge vlan set vid 2 dev dummy2 mcast_router 2  Fix these issues by removing the port from the relevant (global or per-VLAN) router port list in br_multicast_port_ctx_deinit(). The function is invoked during port deletion with the per-port multicast context and during VLAN deletion with the per-{port, VLAN} multicast context.  Note that deleting the multicast router timer is not enough as it only takes care of the temporary multicast router states (1 or 3) and not the permanent one (2).  [1] BUG: KASAN: slab-out-of-bounds in br_multicast_add_router.part.0+0x3f1/0x560 Write of size 8 at addr ffff888004a67328 by task ip/384 [...] Call Trace: <TASK> dump_stack ---truncated---",
      "cve": "CVE-2025-38248",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38248",
          "value": "CVE-2025-38248",
          "url": "https://scout.docker.com/v/CVE-2025-38248?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38248?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ad5b082f9f7a4e26560965200eb0a1a97d80bf3517b7894e4efa096d38aec6e9",
      "category": "container_scanning",
      "message": "CVE-2025-38250 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_core: Fix use-after-free in vhci_flush()  syzbot reported use-after-free in vhci_flush() without repro. [0]  From the splat, a thread close()d a vhci file descriptor while its device was being used by iotcl() on another thread.  Once the last fd refcnt is released, vhci_release() calls hci_unregister_dev(), hci_free_dev(), and kfree() for struct vhci_data, which is set to hci_dev->dev->driver_data.  The problem is that there is no synchronisation after unlinking hdev from hci_dev_list in hci_unregister_dev().  There might be another thread still accessing the hdev which was fetched before the unlink operation.  We can use SRCU for such synchronisation.  Let's run hci_dev_reset() under SRCU and wait for its completion in hci_unregister_dev().  Another option would be to restore hci_dev->destruct(), which was removed in commit 587ae086f6e4 (\"Bluetooth: Remove unused hci-destruct cb\").  However, this would not be a good solution, as we should not run hci_unregister_dev() while there are in-flight ioctl() requests, which could lead to another data-race KCSAN splat.  Note that other drivers seem to have the same problem, for exmaple, virtbt_remove().  [0]: BUG: KASAN: slab-use-after-free in skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline] BUG: KASAN: slab-use-after-free in skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937 Read of size 8 at addr ffff88807cb8d858 by task syz.1.219/6718  CPU: 1 UID: 0 PID: 6718 Comm: syz.1.219 Not tainted 6.16.0-rc1-syzkaller-00196-g08207f42d3ff #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xd2/0x2b0 mm/kasan/report.c:521 kasan_report+0x118/0x150 mm/kasan/report.c:634 skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline] skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937 skb_queue_purge include/linux/skbuff.h:3368 [inline] vhci_flush+0x44/0x50 drivers/bluetooth/hci_vhci.c:69 hci_dev_do_reset net/bluetooth/hci_core.c:552 [inline] hci_dev_reset+0x420/0x5c0 net/bluetooth/hci_core.c:592 sock_do_ioctl+0xd9/0x300 net/socket.c:1190 sock_ioctl+0x576/0x790 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fcf5b98e929 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fcf5c7b9038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007fcf5bbb6160 RCX: 00007fcf5b98e929 RDX: 0000000000000000 RSI: 00000000400448cb RDI: 0000000000000009 RBP: 00007fcf5ba10b39 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 00007fcf5bbb6160 R15: 00007ffd6353d528 </TASK>  Allocated by task 6535: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4359 kmalloc_noprof include/linux/slab.h:905 [inline] kzalloc_noprof include/linux/slab.h:1039 [inline] vhci_open+0x57/0x360 drivers/bluetooth/hci_vhci.c:635 misc_open+0x2bc/0x330 drivers/char/misc.c:161 chrdev_open+0x4c9/0x5e0 fs/char_dev.c:414 do_dentry_open+0xdf0/0x1970 fs/open.c:964 vfs_open+0x3b/0x340 fs/open.c:1094 do_open fs/namei.c:3887 [inline] path_openat+0x2ee5/0x3830 fs/name ---truncated---",
      "cve": "CVE-2025-38250",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38250",
          "value": "CVE-2025-38250",
          "url": "https://scout.docker.com/v/CVE-2025-38250?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38250?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3b320f826ae750e3e2cc2a2c75162ca6f5b3d4a9583287031ffa9c77ba45a4fe",
      "category": "container_scanning",
      "message": "CVE-2025-38259 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: codecs: wcd9335: Fix missing free of regulator supplies  Driver gets and enables all regulator supplies in probe path (wcd9335_parse_dt() and wcd9335_power_on_reset()), but does not cleanup in final error paths and in unbind (missing remove() callback).  This leads to leaked memory and unbalanced regulator enable count during probe errors or unbind.  Fix this by converting entire code into devm_regulator_bulk_get_enable() which also greatly simplifies the code.",
      "cve": "CVE-2025-38259",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38259",
          "value": "CVE-2025-38259",
          "url": "https://scout.docker.com/v/CVE-2025-38259?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38259?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6477b63376769670874e97d87c82b7bbb2ea1d96bfdb8770f2eb8155944f53fe",
      "category": "container_scanning",
      "message": "CVE-2025-38261 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: save the SR_SUM status over switches  When threads/tasks are switched we need to ensure the old execution's SR_SUM state is saved and the new thread has the old SR_SUM state restored.  The issue was seen under heavy load especially with the syz-stress tool running, with crashes as follows in schedule_tail:  Unable to handle kernel access to user memory without uaccess routines at virtual address 000000002749f0d0 Oops [#1] Modules linked in: CPU: 1 PID: 4875 Comm: syz-executor.0 Not tainted 5.12.0-rc2-syzkaller-00467-g0d7588ab9ef9 #0 Hardware name: riscv-virtio,qemu (DT) epc : schedule_tail+0x72/0xb2 kernel/sched/core.c:4264 ra : task_pid_vnr include/linux/sched.h:1421 [inline] ra : schedule_tail+0x70/0xb2 kernel/sched/core.c:4264 epc : ffffffe00008c8b0 ra : ffffffe00008c8ae sp : ffffffe025d17ec0 gp : ffffffe005d25378 tp : ffffffe00f0d0000 t0 : 0000000000000000 t1 : 0000000000000001 t2 : 00000000000f4240 s0 : ffffffe025d17ee0 s1 : 000000002749f0d0 a0 : 000000000000002a a1 : 0000000000000003 a2 : 1ffffffc0cfac500 a3 : ffffffe0000c80cc a4 : 5ae9db91c19bbe00 a5 : 0000000000000000 a6 : 0000000000f00000 a7 : ffffffe000082eba s2 : 0000000000040000 s3 : ffffffe00eef96c0 s4 : ffffffe022c77fe0 s5 : 0000000000004000 s6 : ffffffe067d74e00 s7 : ffffffe067d74850 s8 : ffffffe067d73e18 s9 : ffffffe067d74e00 s10: ffffffe00eef96e8 s11: 000000ae6cdf8368 t3 : 5ae9db91c19bbe00 t4 : ffffffc4043cafb2 t5 : ffffffc4043cafba t6 : 0000000000040000 status: 0000000000000120 badaddr: 000000002749f0d0 cause: 000000000000000f Call Trace: [<ffffffe00008c8b0>] schedule_tail+0x72/0xb2 kernel/sched/core.c:4264 [<ffffffe000005570>] ret_from_exception+0x0/0x14 Dumping ftrace buffer: (ftrace buffer empty) ---[ end trace b5f8f9231dc87dda ]---  The issue comes from the put_user() in schedule_tail (kernel/sched/core.c) doing the following:  asmlinkage __visible void schedule_tail(struct task_struct *prev) { ... if (current->set_child_tid) put_user(task_pid_vnr(current), current->set_child_tid); ... }  the put_user() macro causes the code sequence to come out as follows:  1:\t__enable_user_access() 2:\treg = task_pid_vnr(current); 3:\t*current->set_child_tid = reg; 4:\t__disable_user_access()  The problem is that we may have a sleeping function as argument which could clear SR_SUM causing the panic above. This was fixed by evaluating the argument of the put_user() macro outside the user-enabled section in commit 285a76bb2cf5 (\"riscv: evaluate put_user() arg before enabling user access\")\"  In order for riscv to take advantage of unsafe_get/put_XXX() macros and to avoid the same issue we had with put_user() and sleeping functions we must ensure code flow can go through switch_to() from within a region of code with SR_SUM enabled and come back with SR_SUM still enabled. This patch addresses the problem allowing future work to enable full use of unsafe_get/put_XXX() macros without needing to take a CSR bit flip cost on every access. Make switch_to() save and restore SR_SUM.",
      "cve": "CVE-2025-38261",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38261",
          "value": "CVE-2025-38261",
          "url": "https://scout.docker.com/v/CVE-2025-38261?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38261?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a95873109122852340e86ae5edc68985b0cbfe6bf2e4b4e03d7a122287b1a51",
      "category": "container_scanning",
      "message": "CVE-2025-38264 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-tcp: sanitize request list handling  Validate the request in nvme_tcp_handle_r2t() to ensure it's not part of any list, otherwise a malicious R2T PDU might inject a loop in request list processing.",
      "cve": "CVE-2025-38264",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38264",
          "value": "CVE-2025-38264",
          "url": "https://scout.docker.com/v/CVE-2025-38264?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38264?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b6a324ef2bbcaab4c42d5e4f2832296101870537f8d2e18a808dd3f9bfe0c7e6",
      "category": "container_scanning",
      "message": "CVE-2025-38269 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: exit after state insertion failure at btrfs_convert_extent_bit()  If insert_state() state failed it returns an error pointer and we call extent_io_tree_panic() which will trigger a BUG() call. However if CONFIG_BUG is disabled, which is an uncommon and exotic scenario, then we fallthrough and call cache_state() which will dereference the error pointer, resulting in an invalid memory access.  So jump to the 'out' label after calling extent_io_tree_panic(), it also makes the code more clear besides dealing with the exotic scenario where CONFIG_BUG is disabled.",
      "cve": "CVE-2025-38269",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38269",
          "value": "CVE-2025-38269",
          "url": "https://scout.docker.com/v/CVE-2025-38269?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38269?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dce1f245d993a8a6cbbfb6c9391d32f8ef4d44e461e09641376a2ca13a5951d0",
      "category": "container_scanning",
      "message": "CVE-2025-38272 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: dsa: b53: do not enable EEE on bcm63xx  BCM63xx internal switches do not support EEE, but provide multiple RGMII ports where external PHYs may be connected. If one of these PHYs are EEE capable, we may try to enable EEE for the MACs, which then hangs the system on access of the (non-existent) EEE registers.  Fix this by checking if the switch actually supports EEE before attempting to configure it.",
      "cve": "CVE-2025-38272",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38272",
          "value": "CVE-2025-38272",
          "url": "https://scout.docker.com/v/CVE-2025-38272?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38272?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d1edebd5a6ecbab6607e6ad0892b7a8f271f46641bd38230d0d058521c84d874",
      "category": "container_scanning",
      "message": "CVE-2025-38275 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug  The qmp_usb_iomap() helper function currently returns the raw result of devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return a NULL pointer and the caller only checks error pointers with IS_ERR(), NULL could bypass the check and lead to an invalid dereference.  Fix the issue by checking if devm_ioremap() returns NULL. When it does, qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM), ensuring safe and consistent error handling.",
      "cve": "CVE-2025-38275",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38275",
          "value": "CVE-2025-38275",
          "url": "https://scout.docker.com/v/CVE-2025-38275?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38275?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d763fc5b98284380649e34b683f19aefbe8f731464b13e57b7e1c7f50031ad9",
      "category": "container_scanning",
      "message": "CVE-2025-38300 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: sun8i-ce-cipher - fix error handling in sun8i_ce_cipher_prepare()  Fix two DMA cleanup issues on the error path in sun8i_ce_cipher_prepare():  1] If dma_map_sg() fails for areq->dst, the device driver would try to free DMA memory it has not allocated in the first place. To fix this, on the \"theend_sgs\" error path, call dma unmap only if the corresponding dma map was successful.  2] If the dma_map_single() call for the IV fails, the device driver would try to free an invalid DMA memory address on the \"theend_iv\" path: ------------[ cut here ]------------ DMA-API: sun8i-ce 1904000.crypto: device driver tries to free an invalid DMA memory address WARNING: CPU: 2 PID: 69 at kernel/dma/debug.c:968 check_unmap+0x123c/0x1b90 Modules linked in: skcipher_example(O+) CPU: 2 UID: 0 PID: 69 Comm: 1904000.crypto- Tainted: G           O 6.15.0-rc3+ #24 PREEMPT Tainted: [O]=OOT_MODULE Hardware name: OrangePi Zero2 (DT) pc : check_unmap+0x123c/0x1b90 lr : check_unmap+0x123c/0x1b90 ... Call trace: check_unmap+0x123c/0x1b90 (P) debug_dma_unmap_page+0xac/0xc0 dma_unmap_page_attrs+0x1f4/0x5fc sun8i_ce_cipher_do_one+0x1bd4/0x1f40 crypto_pump_work+0x334/0x6e0 kthread_worker_fn+0x21c/0x438 kthread+0x374/0x664 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]---  To fix this, check for !dma_mapping_error() before calling dma_unmap_single() on the \"theend_iv\" path.",
      "cve": "CVE-2025-38300",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38300",
          "value": "CVE-2025-38300",
          "url": "https://scout.docker.com/v/CVE-2025-38300?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38300?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e363357a12bd48761d52000109ffa3a4f678a0d4d4becb6b5ccf31a64f56dadd",
      "category": "container_scanning",
      "message": "CVE-2025-38321 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: Log an error when close_all_cached_dirs fails  Under low-memory conditions, close_all_cached_dirs() can't move the dentries to a separate list to dput() them once the locks are dropped. This will result in a \"Dentry still in use\" error, so add an error message that makes it clear this is what happened:  [  495.281119] CIFS: VFS: \\\\otters.example.com\\share Out of memory while dropping dentries [  495.281595] ------------[ cut here ]------------ [  495.281887] BUG: Dentry ffff888115531138{i=78,n=/}  still in use (2) [unmount of cifs cifs] [  495.282391] WARNING: CPU: 1 PID: 2329 at fs/dcache.c:1536 umount_check+0xc8/0xf0  Also, bail out of looping through all tcons as soon as a single allocation fails, since we're already in trouble, and kmalloc() attempts for subseqeuent tcons are likely to fail just like the first one did.",
      "cve": "CVE-2025-38321",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38321",
          "value": "CVE-2025-38321",
          "url": "https://scout.docker.com/v/CVE-2025-38321?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38321?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "76e4713afe9086ecf08613094d8d5ae941c64d8d0874ced2df251d9e9201b046",
      "category": "container_scanning",
      "message": "CVE-2025-38323 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: atm: add lec_mutex  syzbot found its way in net/atm/lec.c, and found an error path in lecd_attach() could leave a dangling pointer in dev_lec[].  Add a mutex to protect dev_lecp[] uses from lecd_attach(), lec_vcc_attach() and lec_mcast_attach().  Following patch will use this mutex for /proc/net/atm/lec.  BUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline] BUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 Read of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142  CPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xcd/0x680 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 lecd_attach net/atm/lec.c:751 [inline] lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK>  Allocated by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4328 [inline] __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015 alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711 lecd_attach net/atm/lec.c:737 [inline] lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Freed by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2381 [inline] slab_free mm/slub.c:4643 [inline] kfree+0x2b4/0x4d0 mm/slub.c:4842 free_netdev+0x6c5/0x910 net/core/dev.c:11892 lecd_attach net/atm/lec.c:744 [inline] lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893",
      "cve": "CVE-2025-38323",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38323",
          "value": "CVE-2025-38323",
          "url": "https://scout.docker.com/v/CVE-2025-38323?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38323?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "81733a78dd0dae78b95b752cbfcd1eaf93b6bf5d377773e606719c75be1aa5d3",
      "category": "container_scanning",
      "message": "CVE-2025-38329 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: cs_dsp: Fix OOB memory read access in KUnit test (wmfw info)  KASAN reported out of bounds access - cs_dsp_mock_wmfw_add_info(), because the source string length was rounded up to the allocation size.",
      "cve": "CVE-2025-38329",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38329",
          "value": "CVE-2025-38329",
          "url": "https://scout.docker.com/v/CVE-2025-38329?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38329?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1b75a30426b971c5d7874a54dfceab7357e6145d66fecf1eb03dae1e14bb4bc9",
      "category": "container_scanning",
      "message": "CVE-2025-38330 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: cs_dsp: Fix OOB memory read access in KUnit test (ctl cache)  KASAN reported out of bounds access - cs_dsp_ctl_cache_init_multiple_offsets(). The code uses mock_coeff_template.length_bytes (4 bytes) for register value allocations. But later, this length is set to 8 bytes which causes test code failures.  As fix, just remove the lenght override, keeping the original value 4 for all operations.",
      "cve": "CVE-2025-38330",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38330",
          "value": "CVE-2025-38330",
          "url": "https://scout.docker.com/v/CVE-2025-38330?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38330?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ca52f70007a088b31ca1cb792dbc844b47484d5102c5465f0656a3bb737ea804",
      "category": "container_scanning",
      "message": "CVE-2025-38331 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ethernet: cortina: Use TOE/TSO on all TCP  It is desireable to push the hardware accelerator to also process non-segmented TCP frames: we pass the skb->len to the \"TOE/TSO\" offloader and it will handle them.  Without this quirk the driver becomes unstable and lock up and and crash.  I do not know exactly why, but it is probably due to the TOE (TCP offload engine) feature that is coupled with the segmentation feature - it is not possible to turn one part off and not the other, either both TOE and TSO are active, or neither of them.  Not having the TOE part active seems detrimental, as if that hardware feature is not really supposed to be turned off.  The datasheet says:  \"Based on packet parsing and TCP connection/NAT table lookup results, the NetEngine puts the packets belonging to the same TCP connection to the same queue for the software to process. The NetEngine puts incoming packets to the buffer or series of buffers for a jumbo packet. With this hardware acceleration, IP/TCP header parsing, checksum validation and connection lookup are offloaded from the software processing.\"  After numerous tests with the hardware locking up after something between minutes and hours depending on load using iperf3 I have concluded this is necessary to stabilize the hardware.",
      "cve": "CVE-2025-38331",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38331",
          "value": "CVE-2025-38331",
          "url": "https://scout.docker.com/v/CVE-2025-38331?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38331?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4ccf6b2a321be6a36d4427c3f8e46576ff6b1103219c67e56eb66207be21c5e8",
      "category": "container_scanning",
      "message": "CVE-2025-38333 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to bail out in get_new_segment()  ------------[ cut here ]------------ WARNING: CPU: 3 PID: 579 at fs/f2fs/segment.c:2832 new_curseg+0x5e8/0x6dc pc : new_curseg+0x5e8/0x6dc Call trace: new_curseg+0x5e8/0x6dc f2fs_allocate_data_block+0xa54/0xe28 do_write_page+0x6c/0x194 f2fs_do_write_node_page+0x38/0x78 __write_node_page+0x248/0x6d4 f2fs_sync_node_pages+0x524/0x72c f2fs_write_checkpoint+0x4bc/0x9b0 __checkpoint_and_complete_reqs+0x80/0x244 issue_checkpoint_thread+0x8c/0xec kthread+0x114/0x1bc ret_from_fork+0x10/0x20  get_new_segment() detects inconsistent status in between free_segmap and free_secmap, let's record such error into super block, and bail out get_new_segment() instead of continue using the segment.",
      "cve": "CVE-2025-38333",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38333",
          "value": "CVE-2025-38333",
          "url": "https://scout.docker.com/v/CVE-2025-38333?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38333?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c3ef4d9f6c11fddab1b9f102712b6725e657e86ab61c66902f0f5ef8ae2d21ef",
      "category": "container_scanning",
      "message": "CVE-2025-38334 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/sgx: Prevent attempts to reclaim poisoned pages  TL;DR: SGX page reclaim touches the page to copy its contents to secondary storage. SGX instructions do not gracefully handle machine checks. Despite this, the existing SGX code will try to reclaim pages that it _knows_ are poisoned. Avoid even trying to reclaim poisoned pages.  The longer story:  Pages used by an enclave only get epc_page->poison set in arch_memory_failure() but they currently stay on sgx_active_page_list until sgx_encl_release(), with the SGX_EPC_PAGE_RECLAIMER_TRACKED flag untouched.  epc_page->poison is not checked in the reclaimer logic meaning that, if other conditions are met, an attempt will be made to reclaim an EPC page that was poisoned.  This is bad because 1. we don't want that page to end up added to another enclave and 2. it is likely to cause one core to shut down and the kernel to panic.  Specifically, reclaiming uses microcode operations including \"EWB\" which accesses the EPC page contents to encrypt and write them out to non-SGX memory.  Those operations cannot handle MCEs in their accesses other than by putting the executing core into a special shutdown state (affecting both threads with HT.)  The kernel will subsequently panic on the remaining cores seeing the core didn't enter MCE handler(s) in time.  Call sgx_unmark_page_reclaimable() to remove the affected EPC page from sgx_active_page_list on memory error to stop it being considered for reclaiming.  Testing epc_page->poison in sgx_reclaim_pages() would also work but I assume it's better to add code in the less likely paths.  The affected EPC page is not added to &node->sgx_poison_page_list until later in sgx_encl_release()->sgx_free_epc_page() when it is EREMOVEd. Membership on other lists doesn't change to avoid changing any of the lists' semantics except for sgx_active_page_list.  There's a \"TBD\" comment in arch_memory_failure() about pre-emptive actions, the goal here is not to address everything that it may imply.  This also doesn't completely close the time window when a memory error notification will be fatal (for a not previously poisoned EPC page) -- the MCE can happen after sgx_reclaim_pages() has selected its candidates or even *inside* a microcode operation (actually easy to trigger due to the amount of time spent in them.)  The spinlock in sgx_unmark_page_reclaimable() is safe because memory_failure() runs in process context and no spinlocks are held, explicitly noted in a mm/memory-failure.c comment.",
      "cve": "CVE-2025-38334",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38334",
          "value": "CVE-2025-38334",
          "url": "https://scout.docker.com/v/CVE-2025-38334?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38334?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fcf0ce3331837dac56cdf5013a17146670ee04310a37080f786e6dcff02a940b",
      "category": "container_scanning",
      "message": "CVE-2025-38340 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: cs_dsp: Fix OOB memory read access in KUnit test  KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(), because the source string length was rounded up to the allocation size.",
      "cve": "CVE-2025-38340",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38340",
          "value": "CVE-2025-38340",
          "url": "https://scout.docker.com/v/CVE-2025-38340?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38340?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "29b93732b7156eb7833e969e49b994ec85cf556923a92da1626534f07048d471",
      "category": "container_scanning",
      "message": "CVE-2025-38343 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7996: drop fragments with multicast or broadcast RA  IEEE 802.11 fragmentation can only be applied to unicast frames. Therefore, drop fragments with multicast or broadcast RA. This patch addresses vulnerabilities such as CVE-2020-26145.",
      "cve": "CVE-2025-38343",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38343",
          "value": "CVE-2025-38343",
          "url": "https://scout.docker.com/v/CVE-2025-38343?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38343?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "72eb1a0cc934ca64ec89aede1aeb931664111a5f753b42bfb801f274a176680a",
      "category": "container_scanning",
      "message": "CVE-2025-38349 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  eventpoll: don't decrement ep refcount while still holding the ep mutex  Jann Horn points out that epoll is decrementing the ep refcount and then doing a  mutex_unlock(&ep->mtx);  afterwards. That's very wrong, because it can lead to a use-after-free.  That pattern is actually fine for the very last reference, because the code in question will delay the actual call to \"ep_free(ep)\" until after it has unlocked the mutex.  But it's wrong for the much subtler \"next to last\" case when somebody *else* may also be dropping their reference and free the ep while we're still using the mutex.  Note that this is true even if that other user is also using the same ep mutex: mutexes, unlike spinlocks, can not be used for object ownership, even if they guarantee mutual exclusion.  A mutex \"unlock\" operation is not atomic, and as one user is still accessing the mutex as part of unlocking it, another user can come in and get the now released mutex and free the data structure while the first user is still cleaning up.  See our mutex documentation in Documentation/locking/mutex-design.rst, in particular the section [1] about semantics:  \"mutex_unlock() may access the mutex structure even after it has internally released the lock already - so it's not safe for another context to acquire the mutex and assume that the mutex_unlock() context is not using the structure anymore\"  So if we drop our ep ref before the mutex unlock, but we weren't the last one, we may then unlock the mutex, another user comes in, drops _their_ reference and releases the 'ep' as it now has no users - all while the mutex_unlock() is still accessing it.  Fix this by simply moving the ep refcount dropping to outside the mutex: the refcount itself is atomic, and doesn't need mutex protection (that's the whole _point_ of refcounts: unlike mutexes, they are inherently about object lifetimes).",
      "cve": "CVE-2025-38349",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38349",
          "value": "CVE-2025-38349",
          "url": "https://scout.docker.com/v/CVE-2025-38349?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38349?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3e348985b4e4ecf5101ca257811ba6b753ff43df9f64fb8e4d6fe117c8547e9a",
      "category": "container_scanning",
      "message": "CVE-2025-38353 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe: Fix taking invalid lock on wedge  If device wedges on e.g. GuC upload, the submission is not yet enabled and the state is not even initialized. Protect the wedge call so it does nothing in this case. It fixes the following splat:  [] xe 0000:bf:00.0: [drm] device wedged, needs recovery [] ------------[ cut here ]------------ [] DEBUG_LOCKS_WARN_ON(lock->magic != lock) [] WARNING: CPU: 48 PID: 312 at kernel/locking/mutex.c:564 __mutex_lock+0x8a1/0xe60 ... [] RIP: 0010:__mutex_lock+0x8a1/0xe60 []  mutex_lock_nested+0x1b/0x30 []  xe_guc_submit_wedge+0x80/0x2b0 [xe]",
      "cve": "CVE-2025-38353",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38353",
          "value": "CVE-2025-38353",
          "url": "https://scout.docker.com/v/CVE-2025-38353?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38353?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d901c0692aaa36a2170f929f124267f180a82e178e3c274a31a8ea4dc5bc4e50",
      "category": "container_scanning",
      "message": "CVE-2025-38359 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/mm: Fix in_atomic() handling in do_secure_storage_access()  Kernel user spaces accesses to not exported pages in atomic context incorrectly try to resolve the page fault. With debug options enabled call traces like this can be seen:  BUG: sleeping function called from invalid context at kernel/locking/rwsem.c:1523 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 419074, name: qemu-system-s39 preempt_count: 1, expected: 0 RCU nest depth: 0, expected: 0 INFO: lockdep is turned off. Preemption disabled at: [<00000383ea47cfa2>] copy_page_from_iter_atomic+0xa2/0x8a0 CPU: 12 UID: 0 PID: 419074 Comm: qemu-system-s39 Tainted: G        W 6.16.0-20250531.rc0.git0.69b3a602feac.63.fc42.s390x+debug #1 PREEMPT Tainted: [W]=WARN Hardware name: IBM 3931 A01 703 (LPAR) Call Trace: [<00000383e990d282>] dump_stack_lvl+0xa2/0xe8 [<00000383e99bf152>] __might_resched+0x292/0x2d0 [<00000383eaa7c374>] down_read+0x34/0x2d0 [<00000383e99432f8>] do_secure_storage_access+0x108/0x360 [<00000383eaa724b0>] __do_pgm_check+0x130/0x220 [<00000383eaa842e4>] pgm_check_handler+0x114/0x160 [<00000383ea47d028>] copy_page_from_iter_atomic+0x128/0x8a0 ([<00000383ea47d016>] copy_page_from_iter_atomic+0x116/0x8a0) [<00000383e9c45eae>] generic_perform_write+0x16e/0x310 [<00000383e9eb87f4>] ext4_buffered_write_iter+0x84/0x160 [<00000383e9da0de4>] vfs_write+0x1c4/0x460 [<00000383e9da123c>] ksys_write+0x7c/0x100 [<00000383eaa7284e>] __do_syscall+0x15e/0x280 [<00000383eaa8417e>] system_call+0x6e/0x90 INFO: lockdep is turned off.  It is not allowed to take the mmap_lock while in atomic context. Therefore handle such a secure storage access fault as if the accessed page is not mapped: the uaccess function will return -EFAULT, and the caller has to deal with this. Usually this means that the access is retried in process context, which allows to resolve the page fault (or in this case export the page).",
      "cve": "CVE-2025-38359",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38359",
          "value": "CVE-2025-38359",
          "url": "https://scout.docker.com/v/CVE-2025-38359?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38359?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d4d2bb9815bb0f9767778768bf5b7bd6a4709e3e4f961a3049873a81c0ee8292",
      "category": "container_scanning",
      "message": "CVE-2025-38360 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add more checks for DSC / HUBP ONO guarantees  [WHY] For non-zero DSC instances it's possible that the HUBP domain required to drive it for sequential ONO ASICs isn't met, potentially causing the logic to the tile to enter an undefined state leading to a system hang.  [HOW] Add more checks to ensure that the HUBP domain matching the DSC instance is appropriately powered.  (cherry picked from commit da63df07112e5a9857a8d2aaa04255c4206754ec)",
      "cve": "CVE-2025-38360",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38360",
          "value": "CVE-2025-38360",
          "url": "https://scout.docker.com/v/CVE-2025-38360?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38360?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f3b0a485fe93640e592ebc4dca1a19e6a268a51b8416c5f018a53dd32e660252",
      "category": "container_scanning",
      "message": "CVE-2025-38361 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check dce_hwseq before dereferencing it  [WHAT]  hws was checked for null earlier in dce110_blank_stream, indicating hws can be null, and should be checked whenever it is used.  (cherry picked from commit 79db43611ff61280b6de58ce1305e0b2ecf675ad)",
      "cve": "CVE-2025-38361",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38361",
          "value": "CVE-2025-38361",
          "url": "https://scout.docker.com/v/CVE-2025-38361?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38361?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c8ecbeea545a7225eb9d1b9946bf38a88b93ed4e96422dfa3fce34f4ed85b1ce",
      "category": "container_scanning",
      "message": "CVE-2025-38368 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  misc: tps6594-pfsm: Add NULL pointer check in tps6594_pfsm_probe()  The returned value, pfsm->miscdev.name, from devm_kasprintf() could be NULL. A pointer check is added to prevent potential NULL pointer dereference. This is similar to the fix in commit 3027e7b15b02 (\"ice: Fix some null pointer dereference issues in ice_ptp.c\").  This issue is found by our static analysis tool.",
      "cve": "CVE-2025-38368",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38368",
          "value": "CVE-2025-38368",
          "url": "https://scout.docker.com/v/CVE-2025-38368?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38368?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aaa3bd70e1e77be88c50050c7341f725cd4309754335b0bb9392cd28473c9a77",
      "category": "container_scanning",
      "message": "CVE-2025-38369 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: idxd: Check availability of workqueue allocated by idxd wq driver before using  Running IDXD workloads in a container with the /dev directory mounted can trigger a call trace or even a kernel panic when the parent process of the container is terminated.  This issue occurs because, under certain configurations, Docker does not properly propagate the mount replica back to the original mount point.  In this case, when the user driver detaches, the WQ is destroyed but it still calls destroy_workqueue() attempting to completes all pending work. It's necessary to check wq->wq and skip the drain if it no longer exists.",
      "cve": "CVE-2025-38369",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38369",
          "value": "CVE-2025-38369",
          "url": "https://scout.docker.com/v/CVE-2025-38369?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38369?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2af2e7ebf0ce901ce5452d953664f56c5453a3054dea6a6e4bb376cceb6b1c79",
      "category": "container_scanning",
      "message": "CVE-2025-38373 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  IB/mlx5: Fix potential deadlock in MR deregistration  The issue arises when kzalloc() is invoked while holding umem_mutex or any other lock acquired under umem_mutex. This is problematic because kzalloc() can trigger fs_reclaim_aqcuire(), which may, in turn, invoke mmu_notifier_invalidate_range_start(). This function can lead to mlx5_ib_invalidate_range(), which attempts to acquire umem_mutex again, resulting in a deadlock.  The problematic flow: CPU0                      |              CPU1 ---------------------------------------|------------------------------------------------ mlx5_ib_dereg_mr()                     |  revoke_mr()                         |  mutex_lock(&umem_odp->umem_mutex) | | mlx5_mkey_cache_init() |   mutex_lock(&dev->cache.rb_lock) |   mlx5r_cache_create_ent_locked() |     kzalloc(GFP_KERNEL) |       fs_reclaim() |         mmu_notifier_invalidate_range_start() |           mlx5_ib_invalidate_range() |             mutex_lock(&umem_odp->umem_mutex)  cache_ent_find_and_store()        |  mutex_lock(&dev->cache.rb_lock) |  Additionally, when kzalloc() is called from within cache_ent_find_and_store(), we encounter the same deadlock due to re-acquisition of umem_mutex.  Solve by releasing umem_mutex in dereg_mr() after umr_revoke_mr() and before acquiring rb_lock. This ensures that we don't hold umem_mutex while performing memory allocations that could trigger the reclaim path.  This change prevents the deadlock by ensuring proper lock ordering and avoiding holding locks during memory allocation operations that could trigger the reclaim path.  The following lockdep warning demonstrates the deadlock:  python3/20557 is trying to acquire lock: ffff888387542128 (&umem_odp->umem_mutex){+.+.}-{4:4}, at: mlx5_ib_invalidate_range+0x5b/0x550 [mlx5_ib]  but task is already holding lock: ffffffff82f6b840 (mmu_notifier_invalidate_range_start){+.+.}-{0:0}, at: unmap_vmas+0x7b/0x1a0  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #3 (mmu_notifier_invalidate_range_start){+.+.}-{0:0}: fs_reclaim_acquire+0x60/0xd0 mem_cgroup_css_alloc+0x6f/0x9b0 cgroup_init_subsys+0xa4/0x240 cgroup_init+0x1c8/0x510 start_kernel+0x747/0x760 x86_64_start_reservations+0x25/0x30 x86_64_start_kernel+0x73/0x80 common_startup_64+0x129/0x138  -> #2 (fs_reclaim){+.+.}-{0:0}: fs_reclaim_acquire+0x91/0xd0 __kmalloc_cache_noprof+0x4d/0x4c0 mlx5r_cache_create_ent_locked+0x75/0x620 [mlx5_ib] mlx5_mkey_cache_init+0x186/0x360 [mlx5_ib] mlx5_ib_stage_post_ib_reg_umr_init+0x3c/0x60 [mlx5_ib] __mlx5_ib_add+0x4b/0x190 [mlx5_ib] mlx5r_probe+0xd9/0x320 [mlx5_ib] auxiliary_bus_probe+0x42/0x70 really_probe+0xdb/0x360 __driver_probe_device+0x8f/0x130 driver_probe_device+0x1f/0xb0 __driver_attach+0xd4/0x1f0 bus_for_each_dev+0x79/0xd0 bus_add_driver+0xf0/0x200 driver_register+0x6e/0xc0 __auxiliary_driver_register+0x6a/0xc0 do_one_initcall+0x5e/0x390 do_init_module+0x88/0x240 init_module_from_file+0x85/0xc0 idempotent_init_module+0x104/0x300 __x64_sys_finit_module+0x68/0xc0 do_syscall_64+0x6d/0x140 entry_SYSCALL_64_after_hwframe+0x4b/0x53  -> #1 (&dev->cache.rb_lock){+.+.}-{4:4}: __mutex_lock+0x98/0xf10 __mlx5_ib_dereg_mr+0x6f2/0x890 [mlx5_ib] mlx5_ib_dereg_mr+0x21/0x110 [mlx5_ib] ib_dereg_mr_user+0x85/0x1f0 [ib_core]  ---truncated---",
      "cve": "CVE-2025-38373",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38373",
          "value": "CVE-2025-38373",
          "url": "https://scout.docker.com/v/CVE-2025-38373?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38373?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "30a51e9d8897326846cf14a9825f83bd5c1d598a954c16cca5a1664c767dda71",
      "category": "container_scanning",
      "message": "CVE-2025-38408 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  genirq/irq_sim: Initialize work context pointers properly  Initialize `ops` member's pointers properly by using kzalloc() instead of kmalloc() when allocating the simulation work context. Otherwise the pointers contain random content leading to invalid dereferencing.",
      "cve": "CVE-2025-38408",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38408",
          "value": "CVE-2025-38408",
          "url": "https://scout.docker.com/v/CVE-2025-38408?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38408?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "02439a68ce64c6dd885d3f4f942474a504e0499a9602197660772f5f0709e150",
      "category": "container_scanning",
      "message": "CVE-2025-38409 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm: Fix another leak in the submit error path  put_unused_fd() doesn't free the installed file, if we've already done fd_install().  So we need to also free the sync_file.  Patchwork: https://patchwork.freedesktop.org/patch/653583/",
      "cve": "CVE-2025-38409",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38409",
          "value": "CVE-2025-38409",
          "url": "https://scout.docker.com/v/CVE-2025-38409?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38409?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "91b27b1174c98e18428cb7456c9994b182292527cab236f360d1615394093550",
      "category": "container_scanning",
      "message": "CVE-2025-38422 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: lan743x: Modify the EEPROM and OTP size for PCI1xxxx devices  Maximum OTP and EEPROM size for hearthstone PCI1xxxx devices are 8 Kb and 64 Kb respectively. Adjust max size definitions and return correct EEPROM length based on device. Also prevent out-of-bound read/write.",
      "cve": "CVE-2025-38422",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38422",
          "value": "CVE-2025-38422",
          "url": "https://scout.docker.com/v/CVE-2025-38422?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38422?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2b3915759f737c5bf2a07937c5cc844487ee86b467178a36101a6acf6667c986",
      "category": "container_scanning",
      "message": "CVE-2025-38425 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  i2c: tegra: check msg length in SMBUS block read  For SMBUS block read, do not continue to read if the message length passed from the device is '0' or greater than the maximum allowed bytes.",
      "cve": "CVE-2025-38425",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38425",
          "value": "CVE-2025-38425",
          "url": "https://scout.docker.com/v/CVE-2025-38425?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38425?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9ccb707a75c9651780e255a6ebbd173918d2cb60a9ce78232454d7cb562b84fd",
      "category": "container_scanning",
      "message": "CVE-2025-38426 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Add basic validation for RAS header  If RAS header read from EEPROM is corrupted, it could result in trying to allocate huge memory for reading the records. Add some validation to header fields.",
      "cve": "CVE-2025-38426",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38426",
          "value": "CVE-2025-38426",
          "url": "https://scout.docker.com/v/CVE-2025-38426?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38426?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "33aca00e0842fa7b2b1fa61c34cbb05e91ac7b3136354eb8df2c247119b3fedd",
      "category": "container_scanning",
      "message": "CVE-2025-38436 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/scheduler: signal scheduled fence when kill job  When an entity from application B is killed, drm_sched_entity_kill() removes all jobs belonging to that entity through drm_sched_entity_kill_jobs_work(). If application A's job depends on a scheduled fence from application B's job, and that fence is not properly signaled during the killing process, application A's dependency cannot be cleared.  This leads to application A hanging indefinitely while waiting for a dependency that will never be resolved. Fix this issue by ensuring that scheduled fences are properly signaled when an entity is killed, allowing dependent applications to continue execution.",
      "cve": "CVE-2025-38436",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38436",
          "value": "CVE-2025-38436",
          "url": "https://scout.docker.com/v/CVE-2025-38436?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38436?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d231e1d86898190eac422f5764265ae2d662ea93a062aaa38de03d01aaf3d7ed",
      "category": "container_scanning",
      "message": "CVE-2025-38437 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix potential use-after-free in oplock/lease break ack  If ksmbd_iov_pin_rsp return error, use-after-free can happen by accessing opinfo->state and opinfo_put and ksmbd_fd_put could called twice.",
      "cve": "CVE-2025-38437",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38437",
          "value": "CVE-2025-38437",
          "url": "https://scout.docker.com/v/CVE-2025-38437?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38437?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e59ee5daa6ca9b3062df5d1a9d0fba18590041167da7d743afa021e215870703",
      "category": "container_scanning",
      "message": "CVE-2025-38438 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: Intel: hda: Use devm_kstrdup() to avoid memleak.  sof_pdata->tplg_filename can have address allocated by kstrdup() and can be overwritten. Memory leak was detected with kmemleak:  unreferenced object 0xffff88812391ff60 (size 16): comm \"kworker/4:1\", pid 161, jiffies 4294802931 hex dump (first 16 bytes): 73 6f 66 2d 68 64 61 2d 67 65 6e 65 72 69 63 00  sof-hda-generic. backtrace (crc 4bf1675c): __kmalloc_node_track_caller_noprof+0x49c/0x6b0 kstrdup+0x46/0xc0 hda_machine_select.cold+0x1de/0x12cf [snd_sof_intel_hda_generic] sof_init_environment+0x16f/0xb50 [snd_sof] sof_probe_continue+0x45/0x7c0 [snd_sof] sof_probe_work+0x1e/0x40 [snd_sof] process_one_work+0x894/0x14b0 worker_thread+0x5e5/0xfb0 kthread+0x39d/0x760 ret_from_fork+0x31/0x70 ret_from_fork_asm+0x1a/0x30",
      "cve": "CVE-2025-38438",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38438",
          "value": "CVE-2025-38438",
          "url": "https://scout.docker.com/v/CVE-2025-38438?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38438?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3725e343fd5adebb87061097be44310dd55665dfc7affc4821901fe1cb7fceb3",
      "category": "container_scanning",
      "message": "CVE-2025-38440 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Fix race between DIM disable and net_dim()  There's a race between disabling DIM and NAPI callbacks using the dim pointer on the RQ or SQ.  If NAPI checks the DIM state bit and sees it still set, it assumes `rq->dim` or `sq->dim` is valid. But if DIM gets disabled right after that check, the pointer might already be set to NULL, leading to a NULL pointer dereference in net_dim().  Fix this by calling `synchronize_net()` before freeing the DIM context. This ensures all in-progress NAPI callbacks are finished before the pointer is cleared.  Kernel log:  BUG: kernel NULL pointer dereference, address: 0000000000000000 ... RIP: 0010:net_dim+0x23/0x190 ... Call Trace: <TASK> ? __die+0x20/0x60 ? page_fault_oops+0x150/0x3e0 ? common_interrupt+0xf/0xa0 ? sysvec_call_function_single+0xb/0x90 ? exc_page_fault+0x74/0x130 ? asm_exc_page_fault+0x22/0x30 ? net_dim+0x23/0x190 ? mlx5e_poll_ico_cq+0x41/0x6f0 [mlx5_core] ? sysvec_apic_timer_interrupt+0xb/0x90 mlx5e_handle_rx_dim+0x92/0xd0 [mlx5_core] mlx5e_napi_poll+0x2cd/0xac0 [mlx5_core] ? mlx5e_poll_ico_cq+0xe5/0x6f0 [mlx5_core] busy_poll_stop+0xa2/0x200 ? mlx5e_napi_poll+0x1d9/0xac0 [mlx5_core] ? mlx5e_trigger_irq+0x130/0x130 [mlx5_core] __napi_busy_loop+0x345/0x3b0 ? sysvec_call_function_single+0xb/0x90 ? asm_sysvec_call_function_single+0x16/0x20 ? sysvec_apic_timer_interrupt+0xb/0x90 ? pcpu_free_area+0x1e4/0x2e0 napi_busy_loop+0x11/0x20 xsk_recvmsg+0x10c/0x130 sock_recvmsg+0x44/0x70 __sys_recvfrom+0xbc/0x130 ? __schedule+0x398/0x890 __x64_sys_recvfrom+0x20/0x30 do_syscall_64+0x4c/0x100 entry_SYSCALL_64_after_hwframe+0x4b/0x53 ... ---[ end trace 0000000000000000 ]--- ... ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---",
      "cve": "CVE-2025-38440",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38440",
          "value": "CVE-2025-38440",
          "url": "https://scout.docker.com/v/CVE-2025-38440?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38440?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1e88ca9c884c0d6d8b0d9b40a1bab9bd6d9352b2cd9814eb31a67df24a534185",
      "category": "container_scanning",
      "message": "CVE-2025-38449 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/gem: Acquire references on GEM handles for framebuffers  A GEM handle can be released while the GEM buffer object is attached to a DRM framebuffer. This leads to the release of the dma-buf backing the buffer object, if any. [1] Trying to use the framebuffer in further mode-setting operations leads to a segmentation fault. Most easily happens with driver that use shadow planes for vmap-ing the dma-buf during a page flip. An example is shown below.  [  156.791968] ------------[ cut here ]------------ [  156.796830] WARNING: CPU: 2 PID: 2255 at drivers/dma-buf/dma-buf.c:1527 dma_buf_vmap+0x224/0x430 [...] [  156.942028] RIP: 0010:dma_buf_vmap+0x224/0x430 [  157.043420] Call Trace: [  157.045898]  <TASK> [  157.048030]  ? show_trace_log_lvl+0x1af/0x2c0 [  157.052436]  ? show_trace_log_lvl+0x1af/0x2c0 [  157.056836]  ? show_trace_log_lvl+0x1af/0x2c0 [  157.061253]  ? drm_gem_shmem_vmap+0x74/0x710 [  157.065567]  ? dma_buf_vmap+0x224/0x430 [  157.069446]  ? __warn.cold+0x58/0xe4 [  157.073061]  ? dma_buf_vmap+0x224/0x430 [  157.077111]  ? report_bug+0x1dd/0x390 [  157.080842]  ? handle_bug+0x5e/0xa0 [  157.084389]  ? exc_invalid_op+0x14/0x50 [  157.088291]  ? asm_exc_invalid_op+0x16/0x20 [  157.092548]  ? dma_buf_vmap+0x224/0x430 [  157.096663]  ? dma_resv_get_singleton+0x6d/0x230 [  157.101341]  ? __pfx_dma_buf_vmap+0x10/0x10 [  157.105588]  ? __pfx_dma_resv_get_singleton+0x10/0x10 [  157.110697]  drm_gem_shmem_vmap+0x74/0x710 [  157.114866]  drm_gem_vmap+0xa9/0x1b0 [  157.118763]  drm_gem_vmap_unlocked+0x46/0xa0 [  157.123086]  drm_gem_fb_vmap+0xab/0x300 [  157.126979]  drm_atomic_helper_prepare_planes.part.0+0x487/0xb10 [  157.133032]  ? lockdep_init_map_type+0x19d/0x880 [  157.137701]  drm_atomic_helper_commit+0x13d/0x2e0 [  157.142671]  ? drm_atomic_nonblocking_commit+0xa0/0x180 [  157.147988]  drm_mode_atomic_ioctl+0x766/0xe40 [...] [  157.346424] ---[ end trace 0000000000000000 ]---  Acquiring GEM handles for the framebuffer's GEM buffer objects prevents this from happening. The framebuffer's cleanup later puts the handle references.  Commit 1a148af06000 (\"drm/gem-shmem: Use dma_buf from GEM object instance\") triggers the segmentation fault easily by using the dma-buf field more widely. The underlying issue with reference counting has been present before.  v2: - acquire the handle instead of the BO (Christian) - fix comment style (Christian) - drop the Fixes tag (Christian) - rename err_ gotos - add missing Link tag",
      "cve": "CVE-2025-38449",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38449",
          "value": "CVE-2025-38449",
          "url": "https://scout.docker.com/v/CVE-2025-38449?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38449?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a19744866111c26d2208020b409506183958612e2d58bef2a151150942e36240",
      "category": "container_scanning",
      "message": "CVE-2025-38485 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iio: accel: fxls8962af: Fix use after free in fxls8962af_fifo_flush  fxls8962af_fifo_flush() uses indio_dev->active_scan_mask (with iio_for_each_active_channel()) without making sure the indio_dev stays in buffer mode. There is a race if indio_dev exits buffer mode in the middle of the interrupt that flushes the fifo. Fix this by calling synchronize_irq() to ensure that no interrupt is currently running when disabling buffer mode.  Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read [...] _find_first_bit_le from fxls8962af_fifo_flush+0x17c/0x290 fxls8962af_fifo_flush from fxls8962af_interrupt+0x80/0x178 fxls8962af_interrupt from irq_thread_fn+0x1c/0x7c irq_thread_fn from irq_thread+0x110/0x1f4 irq_thread from kthread+0xe0/0xfc kthread from ret_from_fork+0x14/0x2c",
      "cve": "CVE-2025-38485",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38485",
          "value": "CVE-2025-38485",
          "url": "https://scout.docker.com/v/CVE-2025-38485?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38485?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2a888c10109d5be0c73781ceb1b3cf55241edf0d52d64f7cae776e209e028eb8",
      "category": "container_scanning",
      "message": "CVE-2025-38486 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  soundwire: Revert \"soundwire: qcom: Add set_channel_map api support\"  This reverts commit 7796c97df6b1b2206681a07f3c80f6023a6593d5.  This patch broke Dragonboard 845c (sdm845). I see:  Unexpected kernel BRK exception at EL1 Internal error: BRK handler: 00000000f20003e8 [#1]  SMP pc : qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] lr : snd_soc_dai_set_channel_map+0x34/0x78 Call trace: qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] (P) sdm845_dai_init+0x18c/0x2e0 [snd_soc_sdm845] snd_soc_link_init+0x28/0x6c snd_soc_bind_card+0x5f4/0xb0c snd_soc_register_card+0x148/0x1a4 devm_snd_soc_register_card+0x50/0xb0 sdm845_snd_platform_probe+0x124/0x148 [snd_soc_sdm845] platform_probe+0x6c/0xd0 really_probe+0xc0/0x2a4 __driver_probe_device+0x7c/0x130 driver_probe_device+0x40/0x118 __device_attach_driver+0xc4/0x108 bus_for_each_drv+0x8c/0xf0 __device_attach+0xa4/0x198 device_initial_probe+0x18/0x28 bus_probe_device+0xb8/0xbc deferred_probe_work_func+0xac/0xfc process_one_work+0x244/0x658 worker_thread+0x1b4/0x360 kthread+0x148/0x228 ret_from_fork+0x10/0x20 Kernel panic - not syncing: BRK handler: Fatal exception  Dan has also reported following issues with the original patch https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/  Bug #1: The zeroeth element of ctrl->pconfig[] is supposed to be unused.  We start counting at 1.  However this code sets ctrl->pconfig[0].ch_mask = 128.  Bug #2: There are SLIM_MAX_TX_PORTS (16) elements in tx_ch[] array but only QCOM_SDW_MAX_PORTS + 1 (15) in the ctrl->pconfig[] array so it corrupts memory like Yongqin Liu pointed out.  Bug 3: Like Jie Gan pointed out, it erases all the tx information with the rx information.",
      "cve": "CVE-2025-38486",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38486",
          "value": "CVE-2025-38486",
          "url": "https://scout.docker.com/v/CVE-2025-38486?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38486?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "98c9ca50b0af9a5f1b5ce6e5cb257fc98b2016e0e3ff78d33687d2bc98af7c2b",
      "category": "container_scanning",
      "message": "CVE-2025-38491 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mptcp: make fallback action and fallback decision atomic  Syzkaller reported the following splat:  WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 __mptcp_do_fallback net/mptcp/protocol.h:1223 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_do_fallback net/mptcp/protocol.h:1244 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 check_fully_established net/mptcp/options.c:982 [inline] WARNING: CPU: 1 PID: 7704 at net/mptcp/protocol.h:1223 mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153 Modules linked in: CPU: 1 UID: 0 PID: 7704 Comm: syz.3.1419 Not tainted 6.16.0-rc3-gbd5ce2324dba #20 PREEMPT(voluntary) Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 RIP: 0010:__mptcp_do_fallback net/mptcp/protocol.h:1223 [inline] RIP: 0010:mptcp_do_fallback net/mptcp/protocol.h:1244 [inline] RIP: 0010:check_fully_established net/mptcp/options.c:982 [inline] RIP: 0010:mptcp_incoming_options+0x21a8/0x2510 net/mptcp/options.c:1153 Code: 24 18 e8 bb 2a 00 fd e9 1b df ff ff e8 b1 21 0f 00 e8 ec 5f c4 fc 44 0f b7 ac 24 b0 00 00 00 e9 54 f1 ff ff e8 d9 5f c4 fc 90 <0f> 0b 90 e9 b8 f4 ff ff e8 8b 2a 00 fd e9 8d e6 ff ff e8 81 2a 00 RSP: 0018:ffff8880a3f08448 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff8880180a8000 RCX: ffffffff84afcf45 RDX: ffff888090223700 RSI: ffffffff84afdaa7 RDI: 0000000000000001 RBP: ffff888017955780 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000 R13: ffff8880180a8910 R14: ffff8880a3e9d058 R15: 0000000000000000 FS:  00005555791b8500(0000) GS:ffff88811c495000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000110c2800b7 CR3: 0000000058e44000 CR4: 0000000000350ef0 Call Trace: <IRQ> tcp_reset+0x26f/0x2b0 net/ipv4/tcp_input.c:4432 tcp_validate_incoming+0x1057/0x1b60 net/ipv4/tcp_input.c:5975 tcp_rcv_established+0x5b5/0x21f0 net/ipv4/tcp_input.c:6166 tcp_v4_do_rcv+0x5dc/0xa70 net/ipv4/tcp_ipv4.c:1925 tcp_v4_rcv+0x3473/0x44a0 net/ipv4/tcp_ipv4.c:2363 ip_protocol_deliver_rcu+0xba/0x480 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x2f1/0x500 net/ipv4/ip_input.c:233 NF_HOOK include/linux/netfilter.h:317 [inline] NF_HOOK include/linux/netfilter.h:311 [inline] ip_local_deliver+0x1be/0x560 net/ipv4/ip_input.c:254 dst_input include/net/dst.h:469 [inline] ip_rcv_finish net/ipv4/ip_input.c:447 [inline] NF_HOOK include/linux/netfilter.h:317 [inline] NF_HOOK include/linux/netfilter.h:311 [inline] ip_rcv+0x514/0x810 net/ipv4/ip_input.c:567 __netif_receive_skb_one_core+0x197/0x1e0 net/core/dev.c:5975 __netif_receive_skb+0x1f/0x120 net/core/dev.c:6088 process_backlog+0x301/0x1360 net/core/dev.c:6440 __napi_poll.constprop.0+0xba/0x550 net/core/dev.c:7453 napi_poll net/core/dev.c:7517 [inline] net_rx_action+0xb44/0x1010 net/core/dev.c:7644 handle_softirqs+0x1d0/0x770 kernel/softirq.c:579 do_softirq+0x3f/0x90 kernel/softirq.c:480 </IRQ> <TASK> __local_bh_enable_ip+0xed/0x110 kernel/softirq.c:407 local_bh_enable include/linux/bottom_half.h:33 [inline] inet_csk_listen_stop+0x2c5/0x1070 net/ipv4/inet_connection_sock.c:1524 mptcp_check_listen_stop.part.0+0x1cc/0x220 net/mptcp/protocol.c:2985 mptcp_check_listen_stop net/mptcp/mib.h:118 [inline] __mptcp_close+0x9b9/0xbd0 net/mptcp/protocol.c:3000 mptcp_close+0x2f/0x140 net/mptcp/protocol.c:3066 inet_release+0xed/0x200 net/ipv4/af_inet.c:435 inet6_release+0x4f/0x70 net/ipv6/af_inet6.c:487 __sock_release+0xb3/0x270 net/socket.c:649 sock_close+0x1c/0x30 net/socket.c:1439 __fput+0x402/0xb70 fs/file_table.c:465 task_work_run+0x150/0x240 kernel/task_work.c:227 resume_user_mode_work include/linux/resume_user_mode.h:50 [inline] exit_to_user_mode_loop+0xd4 ---truncated---",
      "cve": "CVE-2025-38491",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38491",
          "value": "CVE-2025-38491",
          "url": "https://scout.docker.com/v/CVE-2025-38491?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38491?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "317618701f387f340028b1532771bfb02f7600553bbb19c42ff6ea0220143386",
      "category": "container_scanning",
      "message": "CVE-2025-38501 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: limit repeated connections from clients with the same IP  Repeated connections from clients with the same IP address may exhaust the max connections and prevent other normal client connections. This patch limit repeated connections from clients with the same IP.",
      "cve": "CVE-2025-38501",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38501",
          "value": "CVE-2025-38501",
          "url": "https://scout.docker.com/v/CVE-2025-38501?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38501?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6544975daee76d6ef642d7105c58748d314a6c5f17e3f9a57928f586e657146f",
      "category": "container_scanning",
      "message": "CVE-2025-38503 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix assertion when building free space tree  When building the free space tree with the block group tree feature enabled, we can hit an assertion failure like this:  BTRFS info (device loop0 state M): rebuilding free space tree assertion failed: ret == 0, in fs/btrfs/free-space-tree.c:1102 ------------[ cut here ]------------ kernel BUG at fs/btrfs/free-space-tree.c:1102! Internal error: Oops - BUG: 00000000f2000800 [#1]  SMP Modules linked in: CPU: 1 UID: 0 PID: 6592 Comm: syz-executor322 Not tainted 6.15.0-rc7-syzkaller-gd7fa1af5b33e #0 PREEMPT Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 lr : populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 sp : ffff8000a4ce7600 x29: ffff8000a4ce76e0 x28: ffff0000c9bc6000 x27: ffff0000ddfff3d8 x26: ffff0000ddfff378 x25: dfff800000000000 x24: 0000000000000001 x23: ffff8000a4ce7660 x22: ffff70001499cecc x21: ffff0000e1d8c160 x20: ffff0000e1cb7800 x19: ffff0000e1d8c0b0 x18: 00000000ffffffff x17: ffff800092f39000 x16: ffff80008ad27e48 x15: ffff700011e740c0 x14: 1ffff00011e740c0 x13: 0000000000000004 x12: ffffffffffffffff x11: ffff700011e740c0 x10: 0000000000ff0100 x9 : 94ef24f55d2dbc00 x8 : 94ef24f55d2dbc00 x7 : 0000000000000001 x6 : 0000000000000001 x5 : ffff8000a4ce6f98 x4 : ffff80008f415ba0 x3 : ffff800080548ef0 x2 : 0000000000000000 x1 : 0000000100000000 x0 : 000000000000003e Call trace: populate_free_space_tree+0x514/0x518 fs/btrfs/free-space-tree.c:1102 (P) btrfs_rebuild_free_space_tree+0x14c/0x54c fs/btrfs/free-space-tree.c:1337 btrfs_start_pre_rw_mount+0xa78/0xe10 fs/btrfs/disk-io.c:3074 btrfs_remount_rw fs/btrfs/super.c:1319 [inline] btrfs_reconfigure+0x828/0x2418 fs/btrfs/super.c:1543 reconfigure_super+0x1d4/0x6f0 fs/super.c:1083 do_remount fs/namespace.c:3365 [inline] path_mount+0xb34/0xde0 fs/namespace.c:4200 do_mount fs/namespace.c:4221 [inline] __do_sys_mount fs/namespace.c:4432 [inline] __se_sys_mount fs/namespace.c:4409 [inline] __arm64_sys_mount+0x3e8/0x468 fs/namespace.c:4409 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x58/0x17c arch/arm64/kernel/entry-common.c:767 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:786 el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600 Code: f0047182 91178042 528089c3 9771d47b (d4210000) ---[ end trace 0000000000000000 ]---  This happens because we are processing an empty block group, which has no extents allocated from it, there are no items for this block group, including the block group item since block group items are stored in a dedicated tree when using the block group tree feature. It also means this is the block group with the highest start offset, so there are no higher keys in the extent root, hence btrfs_search_slot_for_read() returns 1 (no higher key found).  Fix this by asserting 'ret' is 0 only if the block group tree feature is not enabled, in which case we should find a block group item for the block group since it's stored in the extent root and block group item keys are greater than extent item keys (the value for BTRFS_BLOCK_GROUP_ITEM_KEY is 192 and for BTRFS_EXTENT_ITEM_KEY and BTRFS_METADATA_ITEM_KEY the values are 168 and 169 respectively). In case 'ret' is 1, we just need to add a record to the free space tree which spans the whole block group, and we can achieve this by making 'ret == 0' as the while loop's condition.",
      "cve": "CVE-2025-38503",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38503",
          "value": "CVE-2025-38503",
          "url": "https://scout.docker.com/v/CVE-2025-38503?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38503?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d1460cec256c1e6229296ce6f653c92b754718d7833f173e5c77e929184a6c85",
      "category": "container_scanning",
      "message": "CVE-2025-38507 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: nintendo: avoid bluetooth suspend/resume stalls  Ensure we don't stall or panic the kernel when using bluetooth-connected controllers. This was reported as an issue on android devices using kernel 6.6 due to the resume hook which had been added for usb joycons.  First, set a new state value to JOYCON_CTLR_STATE_SUSPENDED in a newly-added nintendo_hid_suspend. This makes sure we will not stall out the kernel waiting for input reports during led classdev suspend. The stalls could happen if connectivity is unreliable or lost to the controller prior to suspend.  Second, since we lose connectivity during suspend, do not try joycon_init() for bluetooth controllers in the nintendo_hid_resume path.  Tested via multiple suspend/resume flows when using the controller both in USB and bluetooth modes.",
      "cve": "CVE-2025-38507",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38507",
          "value": "CVE-2025-38507",
          "url": "https://scout.docker.com/v/CVE-2025-38507?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38507?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9e6ba48e1ac2f950b368fa4c9ae251645525f57a7fcaf2fc043620f4f1a70eb4",
      "category": "container_scanning",
      "message": "CVE-2025-38512 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: prevent A-MSDU attacks in mesh networks  This patch is a mitigation to prevent the A-MSDU spoofing vulnerability for mesh networks. The initial update to the IEEE 802.11 standard, in response to the FragAttacks, missed this case (CVE-2025-27558). It can be considered a variant of CVE-2020-24588 but for mesh networks.  This patch tries to detect if a standard MSDU was turned into an A-MSDU by an adversary. This is done by parsing a received A-MSDU as a standard MSDU, calculating the length of the Mesh Control header, and seeing if the 6 bytes after this header equal the start of an rfc1042 header. If equal, this is a strong indication of an ongoing attack attempt.  This defense was tested with mac80211_hwsim against a mesh network that uses an empty Mesh Address Extension field, i.e., when four addresses are used, and when using a 12-byte Mesh Address Extension field, i.e., when six addresses are used. Functionality of normal MSDUs and A-MSDUs was also tested, and confirmed working, when using both an empty and 12-byte Mesh Address Extension field.  It was also tested with mac80211_hwsim that A-MSDU attacks in non-mesh networks keep being detected and prevented.  Note that the vulnerability being patched, and the defense being implemented, was also discussed in the following paper and in the following IEEE 802.11 presentation:  https://papers.mathyvanhoef.com/wisec2025.pdf https://mentor.ieee.org/802.11/dcn/25/11-25-0949-00-000m-a-msdu-mesh-spoof-protection.docx",
      "cve": "CVE-2025-38512",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38512",
          "value": "CVE-2025-38512",
          "url": "https://scout.docker.com/v/CVE-2025-38512?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38512?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "08673702d222fd6bb5b7dbc03f6a30e4d2b038ee7cc8d77033baf7e2a7b96629",
      "category": "container_scanning",
      "message": "CVE-2025-38520 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Don't call mmput from MMU notifier callback  If the process is exiting, the mmput inside mmu notifier callback from compactd or fork or numa balancing could release the last reference of mm struct to call exit_mmap and free_pgtable, this triggers deadlock with below backtrace.  The deadlock will leak kfd process as mmu notifier release is not called and cause VRAM leaking.  The fix is to take mm reference mmget_non_zero when adding prange to the deferred list to pair with mmput in deferred list work.  If prange split and add into pchild list, the pchild work_item.mm is not used, so remove the mm parameter from svm_range_unmap_split and svm_range_add_child.  The backtrace of hung task:  INFO: task python:348105 blocked for more than 64512 seconds. Call Trace: __schedule+0x1c3/0x550 schedule+0x46/0xb0 rwsem_down_write_slowpath+0x24b/0x4c0 unlink_anon_vmas+0xb1/0x1c0 free_pgtables+0xa9/0x130 exit_mmap+0xbc/0x1a0 mmput+0x5a/0x140 svm_range_cpu_invalidate_pagetables+0x2b/0x40 [amdgpu] mn_itree_invalidate+0x72/0xc0 __mmu_notifier_invalidate_range_start+0x48/0x60 try_to_unmap_one+0x10fa/0x1400 rmap_walk_anon+0x196/0x460 try_to_unmap+0xbb/0x210 migrate_page_unmap+0x54d/0x7e0 migrate_pages_batch+0x1c3/0xae0 migrate_pages_sync+0x98/0x240 migrate_pages+0x25c/0x520 compact_zone+0x29d/0x590 compact_zone_order+0xb6/0xf0 try_to_compact_pages+0xbe/0x220 __alloc_pages_direct_compact+0x96/0x1a0 __alloc_pages_slowpath+0x410/0x930 __alloc_pages_nodemask+0x3a9/0x3e0 do_huge_pmd_anonymous_page+0xd7/0x3e0 __handle_mm_fault+0x5e3/0x5f0 handle_mm_fault+0xf7/0x2e0 hmm_vma_fault.isra.0+0x4d/0xa0 walk_pmd_range.isra.0+0xa8/0x310 walk_pud_range+0x167/0x240 walk_pgd_range+0x55/0x100 __walk_page_range+0x87/0x90 walk_page_range+0xf6/0x160 hmm_range_fault+0x4f/0x90 amdgpu_hmm_range_get_pages+0x123/0x230 [amdgpu] amdgpu_ttm_tt_get_user_pages+0xb1/0x150 [amdgpu] init_user_pages+0xb1/0x2a0 [amdgpu] amdgpu_amdkfd_gpuvm_alloc_memory_of_gpu+0x543/0x7d0 [amdgpu] kfd_ioctl_alloc_memory_of_gpu+0x24c/0x4e0 [amdgpu] kfd_ioctl+0x29d/0x500 [amdgpu]  (cherry picked from commit a29e067bd38946f752b0ef855f3dfff87e77bec7)",
      "cve": "CVE-2025-38520",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38520",
          "value": "CVE-2025-38520",
          "url": "https://scout.docker.com/v/CVE-2025-38520?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38520?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "80a59cfe9d62896d4621294ab5002be952e8719d93779574d95a8009153ef5b0",
      "category": "container_scanning",
      "message": "CVE-2025-38524 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rxrpc: Fix recv-recv race of completed call  If a call receives an event (such as incoming data), the call gets placed on the socket's queue and a thread in recvmsg can be awakened to go and process it.  Once the thread has picked up the call off of the queue, further events will cause it to be requeued, and once the socket lock is dropped (recvmsg uses call->user_mutex to allow the socket to be used in parallel), a second thread can come in and its recvmsg can pop the call off the socket queue again.  In such a case, the first thread will be receiving stuff from the call and the second thread will be blocked on call->user_mutex.  The first thread can, at this point, process both the event that it picked call for and the event that the second thread picked the call for and may see the call terminate - in which case the call will be \"released\", decoupling the call from the user call ID assigned to it (RXRPC_USER_CALL_ID in the control message).  The first thread will return okay, but then the second thread will wake up holding the user_mutex and, if it sees that the call has been released by the first thread, it will BUG thusly:  kernel BUG at net/rxrpc/recvmsg.c:474!  Fix this by just dequeuing the call and ignoring it if it is seen to be already released.  We can't tell userspace about it anyway as the user call ID has become stale.",
      "cve": "CVE-2025-38524",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38524",
          "value": "CVE-2025-38524",
          "url": "https://scout.docker.com/v/CVE-2025-38524?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38524?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "62b688810b8afa77048b12bc23773bab17be4a127657f919f10b219b0de755c0",
      "category": "container_scanning",
      "message": "CVE-2025-38531 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iio: common: st_sensors: Fix use of uninitialize device structs  Throughout the various probe functions &indio_dev->dev is used before it is initialized. This caused a kernel panic in st_sensors_power_enable() when the call to devm_regulator_bulk_get_enable() fails and then calls dev_err_probe() with the uninitialized device.  This seems to only cause a panic with dev_err_probe(), dev_err(), dev_warn() and dev_info() don't seem to cause a panic, but are fixed as well.  The issue is reported and traced here: [1]",
      "cve": "CVE-2025-38531",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38531",
          "value": "CVE-2025-38531",
          "url": "https://scout.docker.com/v/CVE-2025-38531?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38531?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "17b90d1640b43f423d324c1d83b54edb415e3c0f51b5b7144e954e94171b8956",
      "category": "container_scanning",
      "message": "CVE-2025-38544 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rxrpc: Fix bug due to prealloc collision  When userspace is using AF_RXRPC to provide a server, it has to preallocate incoming calls and assign to them call IDs that will be used to thread related recvmsg() and sendmsg() together.  The preallocated call IDs will automatically be attached to calls as they come in until the pool is empty.  To the kernel, the call IDs are just arbitrary numbers, but userspace can use the call ID to hold a pointer to prepared structs.  In any case, the user isn't permitted to create two calls with the same call ID (call IDs become available again when the call ends) and EBADSLT should result from sendmsg() if an attempt is made to preallocate a call with an in-use call ID.  However, the cleanup in the error handling will trigger both assertions in rxrpc_cleanup_call() because the call isn't marked complete and isn't marked as having been released.  Fix this by setting the call state in rxrpc_service_prealloc_one() and then marking it as being released before calling the cleanup function.",
      "cve": "CVE-2025-38544",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38544",
          "value": "CVE-2025-38544",
          "url": "https://scout.docker.com/v/CVE-2025-38544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1184adfb137e1a0ab4d7ce2de491c01963c3ee4f8b4b5658ef264dd6d3c7db81",
      "category": "container_scanning",
      "message": "CVE-2025-38546 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  atm: clip: Fix memory leak of struct clip_vcc.  ioctl(ATMARP_MKIP) allocates struct clip_vcc and set it to vcc->user_back.  The code assumes that vcc_destroy_socket() passes NULL skb to vcc->push() when the socket is close()d, and then clip_push() frees clip_vcc.  However, ioctl(ATMARPD_CTRL) sets NULL to vcc->push() in atm_init_atmarp(), resulting in memory leak.  Let's serialise two ioctl() by lock_sock() and check vcc->push() in atm_init_atmarp() to prevent memleak.",
      "cve": "CVE-2025-38546",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38546",
          "value": "CVE-2025-38546",
          "url": "https://scout.docker.com/v/CVE-2025-38546?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38546?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b2e6112b9e95c055d7860425ec658545379e7c29e248d71669c2921d78396e2d",
      "category": "container_scanning",
      "message": "CVE-2025-38552 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mptcp: plug races between subflow fail and subflow creation  We have races similar to the one addressed by the previous patch between subflow failing and additional subflow creation. They are just harder to trigger.  The solution is similar. Use a separate flag to track the condition 'socket state prevent any additional subflow creation' protected by the fallback lock.  The socket fallback makes such flag true, and also receiving or sending an MP_FAIL option.  The field 'allow_infinite_fallback' is now always touched under the relevant lock, we can drop the ONCE annotation on write.",
      "cve": "CVE-2025-38552",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38552",
          "value": "CVE-2025-38552",
          "url": "https://scout.docker.com/v/CVE-2025-38552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2a00d6ab81bbda068a9debca91089131f6b6444e636031d2e8e076906611eda1",
      "category": "container_scanning",
      "message": "CVE-2025-38556 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: core: Harden s32ton() against conversion to 0 bits  Testing by the syzbot fuzzer showed that the HID core gets a shift-out-of-bounds exception when it tries to convert a 32-bit quantity to a 0-bit quantity.  Ideally this should never occur, but there are buggy devices and some might have a report field with size set to zero; we shouldn't reject the report or the device just because of that.  Instead, harden the s32ton() routine so that it returns a reasonable result instead of crashing when it is called with the number of bits set to 0 -- the same as what snto32() does.",
      "cve": "CVE-2025-38556",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38556",
          "value": "CVE-2025-38556",
          "url": "https://scout.docker.com/v/CVE-2025-38556?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38556?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c80c64d3ad72d22e40060e43075d69235ecd74c2024ee030be15000c3d705ec9",
      "category": "container_scanning",
      "message": "CVE-2025-38560 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/sev: Evict cache lines during SNP memory validation  An SNP cache coherency vulnerability requires a cache line eviction mitigation when validating memory after a page state change to private. The specific mitigation is to touch the first and last byte of each 4K page that is being validated. There is no need to perform the mitigation when performing a page state change to shared and rescinding validation.  CPUID bit Fn8000001F_EBX[31] defines the COHERENCY_SFW_NO CPUID bit that, when set, indicates that the software mitigation for this vulnerability is not needed.  Implement the mitigation and invoke it when validating memory (making it private) and the COHERENCY_SFW_NO bit is not set, indicating the SNP guest is vulnerable.",
      "cve": "CVE-2025-38560",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38560",
          "value": "CVE-2025-38560",
          "url": "https://scout.docker.com/v/CVE-2025-38560?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38560?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "93901aa2d607909569e817428a56e23900370eb7cd5b4e145d3cabb4f3ae11bf",
      "category": "container_scanning",
      "message": "CVE-2025-38561 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix Preauh_HashValue race condition  If client send multiple session setup requests to ksmbd, Preauh_HashValue race condition could happen. There is no need to free sess->Preauh_HashValue at session setup phase. It can be freed together with session at connection termination phase.",
      "cve": "CVE-2025-38561",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38561",
          "value": "CVE-2025-38561",
          "url": "https://scout.docker.com/v/CVE-2025-38561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38561?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9e6b74b6e8b594ccf249407e5dba2184c012581a92081b21e2fd0a36b31bdce",
      "category": "container_scanning",
      "message": "CVE-2025-38562 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix null pointer dereference error in generate_encryptionkey  If client send two session setups with krb5 authenticate to ksmbd, null pointer dereference error in generate_encryptionkey could happen. sess->Preauth_HashValue is set to NULL if session is valid. So this patch skip generate encryption key if session is valid.",
      "cve": "CVE-2025-38562",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38562",
          "value": "CVE-2025-38562",
          "url": "https://scout.docker.com/v/CVE-2025-38562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "46b0891f53f1a6166fe0114ffb31020767eacc975d895698c95e1acbb3508943",
      "category": "container_scanning",
      "message": "CVE-2025-38574 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  pptp: ensure minimal skb length in pptp_xmit()  Commit aabc6596ffb3 (\"net: ppp: Add bound checking for skb data on ppp_sync_txmung\") fixed ppp_sync_txmunge()  We need a similar fix in pptp_xmit(), otherwise we might read uninit data as reported by syzbot.  BUG: KMSAN: uninit-value in pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193 pptp_xmit+0xc34/0x2720 drivers/net/ppp/pptp.c:193 ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2290 [inline] ppp_input+0x1d6/0xe60 drivers/net/ppp/ppp_generic.c:2314 pppoe_rcv_core+0x1e8/0x760 drivers/net/ppp/pppoe.c:379 sk_backlog_rcv+0x142/0x420 include/net/sock.h:1148 __release_sock+0x1d3/0x330 net/core/sock.c:3213 release_sock+0x6b/0x270 net/core/sock.c:3767 pppoe_sendmsg+0x15d/0xcb0 drivers/net/ppp/pppoe.c:904 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x330/0x3d0 net/socket.c:727 ____sys_sendmsg+0x893/0xd80 net/socket.c:2566 ___sys_sendmsg+0x271/0x3b0 net/socket.c:2620 __sys_sendmmsg+0x2d9/0x7c0 net/socket.c:2709",
      "cve": "CVE-2025-38574",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38574",
          "value": "CVE-2025-38574",
          "url": "https://scout.docker.com/v/CVE-2025-38574?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38574?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "671dbb12e431d9003b433e2f3ba4c90ac68e4b9eff9209f189997f7a56615a85",
      "category": "container_scanning",
      "message": "CVE-2025-38590 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Remove skb secpath if xfrm state is not found  Hardware returns a unique identifier for a decrypted packet's xfrm state, this state is looked up in an xarray. However, the state might have been freed by the time of this lookup.  Currently, if the state is not found, only a counter is incremented. The secpath (sp) extension on the skb is not removed, resulting in sp->len becoming 0.  Subsequently, functions like __xfrm_policy_check() attempt to access fields such as xfrm_input_state(skb)->xso.type (which dereferences sp->xvec[sp->len - 1]) without first validating sp->len. This leads to a crash when dereferencing an invalid state pointer.  This patch prevents the crash by explicitly removing the secpath extension from the skb if the xfrm state is not found after hardware decryption. This ensures downstream functions do not operate on a zero-length secpath.  BUG: unable to handle page fault for address: ffffffff000002c8 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 282e067 P4D 282e067 PUD 0 Oops: Oops: 0000 [#1] SMP CPU: 12 UID: 0 PID: 0 Comm: swapper/12 Not tainted 6.15.0-rc7_for_upstream_min_debug_2025_05_27_22_44 #1 NONE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:__xfrm_policy_check+0x61a/0xa30 Code: b6 77 7f 83 e6 02 74 14 4d 8b af d8 00 00 00 41 0f b6 45 05 c1 e0 03 48 98 49 01 c5 41 8b 45 00 83 e8 01 48 98 49 8b 44 c5 10 <0f> b6 80 c8 02 00 00 83 e0 0c 3c 04 0f 84 0c 02 00 00 31 ff 80 fa RSP: 0018:ffff88885fb04918 EFLAGS: 00010297 RAX: ffffffff00000000 RBX: 0000000000000002 RCX: 0000000000000000 RDX: 0000000000000002 RSI: 0000000000000002 RDI: 0000000000000000 RBP: ffffffff8311af80 R08: 0000000000000020 R09: 00000000c2eda353 R10: ffff88812be2bbc8 R11: 000000001faab533 R12: ffff88885fb049c8 R13: ffff88812be2bbc8 R14: 0000000000000000 R15: ffff88811896ae00 FS:  0000000000000000(0000) GS:ffff8888dca82000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffff000002c8 CR3: 0000000243050002 CR4: 0000000000372eb0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> ? try_to_wake_up+0x108/0x4c0 ? udp4_lib_lookup2+0xbe/0x150 ? udp_lib_lport_inuse+0x100/0x100 ? __udp4_lib_lookup+0x2b0/0x410 __xfrm_policy_check2.constprop.0+0x11e/0x130 udp_queue_rcv_one_skb+0x1d/0x530 udp_unicast_rcv_skb+0x76/0x90 __udp4_lib_rcv+0xa64/0xe90 ip_protocol_deliver_rcu+0x20/0x130 ip_local_deliver_finish+0x75/0xa0 ip_local_deliver+0xc1/0xd0 ? ip_protocol_deliver_rcu+0x130/0x130 ip_sublist_rcv+0x1f9/0x240 ? ip_rcv_finish_core+0x430/0x430 ip_list_rcv+0xfc/0x130 __netif_receive_skb_list_core+0x181/0x1e0 netif_receive_skb_list_internal+0x200/0x360 ? mlx5e_build_rx_skb+0x1bc/0xda0 [mlx5_core] gro_receive_skb+0xfd/0x210 mlx5e_handle_rx_cqe_mpwrq+0x141/0x280 [mlx5_core] mlx5e_poll_rx_cq+0xcc/0x8e0 [mlx5_core] ? mlx5e_handle_rx_dim+0x91/0xd0 [mlx5_core] mlx5e_napi_poll+0x114/0xab0 [mlx5_core] __napi_poll+0x25/0x170 net_rx_action+0x32d/0x3a0 ? mlx5_eq_comp_int+0x8d/0x280 [mlx5_core] ? notifier_call_chain+0x33/0xa0 handle_softirqs+0xda/0x250 irq_exit_rcu+0x6d/0xc0 common_interrupt+0x81/0xa0 </IRQ>",
      "cve": "CVE-2025-38590",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38590",
          "value": "CVE-2025-38590",
          "url": "https://scout.docker.com/v/CVE-2025-38590?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38590?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "703350f35282137e1e48295a644c0ac1cfcc91bc17ce44ca3fdfe72f7220b50c",
      "category": "container_scanning",
      "message": "CVE-2025-38591 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Reject narrower access to pointer ctx fields  The following BPF program, simplified from a syzkaller repro, causes a kernel warning:  r0 = *(u8 *)(r1 + 169); exit;  With pointer field sk being at offset 168 in __sk_buff. This access is detected as a narrower read in bpf_skb_is_valid_access because it doesn't match offsetof(struct __sk_buff, sk). It is therefore allowed and later proceeds to bpf_convert_ctx_access. Note that for the \"is_narrower_load\" case in the convert_ctx_accesses(), the insn->off is aligned, so the cnt may not be 0 because it matches the offsetof(struct __sk_buff, sk) in the bpf_convert_ctx_access. However, the target_size stays 0 and the verifier errors with a kernel warning:  verifier bug: error during ctx access conversion(1)  This patch fixes that to return a proper \"invalid bpf_context access off=X size=Y\" error on the load instruction.  The same issue affects multiple other fields in context structures that allow narrow access. Some other non-affected fields (for sk_msg, sk_lookup, and sockopt) were also changed to use bpf_ctx_range_ptr for consistency.  Note this syzkaller crash was reported in the \"Closes\" link below, which used to be about a different bug, fixed in commit fce7bd8e385a (\"bpf/verifier: Handle BPF_LOAD_ACQ instructions in insn_def_regno()\"). Because syzbot somehow confused the two bugs, the new crash and repro didn't get reported to the mailing list.",
      "cve": "CVE-2025-38591",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38591",
          "value": "CVE-2025-38591",
          "url": "https://scout.docker.com/v/CVE-2025-38591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "69f98f28705be91fa88fc6402eac823095d8bf0574b1f2e1ef5c581e9010342e",
      "category": "container_scanning",
      "message": "CVE-2025-38595 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xen: fix UAF in dmabuf_exp_from_pages()  [dma_buf_fd() fixes; no preferences regarding the tree it goes through - up to xen folks]  As soon as we'd inserted a file reference into descriptor table, another thread could close it.  That's fine for the case when all we are doing is returning that descriptor to userland (it's a race, but it's a userland race and there's nothing the kernel can do about it).  However, if we follow fd_install() with any kind of access to objects that would be destroyed on close (be it the struct file itself or anything destroyed by its ->release()), we have a UAF.  dma_buf_fd() is a combination of reserving a descriptor and fd_install(). gntdev dmabuf_exp_from_pages() calls it and then proceeds to access the objects destroyed on close - starting with gntdev_dmabuf itself.  Fix that by doing reserving descriptor before anything else and do fd_install() only when everything had been set up.",
      "cve": "CVE-2025-38595",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38595",
          "value": "CVE-2025-38595",
          "url": "https://scout.docker.com/v/CVE-2025-38595?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38595?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a27f42a5d8d1ece61d251c8518613ae8c9a3571040b043fdb77d9d8ba0043c21",
      "category": "container_scanning",
      "message": "CVE-2025-38615 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/ntfs3: cancle set bad inode after removing name fails  The reproducer uses a file0 on a ntfs3 file system with a corrupted i_link. When renaming, the file0's inode is marked as a bad inode because the file name cannot be deleted.  The underlying bug is that make_bad_inode() is called on a live inode. In some cases it's \"icache lookup finds a normal inode, d_splice_alias() is called to attach it to dentry, while another thread decides to call make_bad_inode() on it - that would evict it from icache, but we'd already found it there earlier\". In some it's outright \"we have an inode attached to dentry - that's how we got it in the first place; let's call make_bad_inode() on it just for shits and giggles\".",
      "cve": "CVE-2025-38615",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38615",
          "value": "CVE-2025-38615",
          "url": "https://scout.docker.com/v/CVE-2025-38615?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38615?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3c73d5950e480c5fe529c64540b30274f6f88bd4187b2ff429b3699dc9741aa0",
      "category": "container_scanning",
      "message": "CVE-2025-38621 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md: make rdev_addable usable for rcu mode  Our testcase trigger panic:  BUG: kernel NULL pointer dereference, address: 00000000000000e0 ... Oops: Oops: 0000 [#1] SMP NOPTI CPU: 2 UID: 0 PID: 85 Comm: kworker/2:1 Not tainted 6.16.0+ #94 PREEMPT(none) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Workqueue: md_misc md_start_sync RIP: 0010:rdev_addable+0x4d/0xf0 ... Call Trace: <TASK> md_start_sync+0x329/0x480 process_one_work+0x226/0x6d0 worker_thread+0x19e/0x340 kthread+0x10f/0x250 ret_from_fork+0x14d/0x180 ret_from_fork_asm+0x1a/0x30 </TASK> Modules linked in: raid10 CR2: 00000000000000e0 ---[ end trace 0000000000000000 ]--- RIP: 0010:rdev_addable+0x4d/0xf0  md_spares_need_change in md_start_sync will call rdev_addable which protected by rcu_read_lock/rcu_read_unlock. This rcu context will help protect rdev won't be released, but rdev->mddev will be set to NULL before we call synchronize_rcu in md_kick_rdev_from_array. Fix this by using READ_ONCE and check does rdev->mddev still alive.",
      "cve": "CVE-2025-38621",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38621",
          "value": "CVE-2025-38621",
          "url": "https://scout.docker.com/v/CVE-2025-38621?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38621?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "89afc942d78d6928808348caafd69b6b75e3da1c5f6451f01aa2c13dc4f16935",
      "category": "container_scanning",
      "message": "CVE-2025-38626 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to trigger foreground gc during f2fs_map_blocks() in lfs mode  w/ \"mode=lfs\" mount option, generic/299 will cause system panic as below:  ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2835! Call Trace: <TASK> f2fs_allocate_data_block+0x6f4/0xc50 f2fs_map_blocks+0x970/0x1550 f2fs_iomap_begin+0xb2/0x1e0 iomap_iter+0x1d6/0x430 __iomap_dio_rw+0x208/0x9a0 f2fs_file_write_iter+0x6b3/0xfa0 aio_write+0x15d/0x2e0 io_submit_one+0x55e/0xab0 __x64_sys_io_submit+0xa5/0x230 do_syscall_64+0x84/0x2f0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0010:new_curseg+0x70f/0x720  The root cause of we run out-of-space is: in f2fs_map_blocks(), f2fs may trigger foreground gc only if it allocates any physical block, it will be a little bit later when there is multiple threads writing data w/ aio/dio/bufio method in parallel, since we always use OPU in lfs mode, so f2fs_map_blocks() does block allocations aggressively.  In order to fix this issue, let's give a chance to trigger foreground gc in prior to block allocation in f2fs_map_blocks().",
      "cve": "CVE-2025-38626",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38626",
          "value": "CVE-2025-38626",
          "url": "https://scout.docker.com/v/CVE-2025-38626?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38626?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "00a8c670df5b251140fb304dab7b2122174a415f7936c2b200e5c5b2af3bf0c8",
      "category": "container_scanning",
      "message": "CVE-2025-38643 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: cfg80211: Add missing lock in cfg80211_check_and_end_cac()  Callers of wdev_chandef() must hold the wiphy mutex.  But the worker cfg80211_propagate_cac_done_wk() never takes the lock. Which triggers the warning below with the mesh_peer_connected_dfs test from hostapd and not (yet) released mac80211 code changes:  WARNING: CPU: 0 PID: 495 at net/wireless/chan.c:1552 wdev_chandef+0x60/0x165 Modules linked in: CPU: 0 UID: 0 PID: 495 Comm: kworker/u4:2 Not tainted 6.14.0-rc5-wt-g03960e6f9d47 #33 13c287eeabfe1efea01c0bcc863723ab082e17cf Workqueue: cfg80211 cfg80211_propagate_cac_done_wk Stack: 00000000 00000001 ffffff00 6093267c 00000000 6002ec30 6d577c50 60037608 00000000 67e8d108 6063717b 00000000 Call Trace: [<6002ec30>] ? _printk+0x0/0x98 [<6003c2b3>] show_stack+0x10e/0x11a [<6002ec30>] ? _printk+0x0/0x98 [<60037608>] dump_stack_lvl+0x71/0xb8 [<6063717b>] ? wdev_chandef+0x60/0x165 [<6003766d>] dump_stack+0x1e/0x20 [<6005d1b7>] __warn+0x101/0x20f [<6005d3a8>] warn_slowpath_fmt+0xe3/0x15d [<600b0c5c>] ? mark_lock.part.0+0x0/0x4ec [<60751191>] ? __this_cpu_preempt_check+0x0/0x16 [<600b11a2>] ? mark_held_locks+0x5a/0x6e [<6005d2c5>] ? warn_slowpath_fmt+0x0/0x15d [<60052e53>] ? unblock_signals+0x3a/0xe7 [<60052f2d>] ? um_set_signals+0x2d/0x43 [<60751191>] ? __this_cpu_preempt_check+0x0/0x16 [<607508b2>] ? lock_is_held_type+0x207/0x21f [<6063717b>] wdev_chandef+0x60/0x165 [<605f89b4>] regulatory_propagate_dfs_state+0x247/0x43f [<60052f00>] ? um_set_signals+0x0/0x43 [<605e6bfd>] cfg80211_propagate_cac_done_wk+0x3a/0x4a [<6007e460>] process_scheduled_works+0x3bc/0x60e [<6007d0ec>] ? move_linked_works+0x4d/0x81 [<6007d120>] ? assign_work+0x0/0xaa [<6007f81f>] worker_thread+0x220/0x2dc [<600786ef>] ? set_pf_worker+0x0/0x57 [<60087c96>] ? to_kthread+0x0/0x43 [<6008ab3c>] kthread+0x2d3/0x2e2 [<6007f5ff>] ? worker_thread+0x0/0x2dc [<6006c05b>] ? calculate_sigpending+0x0/0x56 [<6003b37d>] new_thread_handler+0x4a/0x64 irq event stamp: 614611 hardirqs last  enabled at (614621): [<00000000600bc96b>] __up_console_sem+0x82/0xaf hardirqs last disabled at (614630): [<00000000600bc92c>] __up_console_sem+0x43/0xaf softirqs last  enabled at (614268): [<00000000606c55c6>] __ieee80211_wake_queue+0x933/0x985 softirqs last disabled at (614266): [<00000000606c52d6>] __ieee80211_wake_queue+0x643/0x985",
      "cve": "CVE-2025-38643",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38643",
          "value": "CVE-2025-38643",
          "url": "https://scout.docker.com/v/CVE-2025-38643?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38643?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "af31e3dd2724d7834221fe8eadba7dc4d796541e4e2d085d529b4de1f2e3f903",
      "category": "container_scanning",
      "message": "CVE-2025-38644 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: reject TDLS operations when station is not associated  syzbot triggered a WARN in ieee80211_tdls_oper() by sending NL80211_TDLS_ENABLE_LINK immediately after NL80211_CMD_CONNECT, before association completed and without prior TDLS setup.  This left internal state like sdata->u.mgd.tdls_peer uninitialized, leading to a WARN_ON() in code paths that assumed it was valid.  Reject the operation early if not in station mode or not associated.",
      "cve": "CVE-2025-38644",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38644",
          "value": "CVE-2025-38644",
          "url": "https://scout.docker.com/v/CVE-2025-38644?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38644?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f024bcfb927dfa80eaafe77e47731cff2dcbe5860d125abc81e90bffd701c022",
      "category": "container_scanning",
      "message": "CVE-2025-38659 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gfs2: No more self recovery  When a node withdraws and it turns out that it is the only node that has the filesystem mounted, gfs2 currently tries to replay the local journal to bring the filesystem back into a consistent state.  Not only is that a very bad idea, it has also never worked because gfs2_recover_func() will refuse to do anything during a withdraw.  However, before even getting to this point, gfs2_recover_func() dereferences sdp->sd_jdesc->jd_inode.  This was a use-after-free before commit 04133b607a78 (\"gfs2: Prevent double iput for journal on error\") and is a NULL pointer dereference since then.  Simply get rid of self recovery to fix that.",
      "cve": "CVE-2025-38659",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38659",
          "value": "CVE-2025-38659",
          "url": "https://scout.docker.com/v/CVE-2025-38659?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38659?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3d810cb39ed79947446cea9cc7a221b5d6051d7901f76ddac2a917ec1e2963b2",
      "category": "container_scanning",
      "message": "CVE-2025-38665 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  can: netlink: can_changelink(): fix NULL pointer deref of struct can_priv::do_set_mode  Andrei Lalaev reported a NULL pointer deref when a CAN device is restarted from Bus Off and the driver does not implement the struct can_priv::do_set_mode callback.  There are 2 code path that call struct can_priv::do_set_mode: - directly by a manual restart from the user space, via can_changelink() - delayed automatic restart after bus off (deactivated by default)  To prevent the NULL pointer deference, refuse a manual restart or configure the automatic restart delay in can_changelink() and report the error via extack to user space.  As an additional safety measure let can_restart() return an error if can_priv::do_set_mode is not set instead of dereferencing it unchecked.",
      "cve": "CVE-2025-38665",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38665",
          "value": "CVE-2025-38665",
          "url": "https://scout.docker.com/v/CVE-2025-38665?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38665?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "97f3e7a9670389eddf873082675f8dd8f78f286d6d2920ba7d753a29a921771b",
      "category": "container_scanning",
      "message": "CVE-2025-38669 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/gem-shmem: Use dma_buf from GEM object instance\"  This reverts commit 1a148af06000e545e714fe3210af3d77ff903c11.  The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref.  Workarounds in commit 5307dce878d4 (\"drm/gem: Acquire references on GEM handles for framebuffers\") and commit f6bfc9afc751 (\"drm/framebuffer: Acquire internal references on GEM handles\") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated.  Hence, this revert to going back to using .import_attach->dmabuf.  v3: - cc stable",
      "cve": "CVE-2025-38669",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38669",
          "value": "CVE-2025-38669",
          "url": "https://scout.docker.com/v/CVE-2025-38669?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38669?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5aab02ec725839b5884bb9f2b15ffc94a9e4e442a68045bf638010187900a471",
      "category": "container_scanning",
      "message": "CVE-2025-38672 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/gem-dma: Use dma_buf from GEM object instance\"  This reverts commit e8afa1557f4f963c9a511bd2c6074a941c308685.  The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref.  Workarounds in commit 5307dce878d4 (\"drm/gem: Acquire references on GEM handles for framebuffers\") and commit f6bfc9afc751 (\"drm/framebuffer: Acquire internal references on GEM handles\") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated.  Hence, this revert to going back to using .import_attach->dmabuf.  v3: - cc stable",
      "cve": "CVE-2025-38672",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38672",
          "value": "CVE-2025-38672",
          "url": "https://scout.docker.com/v/CVE-2025-38672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "abb9471e640626961a448a56b7a57374c1a6d17f8bf27e002a359cb1810d6a9f",
      "category": "container_scanning",
      "message": "CVE-2025-38673 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/gem-framebuffer: Use dma_buf from GEM object instance\"  This reverts commit cce16fcd7446dcff7480cd9d2b6417075ed81065.  The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref.  Workarounds in commit 5307dce878d4 (\"drm/gem: Acquire references on GEM handles for framebuffers\") and commit f6bfc9afc751 (\"drm/framebuffer: Acquire internal references on GEM handles\") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated.  Hence, this revert to going back to using .import_attach->dmabuf.  v3: - cc stable",
      "cve": "CVE-2025-38673",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38673",
          "value": "CVE-2025-38673",
          "url": "https://scout.docker.com/v/CVE-2025-38673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db2ee08051bddc474ac626d54e683ed5c48bf533f5790f27d7fd26dc3d675570",
      "category": "container_scanning",
      "message": "CVE-2025-38674 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/prime: Use dma_buf from GEM object instance\"  This reverts commit f83a9b8c7fd0557b0c50784bfdc1bbe9140c9bf8.  The dma_buf field in struct drm_gem_object is not stable over the object instance's lifetime. The field becomes NULL when user space releases the final GEM handle on the buffer object. This resulted in a NULL-pointer deref.  Workarounds in commit 5307dce878d4 (\"drm/gem: Acquire references on GEM handles for framebuffers\") and commit f6bfc9afc751 (\"drm/framebuffer: Acquire internal references on GEM handles\") only solved the problem partially. They especially don't work for buffer objects without a DRM framebuffer associated.  Hence, this revert to going back to using .import_attach->dmabuf.  v3: - cc stable",
      "cve": "CVE-2025-38674",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38674",
          "value": "CVE-2025-38674",
          "url": "https://scout.docker.com/v/CVE-2025-38674?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38674?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "084c878234aa75c7485f0bdb263a7836a6de4a1dfc9a77222ef16860b53a0692",
      "category": "container_scanning",
      "message": "CVE-2025-38679 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: venus: Fix OOB read due to missing payload bound check  Currently, The event_seq_changed() handler processes a variable number of properties sent by the firmware. The number of properties is indicated by the firmware and used to iterate over the payload. However, the payload size is not being validated against the actual message length.  This can lead to out-of-bounds memory access if the firmware provides a property count that exceeds the data available in the payload. Such a condition can result in kernel crashes or potential information leaks if memory beyond the buffer is accessed.  Fix this by properly validating the remaining size of the payload before each property access and updating bounds accordingly as properties are parsed.  This ensures that property parsing is safely bounded within the received message buffer and protects against malformed or malicious firmware behavior.",
      "cve": "CVE-2025-38679",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38679",
          "value": "CVE-2025-38679",
          "url": "https://scout.docker.com/v/CVE-2025-38679?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38679?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2f9cca8a4123c379b16572e8a7aba972bd4ffe8bfc43d3cd2d6fefdc4bb52945",
      "category": "container_scanning",
      "message": "CVE-2025-38689 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/fpu: Fix NULL dereference in avx512_status()  Problem ------- With CONFIG_X86_DEBUG_FPU enabled, reading /proc/[kthread]/arch_status causes a warning and a NULL pointer dereference.  This is because the AVX-512 timestamp code uses x86_task_fpu() but doesn't check it for NULL. CONFIG_X86_DEBUG_FPU addles that function for kernel threads (PF_KTHREAD specifically), making it return NULL.  The point of the warning was to ensure that kernel threads only access task->fpu after going through kernel_fpu_begin()/_end(). Note: all kernel tasks exposed in /proc have a valid task->fpu.  Solution -------- One option is to silence the warning and check for NULL from x86_task_fpu(). However, that warning is fairly fresh and seems like a defense against misuse of the FPU state in kernel threads.  Instead, stop outputting AVX-512_elapsed_ms for kernel threads altogether. The data was garbage anyway because avx512_timestamp is only updated for user threads, not kernel threads.  If anyone ever wants to track kernel thread AVX-512 use, they can come back later and do it properly, separate from this bug fix.  [ dhansen: mostly rewrite changelog ]",
      "cve": "CVE-2025-38689",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38689",
          "value": "CVE-2025-38689",
          "url": "https://scout.docker.com/v/CVE-2025-38689?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38689?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ae764f0a8bfa47b1fd5f21f8b19211bc76873804b4cebb68bb92079023eadd5a",
      "category": "container_scanning",
      "message": "CVE-2025-38692 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  exfat: add cluster chain loop check for dir  An infinite loop may occur if the following conditions occur due to file system corruption.  (1) Condition for exfat_count_dir_entries() to loop infinitely. - The cluster chain includes a loop. - There is no UNUSED entry in the cluster chain.  (2) Condition for exfat_create_upcase_table() to loop infinitely. - The cluster chain of the root directory includes a loop. - There are no UNUSED entry and up-case table entry in the cluster chain of the root directory.  (3) Condition for exfat_load_bitmap() to loop infinitely. - The cluster chain of the root directory includes a loop. - There are no UNUSED entry and bitmap entry in the cluster chain of the root directory.  (4) Condition for exfat_find_dir_entry() to loop infinitely. - The cluster chain includes a loop. - The unused directory entries were exhausted by some operation.  (5) Condition for exfat_check_dir_empty() to loop infinitely. - The cluster chain includes a loop. - The unused directory entries were exhausted by some operation. - All files and sub-directories under the directory are deleted.  This commit adds checks to break the above infinite loop.",
      "cve": "CVE-2025-38692",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38692",
          "value": "CVE-2025-38692",
          "url": "https://scout.docker.com/v/CVE-2025-38692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dd3c622d7d838a87b0ea15dbce505749a2cd2da0170f65f62ac9db1582e75500",
      "category": "container_scanning",
      "message": "CVE-2025-38702 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbdev: fix potential buffer overflow in do_register_framebuffer()  The current implementation may lead to buffer overflow when: 1.  Unregistration creates NULL gaps in registered_fb[] 2.  All array slots become occupied despite num_registered_fb < FB_MAX 3.  The registration loop exceeds array bounds  Add boundary check to prevent registered_fb[FB_MAX] access.",
      "cve": "CVE-2025-38702",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38702",
          "value": "CVE-2025-38702",
          "url": "https://scout.docker.com/v/CVE-2025-38702?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38702?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2013a5faf42317d772aeb800909047cb14faca3c537ac2c4d8bd2463928ad4ee",
      "category": "container_scanning",
      "message": "CVE-2025-38703 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe: Make dma-fences compliant with the safe access rules  Xe can free some of the data pointed to by the dma-fences it exports. Most notably the timeline name can get freed if userspace closes the associated submit queue. At the same time the fence could have been exported to a third party (for example a sync_fence fd) which will then cause an use- after-free on subsequent access.  To make this safe we need to make the driver compliant with the newly documented dma-fence rules. Driver has to ensure a RCU grace period between signalling a fence and freeing any data pointed to by said fence.  For the timeline name we simply make the queue be freed via kfree_rcu and for the shared lock associated with multiple queues we add a RCU grace period before freeing the per GT structure holding the lock.",
      "cve": "CVE-2025-38703",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38703",
          "value": "CVE-2025-38703",
          "url": "https://scout.docker.com/v/CVE-2025-38703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2cc34d7ddf293faf48ed95d5621f243c153976fa3c4f313f052d132b05745672",
      "category": "container_scanning",
      "message": "CVE-2025-38704 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcu/nocb: Fix possible invalid rdp's->nocb_cb_kthread pointer access  In the preparation stage of CPU online, if the corresponding the rdp's->nocb_cb_kthread does not exist, will be created, there is a situation where the rdp's rcuop kthreads creation fails, and then de-offload this CPU's rdp, does not assign this CPU's rdp->nocb_cb_kthread pointer, but this rdp's->nocb_gp_rdp and rdp's->rdp_gp->nocb_gp_kthread is still valid.  This will cause the subsequent re-offload operation of this offline CPU, which will pass the conditional check and the kthread_unpark() will access invalid rdp's->nocb_cb_kthread pointer.  This commit therefore use rdp's->nocb_gp_kthread instead of rdp_gp's->nocb_gp_kthread for safety check.",
      "cve": "CVE-2025-38704",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38704",
          "value": "CVE-2025-38704",
          "url": "https://scout.docker.com/v/CVE-2025-38704?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38704?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1dd8cbfaacfafc4d89ca780f109ec109cc77e2878db4d5a5794b791892722c37",
      "category": "container_scanning",
      "message": "CVE-2025-38705 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: fix null pointer access  Writing a string without delimiters (' ', '\\n', '\\0') to the under gpu_od/fan_ctrl sysfs or pp_power_profile_mode for the CUSTOM profile will result in a null pointer dereference.",
      "cve": "CVE-2025-38705",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38705",
          "value": "CVE-2025-38705",
          "url": "https://scout.docker.com/v/CVE-2025-38705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "627835d3bf3b67dc0450b6bc0a97f5bc464acf6b88926e98ae262b4085baf483",
      "category": "container_scanning",
      "message": "CVE-2025-38709 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  loop: Avoid updating block size under exclusive owner  Syzbot came up with a reproducer where a loop device block size is changed underneath a mounted filesystem. This causes a mismatch between the block device block size and the block size stored in the superblock causing confusion in various places such as fs/buffer.c. The particular issue triggered by syzbot was a warning in __getblk_slow() due to requested buffer size not matching block device block size.  Fix the problem by getting exclusive hold of the loop device to change its block size. This fails if somebody (such as filesystem) has already an exclusive ownership of the block device and thus prevents modifying the loop device under some exclusive owner which doesn't expect it.",
      "cve": "CVE-2025-38709",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38709",
          "value": "CVE-2025-38709",
          "url": "https://scout.docker.com/v/CVE-2025-38709?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38709?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "505b64069de0bda014a63d4366021e2f32db13e2eb10c3f30f06feb655d81140",
      "category": "container_scanning",
      "message": "CVE-2025-38710 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gfs2: Validate i_depth for exhash directories  A fuzzer test introduced corruption that ends up with a depth of 0 in dir_e_read(), causing an undefined shift by 32 at:  index = hash >> (32 - dip->i_depth);  As calculated in an open-coded way in dir_make_exhash(), the minimum depth for an exhash directory is ilog2(sdp->sd_hash_ptrs) and 0 is invalid as sdp->sd_hash_ptrs is fixed as sdp->bsize / 16 at mount time.  So we can avoid the undefined behaviour by checking for depth values lower than the minimum in gfs2_dinode_in(). Values greater than the maximum are already being checked for there.  Also switch the calculation in dir_make_exhash() to use ilog2() to clarify how the depth is calculated.  Tested with the syzkaller repro.c and xfstests '-g quick'.",
      "cve": "CVE-2025-38710",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38710",
          "value": "CVE-2025-38710",
          "url": "https://scout.docker.com/v/CVE-2025-38710?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38710?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b8278c8bf4921a0e39c9c057e3f29f5ca936bcd8152ddc9107b0047d0e75b690",
      "category": "container_scanning",
      "message": "CVE-2025-38716 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hfs: fix general protection fault in hfs_find_init()  The hfs_find_init() method can trigger the crash if tree pointer is NULL:  [   45.746290][ T9787] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000008: 0000 [#1] SMP KAI [   45.747287][ T9787] KASAN: null-ptr-deref in range [0x0000000000000040-0x0000000000000047] [   45.748716][ T9787] CPU: 2 UID: 0 PID: 9787 Comm: repro Not tainted 6.16.0-rc3 #10 PREEMPT(full) [   45.750250][ T9787] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [   45.751983][ T9787] RIP: 0010:hfs_find_init+0x86/0x230 [   45.752834][ T9787] Code: c1 ea 03 80 3c 02 00 0f 85 9a 01 00 00 4c 8d 6b 40 48 c7 45 18 00 00 00 00 48 b8 00 00 00 00 00 fc [   45.755574][ T9787] RSP: 0018:ffffc90015157668 EFLAGS: 00010202 [   45.756432][ T9787] RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff819a4d09 [   45.757457][ T9787] RDX: 0000000000000008 RSI: ffffffff819acd3a RDI: ffffc900151576e8 [   45.758282][ T9787] RBP: ffffc900151576d0 R08: 0000000000000005 R09: 0000000000000000 [   45.758943][ T9787] R10: 0000000080000000 R11: 0000000000000001 R12: 0000000000000004 [   45.759619][ T9787] R13: 0000000000000040 R14: ffff88802c50814a R15: 0000000000000000 [   45.760293][ T9787] FS:  00007ffb72734540(0000) GS:ffff8880cec64000(0000) knlGS:0000000000000000 [   45.761050][ T9787] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [   45.761606][ T9787] CR2: 00007f9bd8225000 CR3: 000000010979a000 CR4: 00000000000006f0 [   45.762286][ T9787] Call Trace: [   45.762570][ T9787]  <TASK> [   45.762824][ T9787]  hfs_ext_read_extent+0x190/0x9d0 [   45.763269][ T9787]  ? submit_bio_noacct_nocheck+0x2dd/0xce0 [   45.763766][ T9787]  ? __pfx_hfs_ext_read_extent+0x10/0x10 [   45.764250][ T9787]  hfs_get_block+0x55f/0x830 [   45.764646][ T9787]  block_read_full_folio+0x36d/0x850 [   45.765105][ T9787]  ? __pfx_hfs_get_block+0x10/0x10 [   45.765541][ T9787]  ? const_folio_flags+0x5b/0x100 [   45.765972][ T9787]  ? __pfx_hfs_read_folio+0x10/0x10 [   45.766415][ T9787]  filemap_read_folio+0xbe/0x290 [   45.766840][ T9787]  ? __pfx_filemap_read_folio+0x10/0x10 [   45.767325][ T9787]  ? __filemap_get_folio+0x32b/0xbf0 [   45.767780][ T9787]  do_read_cache_folio+0x263/0x5c0 [   45.768223][ T9787]  ? __pfx_hfs_read_folio+0x10/0x10 [   45.768666][ T9787]  read_cache_page+0x5b/0x160 [   45.769070][ T9787]  hfs_btree_open+0x491/0x1740 [   45.769481][ T9787]  hfs_mdb_get+0x15e2/0x1fb0 [   45.769877][ T9787]  ? __pfx_hfs_mdb_get+0x10/0x10 [   45.770316][ T9787]  ? find_held_lock+0x2b/0x80 [   45.770731][ T9787]  ? lockdep_init_map_type+0x5c/0x280 [   45.771200][ T9787]  ? lockdep_init_map_type+0x5c/0x280 [   45.771674][ T9787]  hfs_fill_super+0x38e/0x720 [   45.772092][ T9787]  ? __pfx_hfs_fill_super+0x10/0x10 [   45.772549][ T9787]  ? snprintf+0xbe/0x100 [   45.772931][ T9787]  ? __pfx_snprintf+0x10/0x10 [   45.773350][ T9787]  ? do_raw_spin_lock+0x129/0x2b0 [   45.773796][ T9787]  ? find_held_lock+0x2b/0x80 [   45.774215][ T9787]  ? set_blocksize+0x40a/0x510 [   45.774636][ T9787]  ? sb_set_blocksize+0x176/0x1d0 [   45.775087][ T9787]  ? setup_bdev_super+0x369/0x730 [   45.775533][ T9787]  get_tree_bdev_flags+0x384/0x620 [   45.775985][ T9787]  ? __pfx_hfs_fill_super+0x10/0x10 [   45.776453][ T9787]  ? __pfx_get_tree_bdev_flags+0x10/0x10 [   45.776950][ T9787]  ? bpf_lsm_capable+0x9/0x10 [   45.777365][ T9787]  ? security_capable+0x80/0x260 [   45.777803][ T9787]  vfs_get_tree+0x8e/0x340 [   45.778203][ T9787]  path_mount+0x13de/0x2010 [   45.778604][ T9787]  ? kmem_cache_free+0x2b0/0x4c0 [   45.779052][ T9787]  ? __pfx_path_mount+0x10/0x10 [   45.779480][ T9787]  ? getname_flags.part.0+0x1c5/0x550 [   45.779954][ T9787]  ? putname+0x154/0x1a0 [   45.780335][ T9787]  __x64_sys_mount+0x27b/0x300 [   45.780758][ T9787]  ? __pfx___x64_sys_mount+0x10/0x10 [   45.781232][ T9787] ---truncated---",
      "cve": "CVE-2025-38716",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38716",
          "value": "CVE-2025-38716",
          "url": "https://scout.docker.com/v/CVE-2025-38716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "76c3ea7603e32fdfa462b54355b9589dd0c355f387f441abefabffd56866eab4",
      "category": "container_scanning",
      "message": "CVE-2025-38717 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: kcm: Fix race condition in kcm_unattach()  syzbot found a race condition when kcm_unattach(psock) and kcm_release(kcm) are executed at the same time.  kcm_unattach() is missing a check of the flag kcm->tx_stopped before calling queue_work().  If the kcm has a reserved psock, kcm_unattach() might get executed between cancel_work_sync() and unreserve_psock() in kcm_release(), requeuing kcm->tx_work right before kcm gets freed in kcm_done().  Remove kcm->tx_stopped and replace it by the less error-prone disable_work_sync().",
      "cve": "CVE-2025-38717",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38717",
          "value": "CVE-2025-38717",
          "url": "https://scout.docker.com/v/CVE-2025-38717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9625c44f92d6768b2c51b2ab63edbc23d452d2d6a2dbe3f540356a59aad5628",
      "category": "container_scanning",
      "message": "CVE-2025-38728 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb3: fix for slab out of bounds on mount to ksmbd  With KASAN enabled, it is possible to get a slab out of bounds during mount to ksmbd due to missing check in parse_server_interfaces() (see below):  BUG: KASAN: slab-out-of-bounds in parse_server_interfaces+0x14ee/0x1880 [cifs] Read of size 4 at addr ffff8881433dba98 by task mount/9827  CPU: 5 UID: 0 PID: 9827 Comm: mount Tainted: G OE       6.16.0-rc2-kasan #2 PREEMPT(voluntary) Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: Dell Inc. Precision Tower 3620/0MWYPT, BIOS 2.13.1 06/14/2019 Call Trace: <TASK> dump_stack_lvl+0x9f/0xf0 print_report+0xd1/0x670 __virt_addr_valid+0x22c/0x430 ? parse_server_interfaces+0x14ee/0x1880 [cifs] ? kasan_complete_mode_report_info+0x2a/0x1f0 ? parse_server_interfaces+0x14ee/0x1880 [cifs] kasan_report+0xd6/0x110 parse_server_interfaces+0x14ee/0x1880 [cifs] __asan_report_load_n_noabort+0x13/0x20 parse_server_interfaces+0x14ee/0x1880 [cifs] ? __pfx_parse_server_interfaces+0x10/0x10 [cifs] ? trace_hardirqs_on+0x51/0x60 SMB3_request_interfaces+0x1ad/0x3f0 [cifs] ? __pfx_SMB3_request_interfaces+0x10/0x10 [cifs] ? SMB2_tcon+0x23c/0x15d0 [cifs] smb3_qfs_tcon+0x173/0x2b0 [cifs] ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs] ? cifs_get_tcon+0x105d/0x2120 [cifs] ? do_raw_spin_unlock+0x5d/0x200 ? cifs_get_tcon+0x105d/0x2120 [cifs] ? __pfx_smb3_qfs_tcon+0x10/0x10 [cifs] cifs_mount_get_tcon+0x369/0xb90 [cifs] ? dfs_cache_find+0xe7/0x150 [cifs] dfs_mount_share+0x985/0x2970 [cifs] ? check_path.constprop.0+0x28/0x50 ? save_trace+0x54/0x370 ? __pfx_dfs_mount_share+0x10/0x10 [cifs] ? __lock_acquire+0xb82/0x2ba0 ? __kasan_check_write+0x18/0x20 cifs_mount+0xbc/0x9e0 [cifs] ? __pfx_cifs_mount+0x10/0x10 [cifs] ? do_raw_spin_unlock+0x5d/0x200 ? cifs_setup_cifs_sb+0x29d/0x810 [cifs] cifs_smb3_do_mount+0x263/0x1990 [cifs]",
      "cve": "CVE-2025-38728",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38728",
          "value": "CVE-2025-38728",
          "url": "https://scout.docker.com/v/CVE-2025-38728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "51ec008d67f5cd98848aae6f72c9396049edb6d41592fc6469136f50ae709127",
      "category": "container_scanning",
      "message": "CVE-2025-38734 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: fix UAF on smcsk after smc_listen_out()  BPF CI testing report a UAF issue:  [   16.446633] BUG: kernel NULL pointer dereference, address: 000000000000003  0 [   16.447134] #PF: supervisor read access in kernel mod  e [   16.447516] #PF: error_code(0x0000) - not-present pag  e [   16.447878] PGD 0 P4D   0 [   16.448063] Oops: Oops: 0000 [#1] PREEMPT SMP NOPT  I [   16.448409] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Tainted: G OE      6.13.0-rc3-g89e8a75fda73-dirty #4  2 [   16.449124] Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODUL  E [   16.449502] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/201  4 [   16.450201] Workqueue: smc_hs_wq smc_listen_wor  k [   16.450531] RIP: 0010:smc_listen_work+0xc02/0x159  0 [   16.452158] RSP: 0018:ffffb5ab40053d98 EFLAGS: 0001024  6 [   16.452526] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 000000000000030  0 [   16.452994] RDX: 0000000000000280 RSI: 00003513840053f0 RDI: 000000000000000  0 [   16.453492] RBP: ffffa097808e3800 R08: ffffa09782dba1e0 R09: 000000000000000  5 [   16.453987] R10: 0000000000000000 R11: 0000000000000000 R12: ffffa0978274640  0 [   16.454497] R13: 0000000000000000 R14: 0000000000000000 R15: ffffa09782d4092  0 [   16.454996] FS:  0000000000000000(0000) GS:ffffa097bbc00000(0000) knlGS:000000000000000  0 [   16.455557] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003  3 [   16.455961] CR2: 0000000000000030 CR3: 0000000102788004 CR4: 0000000000770ef  0 [   16.456459] PKRU: 5555555  4 [   16.456654] Call Trace  : [   16.456832]  <TASK  > [   16.456989]  ? __die+0x23/0x7  0 [   16.457215]  ? page_fault_oops+0x180/0x4c  0 [   16.457508]  ? __lock_acquire+0x3e6/0x249  0 [   16.457801]  ? exc_page_fault+0x68/0x20  0 [   16.458080]  ? asm_exc_page_fault+0x26/0x3  0 [   16.458389]  ? smc_listen_work+0xc02/0x159  0 [   16.458689]  ? smc_listen_work+0xc02/0x159  0 [   16.458987]  ? lock_is_held_type+0x8f/0x10  0 [   16.459284]  process_one_work+0x1ea/0x6d  0 [   16.459570]  worker_thread+0x1c3/0x38  0 [   16.459839]  ? __pfx_worker_thread+0x10/0x1  0 [   16.460144]  kthread+0xe0/0x11  0 [   16.460372]  ? __pfx_kthread+0x10/0x1  0 [   16.460640]  ret_from_fork+0x31/0x5  0 [   16.460896]  ? __pfx_kthread+0x10/0x1  0 [   16.461166]  ret_from_fork_asm+0x1a/0x3  0 [   16.461453]  </TASK  > [   16.461616] Modules linked in: bpf_testmod(OE) [last unloaded: bpf_testmod(OE)  ] [   16.462134] CR2: 000000000000003  0 [   16.462380] ---[ end trace 0000000000000000 ]--- [   16.462710] RIP: 0010:smc_listen_work+0xc02/0x1590  The direct cause of this issue is that after smc_listen_out_connected(), newclcsock->sk may be NULL since it will releases the smcsk. Therefore, if the application closes the socket immediately after accept, newclcsock->sk can be NULL. A possible execution order could be as follows:  smc_listen_work                                 | userspace ----------------------------------------------------------------- lock_sock(sk)                                   | smc_listen_out_connected()                      | | \\- smc_listen_out                             | |    | \\- release_sock                          | | |- sk->sk_data_ready()                   | | fd = accept(); | close(fd); |  \\- socket->sk = NULL; /* newclcsock->sk is NULL now */ SMC_STAT_SERV_SUCC_INC(sock_net(newclcsock->sk))  Since smc_listen_out_connected() will not fail, simply swapping the order of the code can easily fix this issue.",
      "cve": "CVE-2025-38734",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38734",
          "value": "CVE-2025-38734",
          "url": "https://scout.docker.com/v/CVE-2025-38734?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38734?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "57281e1b8429b94f19784aa0112fb0288f40ec91d15eed42c30e040f915e6a7f",
      "category": "container_scanning",
      "message": "CVE-2025-39677 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: Fix backlog accounting in qdisc_dequeue_internal  This issue applies for the following qdiscs: hhf, fq, fq_codel, and fq_pie, and occurs in their change handlers when adjusting to the new limit. The problem is the following in the values passed to the subsequent qdisc_tree_reduce_backlog call given a tbf parent:  When the tbf parent runs out of tokens, skbs of these qdiscs will be placed in gso_skb. Their peek handlers are qdisc_peek_dequeued, which accounts for both qlen and backlog. However, in the case of qdisc_dequeue_internal, ONLY qlen is accounted for when pulling from gso_skb. This means that these qdiscs are missing a qdisc_qstats_backlog_dec when dropping packets to satisfy the new limit in their change handlers.  One can observe this issue with the following (with tc patched to support a limit of 0):  export TARGET=fq tc qdisc del dev lo root tc qdisc add dev lo root handle 1: tbf rate 8bit burst 100b latency 1ms tc qdisc replace dev lo handle 3: parent 1:1 $TARGET limit 1000 echo ''; echo 'add child'; tc -s -d qdisc show dev lo ping -I lo -f -c2 -s32 -W0.001 127.0.0.1 2>&1 >/dev/null echo ''; echo 'after ping'; tc -s -d qdisc show dev lo tc qdisc change dev lo handle 3: parent 1:1 $TARGET limit 0 echo ''; echo 'after limit drop'; tc -s -d qdisc show dev lo tc qdisc replace dev lo handle 2: parent 1:1 sfq echo ''; echo 'post graft'; tc -s -d qdisc show dev lo  The second to last show command shows 0 packets but a positive number (74) of backlog bytes. The problem becomes clearer in the last show command, where qdisc_purge_queue triggers qdisc_tree_reduce_backlog with the positive backlog and causes an underflow in the tbf parent's backlog (4096 Mb instead of 0).  To fix this issue, the codepath for all clients of qdisc_dequeue_internal has been simplified: codel, pie, hhf, fq, fq_pie, and fq_codel. qdisc_dequeue_internal handles the backlog adjustments for all cases that do not directly use the dequeue handler.  The old fq_codel_change limit adjustment loop accumulated the arguments to the subsequent qdisc_tree_reduce_backlog call through the cstats field. However, this is confusing and error prone as fq_codel_dequeue could also potentially mutate this field (which qdisc_dequeue_internal calls in the non gso_skb case), so we have unified the code here with other qdiscs.",
      "cve": "CVE-2025-39677",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39677",
          "value": "CVE-2025-39677",
          "url": "https://scout.docker.com/v/CVE-2025-39677?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39677?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "23389c9d45253f870d83d20751c47962ffd147ca1169be57ba4547a9bbbeae84",
      "category": "container_scanning",
      "message": "CVE-2025-39692 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: server: split ksmbd_rdma_stop_listening() out of ksmbd_rdma_destroy()  We can't call destroy_workqueue(smb_direct_wq); before stop_sessions()!  Otherwise already existing connections try to use smb_direct_wq as a NULL pointer.",
      "cve": "CVE-2025-39692",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39692",
          "value": "CVE-2025-39692",
          "url": "https://scout.docker.com/v/CVE-2025-39692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dce31dc97deda8e1729e1a14cdf52d3893ddc5e9dfc404aadb3699b6ba12d9a4",
      "category": "container_scanning",
      "message": "CVE-2025-39705 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: fix a Null pointer dereference vulnerability  [Why] A null pointer dereference vulnerability exists in the AMD display driver's (DC module) cleanup function dc_destruct(). When display control context (dc->ctx) construction fails (due to memory allocation failure), this pointer remains NULL. During subsequent error handling when dc_destruct() is called, there's no NULL check before dereferencing the perf_trace member (dc->ctx->perf_trace), causing a kernel null pointer dereference crash.  [How] Check if dc->ctx is non-NULL before dereferencing.  (Updated commit text and removed unnecessary error message) (cherry picked from commit 9dd8e2ba268c636c240a918e0a31e6feaee19404)",
      "cve": "CVE-2025-39705",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39705",
          "value": "CVE-2025-39705",
          "url": "https://scout.docker.com/v/CVE-2025-39705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b89162d90edee67deb4741781a852124a0da74fc17ea7eeb70dabbf514693e8e",
      "category": "container_scanning",
      "message": "CVE-2025-39706 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Destroy KFD debugfs after destroy KFD wq  Since KFD proc content was moved to kernel debugfs, we can't destroy KFD debugfs before kfd_process_destroy_wq. Move kfd_process_destroy_wq prior to kfd_debugfs_fini to fix a kernel NULL pointer problem. It happens when /sys/kernel/debug/kfd was already destroyed in kfd_debugfs_fini but kfd_process_destroy_wq calls kfd_debugfs_remove_process. This line debugfs_remove_recursive(entry->proc_dentry); tries to remove /sys/kernel/debug/kfd/proc/<pid> while /sys/kernel/debug/kfd is already gone. It hangs the kernel by kernel NULL pointer.  (cherry picked from commit 0333052d90683d88531558dcfdbf2525cc37c233)",
      "cve": "CVE-2025-39706",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39706",
          "value": "CVE-2025-39706",
          "url": "https://scout.docker.com/v/CVE-2025-39706?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39706?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c86fbdb12f0f68350c0456daf06b6cec064e9a9d9596d34af3f499a32055de1b",
      "category": "container_scanning",
      "message": "CVE-2025-39707 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: check if hubbub is NULL in debugfs/amdgpu_dm_capabilities  HUBBUB structure is not initialized on DCE hardware, so check if it is NULL to avoid null dereference while accessing amdgpu_dm_capabilities file in debugfs.",
      "cve": "CVE-2025-39707",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39707",
          "value": "CVE-2025-39707",
          "url": "https://scout.docker.com/v/CVE-2025-39707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "85d0a022a6f419025259d430f36ab3d5dccb124fdc3af9a5b92dbafdd4da52cd",
      "category": "container_scanning",
      "message": "CVE-2025-39715 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Revise gateway LWS calls to probe user read access  We use load and stbys,e instructions to trigger memory reference interruptions without writing to memory. Because of the way read access support is implemented, read access interruptions are only triggered at privilege levels 2 and 3. The kernel and gateway page execute at privilege level 0, so this code never triggers a read access interruption. Thus, it is currently possible for user code to execute a LWS compare and swap operation at an address that is read protected at privilege level 3 (PRIV_USER).  Fix this by probing read access rights at privilege level 3 and branching to lws_fault if access isn't allowed.",
      "cve": "CVE-2025-39715",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39715",
          "value": "CVE-2025-39715",
          "url": "https://scout.docker.com/v/CVE-2025-39715?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39715?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4e0d495bc37abd460aeb2ad5ee354d61655fde685b98aefc01efa1c46565a642",
      "category": "container_scanning",
      "message": "CVE-2025-39716 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Revise __get_user() to probe user read access  Because of the way read access support is implemented, read access interruptions are only triggered at privilege levels 2 and 3. The kernel executes at privilege level 0, so __get_user() never triggers a read access interruption (code 26). Thus, it is currently possible for user code to access a read protected address via a system call.  Fix this by probing read access rights at privilege level 3 (PRIV_USER) and setting __gu_err to -EFAULT (-14) if access isn't allowed.  Note the cmpiclr instruction does a 32-bit compare because COND macro doesn't work inside asm.",
      "cve": "CVE-2025-39716",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39716",
          "value": "CVE-2025-39716",
          "url": "https://scout.docker.com/v/CVE-2025-39716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e38a075239de44b30f07ba8efd341d6149c5fa6c9310199154a365106b52d38d",
      "category": "container_scanning",
      "message": "CVE-2025-39720 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix refcount leak causing resource not released  When ksmbd_conn_releasing(opinfo->conn) returns true,the refcount was not decremented properly, causing a refcount leak that prevents the count from reaching zero and the memory from being released.",
      "cve": "CVE-2025-39720",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39720",
          "value": "CVE-2025-39720",
          "url": "https://scout.docker.com/v/CVE-2025-39720?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39720?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8858db57bb7abf5eca48c28ff5879977d5620c75de2d55d1db86dba0460a0d0d",
      "category": "container_scanning",
      "message": "CVE-2025-39726 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/ism: fix concurrency management in ism_cmd()  The s390x ISM device data sheet clearly states that only one request-response sequence is allowable per ISM function at any point in time.  Unfortunately as of today the s390/ism driver in Linux does not honor that requirement. This patch aims to rectify that.  This problem was discovered based on Aliaksei's bug report which states that for certain workloads the ISM functions end up entering error state (with PEC 2 as seen from the logs) after a while and as a consequence connections handled by the respective function break, and for future connection requests the ISM device is not considered -- given it is in a dysfunctional state. During further debugging PEC 3A was observed as well.  A kernel message like [ 1211.244319] zpci: 061a:00:00.0: Event 0x2 reports an error for PCI function 0x61a is a reliable indicator of the stated function entering error state with PEC 2. Let me also point out that a kernel message like [ 1211.244325] zpci: 061a:00:00.0: The ism driver bound to the device does not support error recovery is a reliable indicator that the ISM function won't be auto-recovered because the ISM driver currently lacks support for it.  On a technical level, without this synchronization, commands (inputs to the FW) may be partially or fully overwritten (corrupted) by another CPU trying to issue commands on the same function. There is hard evidence that this can lead to DMB token values being used as DMB IOVAs, leading to PEC 2 PCI events indicating invalid DMA. But this is only one of the failure modes imaginable. In theory even completely losing one command and executing another one twice and then trying to interpret the outputs as if the command we intended to execute was actually executed and not the other one is also possible.  Frankly, I don't feel confident about providing an exhaustive list of possible consequences.",
      "cve": "CVE-2025-39726",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39726",
          "value": "CVE-2025-39726",
          "url": "https://scout.docker.com/v/CVE-2025-39726?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39726?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e78b8c0409b2eb35019081443ea6730a218445536ed12ea57fbd3a72dc865fcd",
      "category": "container_scanning",
      "message": "CVE-2025-39732 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: fix sleeping-in-atomic in ath11k_mac_op_set_bitrate_mask()  ath11k_mac_disable_peer_fixed_rate() is passed as the iterator to ieee80211_iterate_stations_atomic(). Note in this case the iterator is required to be atomic, however ath11k_mac_disable_peer_fixed_rate() does not follow it as it might sleep. Consequently below warning is seen:  BUG: sleeping function called from invalid context at wmi.c:304 Call Trace: <TASK> dump_stack_lvl __might_resched.cold ath11k_wmi_cmd_send ath11k_wmi_set_peer_param ath11k_mac_disable_peer_fixed_rate ieee80211_iterate_stations_atomic ath11k_mac_op_set_bitrate_mask.cold  Change to ieee80211_iterate_stations_mtx() to fix this issue.  Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30",
      "cve": "CVE-2025-39732",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39732",
          "value": "CVE-2025-39732",
          "url": "https://scout.docker.com/v/CVE-2025-39732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f284562941383175547152d52abf765a18690da1e9b68e212177e2dfd1adce89",
      "category": "container_scanning",
      "message": "CVE-2025-39744 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcu: Fix rcu_read_unlock() deadloop due to IRQ work  During rcu_read_unlock_special(), if this happens during irq_exit(), we can lockup if an IPI is issued. This is because the IPI itself triggers the irq_exit() path causing a recursive lock up.  This is precisely what Xiongfeng found when invoking a BPF program on the trace_tick_stop() tracepoint As shown in the trace below. Fix by managing the irq_work state correctly.  irq_exit() __irq_exit_rcu() /* in_hardirq() returns false after this */ preempt_count_sub(HARDIRQ_OFFSET) tick_irq_exit() tick_nohz_irq_exit() tick_nohz_stop_sched_tick() trace_tick_stop()  /* a bpf prog is hooked on this trace point */ __bpf_trace_tick_stop() bpf_trace_run2() rcu_read_unlock_special() /* will send a IPI to itself */ irq_work_queue_on(&rdp->defer_qs_iw, rdp->cpu);  A simple reproducer can also be obtained by doing the following in tick_irq_exit(). It will hang on boot without the patch:  static inline void tick_irq_exit(void) { +\trcu_read_lock(); +\tWRITE_ONCE(current->rcu_read_unlock_special.b.need_qs, true); +\trcu_read_unlock(); +  [neeraj: Apply Frederic's suggested fix for PREEMPT_RT]",
      "cve": "CVE-2025-39744",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39744",
          "value": "CVE-2025-39744",
          "url": "https://scout.docker.com/v/CVE-2025-39744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "716a86fc69a2d17eb9079b9534729c5b03eeefe0a656ce92376abde74c14be38",
      "category": "container_scanning",
      "message": "CVE-2025-39745 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcutorture: Fix rcutorture_one_extend_check() splat in RT kernels  For built with CONFIG_PREEMPT_RT=y kernels, running rcutorture tests resulted in the following splat:  [   68.797425] rcutorture_one_extend_check during change: Current 0x1  To add 0x1  To remove 0x0  preempt_count() 0x0 [   68.797533] WARNING: CPU: 2 PID: 512 at kernel/rcu/rcutorture.c:1993 rcutorture_one_extend_check+0x419/0x560 [rcutorture] [   68.797601] Call Trace: [   68.797602]  <TASK> [   68.797619]  ? lockdep_softirqs_off+0xa5/0x160 [   68.797631]  rcutorture_one_extend+0x18e/0xcc0 [rcutorture 2466dbd2ff34dbaa36049cb323a80c3306ac997c] [   68.797646]  ? local_clock+0x19/0x40 [   68.797659]  rcu_torture_one_read+0xf0/0x280 [rcutorture 2466dbd2ff34dbaa36049cb323a80c3306ac997c] [   68.797678]  ? __pfx_rcu_torture_one_read+0x10/0x10 [rcutorture 2466dbd2ff34dbaa36049cb323a80c3306ac997c] [   68.797804]  ? __pfx_rcu_torture_timer+0x10/0x10 [rcutorture 2466dbd2ff34dbaa36049cb323a80c3306ac997c] [   68.797815] rcu-torture: rcu_torture_reader task started [   68.797824] rcu-torture: Creating rcu_torture_reader task [   68.797824]  rcu_torture_reader+0x238/0x580 [rcutorture 2466dbd2ff34dbaa36049cb323a80c3306ac997c] [   68.797836]  ? kvm_sched_clock_read+0x15/0x30  Disable BH does not change the SOFTIRQ corresponding bits in preempt_count() for RT kernels, this commit therefore use softirq_count() to check the if BH is disabled.",
      "cve": "CVE-2025-39745",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39745",
          "value": "CVE-2025-39745",
          "url": "https://scout.docker.com/v/CVE-2025-39745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "413dc29af53fae62503859385e1bb0b652870093f1b7ea2944f1acff111b2abd",
      "category": "container_scanning",
      "message": "CVE-2025-39746 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath10k: shutdown driver when hardware is unreliable  In rare cases, ath10k may lose connection with the PCIe bus due to some unknown reasons, which could further lead to system crashes during resuming due to watchdog timeout:  ath10k_pci 0000:01:00.0: wmi command 20486 timeout, restarting hardware ath10k_pci 0000:01:00.0: already restarting ath10k_pci 0000:01:00.0: failed to stop WMI vdev 0: -11 ath10k_pci 0000:01:00.0: failed to stop vdev 0: -11 ieee80211 phy0: PM: **** DPM device timeout **** Call Trace: panic+0x125/0x315 dpm_watchdog_set+0x54/0x54 dpm_watchdog_handler+0x57/0x57 call_timer_fn+0x31/0x13c  At this point, all WMI commands will timeout and attempt to restart device. So set a threshold for consecutive restart failures. If the threshold is exceeded, consider the hardware is unreliable and all ath10k operations should be skipped to avoid system crash.  fail_cont_count and pending_recovery are atomic variables, and do not involve complex conditional logic. Therefore, even if recovery check and reconfig complete are executed concurrently, the recovery mechanism will not be broken.  Tested-on: QCA6174 hw3.2 PCI WLAN.RM.4.4.1-00288-QCARMSWPZ-1",
      "cve": "CVE-2025-39746",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39746",
          "value": "CVE-2025-39746",
          "url": "https://scout.docker.com/v/CVE-2025-39746?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39746?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d16711a9c3d05e286f2ac8e0d1641c4d9a8cbe9dc5691dd326ff8318661c6628",
      "category": "container_scanning",
      "message": "CVE-2025-39747 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm: Add error handling for krealloc in metadata setup  Function msm_ioctl_gem_info_set_metadata() now checks for krealloc failure and returns -ENOMEM, avoiding potential NULL pointer dereference. Explicitly avoids __GFP_NOFAIL due to deadlock risks and allocation constraints.  Patchwork: https://patchwork.freedesktop.org/patch/661235/",
      "cve": "CVE-2025-39747",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39747",
          "value": "CVE-2025-39747",
          "url": "https://scout.docker.com/v/CVE-2025-39747?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39747?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0a7f3182a24eeac9152f067bb965c607976665c410194f71fc78599c7f2e716c",
      "category": "container_scanning",
      "message": "CVE-2025-39748 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Forget ranges when refining tnum after JSET  Syzbot reported a kernel warning due to a range invariant violation on the following BPF program.  0: call bpf_get_netns_cookie 1: if r0 == 0 goto <exit> 2: if r0 & Oxffffffff goto <exit>  The issue is on the path where we fall through both jumps.  That path is unreachable at runtime: after insn 1, we know r0 != 0, but with the sign extension on the jset, we would only fallthrough insn 2 if r0 == 0. Unfortunately, is_branch_taken() isn't currently able to figure this out, so the verifier walks all branches. The verifier then refines the register bounds using the second condition and we end up with inconsistent bounds on this unreachable path:  1: if r0 == 0 goto <exit> r0: u64=[0x1, 0xffffffffffffffff] var_off=(0, 0xffffffffffffffff) 2: if r0 & 0xffffffff goto <exit> r0 before reg_bounds_sync: u64=[0x1, 0xffffffffffffffff] var_off=(0, 0) r0 after reg_bounds_sync:  u64=[0x1, 0] var_off=(0, 0)  Improving the range refinement for JSET to cover all cases is tricky. We also don't expect many users to rely on JSET given LLVM doesn't generate those instructions. So instead of improving the range refinement for JSETs, Eduard suggested we forget the ranges whenever we're narrowing tnums after a JSET. This patch implements that approach.",
      "cve": "CVE-2025-39748",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39748",
          "value": "CVE-2025-39748",
          "url": "https://scout.docker.com/v/CVE-2025-39748?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39748?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c0480d8094855bbf152da7079d0959f78ec5f13ae25ffd84759121fc8532bda8",
      "category": "container_scanning",
      "message": "CVE-2025-39750 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Correct tid cleanup when tid setup fails  Currently, if any error occurs during ath12k_dp_rx_peer_tid_setup(), the tid value is already incremented, even though the corresponding TID is not actually allocated. Proceed to ath12k_dp_rx_peer_tid_delete() starting from unallocated tid, which might leads to freeing unallocated TID and cause potential crash or out-of-bounds access.  Hence, fix by correctly decrementing tid before cleanup to match only the successfully allocated TIDs.  Also, remove tid-- from failure case of ath12k_dp_rx_peer_frag_setup(), as decrementing the tid before cleanup in loop will take care of this.  Compile tested only.",
      "cve": "CVE-2025-39750",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39750",
          "value": "CVE-2025-39750",
          "url": "https://scout.docker.com/v/CVE-2025-39750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6c599bf4717a8ae0ebdb14a5b3efd8ae7e703cf9cac38ffd264ac9ca5f3fd7a4",
      "category": "container_scanning",
      "message": "CVE-2025-39753 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gfs2: Set .migrate_folio in gfs2_{rgrp,meta}_aops  Clears up the warning added in 7ee3647243e5 (\"migrate: Remove call to ->writepage\") that occurs in various xfstests, causing \"something found in dmesg\" failures.  [  341.136573] gfs2_meta_aops does not implement migrate_folio [  341.136953] WARNING: CPU: 1 PID: 36 at mm/migrate.c:944 move_to_new_folio+0x2f8/0x300",
      "cve": "CVE-2025-39753",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39753",
          "value": "CVE-2025-39753",
          "url": "https://scout.docker.com/v/CVE-2025-39753?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39753?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "376c1f8264e518cb0cf824b593293860be149ea5f06e29b6ff0abeff31beb6ee",
      "category": "container_scanning",
      "message": "CVE-2025-39754 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/smaps: fix race between smaps_hugetlb_range and migration  smaps_hugetlb_range() handles the pte without holdling ptl, and may be concurrenct with migration, leaing to BUG_ON in pfn_swap_entry_to_page(). The race is as follows.  smaps_hugetlb_range              migrate_pages huge_ptep_get remove_migration_ptes folio_unlock pfn_swap_entry_folio BUG_ON  To fix it, hold ptl lock in smaps_hugetlb_range().",
      "cve": "CVE-2025-39754",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39754",
          "value": "CVE-2025-39754",
          "url": "https://scout.docker.com/v/CVE-2025-39754?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39754?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "91db0374de29338d3be95fda9c56d151c39d566423848b36ac9fd457fd10d4a7",
      "category": "container_scanning",
      "message": "CVE-2025-39759 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: qgroup: fix race between quota disable and quota rescan ioctl  There's a race between a task disabling quotas and another running the rescan ioctl that can result in a use-after-free of qgroup records from the fs_info->qgroup_tree rbtree.  This happens as follows:  1) Task A enters btrfs_ioctl_quota_rescan() -> btrfs_qgroup_rescan();  2) Task B enters btrfs_quota_disable() and calls btrfs_qgroup_wait_for_completion(), which does nothing because at that point fs_info->qgroup_rescan_running is false (it wasn't set yet by task A);  3) Task B calls btrfs_free_qgroup_config() which starts freeing qgroups from fs_info->qgroup_tree without taking the lock fs_info->qgroup_lock;  4) Task A enters qgroup_rescan_zero_tracking() which starts iterating the fs_info->qgroup_tree tree while holding fs_info->qgroup_lock, but task B is freeing qgroup records from that tree without holding the lock, resulting in a use-after-free.  Fix this by taking fs_info->qgroup_lock at btrfs_free_qgroup_config(). Also at btrfs_qgroup_rescan() don't start the rescan worker if quotas were already disabled.",
      "cve": "CVE-2025-39759",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39759",
          "value": "CVE-2025-39759",
          "url": "https://scout.docker.com/v/CVE-2025-39759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e8da2d5172a90dc3ef8a8a274563745b7812a60cb876419c90d6d15a23b83f0e",
      "category": "container_scanning",
      "message": "CVE-2025-39761 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Decrement TID on RX peer frag setup error handling  Currently, TID is not decremented before peer cleanup, during error handling path of ath12k_dp_rx_peer_frag_setup(). This could lead to out-of-bounds access in peer->rx_tid[].  Hence, add a decrement operation for TID, before peer cleanup to ensures proper cleanup and prevents out-of-bounds access issues when the RX peer frag setup fails.  Found during code review. Compile tested only.",
      "cve": "CVE-2025-39761",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39761",
          "value": "CVE-2025-39761",
          "url": "https://scout.docker.com/v/CVE-2025-39761?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39761?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "10e9abeb4fb83c044df704ac1cd466e13c9fcc86893c7f78048bc665c8c5f3e0",
      "category": "container_scanning",
      "message": "CVE-2025-39762 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: add null check  [WHY] Prevents null pointer dereferences to enhance function robustness  [HOW] Adds early null check and return false if invalid.",
      "cve": "CVE-2025-39762",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39762",
          "value": "CVE-2025-39762",
          "url": "https://scout.docker.com/v/CVE-2025-39762?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39762?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f5013d12fd4782e2c354764979508c0f657c9d2d0a840a220860712ca472e7f2",
      "category": "container_scanning",
      "message": "CVE-2025-39763 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ACPI: APEI: send SIGBUS to current task if synchronous memory error not recovered  If a synchronous error is detected as a result of user-space process triggering a 2-bit uncorrected error, the CPU will take a synchronous error exception such as Synchronous External Abort (SEA) on Arm64. The kernel will queue a memory_failure() work which poisons the related page, unmaps the page, and then sends a SIGBUS to the process, so that a system wide panic can be avoided.  However, no memory_failure() work will be queued when abnormal synchronous errors occur. These errors can include situations like invalid PA, unexpected severity, no memory failure config support, invalid GUID section, etc. In such a case, the user-space process will trigger SEA again.  This loop can potentially exceed the platform firmware threshold or even trigger a kernel hard lockup, leading to a system reboot.  Fix it by performing a force kill if no memory_failure() work is queued for synchronous errors.  [ rjw: Changelog edits ]",
      "cve": "CVE-2025-39763",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39763",
          "value": "CVE-2025-39763",
          "url": "https://scout.docker.com/v/CVE-2025-39763?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39763?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5d8266f70e2d78d444c2d4f732ac3f9061d1240c39863fc826569275febc3dfc",
      "category": "container_scanning",
      "message": "CVE-2025-39764 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: ctnetlink: remove refcounting in expectation dumpers  Same pattern as previous patch: do not keep the expectation object alive via refcount, only store a cookie value and then use that as the skip hint for dump resumption.  AFAICS this has the same issue as the one resolved in the conntrack dumper, when we do if (!refcount_inc_not_zero(&exp->use))  to increment the refcount, there is a chance that exp == last, which causes a double-increment of the refcount and subsequent memory leak.",
      "cve": "CVE-2025-39764",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39764",
          "value": "CVE-2025-39764",
          "url": "https://scout.docker.com/v/CVE-2025-39764?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39764?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b528f31b1361483e01581ea5a79050b35cb6f4298f6bca114e9421c27ea74bf3",
      "category": "container_scanning",
      "message": "CVE-2025-39770 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: gso: Forbid IPv6 TSO with extensions on devices with only IPV6_CSUM  When performing Generic Segmentation Offload (GSO) on an IPv6 packet that contains extension headers, the kernel incorrectly requests checksum offload if the egress device only advertises NETIF_F_IPV6_CSUM feature, which has a strict contract: it supports checksum offload only for plain TCP or UDP over IPv6 and explicitly does not support packets with extension headers. The current GSO logic violates this contract by failing to disable the feature for packets with extension headers, such as those used in GREoIPv6 tunnels.  This violation results in the device being asked to perform an operation it cannot support, leading to a `skb_warn_bad_offload` warning and a collapse of network throughput. While device TSO/USO is correctly bypassed in favor of software GSO for these packets, the GSO stack must be explicitly told not to request checksum offload.  Mask NETIF_F_IPV6_CSUM, NETIF_F_TSO6 and NETIF_F_GSO_UDP_L4 in gso_features_check if the IPv6 header contains extension headers to compute checksum in software.  The exception is a BIG TCP extension, which, as stated in commit 68e068cabd2c6c53 (\"net: reenable NETIF_F_IPV6_CSUM offload for BIG TCP packets\"): \"The feature is only enabled on devices that support BIG TCP TSO. The header is only present for PF_PACKET taps like tcpdump, and not transmitted by physical devices.\"  kernel log output (truncated): WARNING: CPU: 1 PID: 5273 at net/core/dev.c:3535 skb_warn_bad_offload+0x81/0x140 ... Call Trace: <TASK> skb_checksum_help+0x12a/0x1f0 validate_xmit_skb+0x1a3/0x2d0 validate_xmit_skb_list+0x4f/0x80 sch_direct_xmit+0x1a2/0x380 __dev_xmit_skb+0x242/0x670 __dev_queue_xmit+0x3fc/0x7f0 ip6_finish_output2+0x25e/0x5d0 ip6_finish_output+0x1fc/0x3f0 ip6_tnl_xmit+0x608/0xc00 [ip6_tunnel] ip6gre_tunnel_xmit+0x1c0/0x390 [ip6_gre] dev_hard_start_xmit+0x63/0x1c0 __dev_queue_xmit+0x6d0/0x7f0 ip6_finish_output2+0x214/0x5d0 ip6_finish_output+0x1fc/0x3f0 ip6_xmit+0x2ca/0x6f0 ip6_finish_output+0x1fc/0x3f0 ip6_xmit+0x2ca/0x6f0 inet6_csk_xmit+0xeb/0x150 __tcp_transmit_skb+0x555/0xa80 tcp_write_xmit+0x32a/0xe90 tcp_sendmsg_locked+0x437/0x1110 tcp_sendmsg+0x2f/0x50 ... skb linear:   00000000: e4 3d 1a 7d ec 30 e4 3d 1a 7e 5d 90 86 dd 60 0e skb linear:   00000010: 00 0a 1b 34 3c 40 20 11 00 00 00 00 00 00 00 00 skb linear:   00000020: 00 00 00 00 00 12 20 11 00 00 00 00 00 00 00 00 skb linear:   00000030: 00 00 00 00 00 11 2f 00 04 01 04 01 01 00 00 00 skb linear:   00000040: 86 dd 60 0e 00 0a 1b 00 06 40 20 23 00 00 00 00 skb linear:   00000050: 00 00 00 00 00 00 00 00 00 12 20 23 00 00 00 00 skb linear:   00000060: 00 00 00 00 00 00 00 00 00 11 bf 96 14 51 13 f9 skb linear:   00000070: ae 27 a0 a8 2b e3 80 18 00 40 5b 6f 00 00 01 01 skb linear:   00000080: 08 0a 42 d4 50 d5 4b 70 f8 1a",
      "cve": "CVE-2025-39770",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39770",
          "value": "CVE-2025-39770",
          "url": "https://scout.docker.com/v/CVE-2025-39770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8f6f952bdc80a8680ad19caf3ba0f1e3216e99a394631be4a893a6fe3bcbb65d",
      "category": "container_scanning",
      "message": "CVE-2025-39771 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  regulator: pca9450: Use devm_register_sys_off_handler  With module test, there is error dump: ------------[ cut here ]------------ notifier callback pca9450_i2c_restart_handler already registered WARNING: kernel/notifier.c:23 at notifier_chain_register+0x5c/0x88, CPU#0: kworker/u16:3/50 Call trace: notifier_chain_register+0x5c/0x88 (P) atomic_notifier_chain_register+0x30/0x58 register_restart_handler+0x1c/0x28 pca9450_i2c_probe+0x418/0x538 i2c_device_probe+0x220/0x3d0 really_probe+0x114/0x410 __driver_probe_device+0xa0/0x150 driver_probe_device+0x40/0x114 __device_attach_driver+0xd4/0x12c  So use devm_register_sys_off_handler to let kernel handle the resource free to avoid kernel dump.",
      "cve": "CVE-2025-39771",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39771",
          "value": "CVE-2025-39771",
          "url": "https://scout.docker.com/v/CVE-2025-39771?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39771?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f7d9b949f86293ef8e1eb50c5d4038ec4abde622f2cbb29ac7fc01d1b93bd327",
      "category": "container_scanning",
      "message": "CVE-2025-39779 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: subpage: keep TOWRITE tag until folio is cleaned  btrfs_subpage_set_writeback() calls folio_start_writeback() the first time a folio is written back, and it also clears the PAGECACHE_TAG_TOWRITE tag even if there are still dirty blocks in the folio. This can break ordering guarantees, such as those required by btrfs_wait_ordered_extents().  That ordering breakage leads to a real failure. For example, running generic/464 on a zoned setup will hit the following ASSERT. This happens because the broken ordering fails to flush existing dirty pages before the file size is truncated.  assertion failed: !list_empty(&ordered->list) :: 0, in fs/btrfs/zoned.c:1899 ------------[ cut here ]------------ kernel BUG at fs/btrfs/zoned.c:1899! Oops: invalid opcode: 0000 [#1] SMP NOPTI CPU: 2 UID: 0 PID: 1906169 Comm: kworker/u130:2 Kdump: loaded Not tainted 6.16.0-rc6-BTRFS-ZNS+ #554 PREEMPT(voluntary) Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021 Workqueue: btrfs-endio-write btrfs_work_helper [btrfs] RIP: 0010:btrfs_finish_ordered_zoned.cold+0x50/0x52 [btrfs] RSP: 0018:ffffc9002efdbd60 EFLAGS: 00010246 RAX: 000000000000004c RBX: ffff88811923c4e0 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffffffff827e38b1 RDI: 00000000ffffffff RBP: ffff88810005d000 R08: 00000000ffffdfff R09: ffffffff831051c8 R10: ffffffff83055220 R11: 0000000000000000 R12: ffff8881c2458c00 R13: ffff88811923c540 R14: ffff88811923c5e8 R15: ffff8881c1bd9680 FS:  0000000000000000(0000) GS:ffff88a04acd0000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f907c7a918c CR3: 0000000004024000 CR4: 0000000000350ef0 Call Trace: <TASK> ? srso_return_thunk+0x5/0x5f btrfs_finish_ordered_io+0x4a/0x60 [btrfs] btrfs_work_helper+0xf9/0x490 [btrfs] process_one_work+0x204/0x590 ? srso_return_thunk+0x5/0x5f worker_thread+0x1d6/0x3d0 ? __pfx_worker_thread+0x10/0x10 kthread+0x118/0x230 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x205/0x260 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>  Consider process A calling writepages() with WB_SYNC_NONE. In zoned mode or for compressed writes, it locks several folios for delalloc and starts writing them out. Let's call the last locked folio folio X. Suppose the write range only partially covers folio X, leaving some pages dirty. Process A calls btrfs_subpage_set_writeback() when building a bio. This function call clears the TOWRITE tag of folio X, whose size = 8K and the block size = 4K. It is following state.  0     4K    8K |/////|/////|  (flag: DIRTY, tag: DIRTY) <-----> Process A will write this range.  Now suppose process B concurrently calls writepages() with WB_SYNC_ALL. It calls tag_pages_for_writeback() to tag dirty folios with PAGECACHE_TAG_TOWRITE. Since folio X is still dirty, it gets tagged. Then, B collects tagged folios using filemap_get_folios_tag() and must wait for folio X to be written before returning from writepages().  0     4K    8K |/////|/////|  (flag: DIRTY, tag: DIRTY|TOWRITE)  However, between tagging and collecting, process A may call btrfs_subpage_set_writeback() and clear folio X's TOWRITE tag. 0     4K    8K |     |/////|  (flag: DIRTY|WRITEBACK, tag: DIRTY)  As a result, process B won't see folio X in its batch, and returns without waiting for it. This breaks the WB_SYNC_ALL ordering requirement.  Fix this by using btrfs_subpage_set_writeback_keepwrite(), which retains the TOWRITE tag. We now manually clear the tag only after the folio becomes clean, via the xas operation.",
      "cve": "CVE-2025-39779",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39779",
          "value": "CVE-2025-39779",
          "url": "https://scout.docker.com/v/CVE-2025-39779?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39779?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "957d56c7a33fa8bd8109445a8a4f672291368812c513aa4e0419ba3486f5b2e8",
      "category": "container_scanning",
      "message": "CVE-2025-39781 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Drop WARN_ON_ONCE() from flush_cache_vmap  I have observed warning to occassionally trigger.",
      "cve": "CVE-2025-39781",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39781",
          "value": "CVE-2025-39781",
          "url": "https://scout.docker.com/v/CVE-2025-39781?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39781?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "da49783b3db6e98c49b0c473bc6662956a0c70b3af1779323f4ddc9345225bc7",
      "category": "container_scanning",
      "message": "CVE-2025-39789 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: x86/aegis - Add missing error checks  The skcipher_walk functions can allocate memory and can fail, so checking for errors is necessary.",
      "cve": "CVE-2025-39789",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39789",
          "value": "CVE-2025-39789",
          "url": "https://scout.docker.com/v/CVE-2025-39789?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39789?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c31d8a3085f57281499812325ad96a55811bc46e28e20e30439535bbe4ebc54b",
      "category": "container_scanning",
      "message": "CVE-2025-39797 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xfrm: Duplicate SPI Handling  The issue originates when Strongswan initiates an XFRM_MSG_ALLOCSPI Netlink message, which triggers the kernel function xfrm_alloc_spi(). This function is expected to ensure uniqueness of the Security Parameter Index (SPI) for inbound Security Associations (SAs). However, it can return success even when the requested SPI is already in use, leading to duplicate SPIs assigned to multiple inbound SAs, differentiated only by their destination addresses.  This behavior causes inconsistencies during SPI lookups for inbound packets. Since the lookup may return an arbitrary SA among those with the same SPI, packet processing can fail, resulting in packet drops.  According to RFC 4301 section 4.4.2 , for inbound processing a unicast SA is uniquely identified by the SPI and optionally protocol.  Reproducing the Issue Reliably: To consistently reproduce the problem, restrict the available SPI range in charon.conf : spi_min = 0x10000000 spi_max = 0x10000002 This limits the system to only 2 usable SPI values. Next, create more than 2 Child SA. each using unique pair of src/dst address. As soon as the 3rd Child SA is initiated, it will be assigned a duplicate SPI, since the SPI pool is already exhausted. With a narrow SPI range, the issue is consistently reproducible. With a broader/default range, it becomes rare and unpredictable.  Current implementation: xfrm_spi_hash() lookup function computes hash using daddr, proto, and family. So if two SAs have the same SPI but different destination addresses, then they will: a. Hash into different buckets b. Be stored in different linked lists (byspi + h) c. Not be seen in the same hlist_for_each_entry_rcu() iteration. As a result, the lookup will result in NULL and kernel allows that Duplicate SPI  Proposed Change: xfrm_state_lookup_spi_proto() does a truly global search - across all states, regardless of hash bucket and matches SPI and proto.",
      "cve": "CVE-2025-39797",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39797",
          "value": "CVE-2025-39797",
          "url": "https://scout.docker.com/v/CVE-2025-39797?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39797?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f5ff3eeff37fa3a02b1f98eadae19faad85cd1f44801b89b1016d44ab9c499c4",
      "category": "container_scanning",
      "message": "CVE-2025-39800 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: abort transaction on unexpected eb generation at btrfs_copy_root()  If we find an unexpected generation for the extent buffer we are cloning at btrfs_copy_root(), we just WARN_ON() and don't error out and abort the transaction, meaning we allow to persist metadata with an unexpected generation. Instead of warning only, abort the transaction and return -EUCLEAN.",
      "cve": "CVE-2025-39800",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39800",
          "value": "CVE-2025-39800",
          "url": "https://scout.docker.com/v/CVE-2025-39800?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39800?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1640ac688b751f0248ad527c6bd11d96de416a431f5524aceb26a01038a59be4",
      "category": "container_scanning",
      "message": "CVE-2025-39810 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bnxt_en: Fix memory corruption when FW resources change during ifdown  bnxt_set_dflt_rings() assumes that it is always called before any TC has been created.  So it doesn't take bp->num_tc into account and assumes that it is always 0 or 1.  In the FW resource or capability change scenario, the FW will return flags in bnxt_hwrm_if_change() that will cause the driver to reinitialize and call bnxt_cancel_reservations().  This will lead to bnxt_init_dflt_ring_mode() calling bnxt_set_dflt_rings() and bp->num_tc may be greater than 1.  This will cause bp->tx_ring[] to be sized too small and cause memory corruption in bnxt_alloc_cp_rings().  Fix it by properly scaling the TX rings by bp->num_tc in the code paths mentioned above.  Add 2 helper functions to determine bp->tx_nr_rings and bp->tx_nr_rings_per_tc.",
      "cve": "CVE-2025-39810",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39810",
          "value": "CVE-2025-39810",
          "url": "https://scout.docker.com/v/CVE-2025-39810?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39810?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "68235bb76ce7e411971eb464136974538802d3dd5e136bcebfd2136fbd79cdfd",
      "category": "container_scanning",
      "message": "CVE-2025-39819 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/smb: Fix inconsistent refcnt update  A possible inconsistent update of refcount was identified in `smb2_compound_op`. Such inconsistent update could lead to possible resource leaks.  Why it is a possible bug: 1. In the comment section of the function, it clearly states that the reference to `cfile` should be dropped after calling this function. 2. Every control flow path would check and drop the reference to `cfile`, except the patched one. 3. Existing callers would not handle refcount update of `cfile` if -ENOMEM is returned.  To fix the bug, an extra goto label \"out\" is added, to make sure that the cleanup logic would always be respected. As the problem is caused by the allocation failure of `vars`, the cleanup logic between label \"finished\" and \"out\" can be safely ignored. According to the definition of function `is_replayable_error`, the error code of \"-ENOMEM\" is not recoverable. Therefore, the replay logic also gets ignored.",
      "cve": "CVE-2025-39819",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39819",
          "value": "CVE-2025-39819",
          "url": "https://scout.docker.com/v/CVE-2025-39819?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39819?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "758fd8a184b19884d76ef237255a1df2eef9232b51aec60d44b7eacf1e33424a",
      "category": "container_scanning",
      "message": "CVE-2025-39825 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix race with concurrent opens in rename(2)  Besides sending the rename request to the server, the rename process also involves closing any deferred close, waiting for outstanding I/O to complete as well as marking all existing open handles as deleted to prevent them from deferring closes, which increases the race window for potential concurrent opens on the target file.  Fix this by unhashing the dentry in advance to prevent any concurrent opens on the target.",
      "cve": "CVE-2025-39825",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39825",
          "value": "CVE-2025-39825",
          "url": "https://scout.docker.com/v/CVE-2025-39825?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39825?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "689738b631d0e2e8b07190cecb8464c03bad8ca3068e7d98a4c43422c0ac3ec7",
      "category": "container_scanning",
      "message": "CVE-2025-39826 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: rose: convert 'use' field to refcount_t  The 'use' field in struct rose_neigh is used as a reference counter but lacks atomicity. This can lead to race conditions where a rose_neigh structure is freed while still being referenced by other code paths.  For example, when rose_neigh->use becomes zero during an ioctl operation via rose_rt_ioctl(), the structure may be removed while its timer is still active, potentially causing use-after-free issues.  This patch changes the type of 'use' from unsigned short to refcount_t and updates all code paths to use rose_neigh_hold() and rose_neigh_put() which operate reference counts atomically.",
      "cve": "CVE-2025-39826",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39826",
          "value": "CVE-2025-39826",
          "url": "https://scout.docker.com/v/CVE-2025-39826?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39826?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5ba316831583dd32687c5d6126f2b9da739e67ee6d2936b73af47e855bffd58e",
      "category": "container_scanning",
      "message": "CVE-2025-39827 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: rose: include node references in rose_neigh refcount  Current implementation maintains two separate reference counting mechanisms: the 'count' field in struct rose_neigh tracks references from rose_node structures, while the 'use' field (now refcount_t) tracks references from rose_sock.  This patch merges these two reference counting systems using 'use' field for proper reference management. Specifically, this patch adds incrementing and decrementing of rose_neigh->use when rose_neigh->count is incremented or decremented.  This patch also modifies rose_rt_free(), rose_rt_device_down() and rose_clear_route() to properly release references to rose_neigh objects before freeing a rose_node through rose_remove_node().  These changes ensure rose_neigh structures are properly freed only when all references, including those from rose_node structures, are released. As a result, this resolves a slab-use-after-free issue reported by Syzbot.",
      "cve": "CVE-2025-39827",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39827",
          "value": "CVE-2025-39827",
          "url": "https://scout.docker.com/v/CVE-2025-39827?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39827?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9a5c6bcdfd91865c71061521a3f96b141af6001a30769b60d207bf6b82208c6e",
      "category": "container_scanning",
      "message": "CVE-2025-39829 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  trace/fgraph: Fix the warning caused by missing unregister notifier  This warning was triggered during testing on v6.16:  notifier callback ftrace_suspend_notifier_call already registered WARNING: CPU: 2 PID: 86 at kernel/notifier.c:23 notifier_chain_register+0x44/0xb0 ... Call Trace: <TASK> blocking_notifier_chain_register+0x34/0x60 register_ftrace_graph+0x330/0x410 ftrace_profile_write+0x1e9/0x340 vfs_write+0xf8/0x420 ? filp_flush+0x8a/0xa0 ? filp_close+0x1f/0x30 ? do_dup2+0xaf/0x160 ksys_write+0x65/0xe0 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x77/0x7f  When writing to the function_profile_enabled interface, the notifier was not unregistered after start_graph_tracing failed, causing a warning the next time function_profile_enabled was written.  Fixed by adding unregister_pm_notifier in the exception path.",
      "cve": "CVE-2025-39829",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39829",
          "value": "CVE-2025-39829",
          "url": "https://scout.docker.com/v/CVE-2025-39829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39829?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b32cd1c483a30bffe1843903e85c145c0b329cddc60339a6fb0e31ca01d9d68d",
      "category": "container_scanning",
      "message": "CVE-2025-39833 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mISDN: hfcpci: Fix warning when deleting uninitialized timer  With CONFIG_DEBUG_OBJECTS_TIMERS unloading hfcpci module leads to the following splat:  [  250.215892] ODEBUG: assert_init not available (active state 0) object: ffffffffc01a3dc0 object type: timer_list hint: 0x0 [  250.217520] WARNING: CPU: 0 PID: 233 at lib/debugobjects.c:612 debug_print_object+0x1b6/0x2c0 [  250.218775] Modules linked in: hfcpci(-) mISDN_core [  250.219537] CPU: 0 UID: 0 PID: 233 Comm: rmmod Not tainted 6.17.0-rc2-g6f713187ac98 #2 PREEMPT(voluntary) [  250.220940] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [  250.222377] RIP: 0010:debug_print_object+0x1b6/0x2c0 [  250.223131] Code: fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 75 4f 41 56 48 8b 14 dd a0 4e 01 9f 48 89 ee 48 c7 c7 20 46 01 9f e8 cb 84d [  250.225805] RSP: 0018:ffff888015ea7c08 EFLAGS: 00010286 [  250.226608] RAX: 0000000000000000 RBX: 0000000000000005 RCX: ffffffff9be93a95 [  250.227708] RDX: 1ffff1100d945138 RSI: 0000000000000008 RDI: ffff88806ca289c0 [  250.228993] RBP: ffffffff9f014a00 R08: 0000000000000001 R09: ffffed1002bd4f39 [  250.230043] R10: ffff888015ea79cf R11: 0000000000000001 R12: 0000000000000001 [  250.231185] R13: ffffffff9eea0520 R14: 0000000000000000 R15: ffff888015ea7cc8 [  250.232454] FS:  00007f3208f01540(0000) GS:ffff8880caf5a000(0000) knlGS:0000000000000000 [  250.233851] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  250.234856] CR2: 00007f32090a7421 CR3: 0000000004d63000 CR4: 00000000000006f0 [  250.236117] Call Trace: [  250.236599]  <TASK> [  250.236967]  ? trace_irq_enable.constprop.0+0xd4/0x130 [  250.237920]  debug_object_assert_init+0x1f6/0x310 [  250.238762]  ? __pfx_debug_object_assert_init+0x10/0x10 [  250.239658]  ? __lock_acquire+0xdea/0x1c70 [  250.240369]  __try_to_del_timer_sync+0x69/0x140 [  250.241172]  ? __pfx___try_to_del_timer_sync+0x10/0x10 [  250.242058]  ? __timer_delete_sync+0xc6/0x120 [  250.242842]  ? lock_acquire+0x30/0x80 [  250.243474]  ? __timer_delete_sync+0xc6/0x120 [  250.244262]  __timer_delete_sync+0x98/0x120 [  250.245015]  HFC_cleanup+0x10/0x20 [hfcpci] [  250.245704]  __do_sys_delete_module+0x348/0x510 [  250.246461]  ? __pfx___do_sys_delete_module+0x10/0x10 [  250.247338]  do_syscall_64+0xc1/0x360 [  250.247924]  entry_SYSCALL_64_after_hwframe+0x77/0x7f  Fix this by initializing hfc_tl timer with DEFINE_TIMER macro. Also, use mod_timer instead of manual timeout update.",
      "cve": "CVE-2025-39833",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39833",
          "value": "CVE-2025-39833",
          "url": "https://scout.docker.com/v/CVE-2025-39833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f326437c9f527be345de17a34aa70474aa0e8c854e74c0a8670364a54ff8bcea",
      "category": "container_scanning",
      "message": "CVE-2025-39838 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cifs: prevent NULL pointer dereference in UTF16 conversion  There can be a NULL pointer dereference bug here. NULL is passed to __cifs_sfu_make_node without checks, which passes it unchecked to cifs_strndup_to_utf16, which in turn passes it to cifs_local_to_utf16_bytes where '*from' is dereferenced, causing a crash.  This patch adds a check for NULL 'src' in cifs_strndup_to_utf16 and returns NULL early to prevent dereferencing NULL pointer.  Found by Linux Verification Center (linuxtesting.org) with SVACE",
      "cve": "CVE-2025-39838",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39838",
          "value": "CVE-2025-39838",
          "url": "https://scout.docker.com/v/CVE-2025-39838?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39838?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "840e5d7c523ea328b49eb7420fa289393ee33d6c69e855c99a7c8961fa22d739",
      "category": "container_scanning",
      "message": "CVE-2025-39850 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vxlan: Fix NPD in {arp,neigh}_reduce() when using nexthop objects  When the \"proxy\" option is enabled on a VXLAN device, the device will suppress ARP requests and IPv6 Neighbor Solicitation messages if it is able to reply on behalf of the remote host. That is, if a matching and valid neighbor entry is configured on the VXLAN device whose MAC address is not behind the \"any\" remote (0.0.0.0 / ::).  The code currently assumes that the FDB entry for the neighbor's MAC address points to a valid remote destination, but this is incorrect if the entry is associated with an FDB nexthop group. This can result in a NPD [1][3] which can be reproduced using [2][4].  Fix by checking that the remote destination exists before dereferencing it.  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] CPU: 4 UID: 0 PID: 365 Comm: arping Not tainted 6.17.0-rc2-virtme-g2a89cb21162c #2 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014 RIP: 0010:vxlan_xmit+0xb58/0x15f0 [...] Call Trace: <TASK> dev_hard_start_xmit+0x5d/0x1c0 __dev_queue_xmit+0x246/0xfd0 packet_sendmsg+0x113a/0x1850 __sock_sendmsg+0x38/0x70 __sys_sendto+0x126/0x180 __x64_sys_sendto+0x24/0x30 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x4b/0x53  [2] #!/bin/bash  ip address add 192.0.2.1/32 dev lo  ip nexthop add id 1 via 192.0.2.2 fdb ip nexthop add id 10 group 1 fdb  ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 4789 proxy  ip neigh add 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm dev vx0  bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10  arping -b -c 1 -s 192.0.2.1 -I vx0 192.0.2.3  [3] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] CPU: 13 UID: 0 PID: 372 Comm: ndisc6 Not tainted 6.17.0-rc2-virtmne-g6ee90cb26014 #3 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1v996), BIOS 1.17.0-4.fc41 04/01/2x014 RIP: 0010:vxlan_xmit+0x803/0x1600 [...] Call Trace: <TASK> dev_hard_start_xmit+0x5d/0x1c0 __dev_queue_xmit+0x246/0xfd0 ip6_finish_output2+0x210/0x6c0 ip6_finish_output+0x1af/0x2b0 ip6_mr_output+0x92/0x3e0 ip6_send_skb+0x30/0x90 rawv6_sendmsg+0xe6e/0x12e0 __sock_sendmsg+0x38/0x70 __sys_sendto+0x126/0x180 __x64_sys_sendto+0x24/0x30 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x4b/0x53 RIP: 0033:0x7f383422ec77  [4] #!/bin/bash  ip address add 2001:db8:1::1/128 dev lo  ip nexthop add id 1 via 2001:db8:1::1 fdb ip nexthop add id 10 group 1 fdb  ip link add name vx0 up type vxlan id 10010 local 2001:db8:1::1 dstport 4789 proxy  ip neigh add 2001:db8:1::3 lladdr 00:11:22:33:44:55 nud perm dev vx0  bridge fdb add 00:11:22:33:44:55 dev vx0 self static nhid 10  ndisc6 -r 1 -s 2001:db8:1::1 -w 1 2001:db8:1::3 vx0",
      "cve": "CVE-2025-39850",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39850",
          "value": "CVE-2025-39850",
          "url": "https://scout.docker.com/v/CVE-2025-39850?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39850?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e00909702578b64b51ccb4ec8320f7b1afe7d337e1bee05bbcffe3fd2ac9be33",
      "category": "container_scanning",
      "message": "CVE-2025-39851 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vxlan: Fix NPD when refreshing an FDB entry with a nexthop object  VXLAN FDB entries can point to either a remote destination or an FDB nexthop group. The latter is usually used in EVPN deployments where learning is disabled.  However, when learning is enabled, an incoming packet might try to refresh an FDB entry that points to an FDB nexthop group and therefore does not have a remote. Such packets should be dropped, but they are only dropped after dereferencing the non-existent remote, resulting in a NPD [1] which can be reproduced using [2].  Fix by dropping such packets earlier. Remove the misleading comment from first_remote_rcu().  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] CPU: 13 UID: 0 PID: 361 Comm: mausezahn Not tainted 6.17.0-rc1-virtme-g9f6b606b6b37 #1 PREEMPT(voluntary) Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.17.0-4.fc41 04/01/2014 RIP: 0010:vxlan_snoop+0x98/0x1e0 [...] Call Trace: <TASK> vxlan_encap_bypass+0x209/0x240 encap_bypass_if_local+0xb1/0x100 vxlan_xmit_one+0x1375/0x17e0 vxlan_xmit+0x6b4/0x15f0 dev_hard_start_xmit+0x5d/0x1c0 __dev_queue_xmit+0x246/0xfd0 packet_sendmsg+0x113a/0x1850 __sock_sendmsg+0x38/0x70 __sys_sendto+0x126/0x180 __x64_sys_sendto+0x24/0x30 do_syscall_64+0xa4/0x260 entry_SYSCALL_64_after_hwframe+0x4b/0x53  [2] #!/bin/bash  ip address add 192.0.2.1/32 dev lo ip address add 192.0.2.2/32 dev lo  ip nexthop add id 1 via 192.0.2.3 fdb ip nexthop add id 10 group 1 fdb  ip link add name vx0 up type vxlan id 10010 local 192.0.2.1 dstport 12345 localbypass ip link add name vx1 up type vxlan id 10020 local 192.0.2.2 dstport 54321 learning  bridge fdb add 00:11:22:33:44:55 dev vx0 self static dst 192.0.2.2 port 54321 vni 10020 bridge fdb add 00:aa:bb:cc:dd:ee dev vx1 self static nhid 10  mausezahn vx0 -a 00:aa:bb:cc:dd:ee -b 00:11:22:33:44:55 -c 1 -q",
      "cve": "CVE-2025-39851",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39851",
          "value": "CVE-2025-39851",
          "url": "https://scout.docker.com/v/CVE-2025-39851?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39851?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f858cf5ed17f5e6f7d1c0a41691d7d718e3c9762a9d7002c88869aa0627e471a",
      "category": "container_scanning",
      "message": "CVE-2025-39859 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ptp: ocp: fix use-after-free bugs causing by ptp_ocp_watchdog  The ptp_ocp_detach() only shuts down the watchdog timer if it is pending. However, if the timer handler is already running, the timer_delete_sync() is not called. This leads to race conditions where the devlink that contains the ptp_ocp is deallocated while the timer handler is still accessing it, resulting in use-after-free bugs. The following details one of the race scenarios.  (thread 1)                           | (thread 2) ptp_ocp_remove()                     | ptp_ocp_detach()                   | ptp_ocp_watchdog() if (timer_pending(&bp->watchdog))|   bp = timer_container_of() timer_delete_sync()            | | devlink_free(devlink) //free       | |   bp-> //use  Resolve this by unconditionally calling timer_delete_sync() to ensure the timer is reliably deactivated, preventing any access after free.",
      "cve": "CVE-2025-39859",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39859",
          "value": "CVE-2025-39859",
          "url": "https://scout.docker.com/v/CVE-2025-39859?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39859?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f5f1af31d9752b6761d2344ab572be6a25d5ae98106ab7ec62b78271dd65b8bd",
      "category": "container_scanning",
      "message": "CVE-2025-39863 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: brcmfmac: fix use-after-free when rescheduling brcmf_btcoex_info work  The brcmf_btcoex_detach() only shuts down the btcoex timer, if the flag timer_on is false. However, the brcmf_btcoex_timerfunc(), which runs as timer handler, sets timer_on to false. This creates critical race conditions:  1.If brcmf_btcoex_detach() is called while brcmf_btcoex_timerfunc() is executing, it may observe timer_on as false and skip the call to timer_shutdown_sync().  2.The brcmf_btcoex_timerfunc() may then reschedule the brcmf_btcoex_info worker after the cancel_work_sync() has been executed, resulting in use-after-free bugs.  The use-after-free bugs occur in two distinct scenarios, depending on the timing of when the brcmf_btcoex_info struct is freed relative to the execution of its worker thread.  Scenario 1: Freed before the worker is scheduled  The brcmf_btcoex_info is deallocated before the worker is scheduled. A race condition can occur when schedule_work(&bt_local->work) is called after the target memory has been freed. The sequence of events is detailed below:  CPU0                           | CPU1 brcmf_btcoex_detach            | brcmf_btcoex_timerfunc |   bt_local->timer_on = false; if (cfg->btcoex->timer_on)   | ...                        | cancel_work_sync();          | ...                          | kfree(cfg->btcoex); // FREE  | |   schedule_work(&bt_local->work); // USE  Scenario 2: Freed after the worker is scheduled  The brcmf_btcoex_info is freed after the worker has been scheduled but before or during its execution. In this case, statements within the brcmf_btcoex_handler()  such as the container_of macro and subsequent dereferences of the brcmf_btcoex_info object will cause a use-after-free access. The following timeline illustrates this scenario:  CPU0                            | CPU1 brcmf_btcoex_detach             | brcmf_btcoex_timerfunc |   bt_local->timer_on = false; if (cfg->btcoex->timer_on)    | ...                         | cancel_work_sync();           | ...                           |   schedule_work(); // Reschedule | kfree(cfg->btcoex); // FREE   |   brcmf_btcoex_handler() // Worker /*                            |     btci = container_of(....); // USE The kfree() above could      |     ... also occur at any point      |     btci-> // USE during the worker's execution| */                           |  To resolve the race conditions, drop the conditional check and call timer_shutdown_sync() directly. It can deactivate the timer reliably, regardless of its current state. Once stopped, the timer_on state is then set to false.",
      "cve": "CVE-2025-39863",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39863",
          "value": "CVE-2025-39863",
          "url": "https://scout.docker.com/v/CVE-2025-39863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2e76070dd5da0cc18f4d72686aca726884d52a1dfb77413b57180475747df01f",
      "category": "container_scanning",
      "message": "CVE-2025-39877 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/damon/sysfs: fix use-after-free in state_show()  state_show() reads kdamond->damon_ctx without holding damon_sysfs_lock. This allows a use-after-free race:  CPU 0                         CPU 1 -----                         ----- state_show()                  damon_sysfs_turn_damon_on() ctx = kdamond->damon_ctx;     mutex_lock(&damon_sysfs_lock); damon_destroy_ctx(kdamond->damon_ctx); kdamond->damon_ctx = NULL; mutex_unlock(&damon_sysfs_lock); damon_is_running(ctx);        /* ctx is freed */ mutex_lock(&ctx->kdamond_lock); /* UAF */  (The race can also occur with damon_sysfs_kdamonds_rm_dirs() and damon_sysfs_kdamond_release(), which free or replace the context under damon_sysfs_lock.)  Fix by taking damon_sysfs_lock before dereferencing the context, mirroring the locking used in pid_show().  The bug has existed since state_show() first accessed kdamond->damon_ctx.",
      "cve": "CVE-2025-39877",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39877",
          "value": "CVE-2025-39877",
          "url": "https://scout.docker.com/v/CVE-2025-39877?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39877?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e6200c9a9bbb1d98918652a9a9577927ff8667d0d70646d9bd4140b92f5d12b2",
      "category": "container_scanning",
      "message": "CVE-2025-39884 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix subvolume deletion lockup caused by inodes xarray race  There is a race condition between inode eviction and inode caching that can cause a live struct btrfs_inode to be missing from the root->inodes xarray. Specifically, there is a window during evict() between the inode being unhashed and deleted from the xarray. If btrfs_iget() is called for the same inode in that window, it will be recreated and inserted into the xarray, but then eviction will delete the new entry, leaving nothing in the xarray:  Thread 1                          Thread 2 --------------------------------------------------------------- evict() remove_inode_hash() btrfs_iget_path() btrfs_iget_locked() btrfs_read_locked_inode() btrfs_add_inode_to_root() destroy_inode() btrfs_destroy_inode() btrfs_del_inode_from_root() __xa_erase  In turn, this can cause issues for subvolume deletion. Specifically, if an inode is in this lost state, and all other inodes are evicted, then btrfs_del_inode_from_root() will call btrfs_add_dead_root() prematurely. If the lost inode has a delayed_node attached to it, then when btrfs_clean_one_deleted_snapshot() calls btrfs_kill_all_delayed_nodes(), it will loop forever because the delayed_nodes xarray will never become empty (unless memory pressure forces the inode out). We saw this manifest as soft lockups in production.  Fix it by only deleting the xarray entry if it matches the given inode (using __xa_cmpxchg()).",
      "cve": "CVE-2025-39884",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39884",
          "value": "CVE-2025-39884",
          "url": "https://scout.docker.com/v/CVE-2025-39884?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39884?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "adf53bd591c3a387092af4eea3fb6f1c78991775ccbbffc974a4f83ef6c7f0b0",
      "category": "container_scanning",
      "message": "CVE-2025-39886 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Tell memcg to use allow_spinning=false path in bpf_timer_init()  Currently, calling bpf_map_kmalloc_node() from __bpf_async_init() can cause various locking issues; see the following stack trace (edited for style) as one example:  ... [10.011566]  do_raw_spin_lock.cold [10.011570]  try_to_wake_up             (5) double-acquiring the same [10.011575]  kick_pool                      rq_lock, causing a hardlockup [10.011579]  __queue_work [10.011582]  queue_work_on [10.011585]  kernfs_notify [10.011589]  cgroup_file_notify [10.011593]  try_charge_memcg           (4) memcg accounting raises an [10.011597]  obj_cgroup_charge_pages        MEMCG_MAX event [10.011599]  obj_cgroup_charge_account [10.011600]  __memcg_slab_post_alloc_hook [10.011603]  __kmalloc_node_noprof ... [10.011611]  bpf_map_kmalloc_node [10.011612]  __bpf_async_init [10.011615]  bpf_timer_init             (3) BPF calls bpf_timer_init() [10.011617]  bpf_prog_xxxxxxxxxxxxxxxx_fcg_runnable [10.011619]  bpf__sched_ext_ops_runnable [10.011620]  enqueue_task_scx           (2) BPF runs with rq_lock held [10.011622]  enqueue_task [10.011626]  ttwu_do_activate [10.011629]  sched_ttwu_pending         (1) grabs rq_lock ...  The above was reproduced on bpf-next (b338cf849ec8) by modifying ./tools/sched_ext/scx_flatcg.bpf.c to call bpf_timer_init() during ops.runnable(), and hacking the memcg accounting code a bit to make a bpf_timer_init() call more likely to raise an MEMCG_MAX event.  We have also run into other similar variants (both internally and on bpf-next), including double-acquiring cgroup_file_kn_lock, the same worker_pool::lock, etc.  As suggested by Shakeel, fix this by using __GFP_HIGH instead of GFP_ATOMIC in __bpf_async_init(), so that e.g. if try_charge_memcg() raises an MEMCG_MAX event, we call __memcg_memory_event() with @allow_spinning=false and avoid calling cgroup_file_notify() there.  Depends on mm patch \"memcg: skip cgroup_file_notify if spinning is not allowed\": https://lore.kernel.org/bpf/20250905201606.66198-1-shakeel.butt@linux.dev/  v0 approach s/bpf_map_kmalloc_node/bpf_mem_alloc/ https://lore.kernel.org/bpf/20250905061919.439648-1-yepeilin@google.com/ v1 approach: https://lore.kernel.org/bpf/20250905234547.862249-1-yepeilin@google.com/",
      "cve": "CVE-2025-39886",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39886",
          "value": "CVE-2025-39886",
          "url": "https://scout.docker.com/v/CVE-2025-39886?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39886?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec83df4fb3a3e3e2d82ef55ed6b529786a6312e62f17ce891c523b89252a4823",
      "category": "container_scanning",
      "message": "CVE-2025-39901 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  i40e: remove read access to debugfs files  The 'command' and 'netdev_ops' debugfs files are a legacy debugging interface supported by the i40e driver since its early days by commit 02e9c290814c (\"i40e: debugfs interface\").  Both of these debugfs files provide a read handler which is mostly useless, and which is implemented with questionable logic. They both use a static 256 byte buffer which is initialized to the empty string. In the case of the 'command' file this buffer is literally never used and simply wastes space. In the case of the 'netdev_ops' file, the last command written is saved here.  On read, the files contents are presented as the name of the device followed by a colon and then the contents of their respective static buffer. For 'command' this will always be \"<device>: \". For 'netdev_ops', this will be \"<device>: <last command written>\". But note the buffer is shared between all devices operated by this module. At best, it is mostly meaningless information, and at worse it could be accessed simultaneously as there doesn't appear to be any locking mechanism.  We have also recently received multiple reports for both read functions about their use of snprintf and potential overflow that could result in reading arbitrary kernel memory. For the 'command' file, this is definitely impossible, since the static buffer is always zero and never written to. For the 'netdev_ops' file, it does appear to be possible, if the user carefully crafts the command input, it will be copied into the buffer, which could be large enough to cause snprintf to truncate, which then causes the copy_to_user to read beyond the length of the buffer allocated by kzalloc.  A minimal fix would be to replace snprintf() with scnprintf() which would cap the return to the number of bytes written, preventing an overflow. A more involved fix would be to drop the mostly useless static buffers, saving 512 bytes and modifying the read functions to stop needing those as input.  Instead, lets just completely drop the read access to these files. These are debug interfaces exposed as part of debugfs, and I don't believe that dropping read access will break any script, as the provided output is pretty useless. You can find the netdev name through other more standard interfaces, and the 'netdev_ops' interface can easily result in garbage if you issue simultaneous writes to multiple devices at once.  In order to properly remove the i40e_dbg_netdev_ops_buf, we need to refactor its write function to avoid using the static buffer. Instead, use the same logic as the i40e_dbg_command_write, with an allocated buffer. Update the code to use this instead of the static buffer, and ensure we free the buffer on exit. This fixes simultaneous writes to 'netdev_ops' on multiple devices, and allows us to remove the now unused static buffer along with removing the read access.",
      "cve": "CVE-2025-39901",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39901",
          "value": "CVE-2025-39901",
          "url": "https://scout.docker.com/v/CVE-2025-39901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "529bc8470a32d4068ee1e810157e39d7d057ebd54b623f814d1fe147e7677ff7",
      "category": "container_scanning",
      "message": "CVE-2025-39905 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: phylink: add lock for serializing concurrent pl->phydev writes with resolver  Currently phylink_resolve() protects itself against concurrent phylink_bringup_phy() or phylink_disconnect_phy() calls which modify pl->phydev by relying on pl->state_mutex.  The problem is that in phylink_resolve(), pl->state_mutex is in a lock inversion state with pl->phydev->lock. So pl->phydev->lock needs to be acquired prior to pl->state_mutex. But that requires dereferencing pl->phydev in the first place, and without pl->state_mutex, that is racy.  Hence the reason for the extra lock. Currently it is redundant, but it will serve a functional purpose once mutex_lock(&phy->lock) will be moved outside of the mutex_lock(&pl->state_mutex) section.  Another alternative considered would have been to let phylink_resolve() acquire the rtnl_mutex, which is also held when phylink_bringup_phy() and phylink_disconnect_phy() are called. But since phylink_disconnect_phy() runs under rtnl_lock(), it would deadlock with phylink_resolve() when calling flush_work(&pl->resolve). Additionally, it would have been undesirable because it would have unnecessarily blocked many other call paths as well in the entire kernel, so the smaller-scoped lock was preferred.",
      "cve": "CVE-2025-39905",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39905",
          "value": "CVE-2025-39905",
          "url": "https://scout.docker.com/v/CVE-2025-39905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1a4bc59a60d636c8660ece3aef92695e83f299695411bd94fdd0f2cd8b16385",
      "category": "container_scanning",
      "message": "CVE-2025-39908 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: dev_ioctl: take ops lock in hwtstamp lower paths  ndo hwtstamp callbacks are expected to run under the per-device ops lock. Make the lower get/set paths consistent with the rest of ndo invocations.  Kernel log: WARNING: CPU: 13 PID: 51364 at ./include/net/netdev_lock.h:70 __netdev_update_features+0x4bd/0xe60 ... RIP: 0010:__netdev_update_features+0x4bd/0xe60 ... Call Trace: <TASK> netdev_update_features+0x1f/0x60 mlx5_hwtstamp_set+0x181/0x290 [mlx5_core] mlx5e_hwtstamp_set+0x19/0x30 [mlx5_core] dev_set_hwtstamp_phylib+0x9f/0x220 dev_set_hwtstamp_phylib+0x9f/0x220 dev_set_hwtstamp+0x13d/0x240 dev_ioctl+0x12f/0x4b0 sock_ioctl+0x171/0x370 __x64_sys_ioctl+0x3f7/0x900 ? __sys_setsockopt+0x69/0xb0 do_syscall_64+0x6f/0x2e0 entry_SYSCALL_64_after_hwframe+0x4b/0x53 ... </TASK> .... ---[ end trace 0000000000000000 ]---  Note that the mlx5_hwtstamp_set and mlx5e_hwtstamp_set functions shown in the trace come from an in progress patch converting the legacy ioctl to ndo_hwtstamp_get/set and are not present in mainline.",
      "cve": "CVE-2025-39908",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39908",
          "value": "CVE-2025-39908",
          "url": "https://scout.docker.com/v/CVE-2025-39908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "037914e09c04ea3a6010add2d40c5bb4e0738019c63c4ecc1cee8a479139f892",
      "category": "container_scanning",
      "message": "CVE-2025-39925 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  can: j1939: implement NETDEV_UNREGISTER notification handler  syzbot is reporting  unregister_netdevice: waiting for vcan0 to become free. Usage count = 2  problem, for j1939 protocol did not have NETDEV_UNREGISTER notification handler for undoing changes made by j1939_sk_bind().  Commit 25fe97cb7620 (\"can: j1939: move j1939_priv_put() into sk_destruct callback\") expects that a call to j1939_priv_put() can be unconditionally delayed until j1939_sk_sock_destruct() is called. But we need to call j1939_priv_put() against an extra ref held by j1939_sk_bind() call (as a part of undoing changes made by j1939_sk_bind()) as soon as NETDEV_UNREGISTER notification fires (i.e. before j1939_sk_sock_destruct() is called via j1939_sk_release()). Otherwise, the extra ref on \"struct j1939_priv\" held by j1939_sk_bind() call prevents \"struct net_device\" from dropping the usage count to 1; making it impossible for unregister_netdevice() to continue.  [mkl: remove space in front of label]",
      "cve": "CVE-2025-39925",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39925",
          "value": "CVE-2025-39925",
          "url": "https://scout.docker.com/v/CVE-2025-39925?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39925?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9de5815802e85b7ea066600ab657ef7c90d563c7e22893d955080d3603798e92",
      "category": "container_scanning",
      "message": "CVE-2025-39927 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: fix race condition validating r_parent before applying state  Add validation to ensure the cached parent directory inode matches the directory info in MDS replies. This prevents client-side race conditions where concurrent operations (e.g. rename) cause r_parent to become stale between request initiation and reply processing, which could lead to applying state changes to incorrect directory inodes.  [ idryomov: folded a kerneldoc fixup and a follow-up fix from Alex to move CEPH_CAP_PIN reference when r_parent is updated:  When the parent directory lock is not held, req->r_parent can become stale and is updated to point to the correct inode.  However, the associated CEPH_CAP_PIN reference was not being adjusted.  The CEPH_CAP_PIN is a reference on an inode that is tracked for accounting purposes.  Moving this pin is important to keep the accounting balanced. When the pin was not moved from the old parent to the new one, it created two problems: The reference on the old, stale parent was never released, causing a reference leak. A reference for the new parent was never acquired, creating the risk of a reference underflow later in ceph_mdsc_release_request().  This patch corrects the logic by releasing the pin from the old parent and acquiring it for the new parent when r_parent is switched.  This ensures reference accounting stays balanced. ]",
      "cve": "CVE-2025-39927",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39927",
          "value": "CVE-2025-39927",
          "url": "https://scout.docker.com/v/CVE-2025-39927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aa6d530aab820c9b9202d363ae845ac455377d52d0611e91c2f5e7409556435a",
      "category": "container_scanning",
      "message": "CVE-2025-39929 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix smbdirect_recv_io leak in smbd_negotiate() error path  During tests of another unrelated patch I was able to trigger this error: Objects remaining on __kmem_cache_shutdown()",
      "cve": "CVE-2025-39929",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39929",
          "value": "CVE-2025-39929",
          "url": "https://scout.docker.com/v/CVE-2025-39929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "242e04124a63ed6311a528af5ed4b4b590194c13d25415195466ac1dce212cdb",
      "category": "container_scanning",
      "message": "CVE-2025-39931 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: af_alg - Set merge to zero early in af_alg_sendmsg  If an error causes af_alg_sendmsg to abort, ctx->merge may contain a garbage value from the previous loop.  This may then trigger a crash on the next entry into af_alg_sendmsg when it attempts to do a merge that can't be done.  Fix this by setting ctx->merge to zero near the start of the loop.",
      "cve": "CVE-2025-39931",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39931",
          "value": "CVE-2025-39931",
          "url": "https://scout.docker.com/v/CVE-2025-39931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "38648ca6b624d1a1a7d0881ef9758b1d3136d26f13bac2d8e6f18dd0d9e72b5c",
      "category": "container_scanning",
      "message": "CVE-2025-39932 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: let smbd_destroy() call disable_work_sync(&info->post_send_credits_work)  In smbd_destroy() we may destroy the memory so we better wait until post_send_credits_work is no longer pending and will never be started again.  I actually just hit the case using rxe:  WARNING: CPU: 0 PID: 138 at drivers/infiniband/sw/rxe/rxe_verbs.c:1032 rxe_post_recv+0x1ee/0x480 [rdma_rxe] ... [ 5305.686979] [    T138]  smbd_post_recv+0x445/0xc10 [cifs] [ 5305.687135] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5 [ 5305.687149] [    T138]  ? __kasan_check_write+0x14/0x30 [ 5305.687185] [    T138]  ? __pfx_smbd_post_recv+0x10/0x10 [cifs] [ 5305.687329] [    T138]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 5305.687356] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5 [ 5305.687368] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5 [ 5305.687378] [    T138]  ? _raw_spin_unlock_irqrestore+0x11/0x60 [ 5305.687389] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5 [ 5305.687399] [    T138]  ? get_receive_buffer+0x168/0x210 [cifs] [ 5305.687555] [    T138]  smbd_post_send_credits+0x382/0x4b0 [cifs] [ 5305.687701] [    T138]  ? __pfx_smbd_post_send_credits+0x10/0x10 [cifs] [ 5305.687855] [    T138]  ? __pfx___schedule+0x10/0x10 [ 5305.687865] [    T138]  ? __pfx__raw_spin_lock_irq+0x10/0x10 [ 5305.687875] [    T138]  ? queue_delayed_work_on+0x8e/0xa0 [ 5305.687889] [    T138]  process_one_work+0x629/0xf80 [ 5305.687908] [    T138]  ? srso_alias_return_thunk+0x5/0xfbef5 [ 5305.687917] [    T138]  ? __kasan_check_write+0x14/0x30 [ 5305.687933] [    T138]  worker_thread+0x87f/0x1570 ...  It means rxe_post_recv was called after rdma_destroy_qp(). This happened because put_receive_buffer() was triggered by ib_drain_qp() and called: queue_work(info->workqueue, &info->post_send_credits_work);",
      "cve": "CVE-2025-39932",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39932",
          "value": "CVE-2025-39932",
          "url": "https://scout.docker.com/v/CVE-2025-39932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2d8381f62e2bd38b9afcb42e6d0c066841c87a36f10016968690755b2d6d1011",
      "category": "container_scanning",
      "message": "CVE-2025-39933 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: let recv_done verify data_offset, data_length and remaining_data_length  This is inspired by the related server fixes.",
      "cve": "CVE-2025-39933",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39933",
          "value": "CVE-2025-39933",
          "url": "https://scout.docker.com/v/CVE-2025-39933?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39933?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "99b918d52fd38bc2b63d84e72353e5fd391f87a2bcda7f605d6d0946b734ce4c",
      "category": "container_scanning",
      "message": "CVE-2025-39940 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm-stripe: fix a possible integer overflow  There's a possible integer overflow in stripe_io_hints if we have too large chunk size. Test if the overflow happened, and if it did, don't set limits->io_min and limits->io_opt;",
      "cve": "CVE-2025-39940",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39940",
          "value": "CVE-2025-39940",
          "url": "https://scout.docker.com/v/CVE-2025-39940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "65cdedcb6d946832eb492f0b0bc007001e6110baf3a19365c5b38dac2e550d3a",
      "category": "container_scanning",
      "message": "CVE-2025-39942 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: smbdirect: verify remaining_data_length respects max_fragmented_recv_size  This is inspired by the check for data_offset + data_length.",
      "cve": "CVE-2025-39942",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39942",
          "value": "CVE-2025-39942",
          "url": "https://scout.docker.com/v/CVE-2025-39942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "47ebeccdd683ade230b277f82db0897f1ced449f6026a5346a82d22b52974d24",
      "category": "container_scanning",
      "message": "CVE-2025-39947 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Harden uplink netdev access against device unbind  The function mlx5_uplink_netdev_get() gets the uplink netdevice pointer from mdev->mlx5e_res.uplink_netdev. However, the netdevice can be removed and its pointer cleared when unbound from the mlx5_core.eth driver. This results in a NULL pointer, causing a kernel panic.  BUG: unable to handle page fault for address: 0000000000001300 at RIP: 0010:mlx5e_vport_rep_load+0x22a/0x270 [mlx5_core] Call Trace: <TASK> mlx5_esw_offloads_rep_load+0x68/0xe0 [mlx5_core] esw_offloads_enable+0x593/0x910 [mlx5_core] mlx5_eswitch_enable_locked+0x341/0x420 [mlx5_core] mlx5_devlink_eswitch_mode_set+0x17e/0x3a0 [mlx5_core] devlink_nl_eswitch_set_doit+0x60/0xd0 genl_family_rcv_msg_doit+0xe0/0x130 genl_rcv_msg+0x183/0x290 netlink_rcv_skb+0x4b/0xf0 genl_rcv+0x24/0x40 netlink_unicast+0x255/0x380 netlink_sendmsg+0x1f3/0x420 __sock_sendmsg+0x38/0x60 __sys_sendto+0x119/0x180 do_syscall_64+0x53/0x1d0 entry_SYSCALL_64_after_hwframe+0x4b/0x53  Ensure the pointer is valid before use by checking it for NULL. If it is valid, immediately call netdev_hold() to take a reference, and preventing the netdevice from being freed while it is in use.",
      "cve": "CVE-2025-39947",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39947",
          "value": "CVE-2025-39947",
          "url": "https://scout.docker.com/v/CVE-2025-39947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "17be7cbb15c595d10d40ac61887be75cc54403c8a203244609f010ddee277674",
      "category": "container_scanning",
      "message": "CVE-2025-39952 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: wilc1000: avoid buffer overflow in WID string configuration  Fix the following copy overflow warning identified by Smatch checker.  drivers/net/wireless/microchip/wilc1000/wlan_cfg.c:184 wilc_wlan_parse_response_frame() error: '__memcpy()' 'cfg->s[i]->str' copy overflow (512 vs 65537)  This patch introduces size check before accessing the memory buffer. The checks are base on the WID type of received data from the firmware. For WID string configuration, the size limit is determined by individual element size in 'struct wilc_cfg_str_vals' that is maintained in 'len' field of 'struct wilc_cfg_str'.",
      "cve": "CVE-2025-39952",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39952",
          "value": "CVE-2025-39952",
          "url": "https://scout.docker.com/v/CVE-2025-39952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4e9dd4ad602777f3989cbbcceeff787524ee7984c6ebc3b4aba333661f65caf0",
      "category": "container_scanning",
      "message": "CVE-2025-39957 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: increase scan_ies_len for S1G  Currently the S1G capability element is not taken into account for the scan_ies_len, which leads to a buffer length validation failure in ieee80211_prep_hw_scan() and subsequent WARN in __ieee80211_start_scan(). This prevents hw scanning from functioning. To fix ensure we accommodate for the S1G capability length.",
      "cve": "CVE-2025-39957",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39957",
          "value": "CVE-2025-39957",
          "url": "https://scout.docker.com/v/CVE-2025-39957?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39957?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5dd751f89bf799eef54796df24cd95b83bd304e677623c5628023499a5ecda66",
      "category": "container_scanning",
      "message": "CVE-2025-39958 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/s390: Make attach succeed when the device was surprise removed  When a PCI device is removed with surprise hotplug, there may still be attempts to attach the device to the default domain as part of tear down via (__iommu_release_dma_ownership()), or because the removal happens during probe (__iommu_probe_device()). In both cases zpci_register_ioat() fails with a cc value indicating that the device handle is invalid. This is because the device is no longer part of the instance as far as the hypervisor is concerned.  Currently this leads to an error return and s390_iommu_attach_device() fails. This triggers the WARN_ON() in __iommu_group_set_domain_nofail() because attaching to the default domain must never fail.  With the device fenced by the hypervisor no DMAs to or from memory are possible and the IOMMU translations have no effect. Proceed as if the registration was successful and let the hotplug event handling clean up the device.  This is similar to how devices in the error state are handled since commit 59bbf596791b (\"iommu/s390: Make attach succeed even if the device is in error state\") except that for removal the domain will not be registered later. This approach was also previously discussed at the link.  Handle both cases, error state and removal, in a helper which checks if the error needs to be propagated or ignored. Avoid magic number condition codes by using the pre-existing, but never used, defines for PCI load/store condition codes and rename them to reflect that they apply to all PCI instructions.",
      "cve": "CVE-2025-39958",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39958",
          "value": "CVE-2025-39958",
          "url": "https://scout.docker.com/v/CVE-2025-39958?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39958?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "87ac3129e018f515f88b31cf1be3674882c39f989dde6d6d3aa57b6261bf20d7",
      "category": "container_scanning",
      "message": "CVE-2025-39961 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/amd/pgtbl: Fix possible race while increase page table level  The AMD IOMMU host page table implementation supports dynamic page table levels (up to 6 levels), starting with a 3-level configuration that expands based on IOVA address. The kernel maintains a root pointer and current page table level to enable proper page table walks in alloc_pte()/fetch_pte() operations.  The IOMMU IOVA allocator initially starts with 32-bit address and onces its exhuasted it switches to 64-bit address (max address is determined based on IOMMU and device DMA capability). To support larger IOVA, AMD IOMMU driver increases page table level.  But in unmap path (iommu_v1_unmap_pages()), fetch_pte() reads pgtable->[root/mode] without lock. So its possible that in exteme corner case, when increase_address_space() is updating pgtable->[root/mode], fetch_pte() reads wrong page table level (pgtable->mode). It does compare the value with level encoded in page table and returns NULL. This will result is iommu_unmap ops to fail and upper layer may retry/log WARN_ON.  CPU 0                                         CPU 1 ------                                       ------ map pages                                    unmap pages alloc_pte() -> increase_address_space()      iommu_v1_unmap_pages() -> fetch_pte() pgtable->root = pte (new root value) READ pgtable->[mode/root] Reads new root, old mode Updates mode (pgtable->mode += 1)  Since Page table level updates are infrequent and already synchronized with a spinlock, implement seqcount to enable lock-free read operations on the read path.",
      "cve": "CVE-2025-39961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39961",
          "value": "CVE-2025-39961",
          "url": "https://scout.docker.com/v/CVE-2025-39961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "088cb17296e4ecc666a602a4a3658883e40b9a667a20184b8157aabead96d739",
      "category": "container_scanning",
      "message": "CVE-2025-39977 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  futex: Prevent use-after-free during requeue-PI  syzbot managed to trigger the following race:  T1                               T2  futex_wait_requeue_pi() futex_do_wait() schedule() futex_requeue() futex_proxy_trylock_atomic() futex_requeue_pi_prepare() requeue_pi_wake_futex() futex_requeue_pi_complete() /* preempt */  * timeout/ signal wakes T1 *  futex_requeue_pi_wakeup_sync() // Q_REQUEUE_PI_LOCKED futex_hash_put() // back to userland, on stack futex_q is garbage  /* back */ wake_up_state(q->task, TASK_NORMAL);  In this scenario futex_wait_requeue_pi() is able to leave without using futex_q::lock_ptr for synchronization.  This can be prevented by reading futex_q::task before updating the futex_q::requeue_state. A reference on the task_struct is not needed because requeue_pi_wake_futex() is invoked with a spinlock_t held which implies a RCU read section.  Even if T1 terminates immediately after, the task_struct will remain valid during T2's wake_up_state().  A READ_ONCE on futex_q::task before futex_requeue_pi_complete() is enough because it ensures that the variable is read before the state is updated.  Read futex_q::task before updating the requeue state, use it for the following wakeup.",
      "cve": "CVE-2025-39977",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39977",
          "value": "CVE-2025-39977",
          "url": "https://scout.docker.com/v/CVE-2025-39977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f12cc9fc2b7e7479fe2e3290d518292168d5eab9e64e4b71901daf382ae71986",
      "category": "container_scanning",
      "message": "CVE-2025-39978 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  octeontx2-pf: Fix potential use after free in otx2_tc_add_flow()  This code calls kfree_rcu(new_node, rcu) and then dereferences \"new_node\" and then dereferences it on the next line.  Two lines later, we take a mutex so I don't think this is an RCU safe region.  Re-order it to do the dereferences before queuing up the free.",
      "cve": "CVE-2025-39978",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39978",
          "value": "CVE-2025-39978",
          "url": "https://scout.docker.com/v/CVE-2025-39978?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39978?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "83f58ca6ad80bb0fa6f1c5f1c84e85899ad10ec8d40938d9c8ca858d7a41e866",
      "category": "container_scanning",
      "message": "CVE-2025-39989 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mce: use is_copy_from_user() to determine copy-from-user context  Patch series \"mm/hwpoison: Fix regressions in memory failure handling\", v4.  ## 1. What am I trying to do:  This patchset resolves two critical regressions related to memory failure handling that have appeared in the upstream kernel since version 5.17, as compared to 5.10 LTS.  - copyin case: poison found in user page while kernel copying from user space - instr case: poison found while instruction fetching in user space  ## 2. What is the expected outcome and why  - For copyin case:  Kernel can recover from poison found where kernel is doing get_user() or copy_from_user() if those places get an error return and the kernel return -EFAULT to the process instead of crashing.  More specifily, MCE handler checks the fixup handler type to decide whether an in kernel #MC can be recovered.  When EX_TYPE_UACCESS is found, the PC jumps to recovery code specified in _ASM_EXTABLE_FAULT() and return a -EFAULT to user space.  - For instr case:  If a poison found while instruction fetching in user space, full recovery is possible.  User process takes #PF, Linux allocates a new page and fills by reading from storage.   ## 3. What actually happens and why  - For copyin case: kernel panic since v5.17  Commit 4c132d1d844a (\"x86/futex: Remove .fixup usage\") introduced a new extable fixup type, EX_TYPE_EFAULT_REG, and later patches updated the extable fixup type for copy-from-user operations, changing it from EX_TYPE_UACCESS to EX_TYPE_EFAULT_REG.  It breaks previous EX_TYPE_UACCESS handling when posion found in get_user() or copy_from_user().  - For instr case: user process is killed by a SIGBUS signal due to #CMCI and #MCE race  When an uncorrected memory error is consumed there is a race between the CMCI from the memory controller reporting an uncorrected error with a UCNA signature, and the core reporting and SRAR signature machine check when the data is about to be consumed.  ### Background: why *UN*corrected errors tied to *C*MCI in Intel platform [1]  Prior to Icelake memory controllers reported patrol scrub events that detected a previously unseen uncorrected error in memory by signaling a broadcast machine check with an SRAO (Software Recoverable Action Optional) signature in the machine check bank.  This was overkill because it's not an urgent problem that no core is on the verge of consuming that bad data.  It's also found that multi SRAO UCE may cause nested MCE interrupts and finally become an IERR.  Hence, Intel downgrades the machine check bank signature of patrol scrub from SRAO to UCNA (Uncorrected, No Action required), and signal changed to #CMCI.  Just to add to the confusion, Linux does take an action (in uc_decode_notifier()) to try to offline the page despite the UC*NA* signature name.  ### Background: why #CMCI and #MCE race when poison is consuming in Intel platform [1]  Having decided that CMCI/UCNA is the best action for patrol scrub errors, the memory controller uses it for reads too.  But the memory controller is executing asynchronously from the core, and can't tell the difference between a \"real\" read and a speculative read.  So it will do CMCI/UCNA if an error is found in any read.  Thus:  1) Core is clever and thinks address A is needed soon, issues a speculative read.  2) Core finds it is going to use address A soon after sending the read request  3) The CMCI from the memory controller is in a race with MCE from the core that will soon try to retire the load from address A.  Quite often (because speculation has got better) the CMCI from the memory controller is delivered before the core is committed to the instruction reading address A, so the interrupt is taken, and Linux offlines the page (marking it as poison).   ## Why user process is killed for instr case  Commit 046545a661af (\"mm/hwpoison: fix error page recovered but reported \"not ---truncated---",
      "cve": "CVE-2025-39989",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39989",
          "value": "CVE-2025-39989",
          "url": "https://scout.docker.com/v/CVE-2025-39989?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39989?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2c3dafc27fd900e97f63dcefda87686839d0f7e0c50dae6eb0b36d111afd210",
      "category": "container_scanning",
      "message": "CVE-2025-39990 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Check the helper function is valid in get_helper_proto  kernel test robot reported verifier bug [1] where the helper func pointer could be NULL due to disabled config option.  As Alexei suggested we could check on that in get_helper_proto directly. Marking tail_call helper func with BPF_PTR_POISON, because it is unused by design.  [1] https://lore.kernel.org/oe-lkp/202507160818.68358831-lkp@intel.com",
      "cve": "CVE-2025-39990",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39990",
          "value": "CVE-2025-39990",
          "url": "https://scout.docker.com/v/CVE-2025-39990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ac3438e5358b7b41bcafe88a900ea3544b97cf6f997d45f7a19ba85061a1fe1f",
      "category": "container_scanning",
      "message": "CVE-2025-39992 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: swap: check for stable address space before operating on the VMA  It is possible to hit a zero entry while traversing the vmas in unuse_mm() called from swapoff path and accessing it causes the OOPS:  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000446--> Loading the memory from offset 0x40 on the XA_ZERO_ENTRY as address. Mem abort info: ESR = 0x0000000096000005 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x05: level 1 translation fault  The issue is manifested from the below race between the fork() on a process and swapoff: fork(dup_mmap())\t\t\tswapoff(unuse_mm) ---------------                         ----------------- 1) Identical mtree is built using __mt_dup().  2) copy_pte_range()--> copy_nonpresent_pte(): The dst mm is added into the mmlist to be visible to the swapoff operation.  3) Fatal signal is sent to the parent process(which is the current during the fork) thus skip the duplication of the vmas and mark the vma range with XA_ZERO_ENTRY as a marker for this process that helps during exit_mmap().  4) swapoff is tried on the 'mm' added to the 'mmlist' as part of the 2.  5) unuse_mm(), that iterates through the vma's of this 'mm' will hit the non-NULL zero entry and operating on this zero entry as a vma is resulting into the oops.  The proper fix would be around not exposing this partially-valid tree to others when droping the mmap lock, which is being solved with [1].  A simpler solution would be checking for MMF_UNSTABLE, as it is set if mm_struct is not fully initialized in dup_mmap().  Thanks to Liam/Lorenzo/David for all the suggestions in fixing this issue.",
      "cve": "CVE-2025-39992",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39992",
          "value": "CVE-2025-39992",
          "url": "https://scout.docker.com/v/CVE-2025-39992?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39992?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "de6b294bdba3ffbdc4f64b5a60a01c41c6e4b3be0bb06d0b830e38d84bd72c55",
      "category": "container_scanning",
      "message": "CVE-2025-39993 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: rc: fix races with imon_disconnect()  Syzbot reports a KASAN issue as below: BUG: KASAN: use-after-free in __create_pipe include/linux/usb.h:1945 [inline] BUG: KASAN: use-after-free in send_packet+0xa2d/0xbc0 drivers/media/rc/imon.c:627 Read of size 4 at addr ffff8880256fb000 by task syz-executor314/4465  CPU: 2 PID: 4465 Comm: syz-executor314 Not tainted 6.0.0-rc1-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.14.0-2 04/01/2014 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:317 [inline] print_report.cold+0x2ba/0x6e9 mm/kasan/report.c:433 kasan_report+0xb1/0x1e0 mm/kasan/report.c:495 __create_pipe include/linux/usb.h:1945 [inline] send_packet+0xa2d/0xbc0 drivers/media/rc/imon.c:627 vfd_write+0x2d9/0x550 drivers/media/rc/imon.c:991 vfs_write+0x2d7/0xdd0 fs/read_write.c:576 ksys_write+0x127/0x250 fs/read_write.c:631 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd  The iMON driver improperly releases the usb_device reference in imon_disconnect without coordinating with active users of the device.  Specifically, the fields usbdev_intf0 and usbdev_intf1 are not protected by the users counter (ictx->users). During probe, imon_init_intf0 or imon_init_intf1 increments the usb_device reference count depending on the interface. However, during disconnect, usb_put_dev is called unconditionally, regardless of actual usage.  As a result, if vfd_write or other operations are still in progress after disconnect, this can lead to a use-after-free of the usb_device pointer.  Thread 1 vfd_write                      Thread 2 imon_disconnect ... if usb_put_dev(ictx->usbdev_intf0) else usb_put_dev(ictx->usbdev_intf1) ... while send_packet if pipe = usb_sndintpipe( ictx->usbdev_intf0) UAF else pipe = usb_sndctrlpipe( ictx->usbdev_intf0, 0) UAF  Guard access to usbdev_intf0 and usbdev_intf1 after disconnect by checking ictx->disconnected in all writer paths. Add early return with -ENODEV in send_packet(), vfd_write(), lcd_write() and display_open() if the device is no longer present.  Set and read ictx->disconnected under ictx->lock to ensure memory synchronization. Acquire the lock in imon_disconnect() before setting the flag to synchronize with any ongoing operations.  Ensure writers exit early and safely after disconnect before the USB core proceeds with cleanup.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "cve": "CVE-2025-39993",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39993",
          "value": "CVE-2025-39993",
          "url": "https://scout.docker.com/v/CVE-2025-39993?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39993?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "48b72786543605246d13fd987dcfbdd40dcb252633b87d7b265946bfab258e0e",
      "category": "container_scanning",
      "message": "CVE-2025-39994 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: tuner: xc5000: Fix use-after-free in xc5000_release  The original code uses cancel_delayed_work() in xc5000_release(), which does not guarantee that the delayed work item timer_sleep has fully completed if it was already running. This leads to use-after-free scenarios where xc5000_release() may free the xc5000_priv while timer_sleep is still active and attempts to dereference the xc5000_priv.  A typical race condition is illustrated below:  CPU 0 (release thread)                 | CPU 1 (delayed work callback) xc5000_release()                       | xc5000_do_timer_sleep() cancel_delayed_work()                | hybrid_tuner_release_state(priv)     | kfree(priv)                        | |   priv = container_of() // UAF  Replace cancel_delayed_work() with cancel_delayed_work_sync() to ensure that the timer_sleep is properly canceled before the xc5000_priv memory is deallocated.  A deadlock concern was considered: xc5000_release() is called in a process context and is not holding any locks that the timer_sleep work item might also need. Therefore, the use of the _sync() variant is safe here.  This bug was initially identified through static analysis.  [hverkuil: fix typo in Subject: tunner -> tuner]",
      "cve": "CVE-2025-39994",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39994",
          "value": "CVE-2025-39994",
          "url": "https://scout.docker.com/v/CVE-2025-39994?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39994?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d172d0767677c2b1f5d8e67c63c1aa37254630281900741f8f1fee943f4e3429",
      "category": "container_scanning",
      "message": "CVE-2025-39995 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: i2c: tc358743: Fix use-after-free bugs caused by orphan timer in probe  The state->timer is a cyclic timer that schedules work_i2c_poll and delayed_work_enable_hotplug, while rearming itself. Using timer_delete() fails to guarantee the timer isn't still running when destroyed, similarly cancel_delayed_work() cannot ensure delayed_work_enable_hotplug has terminated if already executing. During probe failure after timer initialization, these may continue running as orphans and reference the already-freed tc358743_state object through tc358743_irq_poll_timer.  The following is the trace captured by KASAN.  BUG: KASAN: slab-use-after-free in __run_timer_base.part.0+0x7d7/0x8c0 Write of size 8 at addr ffff88800ded83c8 by task swapper/1/0 ... Call Trace: <IRQ> dump_stack_lvl+0x55/0x70 print_report+0xcf/0x610 ? __pfx_sched_balance_find_src_group+0x10/0x10 ? __run_timer_base.part.0+0x7d7/0x8c0 kasan_report+0xb8/0xf0 ? __run_timer_base.part.0+0x7d7/0x8c0 __run_timer_base.part.0+0x7d7/0x8c0 ? rcu_sched_clock_irq+0xb06/0x27d0 ? __pfx___run_timer_base.part.0+0x10/0x10 ? try_to_wake_up+0xb15/0x1960 ? tmigr_update_events+0x280/0x740 ? _raw_spin_lock_irq+0x80/0xe0 ? __pfx__raw_spin_lock_irq+0x10/0x10 tmigr_handle_remote_up+0x603/0x7e0 ? __pfx_tmigr_handle_remote_up+0x10/0x10 ? sched_balance_trigger+0x98/0x9f0 ? sched_tick+0x221/0x5a0 ? _raw_spin_lock_irq+0x80/0xe0 ? __pfx__raw_spin_lock_irq+0x10/0x10 ? tick_nohz_handler+0x339/0x440 ? __pfx_tmigr_handle_remote_up+0x10/0x10 __walk_groups.isra.0+0x42/0x150 tmigr_handle_remote+0x1f4/0x2e0 ? __pfx_tmigr_handle_remote+0x10/0x10 ? ktime_get+0x60/0x140 ? lapic_next_event+0x11/0x20 ? clockevents_program_event+0x1d4/0x2a0 ? hrtimer_interrupt+0x322/0x780 handle_softirqs+0x16a/0x550 irq_exit_rcu+0xaf/0xe0 sysvec_apic_timer_interrupt+0x70/0x80 </IRQ> ...  Allocated by task 141: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x7f/0x90 __kmalloc_node_track_caller_noprof+0x198/0x430 devm_kmalloc+0x7b/0x1e0 tc358743_probe+0xb7/0x610  i2c_device_probe+0x51d/0x880 really_probe+0x1ca/0x5c0 __driver_probe_device+0x248/0x310 driver_probe_device+0x44/0x120 __device_attach_driver+0x174/0x220 bus_for_each_drv+0x100/0x190 __device_attach+0x206/0x370 bus_probe_device+0x123/0x170 device_add+0xd25/0x1470 i2c_new_client_device+0x7a0/0xcd0 do_one_initcall+0x89/0x300 do_init_module+0x29d/0x7f0 load_module+0x4f48/0x69e0 init_module_from_file+0xe4/0x150 idempotent_init_module+0x320/0x670 __x64_sys_finit_module+0xbd/0x120 do_syscall_64+0xac/0x280 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Freed by task 141: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3a/0x60 __kasan_slab_free+0x3f/0x50 kfree+0x137/0x370 release_nodes+0xa4/0x100 devres_release_group+0x1b2/0x380 i2c_device_probe+0x694/0x880 really_probe+0x1ca/0x5c0 __driver_probe_device+0x248/0x310 driver_probe_device+0x44/0x120 __device_attach_driver+0x174/0x220 bus_for_each_drv+0x100/0x190 __device_attach+0x206/0x370 bus_probe_device+0x123/0x170 device_add+0xd25/0x1470 i2c_new_client_device+0x7a0/0xcd0 do_one_initcall+0x89/0x300 do_init_module+0x29d/0x7f0 load_module+0x4f48/0x69e0 init_module_from_file+0xe4/0x150 idempotent_init_module+0x320/0x670 __x64_sys_finit_module+0xbd/0x120 do_syscall_64+0xac/0x280 entry_SYSCALL_64_after_hwframe+0x77/0x7f ...  Replace timer_delete() with timer_delete_sync() and cancel_delayed_work() with cancel_delayed_work_sync() to ensure proper termination of timer and work items before resource cleanup.  This bug was initially identified through static analysis. For reproduction and testing, I created a functional emulation of the tc358743 device via a kernel module and introduced faults through the debugfs interface.",
      "cve": "CVE-2025-39995",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39995",
          "value": "CVE-2025-39995",
          "url": "https://scout.docker.com/v/CVE-2025-39995?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39995?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c559d6c42b482ac5a30dc0a48b4b1e10e140f7495baa48432905988523f2dd7a",
      "category": "container_scanning",
      "message": "CVE-2025-39996 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: b2c2: Fix use-after-free causing by irq_check_work in flexcop_pci_remove  The original code uses cancel_delayed_work() in flexcop_pci_remove(), which does not guarantee that the delayed work item irq_check_work has fully completed if it was already running. This leads to use-after-free scenarios where flexcop_pci_remove() may free the flexcop_device while irq_check_work is still active and attempts to dereference the device.  A typical race condition is illustrated below:  CPU 0 (remove)                         | CPU 1 (delayed work callback) flexcop_pci_remove()                   | flexcop_pci_irq_check_work() cancel_delayed_work()                | flexcop_device_kfree(fc_pci->fc_dev) | |   fc = fc_pci->fc_dev; // UAF  This is confirmed by a KASAN report:  ================================================================== BUG: KASAN: slab-use-after-free in __run_timer_base.part.0+0x7d7/0x8c0 Write of size 8 at addr ffff8880093aa8c8 by task bash/135 ... Call Trace: <IRQ> dump_stack_lvl+0x55/0x70 print_report+0xcf/0x610 ? __run_timer_base.part.0+0x7d7/0x8c0 kasan_report+0xb8/0xf0 ? __run_timer_base.part.0+0x7d7/0x8c0 __run_timer_base.part.0+0x7d7/0x8c0 ? __pfx___run_timer_base.part.0+0x10/0x10 ? __pfx_read_tsc+0x10/0x10 ? ktime_get+0x60/0x140 ? lapic_next_event+0x11/0x20 ? clockevents_program_event+0x1d4/0x2a0 run_timer_softirq+0xd1/0x190 handle_softirqs+0x16a/0x550 irq_exit_rcu+0xaf/0xe0 sysvec_apic_timer_interrupt+0x70/0x80 </IRQ> ...  Allocated by task 1: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x7f/0x90 __kmalloc_noprof+0x1be/0x460 flexcop_device_kmalloc+0x54/0xe0 flexcop_pci_probe+0x1f/0x9d0 local_pci_probe+0xdc/0x190 pci_device_probe+0x2fe/0x470 really_probe+0x1ca/0x5c0 __driver_probe_device+0x248/0x310 driver_probe_device+0x44/0x120 __driver_attach+0xd2/0x310 bus_for_each_dev+0xed/0x170 bus_add_driver+0x208/0x500 driver_register+0x132/0x460 do_one_initcall+0x89/0x300 kernel_init_freeable+0x40d/0x720 kernel_init+0x1a/0x150 ret_from_fork+0x10c/0x1a0 ret_from_fork_asm+0x1a/0x30  Freed by task 135: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3a/0x60 __kasan_slab_free+0x3f/0x50 kfree+0x137/0x370 flexcop_device_kfree+0x32/0x50 pci_device_remove+0xa6/0x1d0 device_release_driver_internal+0xf8/0x210 pci_stop_bus_device+0x105/0x150 pci_stop_and_remove_bus_device_locked+0x15/0x30 remove_store+0xcc/0xe0 kernfs_fop_write_iter+0x2c3/0x440 vfs_write+0x871/0xd70 ksys_write+0xee/0x1c0 do_syscall_64+0xac/0x280 entry_SYSCALL_64_after_hwframe+0x77/0x7f ...  Replace cancel_delayed_work() with cancel_delayed_work_sync() to ensure that the delayed work item is properly canceled and any executing delayed work has finished before the device memory is deallocated.  This bug was initially identified through static analysis. To reproduce and test it, I simulated the B2C2 FlexCop PCI device in QEMU and introduced artificial delays within the flexcop_pci_irq_check_work() function to increase the likelihood of triggering the bug.",
      "cve": "CVE-2025-39996",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39996",
          "value": "CVE-2025-39996",
          "url": "https://scout.docker.com/v/CVE-2025-39996?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39996?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a900666bff32e6e3d66099460e50805bb11553214184a526422fe66a3b27dd71",
      "category": "container_scanning",
      "message": "CVE-2025-39998 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: target: target_core_configfs: Add length check to avoid buffer overflow  A buffer overflow arises from the usage of snprintf to write into the buffer \"buf\" in target_lu_gp_members_show function located in /drivers/target/target_core_configfs.c. This buffer is allocated with size LU_GROUP_NAME_BUF (256 bytes).  snprintf(...) formats multiple strings into buf with the HBA name (hba->hba_group.cg_item), a slash character, a devicename (dev-> dev_group.cg_item) and a newline character, the total formatted string length may exceed the buffer size of 256 bytes.  Since snprintf() returns the total number of bytes that would have been written (the length of %s/%sn ), this value may exceed the buffer length (256 bytes) passed to memcpy(), this will ultimately cause function memcpy reporting a buffer overflow error.  An additional check of the return value of snprintf() can avoid this buffer overflow.",
      "cve": "CVE-2025-39998",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-39998",
          "value": "CVE-2025-39998",
          "url": "https://scout.docker.com/v/CVE-2025-39998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-39998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "56ea62d65f5efe333dff83bc607ffd5ac64400c9c54dbd3f743e74595213c8eb",
      "category": "container_scanning",
      "message": "CVE-2025-40001 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mvsas: Fix use-after-free bugs in mvs_work_queue  During the detaching of Marvell's SAS/SATA controller, the original code calls cancel_delayed_work() in mvs_free() to cancel the delayed work item mwq->work_q. However, if mwq->work_q is already running, the cancel_delayed_work() may fail to cancel it. This can lead to use-after-free scenarios where mvs_free() frees the mvs_info while mvs_work_queue() is still executing and attempts to access the already-freed mvs_info.  A typical race condition is illustrated below:  CPU 0 (remove)            | CPU 1 (delayed work callback) mvs_pci_remove()          | mvs_free()              | mvs_work_queue() cancel_delayed_work() | kfree(mvi)          | |   mvi-> // UAF  Replace cancel_delayed_work() with cancel_delayed_work_sync() to ensure that the delayed work item is properly canceled and any executing delayed work item completes before the mvs_info is deallocated.  This bug was found by static analysis.",
      "cve": "CVE-2025-40001",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40001",
          "value": "CVE-2025-40001",
          "url": "https://scout.docker.com/v/CVE-2025-40001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "64a8f78d82eb98f8ed5770db0170a51bd9c5b7271f1a8092dc89d3fc00ff950d",
      "category": "container_scanning",
      "message": "CVE-2025-40003 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: mscc: ocelot: Fix use-after-free caused by cyclic delayed work  The origin code calls cancel_delayed_work() in ocelot_stats_deinit() to cancel the cyclic delayed work item ocelot->stats_work. However, cancel_delayed_work() may fail to cancel the work item if it is already executing. While destroy_workqueue() does wait for all pending work items in the work queue to complete before destroying the work queue, it cannot prevent the delayed work item from being rescheduled within the ocelot_check_stats_work() function. This limitation exists because the delayed work item is only enqueued into the work queue after its timer expires. Before the timer expiration, destroy_workqueue() has no visibility of this pending work item. Once the work queue appears empty, destroy_workqueue() proceeds with destruction. When the timer eventually expires, the delayed work item gets queued again, leading to the following warning:  workqueue: cannot queue ocelot_check_stats_work on wq ocelot-switch-stats WARNING: CPU: 2 PID: 0 at kernel/workqueue.c:2255 __queue_work+0x875/0xaf0 ... RIP: 0010:__queue_work+0x875/0xaf0 ... RSP: 0018:ffff88806d108b10 EFLAGS: 00010086 RAX: 0000000000000000 RBX: 0000000000000101 RCX: 0000000000000027 RDX: 0000000000000027 RSI: 0000000000000004 RDI: ffff88806d123e88 RBP: ffffffff813c3170 R08: 0000000000000000 R09: ffffed100da247d2 R10: ffffed100da247d1 R11: ffff88806d123e8b R12: ffff88800c00f000 R13: ffff88800d7285c0 R14: ffff88806d0a5580 R15: ffff88800d7285a0 FS:  0000000000000000(0000) GS:ffff8880e5725000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fe18e45ea10 CR3: 0000000005e6c000 CR4: 00000000000006f0 Call Trace: <IRQ> ? kasan_report+0xc6/0xf0 ? __pfx_delayed_work_timer_fn+0x10/0x10 ? __pfx_delayed_work_timer_fn+0x10/0x10 call_timer_fn+0x25/0x1c0 __run_timer_base.part.0+0x3be/0x8c0 ? __pfx_delayed_work_timer_fn+0x10/0x10 ? rcu_sched_clock_irq+0xb06/0x27d0 ? __pfx___run_timer_base.part.0+0x10/0x10 ? try_to_wake_up+0xb15/0x1960 ? _raw_spin_lock_irq+0x80/0xe0 ? __pfx__raw_spin_lock_irq+0x10/0x10 tmigr_handle_remote_up+0x603/0x7e0 ? __pfx_tmigr_handle_remote_up+0x10/0x10 ? sched_balance_trigger+0x1c0/0x9f0 ? sched_tick+0x221/0x5a0 ? _raw_spin_lock_irq+0x80/0xe0 ? __pfx__raw_spin_lock_irq+0x10/0x10 ? tick_nohz_handler+0x339/0x440 ? __pfx_tmigr_handle_remote_up+0x10/0x10 __walk_groups.isra.0+0x42/0x150 tmigr_handle_remote+0x1f4/0x2e0 ? __pfx_tmigr_handle_remote+0x10/0x10 ? ktime_get+0x60/0x140 ? lapic_next_event+0x11/0x20 ? clockevents_program_event+0x1d4/0x2a0 ? hrtimer_interrupt+0x322/0x780 handle_softirqs+0x16a/0x550 irq_exit_rcu+0xaf/0xe0 sysvec_apic_timer_interrupt+0x70/0x80 </IRQ> ...  The following diagram reveals the cause of the above warning:  CPU 0 (remove)             | CPU 1 (delayed work callback) mscc_ocelot_remove()       | ocelot_deinit()          | ocelot_check_stats_work() ocelot_stats_deinit()  | cancel_delayed_work()|   ... |   queue_delayed_work() destroy_workqueue()  | (wait a time) | __queue_work() //UAF  The above scenario actually constitutes a UAF vulnerability.  The ocelot_stats_deinit() is only invoked when initialization failure or resource destruction, so we must ensure that any delayed work items cannot be rescheduled.  Replace cancel_delayed_work() with disable_delayed_work_sync() to guarantee proper cancellation of the delayed work item and ensure completion of any currently executing work before the workqueue is deallocated.  A deadlock concern was considered: ocelot_stats_deinit() is called in a process context and is not holding any locks that the delayed work item might also need. Therefore, the use of the _sync() variant is safe here.  This bug was identified through static analysis. To reproduce the issue and validate the fix, I simulated ocelot-swit ---truncated---",
      "cve": "CVE-2025-40003",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40003",
          "value": "CVE-2025-40003",
          "url": "https://scout.docker.com/v/CVE-2025-40003?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40003?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fedc6e0c3c963f51839e283dc1241754460b288ee5be5905544e9620093d8524",
      "category": "container_scanning",
      "message": "CVE-2025-40005 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: cadence-quadspi: Implement refcount to handle unbind during busy  driver support indirect read and indirect write operation with assumption no force device removal(unbind) operation. However force device removal(removal) is still available to root superuser.  Unbinding driver during operation causes kernel crash. This changes ensure driver able to handle such operation for indirect read and indirect write by implementing refcount to track attached devices to the controller and gracefully wait and until attached devices remove operation completed before proceed with removal operation.",
      "cve": "CVE-2025-40005",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40005",
          "value": "CVE-2025-40005",
          "url": "https://scout.docker.com/v/CVE-2025-40005?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40005?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c34d2d850616ea990aeb0c27a74d9f694afd2b1ea90239c0a77998948a404f95",
      "category": "container_scanning",
      "message": "CVE-2025-40012 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: fix warning in smc_rx_splice() when calling get_page()  smc_lo_register_dmb() allocates DMB buffers with kzalloc(), which are later passed to get_page() in smc_rx_splice(). Since kmalloc memory is not page-backed, this triggers WARN_ON_ONCE() in get_page() and prevents holding a refcount on the buffer. This can lead to use-after-free if the memory is released before splice_to_pipe() completes.  Use folio_alloc() instead, ensuring DMBs are page-backed and safe for get_page().  WARNING: CPU: 18 PID: 12152 at ./include/linux/mm.h:1330 smc_rx_splice+0xaf8/0xe20 [smc] CPU: 18 UID: 0 PID: 12152 Comm: smcapp Kdump: loaded Not tainted 6.17.0-rc3-11705-g9cf4672ecfee #10 NONE Hardware name: IBM 3931 A01 704 (z/VM 7.4.0) Krnl PSW : 0704e00180000000 000793161032696c (smc_rx_splice+0xafc/0xe20 [smc]) R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3 Krnl GPRS: 0000000000000000 001cee80007d3001 00077400000000f8 0000000000000005 0000000000000001 001cee80007d3006 0007740000001000 001c000000000000 000000009b0c99e0 0000000000001000 001c0000000000f8 001c000000000000 000003ffcc6f7c88 0007740003e98000 0007931600000005 000792969b2ff7b8 Krnl Code: 0007931610326960: af000000\t\tmc\t0,0 0007931610326964: a7f4ff43\t\tbrc\t15,00079316103267ea #0007931610326968: af000000\t\tmc\t0,0 >000793161032696c: a7f4ff3f\t\tbrc\t15,00079316103267ea 0007931610326970: e320f1000004\tlg\t%r2,256(%r15) 0007931610326976: c0e53fd1b5f5\tbrasl\t%r14,000793168fd5d560 000793161032697c: a7f4fbb5\t\tbrc\t15,00079316103260e6 0007931610326980: b904002b\t\tlgr\t%r2,%r11 Call Trace: smc_rx_splice+0xafc/0xe20 [smc] smc_rx_splice+0x756/0xe20 [smc]) smc_rx_recvmsg+0xa74/0xe00 [smc] smc_splice_read+0x1ce/0x3b0 [smc] sock_splice_read+0xa2/0xf0 do_splice_read+0x198/0x240 splice_file_to_pipe+0x7e/0x110 do_splice+0x59e/0xde0 __do_splice+0x11a/0x2d0 __s390x_sys_splice+0x140/0x1f0 __do_syscall+0x122/0x280 system_call+0x6e/0x90 Last Breaking-Event-Address: smc_rx_splice+0x960/0xe20 [smc] ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2025-40012",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40012",
          "value": "CVE-2025-40012",
          "url": "https://scout.docker.com/v/CVE-2025-40012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f9f166f5bf3d56835c8b2e715c7a32e25fc6fd2698acc7bb028f9f6ec8d24f51",
      "category": "container_scanning",
      "message": "CVE-2025-40016 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: uvcvideo: Mark invalid entities with id UVC_INVALID_ENTITY_ID  Per UVC 1.1+ specification 3.7.2, units and terminals must have a non-zero unique ID.  ``` Each Unit and Terminal within the video function is assigned a unique identification number, the Unit ID (UID) or Terminal ID (TID), contained in the bUnitID or bTerminalID field of the descriptor. The value 0x00 is reserved for undefined ID, ```  If we add a new entity with id 0 or a duplicated ID, it will be marked as UVC_INVALID_ENTITY_ID.  In a previous attempt commit 3dd075fe8ebb (\"media: uvcvideo: Require entities to have a non-zero unique ID\"), we ignored all the invalid units, this broke a lot of non-compatible cameras. Hopefully we are more lucky this time.  This also prevents some syzkaller reproducers from triggering warnings due to a chain of entities referring to themselves. In one particular case, an Output Unit is connected to an Input Unit, both with the same ID of 1. But when looking up for the source ID of the Output Unit, that same entity is found instead of the input entity, which leads to such warnings.  In another case, a backward chain was considered finished as the source ID was 0. Later on, that entity was found, but its pads were not valid.  Here is a sample stack trace for one of those cases.  [   20.650953] usb 1-1: new high-speed USB device number 2 using dummy_hcd [   20.830206] usb 1-1: Using ep0 maxpacket: 8 [   20.833501] usb 1-1: config 0 descriptor?? [   21.038518] usb 1-1: string descriptor 0 read error: -71 [   21.038893] usb 1-1: Found UVC 0.00 device <unnamed> (2833:0201) [   21.039299] uvcvideo 1-1:0.0: Entity type for entity Output 1 was not initialized! [   21.041583] uvcvideo 1-1:0.0: Entity type for entity Input 1 was not initialized! [   21.042218] ------------[ cut here ]------------ [   21.042536] WARNING: CPU: 0 PID: 9 at drivers/media/mc/mc-entity.c:1147 media_create_pad_link+0x2c4/0x2e0 [   21.043195] Modules linked in: [   21.043535] CPU: 0 UID: 0 PID: 9 Comm: kworker/0:1 Not tainted 6.11.0-rc7-00030-g3480e43aeccf #444 [   21.044101] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 [   21.044639] Workqueue: usb_hub_wq hub_event [   21.045100] RIP: 0010:media_create_pad_link+0x2c4/0x2e0 [   21.045508] Code: fe e8 20 01 00 00 b8 f4 ff ff ff 48 83 c4 30 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 0f 0b eb e9 0f 0b eb 0a 0f 0b eb 06 <0f> 0b eb 02 0f 0b b8 ea ff ff ff eb d4 66 2e 0f 1f 84 00 00 00 00 [   21.046801] RSP: 0018:ffffc9000004b318 EFLAGS: 00010246 [   21.047227] RAX: ffff888004e5d458 RBX: 0000000000000000 RCX: ffffffff818fccf1 [   21.047719] RDX: 000000000000007b RSI: 0000000000000000 RDI: ffff888004313290 [   21.048241] RBP: ffff888004313290 R08: 0001ffffffffffff R09: 0000000000000000 [   21.048701] R10: 0000000000000013 R11: 0001888004313290 R12: 0000000000000003 [   21.049138] R13: ffff888004313080 R14: ffff888004313080 R15: 0000000000000000 [   21.049648] FS:  0000000000000000(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000 [   21.050271] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [   21.050688] CR2: 0000592cc27635b0 CR3: 000000000431c000 CR4: 0000000000750ef0 [   21.051136] PKRU: 55555554 [   21.051331] Call Trace: [   21.051480]  <TASK> [   21.051611]  ? __warn+0xc4/0x210 [   21.051861]  ? media_create_pad_link+0x2c4/0x2e0 [   21.052252]  ? report_bug+0x11b/0x1a0 [   21.052540]  ? trace_hardirqs_on+0x31/0x40 [   21.052901]  ? handle_bug+0x3d/0x70 [   21.053197]  ? exc_invalid_op+0x1a/0x50 [   21.053511]  ? asm_exc_invalid_op+0x1a/0x20 [   21.053924]  ? media_create_pad_link+0x91/0x2e0 [   21.054364]  ? media_create_pad_link+0x2c4/0x2e0 [   21.054834]  ? media_create_pad_link+0x91/0x2e0 [   21.055131]  ? _raw_spin_unlock+0x1e/0x40 [   21.055441]  ? __v4l2_device_register_subdev+0x202/0x210 [   21.055837]  uvc_mc_register_entities+0x358/0x400 [   21.056144]  uvc_register_chains+0x1 ---truncated---",
      "cve": "CVE-2025-40016",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40016",
          "value": "CVE-2025-40016",
          "url": "https://scout.docker.com/v/CVE-2025-40016?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40016?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "889fba013f15916e25de38035c181ef7d39eb80c3ad0520bb5f63f4f49d23d24",
      "category": "container_scanning",
      "message": "CVE-2025-40018 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipvs: Defer ip_vs_ftp unregister during netns cleanup  On the netns cleanup path, __ip_vs_ftp_exit() may unregister ip_vs_ftp before connections with valid cp->app pointers are flushed, leading to a use-after-free.  Fix this by introducing a global `exiting_module` flag, set to true in ip_vs_ftp_exit() before unregistering the pernet subsystem. In __ip_vs_ftp_exit(), skip ip_vs_ftp unregister if called during netns cleanup (when exiting_module is false) and defer it to __ip_vs_cleanup_batch(), which unregisters all apps after all connections are flushed. If called during module exit, unregister ip_vs_ftp immediately.",
      "cve": "CVE-2025-40018",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40018",
          "value": "CVE-2025-40018",
          "url": "https://scout.docker.com/v/CVE-2025-40018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f44cb11e5a73000a239c22577101c25f1c88bac87be081cf242853ac5b9eeee5",
      "category": "container_scanning",
      "message": "CVE-2025-40019 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: essiv - Check ssize for decryption and in-place encryption  Move the ssize check to the start in essiv_aead_crypt so that it's also checked for decryption and in-place encryption.",
      "cve": "CVE-2025-40019",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40019",
          "value": "CVE-2025-40019",
          "url": "https://scout.docker.com/v/CVE-2025-40019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40019?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2c18fee3ba1f3a92bf1cc4c06d21e47c513b179d839734661824fdb22e047e28",
      "category": "container_scanning",
      "message": "CVE-2025-40025 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to do sanity check on node footer for non inode dnode  As syzbot reported below:  ------------[ cut here ]------------ kernel BUG at fs/f2fs/file.c:1243! Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI CPU: 0 UID: 0 PID: 5354 Comm: syz.0.0 Not tainted 6.17.0-rc1-syzkaller-00211-g90d970cade8e #0 PREEMPT(full) RIP: 0010:f2fs_truncate_hole+0x69e/0x6c0 fs/f2fs/file.c:1243 Call Trace: <TASK> f2fs_punch_hole+0x2db/0x330 fs/f2fs/file.c:1306 f2fs_fallocate+0x546/0x990 fs/f2fs/file.c:2018 vfs_fallocate+0x666/0x7e0 fs/open.c:342 ksys_fallocate fs/open.c:366 [inline] __do_sys_fallocate fs/open.c:371 [inline] __se_sys_fallocate fs/open.c:369 [inline] __x64_sys_fallocate+0xc0/0x110 fs/open.c:369 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f1e65f8ebe9  w/ a fuzzed image, f2fs may encounter panic due to it detects inconsistent truncation range in direct node in f2fs_truncate_hole().  The root cause is: a non-inode dnode may has the same footer.ino and footer.nid, so the dnode will be parsed as an inode, then ADDRS_PER_PAGE() may return wrong blkaddr count which may be 923 typically, by chance, dn.ofs_in_node is equal to 923, then count can be calculated to 0 in below statement, later it will trigger panic w/ f2fs_bug_on(, count == 0 || ...).  count = min(end_offset - dn.ofs_in_node, pg_end - pg_start);  This patch introduces a new node_type NODE_TYPE_NON_INODE, then allowing passing the new_type to sanity_check_node_footer in f2fs_get_node_folio() to detect corruption that a non-inode dnode has the same footer.ino and footer.nid.  Scripts to reproduce: mkfs.f2fs -f /dev/vdb mount /dev/vdb /mnt/f2fs touch /mnt/f2fs/foo touch /mnt/f2fs/bar dd if=/dev/zero of=/mnt/f2fs/foo bs=1M count=8 umount /mnt/f2fs inject.f2fs --node --mb i_nid --nid 4 --idx 0 --val 5 /dev/vdb mount /dev/vdb /mnt/f2fs xfs_io /mnt/f2fs/foo -c \"fpunch 6984k 4k\"",
      "cve": "CVE-2025-40025",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40025",
          "value": "CVE-2025-40025",
          "url": "https://scout.docker.com/v/CVE-2025-40025?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40025?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e78a9c6e2d62934d77283c720adf51d69ff3b04da1b016e1b8e63bddf62e989",
      "category": "container_scanning",
      "message": "CVE-2025-40026 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86: Don't (re)check L1 intercepts when completing userspace I/O  When completing emulation of instruction that generated a userspace exit for I/O, don't recheck L1 intercepts as KVM has already finished that phase of instruction execution, i.e. has already committed to allowing L2 to perform I/O.  If L1 (or host userspace) modifies the I/O permission bitmaps during the exit to userspace,  KVM will treat the access as being intercepted despite already having emulated the I/O access.  Pivot on EMULTYPE_NO_DECODE to detect that KVM is completing emulation. Of the three users of EMULTYPE_NO_DECODE, only complete_emulated_io() (the intended \"recipient\") can reach the code in question.  gp_interception()'s use is mutually exclusive with is_guest_mode(), and complete_emulated_insn_gp() unconditionally pairs EMULTYPE_NO_DECODE with EMULTYPE_SKIP.  The bad behavior was detected by a syzkaller program that toggles port I/O interception during the userspace I/O exit, ultimately resulting in a WARN on vcpu->arch.pio.count being non-zero due to KVM no completing emulation of the I/O instruction.  WARNING: CPU: 23 PID: 1083 at arch/x86/kvm/x86.c:8039 emulator_pio_in_out+0x154/0x170 [kvm] Modules linked in: kvm_intel kvm irqbypass CPU: 23 UID: 1000 PID: 1083 Comm: repro Not tainted 6.16.0-rc5-c1610d2d66b1-next-vm #74 NONE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 RIP: 0010:emulator_pio_in_out+0x154/0x170 [kvm] PKRU: 55555554 Call Trace: <TASK> kvm_fast_pio+0xd6/0x1d0 [kvm] vmx_handle_exit+0x149/0x610 [kvm_intel] kvm_arch_vcpu_ioctl_run+0xda8/0x1ac0 [kvm] kvm_vcpu_ioctl+0x244/0x8c0 [kvm] __x64_sys_ioctl+0x8a/0xd0 do_syscall_64+0x5d/0xc60 entry_SYSCALL_64_after_hwframe+0x4b/0x53 </TASK>",
      "cve": "CVE-2025-40026",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40026",
          "value": "CVE-2025-40026",
          "url": "https://scout.docker.com/v/CVE-2025-40026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "75e3f3ab8113d172661320c81ebe0f0d4b5d8bbe3e5269bdbf9463d32f63b9d9",
      "category": "container_scanning",
      "message": "CVE-2025-40027 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/9p: fix double req put in p9_fd_cancelled  Syzkaller reports a KASAN issue as below:  general protection fault, probably for non-canonical address 0xfbd59c0000000021: 0000 [#1] PREEMPT SMP KASAN NOPTI KASAN: maybe wild-memory-access in range [0xdead000000000108-0xdead00000000010f] CPU: 0 PID: 5083 Comm: syz-executor.2 Not tainted 6.1.134-syzkaller-00037-g855bd1d7d838 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014 RIP: 0010:__list_del include/linux/list.h:114 [inline] RIP: 0010:__list_del_entry include/linux/list.h:137 [inline] RIP: 0010:list_del include/linux/list.h:148 [inline] RIP: 0010:p9_fd_cancelled+0xe9/0x200 net/9p/trans_fd.c:734  Call Trace: <TASK> p9_client_flush+0x351/0x440 net/9p/client.c:614 p9_client_rpc+0xb6b/0xc70 net/9p/client.c:734 p9_client_version net/9p/client.c:920 [inline] p9_client_create+0xb51/0x1240 net/9p/client.c:1027 v9fs_session_init+0x1f0/0x18f0 fs/9p/v9fs.c:408 v9fs_mount+0xba/0xcb0 fs/9p/vfs_super.c:126 legacy_get_tree+0x108/0x220 fs/fs_context.c:632 vfs_get_tree+0x8e/0x300 fs/super.c:1573 do_new_mount fs/namespace.c:3056 [inline] path_mount+0x6a6/0x1e90 fs/namespace.c:3386 do_mount fs/namespace.c:3399 [inline] __do_sys_mount fs/namespace.c:3607 [inline] __se_sys_mount fs/namespace.c:3584 [inline] __x64_sys_mount+0x283/0x300 fs/namespace.c:3584 do_syscall_x64 arch/x86/entry/common.c:51 [inline] do_syscall_64+0x35/0x80 arch/x86/entry/common.c:81 entry_SYSCALL_64_after_hwframe+0x6e/0xd8  This happens because of a race condition between:  - The 9p client sending an invalid flush request and later cleaning it up; - The 9p client in p9_read_work() canceled all pending requests.  Thread 1                              Thread 2 ... p9_client_create() ... p9_fd_create() ... p9_conn_create() ... // start Thread 2 INIT_WORK(&m->rq, p9_read_work); p9_read_work() ... p9_client_rpc() ... ... p9_conn_cancel() ... spin_lock(&m->req_lock); ... p9_fd_cancelled() ... ... spin_unlock(&m->req_lock); // status rewrite p9_client_cb(m->client, req, REQ_STATUS_ERROR) // first remove list_del(&req->req_list); ...  spin_lock(&m->req_lock) ... // second remove list_del(&req->req_list); spin_unlock(&m->req_lock) ...  Commit 74d6a5d56629 (\"9p/trans_fd: Fix concurrency del of req_list in p9_fd_cancelled/p9_read_work\") fixes a concurrency issue in the 9p filesystem client where the req_list could be deleted simultaneously by both p9_read_work and p9_fd_cancelled functions, but for the case where req->status equals REQ_STATUS_RCVD.  Update the check for req->status in p9_fd_cancelled to skip processing not just received requests, but anything that is not SENT, as whatever changed the state from SENT also removed the request from its list.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.  [updated the check from status == RECV || status == ERROR to status != SENT]",
      "cve": "CVE-2025-40027",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40027",
          "value": "CVE-2025-40027",
          "url": "https://scout.docker.com/v/CVE-2025-40027?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40027?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "69306f659eb2d1fa8b675f15563ae6a6a2395005a86bd0999f273d0983a07273",
      "category": "container_scanning",
      "message": "CVE-2025-40325 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md/raid10: wait barrier before returning discard request with REQ_NOWAIT  raid10_handle_discard should wait barrier before returning a discard bio which has REQ_NOWAIT. And there is no need to print warning calltrace if a discard bio has REQ_NOWAIT flag. Quality engineer usually checks dmesg and reports error if dmesg has warning/error calltrace.",
      "cve": "CVE-2025-40325",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-40325",
          "value": "CVE-2025-40325",
          "url": "https://scout.docker.com/v/CVE-2025-40325?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-40325?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a91df314bf8195a7407f2649267a1c2d353f03e2442105f13cae48fe4eb16290",
      "category": "container_scanning",
      "message": "CVE-2025-4516 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "There is an issue in CPython when using `bytes.decode(\"unicode_escape\", error=\"ignore|replace\")`. If you are not using the \"unicode_escape\" encoding or an error handler your usage is not affected. To work-around this issue you may stop using the error= handler and instead wrap the bytes.decode() call in a try-except catching the DecodeError.",
      "cve": "CVE-2025-4516",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-4516",
          "value": "CVE-2025-4516",
          "url": "https://scout.docker.com/v/CVE-2025-4516?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-4516?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1fcc7d2fb5bccebef648e99dbc750abfc37e532fe8f74690619c7a51c4e2bae3",
      "category": "container_scanning",
      "message": "CVE-2025-45582 on ubuntu/tar@1.34+dfsg-1ubuntu0.1.22.04.2",
      "description": "GNU Tar through 1.35 allows file overwrite via directory traversal in crafted TAR archives, with a certain two-step process. First, the victim must extract an archive that contains a ../ symlink to a critical directory. Second, the victim must extract an archive that contains a critical file, specified via a relative pathname that begins with the symlink name and ends with that critical file's name. Here, the extraction follows the symlink and overwrites the critical file. This bypasses the protection mechanism of \"Member name contains '..'\" that would occur for a single TAR archive that attempted to specify the critical file via a ../ approach. For example, the first archive can contain \"x -> ../../../../../home/victim/.ssh\" and the second archive can contain x/authorized_keys. This can affect server applications that automatically extract any number of user-supplied TAR archives, and were relying on the blocking of traversal. This can also affect software installation processes in which \"tar xf\" is run more than once (e.g., when installing a package can automatically install two dependencies that are set up as untrusted tarballs instead of official packages). NOTE: the official GNU Tar manual has an otherwise-empty directory for each \"tar xf\" in its Security Rules of Thumb; however, third-party advice leads users to run \"tar xf\" more than once into the same directory.",
      "cve": "CVE-2025-45582",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/tar@1.34%2Bdfsg-1ubuntu0.1.22.04.2?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.34+dfsg-1ubuntu0.1.22.04.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-45582",
          "value": "CVE-2025-45582",
          "url": "https://scout.docker.com/v/CVE-2025-45582?s=ubuntu&n=tar&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-45582?s=ubuntu&n=tar&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0c509c02a225faddc66d3121e7f5cea39be76674cf2072b6686190795e1a41f7",
      "category": "container_scanning",
      "message": "CVE-2025-55005 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to version 7.1.2-1, when preparing to transform from Log to sRGB colorspaces, the logmap construction fails to handle cases where the reference-black or reference-white value is larger than 1024. This leads to corrupting memory beyond the end of the allocated logmap buffer. This issue has been patched in version 7.1.2-1.",
      "cve": "CVE-2025-55005",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-55005",
          "value": "CVE-2025-55005",
          "url": "https://scout.docker.com/v/CVE-2025-55005?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-55005?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "81392ae5a6517648e442b0760eb124047f52591a2e2435358c11a2c1d84e8f8f",
      "category": "container_scanning",
      "message": "CVE-2025-6069 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "The html.parser.HTMLParser class had worse-case quadratic complexity when processing certain crafted malformed inputs potentially leading to amplified denial-of-service.",
      "cve": "CVE-2025-6069",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-6069",
          "value": "CVE-2025-6069",
          "url": "https://scout.docker.com/v/CVE-2025-6069?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-6069?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "93e4769147928e513fb060b8c991afc72292cb7fc244ae9296661bb1034a507c",
      "category": "container_scanning",
      "message": "CVE-2025-8194 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "There is a defect in the CPython tarfile module affecting the TarFile extraction and entry enumeration APIs. The tar implementation would process tar archives with negative offsets without error, resulting in an infinite loop and deadlock during the parsing of maliciously crafted tar archives.  This vulnerability can be mitigated by including the following patch after importing the tarfile module: https://gist.github.com/sethmlarson/1716ac5b82b73dbcbf23ad2eff8b33e1",
      "cve": "CVE-2025-8194",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-8194",
          "value": "CVE-2025-8194",
          "url": "https://scout.docker.com/v/CVE-2025-8194?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-8194?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2a4e06b7484e652929ce71b721d36a2e05e50dc12d405af63643f632dc3a44bc",
      "category": "container_scanning",
      "message": "CVE-2025-8225 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability was found in GNU Binutils 2.44 and classified as problematic. This issue affects the function process_debug_info of the file binutils/dwarf.c of the component DWARF Section Handler. The manipulation leads to memory leak. Attacking locally is a requirement. The identifier of the patch is e51fdff7d2e538c0e5accdd65649ac68e6e0ddd4. It is recommended to apply a patch to fix this issue.",
      "cve": "CVE-2025-8225",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-8225",
          "value": "CVE-2025-8225",
          "url": "https://scout.docker.com/v/CVE-2025-8225?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-8225?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "66379c1c2681b9bdb4ece4eb100dbc6e3f9f2993ab65f8bd29e1f4192da94993",
      "category": "container_scanning",
      "message": "CVE-2025-8941 on ubuntu/pam@1.4.0-11ubuntu2.6",
      "description": "A flaw was found in linux-pam. The pam_namespace module may improperly handle user-controlled paths, allowing local users to exploit symlink attacks and race conditions to elevate their privileges to root. This CVE provides a \"complete\" fix for CVE-2025-6020.",
      "cve": "CVE-2025-8941",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/pam@1.4.0-11ubuntu2.6?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.4.0-11ubuntu2.6"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-8941",
          "value": "CVE-2025-8941",
          "url": "https://scout.docker.com/v/CVE-2025-8941?s=ubuntu&n=pam&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-8941?s=ubuntu&n=pam&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b34becb56ea8245356758470dbda7bc4300e26739963b63f8df0f47c68718e3a",
      "category": "container_scanning",
      "message": "CVE-2024-42155 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/pkey: Wipe copies of protected- and secure-keys  Although the clear-key of neither protected- nor secure-keys is accessible, this key material should only be visible to the calling process. So wipe all copies of protected- or secure-keys from stack, even in case of an error.",
      "cve": "CVE-2024-42155",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42155",
          "value": "CVE-2024-42155",
          "url": "https://scout.docker.com/v/CVE-2024-42155?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42155?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f2b3ecbf6f96c333f115ea2be3036f7b40c58227b347f9ccc5fdcbc1002db3ef",
      "category": "container_scanning",
      "message": "CVE-2021-3574 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A vulnerability was found in ImageMagick-7.0.11-5, where executing a crafted file with the convert command, ASAN detects memory leaks.",
      "cve": "CVE-2021-3574",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3574",
          "value": "CVE-2021-3574",
          "url": "https://scout.docker.com/v/CVE-2021-3574?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3574?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b32b008e935e5c90457234076d548e698ac37e738faf299bcacc5e86fbbddd24",
      "category": "container_scanning",
      "message": "CVE-2022-48667 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb3: fix temporary data corruption in insert range  insert range doesn't discard the affected cached region so can risk temporarily corrupting file data.  Also includes some minor cleanup (avoiding rereading inode size repeatedly unnecessarily) to make it clearer.",
      "cve": "CVE-2022-48667",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48667",
          "value": "CVE-2022-48667",
          "url": "https://scout.docker.com/v/CVE-2022-48667?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48667?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8a45e1e5faf2a8c2aaed0887237e8e294188bfee354d6a195f7ebbf731bfc6c0",
      "category": "container_scanning",
      "message": "CVE-2022-48668 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb3: fix temporary data corruption in collapse range  collapse range doesn't discard the affected cached region so can risk temporarily corrupting the file data. This fixes xfstest generic/031  I also decided to merge a minor cleanup to this into the same patch (avoiding rereading inode size repeatedly unnecessarily) to make it clearer.",
      "cve": "CVE-2022-48668",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48668",
          "value": "CVE-2022-48668",
          "url": "https://scout.docker.com/v/CVE-2022-48668?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48668?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3d2b7bc52609d99b0f1625d807acdc9cb063180e47884451b156a7ec072746a2",
      "category": "container_scanning",
      "message": "CVE-2023-39978 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick before 6.9.12-91 allows attackers to cause a denial of service (memory consumption) in Magick::Draw.",
      "cve": "CVE-2023-39978",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-39978",
          "value": "CVE-2023-39978",
          "url": "https://scout.docker.com/v/CVE-2023-39978?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-39978?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c9da0da72fdc77ead4dbc79c3d2e3f977cef742949a8d99b15970c899190128e",
      "category": "container_scanning",
      "message": "CVE-2024-47738 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: don't use rate mask for offchannel TX either  Like the commit ab9177d83c04 (\"wifi: mac80211: don't use rate mask for scanning\"), ignore incorrect settings to avoid no supported rate warning reported by syzbot.  The syzbot did bisect and found cause is commit 9df66d5b9f45 (\"cfg80211: fix default HE tx bitrate mask in 2G band\"), which however corrects bitmask of HE MCS and recognizes correctly settings of empty legacy rate plus HE MCS rate instead of returning -EINVAL.  As suggestions [1], follow the change of SCAN TX to consider this case of offchannel TX as well.  [1] https://lore.kernel.org/linux-wireless/6ab2dc9c3afe753ca6fdcdd1421e7a1f47e87b84.camel@sipsolutions.net/T/#m2ac2a6d2be06a37c9c47a3d8a44b4f647ed4f024",
      "cve": "CVE-2024-47738",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47738",
          "value": "CVE-2024-47738",
          "url": "https://scout.docker.com/v/CVE-2024-47738?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47738?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "82fd155c49e2cc9aae6c758db189e3143b1c1c6a0d870d30c40e6c4a99fd86bc",
      "category": "container_scanning",
      "message": "CVE-2024-50057 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: typec: tipd: Free IRQ only if it was requested before  In polling mode, if no IRQ was requested there is no need to free it. Call devm_free_irq() only if client->irq is set. This fixes the warning caused by the tps6598x module removal:  WARNING: CPU: 2 PID: 333 at kernel/irq/devres.c:144 devm_free_irq+0x80/0x8c ... ... Call trace: devm_free_irq+0x80/0x8c tps6598x_remove+0x28/0x88 [tps6598x] i2c_device_remove+0x2c/0x9c device_remove+0x4c/0x80 device_release_driver_internal+0x1cc/0x228 driver_detach+0x50/0x98 bus_remove_driver+0x6c/0xbc driver_unregister+0x30/0x60 i2c_del_driver+0x54/0x64 tps6598x_i2c_driver_exit+0x18/0xc3c [tps6598x] __arm64_sys_delete_module+0x184/0x264 invoke_syscall+0x48/0x110 el0_svc_common.constprop.0+0xc8/0xe8 do_el0_svc+0x20/0x2c el0_svc+0x28/0x98 el0t_64_sync_handler+0x13c/0x158 el0t_64_sync+0x190/0x194",
      "cve": "CVE-2024-50057",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50057",
          "value": "CVE-2024-50057",
          "url": "https://scout.docker.com/v/CVE-2024-50057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "91451c9bc83dd982bb5135b872a6e15ccde86d1da9eda7208ea6d4e5369d6b93",
      "category": "container_scanning",
      "message": "CVE-2024-50211 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  udf: refactor inode_bmap() to handle error  Refactor inode_bmap() to handle error since udf_next_aext() can return error now. On situations like ftruncate, udf_extend_file() can now detect errors and bail out early without resorting to checking for particular offsets and assuming internal behavior of these functions.",
      "cve": "CVE-2024-50211",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50211",
          "value": "CVE-2024-50211",
          "url": "https://scout.docker.com/v/CVE-2024-50211?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50211?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9b825a46eaf99f5326e816dae6878b90b44b8d89d87580e4f32303c9b4b8ae9e",
      "category": "container_scanning",
      "message": "CVE-2024-57898 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: cfg80211: clear link ID from bitmap during link delete after clean up  Currently, during link deletion, the link ID is first removed from the valid_links bitmap before performing any clean-up operations. However, some functions require the link ID to remain in the valid_links bitmap. One such example is cfg80211_cac_event(). The flow is -  nl80211_remove_link() cfg80211_remove_link() ieee80211_del_intf_link() ieee80211_vif_set_links() ieee80211_vif_update_links() ieee80211_link_stop() cfg80211_cac_event()  cfg80211_cac_event() requires link ID to be present but it is cleared already in cfg80211_remove_link(). Ultimately, WARN_ON() is hit.  Therefore, clear the link ID from the bitmap only after completing the link clean-up.",
      "cve": "CVE-2024-57898",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57898",
          "value": "CVE-2024-57898",
          "url": "https://scout.docker.com/v/CVE-2024-57898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "04d1d640c89522c781ea8e4017894331d123a7eb7e7ff248c97045c03c7e0351",
      "category": "container_scanning",
      "message": "CVE-2025-55004 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to version 7.1.2-1, ImageMagick is vulnerable to heap-buffer overflow read around the handling of images with separate alpha channels when performing image magnification in ReadOneMNGIMage. This can likely be used to leak subsequent memory contents into the output image. This issue has been patched in version 7.1.2-1.",
      "cve": "CVE-2025-55004",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-55004",
          "value": "CVE-2025-55004",
          "url": "https://scout.docker.com/v/CVE-2025-55004?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-55004?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6a74431d9a7d965e9eb30cb675b7c1dd07b109a38300fb3786773cc2678ba430",
      "category": "container_scanning",
      "message": "CVE-2018-17977 on ubuntu/linux@5.15.0-161.171",
      "description": "The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages, IPPROTO_AH packets, and IPPROTO_IP packets, which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications, as demonstrated on CentOS 7.",
      "cve": "CVE-2018-17977",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2018-17977",
          "value": "CVE-2018-17977",
          "url": "https://scout.docker.com/v/CVE-2018-17977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2018-17977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b8537e4729dc377041d41520ed797cbe53477422da9d41f2dc46bdf67a3c7d4f",
      "category": "container_scanning",
      "message": "CVE-2024-49934 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/inode: Prevent dump_mapping() accessing invalid dentry.d_name.name  It's observed that a crash occurs during hot-remove a memory device, in which user is accessing the hugetlb. See calltrace as following:  ------------[ cut here ]------------ WARNING: CPU: 1 PID: 14045 at arch/x86/mm/fault.c:1278 do_user_addr_fault+0x2a0/0x790 Modules linked in: kmem device_dax cxl_mem cxl_pmem cxl_port cxl_pci dax_hmem dax_pmem nd_pmem cxl_acpi nd_btt cxl_core crc32c_intel nvme virtiofs fuse nvme_core nfit libnvdimm dm_multipath scsi_dh_rdac scsi_dh_emc s mirror dm_region_hash dm_log dm_mod CPU: 1 PID: 14045 Comm: daxctl Not tainted 6.10.0-rc2-lizhijian+ #492 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:do_user_addr_fault+0x2a0/0x790 Code: 48 8b 00 a8 04 0f 84 b5 fe ff ff e9 1c ff ff ff 4c 89 e9 4c 89 e2 be 01 00 00 00 bf 02 00 00 00 e8 b5 ef 24 00 e9 42 fe ff ff <0f> 0b 48 83 c4 08 4c 89 ea 48 89 ee 4c 89 e7 5b 5d 41 5c 41 5d 41 RSP: 0000:ffffc90000a575f0 EFLAGS: 00010046 RAX: ffff88800c303600 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000001000 RSI: ffffffff82504162 RDI: ffffffff824b2c36 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: ffffc90000a57658 R13: 0000000000001000 R14: ffff88800bc2e040 R15: 0000000000000000 FS:  00007f51cb57d880(0000) GS:ffff88807fd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000001000 CR3: 00000000072e2004 CR4: 00000000001706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __warn+0x8d/0x190 ? do_user_addr_fault+0x2a0/0x790 ? report_bug+0x1c3/0x1d0 ? handle_bug+0x3c/0x70 ? exc_invalid_op+0x14/0x70 ? asm_exc_invalid_op+0x16/0x20 ? do_user_addr_fault+0x2a0/0x790 ? exc_page_fault+0x31/0x200 exc_page_fault+0x68/0x200 <...snip...> BUG: unable to handle page fault for address: 0000000000001000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI ---[ end trace 0000000000000000 ]--- BUG: unable to handle page fault for address: 0000000000001000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 14045 Comm: daxctl Kdump: loaded Tainted: G        W 6.10.0-rc2-lizhijian+ #492 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:dentry_name+0x1f4/0x440 <...snip...> ? dentry_name+0x2fa/0x440 vsnprintf+0x1f3/0x4f0 vprintk_store+0x23a/0x540 vprintk_emit+0x6d/0x330 _printk+0x58/0x80 dump_mapping+0x10b/0x1a0 ? __pfx_free_object_rcu+0x10/0x10 __dump_page+0x26b/0x3e0 ? vprintk_emit+0xe0/0x330 ? _printk+0x58/0x80 ? dump_page+0x17/0x50 dump_page+0x17/0x50 do_migrate_range+0x2f7/0x7f0 ? do_migrate_range+0x42/0x7f0 ? offline_pages+0x2f4/0x8c0 offline_pages+0x60a/0x8c0 memory_subsys_offline+0x9f/0x1c0 ? lockdep_hardirqs_on+0x77/0x100 ? _raw_spin_unlock_irqrestore+0x38/0x60 device_offline+0xe3/0x110 state_store+0x6e/0xc0 kernfs_fop_write_iter+0x143/0x200 vfs_write+0x39f/0x560 ksys_write+0x65/0xf0 do_syscall_64+0x62/0x130  Previously, some sanity check have been done in dump_mapping() before the print facility parsing '%pd' though, it's still possible to run into an invalid dentry.d_name.name.  Since dump_mapping() only needs to dump the filename only, retrieve it by itself in a safer way to prevent an unnecessary crash.  Note that either retrieving the filename with '%pd' or strncpy_from_kernel_nofault(), the filename could be unreliable.",
      "cve": "CVE-2024-49934",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49934",
          "value": "CVE-2024-49934",
          "url": "https://scout.docker.com/v/CVE-2024-49934?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49934?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ecdd716f9c9b66930d8e6fb92e205a2040f142d3daa22489cae1efd4ace9620c",
      "category": "container_scanning",
      "message": "CVE-2022-1205 on ubuntu/linux@5.15.0-161.171",
      "description": "A NULL pointer dereference flaw was found in the Linux kernels Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.",
      "cve": "CVE-2022-1205",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-1205",
          "value": "CVE-2022-1205",
          "url": "https://scout.docker.com/v/CVE-2022-1205?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-1205?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "75cfc4a8662d1a61fc26cc9574a23c40f1eb327b8863c7eea821242328395a1f",
      "category": "container_scanning",
      "message": "CVE-2022-48816 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  SUNRPC: lock against ->sock changing during sysfs read  ->sock can be set to NULL asynchronously unless ->recv_mutex is held. So it is important to hold that mutex.  Otherwise a sysfs read can trigger an oops. Commit 17f09d3f619a (\"SUNRPC: Check if the xprt is connected before handling sysfs reads\") appears to attempt to fix this problem, but it only narrows the race window.",
      "cve": "CVE-2022-48816",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48816",
          "value": "CVE-2022-48816",
          "url": "https://scout.docker.com/v/CVE-2022-48816?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48816?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5f91898aa210c35b9008444f57564da81f057ace009bebce4506f89fdd4581c9",
      "category": "container_scanning",
      "message": "CVE-2023-52589 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: rkisp1: Fix IRQ disable race issue  In rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks the interrupts and then apparently assumes that the interrupt handler won't be running, and proceeds in the stop procedure. This is not the case, as the interrupt handler can already be running, which would lead to the ISP being disabled while the interrupt handler handling a captured frame.  This brings up two issues: 1) the ISP could be powered off while the interrupt handler is still running and accessing registers, leading to board lockup, and 2) the interrupt handler code and the code that disables the streaming might do things that conflict.  It is not clear to me if 2) causes a real issue, but 1) can be seen with a suitable delay (or printk in my case) in the interrupt handler, leading to board lockup.",
      "cve": "CVE-2023-52589",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52589",
          "value": "CVE-2023-52589",
          "url": "https://scout.docker.com/v/CVE-2023-52589?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52589?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b915196aceb2be532b7dd2536cdabb992defc3638d3d74c3b24e3e3dc5e77836",
      "category": "container_scanning",
      "message": "CVE-2024-26869 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to truncate meta inode pages forcely  Below race case can cause data corruption:  Thread A\t\t\t\tGC thread - gc_data_segment - ra_data_block - locked meta_inode page - f2fs_inplace_write_data - invalidate_mapping_pages : fail to invalidate meta_inode page due to lock failure or dirty|writeback status - f2fs_submit_page_bio : write last dirty data to old blkaddr - move_data_block - load old data from meta_inode page - f2fs_submit_page_write : write old data to new blkaddr  Because invalidate_mapping_pages() will skip invalidating page which has unclear status including locked, dirty, writeback and so on, so we need to use truncate_inode_pages_range() instead of invalidate_mapping_pages() to make sure meta_inode page will be dropped.",
      "cve": "CVE-2024-26869",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26869",
          "value": "CVE-2024-26869",
          "url": "https://scout.docker.com/v/CVE-2024-26869?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26869?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3ff2c633c0c368bf4da29d88e9dca45b0f31fdd7670dffa44caeb678273699a4",
      "category": "container_scanning",
      "message": "CVE-2024-27408 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: dw-edma: eDMA: Add sync read before starting the DMA transfer in remote setup  The Linked list element and pointer are not stored in the same memory as the eDMA controller register. If the doorbell register is toggled before the full write of the linked list a race condition error will occur. In remote setup we can only use a readl to the memory to assure the full write has occurred.",
      "cve": "CVE-2024-27408",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27408",
          "value": "CVE-2024-27408",
          "url": "https://scout.docker.com/v/CVE-2024-27408?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27408?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fb7f8d71c393c3ac7b3a767716aa37fbb2bf9af05870ac457da91d27e9855d5f",
      "category": "container_scanning",
      "message": "CVE-2024-36024 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Disable idle reallow as part of command/gpint execution  [Why] Workaroud for a race condition where DMCUB is in the process of committing to IPS1 during the handshake causing us to miss the transition into IPS2 and touch the INBOX1 RPTR causing a HW hang.  [How] Disable the reallow to ensure that we have enough of a gap between entry and exit and we're not seeing back-to-back wake_and_executes.",
      "cve": "CVE-2024-36024",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36024",
          "value": "CVE-2024-36024",
          "url": "https://scout.docker.com/v/CVE-2024-36024?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36024?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "37d232606a57b316657342367459f5406e1cf2577758e1e6dcf0105cf073999d",
      "category": "container_scanning",
      "message": "CVE-2024-36927 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipv4: Fix uninit-value access in __ip_make_skb()  KMSAN reported uninit-value access in __ip_make_skb() [1].  __ip_make_skb() tests HDRINCL to know if the skb has icmphdr. However, HDRINCL can cause a race condition. If calling setsockopt(2) with IP_HDRINCL changes HDRINCL while __ip_make_skb() is running, the function will access icmphdr in the skb even if it is not included. This causes the issue reported by KMSAN.  Check FLOWI_FLAG_KNOWN_NH on fl4->flowi4_flags instead of testing HDRINCL on the socket.  Also, fl4->fl4_icmp_type and fl4->fl4_icmp_code are not initialized. These are union in struct flowi4 and are implicitly initialized by flowi4_init_output(), but we should not rely on specific union layout.  Initialize these explicitly in raw_sendmsg().  [1] BUG: KMSAN: uninit-value in __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481 __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481 ip_finish_skb include/net/ip.h:243 [inline] ip_push_pending_frames+0x4c/0x5c0 net/ipv4/ip_output.c:1508 raw_sendmsg+0x2381/0x2690 net/ipv4/raw.c:654 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x274/0x3c0 net/socket.c:745 __sys_sendto+0x62c/0x7b0 net/socket.c:2191 __do_sys_sendto net/socket.c:2203 [inline] __se_sys_sendto net/socket.c:2199 [inline] __x64_sys_sendto+0x130/0x200 net/socket.c:2199 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x6d/0x75  Uninit was created at: slab_post_alloc_hook mm/slub.c:3804 [inline] slab_alloc_node mm/slub.c:3845 [inline] kmem_cache_alloc_node+0x5f6/0xc50 mm/slub.c:3888 kmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:577 __alloc_skb+0x35a/0x7c0 net/core/skbuff.c:668 alloc_skb include/linux/skbuff.h:1318 [inline] __ip_append_data+0x49ab/0x68c0 net/ipv4/ip_output.c:1128 ip_append_data+0x1e7/0x260 net/ipv4/ip_output.c:1365 raw_sendmsg+0x22b1/0x2690 net/ipv4/raw.c:648 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x274/0x3c0 net/socket.c:745 __sys_sendto+0x62c/0x7b0 net/socket.c:2191 __do_sys_sendto net/socket.c:2203 [inline] __se_sys_sendto net/socket.c:2199 [inline] __x64_sys_sendto+0x130/0x200 net/socket.c:2199 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x6d/0x75  CPU: 1 PID: 15709 Comm: syz-executor.7 Not tainted 6.8.0-11567-gb3603fcb79b1 #25 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014",
      "cve": "CVE-2024-36927",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36927",
          "value": "CVE-2024-36927",
          "url": "https://scout.docker.com/v/CVE-2024-36927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bd9695425b82f1504adbb17720ee2ca4a525c4ceef69723b0b8c79e156191937",
      "category": "container_scanning",
      "message": "CVE-2024-36949 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  amd/amdkfd: sync all devices to wait all processes being evicted  If there are more than one device doing reset in parallel, the first device will call kfd_suspend_all_processes() to evict all processes on all devices, this call takes time to finish. other device will start reset and recover without waiting. if the process has not been evicted before doing recover, it will be restored, then caused page fault.",
      "cve": "CVE-2024-36949",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36949",
          "value": "CVE-2024-36949",
          "url": "https://scout.docker.com/v/CVE-2024-36949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1f317d7bd1507da68c89c6a46bd245146c5e42482c56f7eb403c63500da228a2",
      "category": "container_scanning",
      "message": "CVE-2024-37354 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix crash on racing fsync and size-extending write into prealloc  We have been seeing crashes on duplicate keys in btrfs_set_item_key_safe():  BTRFS critical (device vdb): slot 4 key (450 108 8192) new key (450 108 8192) ------------[ cut here ]------------ kernel BUG at fs/btrfs/ctree.c:2620! invalid opcode: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 3139 Comm: xfs_io Kdump: loaded Not tainted 6.9.0 #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:btrfs_set_item_key_safe+0x11f/0x290 [btrfs]  With the following stack trace:  #0  btrfs_set_item_key_safe (fs/btrfs/ctree.c:2620:4) #1  btrfs_drop_extents (fs/btrfs/file.c:411:4) #2  log_one_extent (fs/btrfs/tree-log.c:4732:9) #3  btrfs_log_changed_extents (fs/btrfs/tree-log.c:4955:9) #4  btrfs_log_inode (fs/btrfs/tree-log.c:6626:9) #5  btrfs_log_inode_parent (fs/btrfs/tree-log.c:7070:8) #6  btrfs_log_dentry_safe (fs/btrfs/tree-log.c:7171:8) #7  btrfs_sync_file (fs/btrfs/file.c:1933:8) #8  vfs_fsync_range (fs/sync.c:188:9) #9  vfs_fsync (fs/sync.c:202:9) #10 do_fsync (fs/sync.c:212:9) #11 __do_sys_fdatasync (fs/sync.c:225:9) #12 __se_sys_fdatasync (fs/sync.c:223:1) #13 __x64_sys_fdatasync (fs/sync.c:223:1) #14 do_syscall_x64 (arch/x86/entry/common.c:52:14) #15 do_syscall_64 (arch/x86/entry/common.c:83:7) #16 entry_SYSCALL_64+0xaf/0x14c (arch/x86/entry/entry_64.S:121)  So we're logging a changed extent from fsync, which is splitting an extent in the log tree. But this split part already exists in the tree, triggering the BUG().  This is the state of the log tree at the time of the crash, dumped with drgn (https://github.com/osandov/drgn/blob/main/contrib/btrfs_tree.py) to get more details than btrfs_print_leaf() gives us:  >>> print_extent_buffer(prog.crashed_thread().stack_trace()[0][\"eb\"]) leaf 33439744 level 0 items 72 generation 9 owner 18446744073709551610 leaf 33439744 flags 0x100000000000000 fs uuid e5bd3946-400c-4223-8923-190ef1f18677 chunk uuid d58cb17e-6d02-494a-829a-18b7d8a399da item 0 key (450 INODE_ITEM 0) itemoff 16123 itemsize 160 generation 7 transid 9 size 8192 nbytes 8473563889606862198 block group 0 mode 100600 links 1 uid 0 gid 0 rdev 0 sequence 204 flags 0x10(PREALLOC) atime 1716417703.220000000 (2024-05-22 15:41:43) ctime 1716417704.983333333 (2024-05-22 15:41:44) mtime 1716417704.983333333 (2024-05-22 15:41:44) otime 17592186044416.000000000 (559444-03-08 01:40:16) item 1 key (450 INODE_REF 256) itemoff 16110 itemsize 13 index 195 namelen 3 name: 193 item 2 key (450 XATTR_ITEM 1640047104) itemoff 16073 itemsize 37 location key (0 UNKNOWN.0 0) type XATTR transid 7 data_len 1 name_len 6 name: user.a data a item 3 key (450 EXTENT_DATA 0) itemoff 16020 itemsize 53 generation 9 type 1 (regular) extent data disk byte 303144960 nr 12288 extent data offset 0 nr 4096 ram 12288 extent compression 0 (none) item 4 key (450 EXTENT_DATA 4096) itemoff 15967 itemsize 53 generation 9 type 2 (prealloc) prealloc data disk byte 303144960 nr 12288 prealloc data offset 4096 nr 8192 item 5 key (450 EXTENT_DATA 8192) itemoff 15914 itemsize 53 generation 9 type 2 (prealloc) prealloc data disk byte 303144960 nr 12288 prealloc data offset 8192 nr 4096 ...  So the real problem happened earlier: notice that items 4 (4k-12k) and 5 (8k-12k) overlap. Both are prealloc extents. Item 4 straddles i_size and item 5 starts at i_size.  Here is the state of ---truncated---",
      "cve": "CVE-2024-37354",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-37354",
          "value": "CVE-2024-37354",
          "url": "https://scout.docker.com/v/CVE-2024-37354?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-37354?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cf8c6bc448d706117f77803ccec7097b9b9f2336217ec1f7c9a9aa9e9db2f57d",
      "category": "container_scanning",
      "message": "CVE-2024-38306 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: protect folio::private when attaching extent buffer folios  [BUG] Since v6.8 there are rare kernel crashes reported by various people, the common factor is bad page status error messages like this:  BUG: Bad page state in process kswapd0  pfn:d6e840 page: refcount:0 mapcount:0 mapping:000000007512f4f2 index:0x2796c2c7c pfn:0xd6e840 aops:btree_aops ino:1 flags: 0x17ffffe0000008(uptodate|node=0|zone=2|lastcpupid=0x3fffff) page_type: 0xffffffff() raw: 0017ffffe0000008 dead000000000100 dead000000000122 ffff88826d0be4c0 raw: 00000002796c2c7c 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: non-NULL mapping  [CAUSE] Commit 09e6cef19c9f (\"btrfs: refactor alloc_extent_buffer() to allocate-then-attach method\") changes the sequence when allocating a new extent buffer.  Previously we always called grab_extent_buffer() under mapping->i_private_lock, to ensure the safety on modification on folio::private (which is a pointer to extent buffer for regular sectorsize).  This can lead to the following race:  Thread A is trying to allocate an extent buffer at bytenr X, with 4 4K pages, meanwhile thread B is trying to release the page at X + 4K (the second page of the extent buffer at X).  Thread A                |                 Thread B -----------------------------------+------------------------------------- | btree_release_folio() | | This is for the page at X + 4K, | | Not page X. | | alloc_extent_buffer()              | |- release_extent_buffer() |- filemap_add_folio() for the     | |  |- atomic_dec_and_test(eb->refs) |  page at bytenr X (the first     | |  | |  page).                          | |  | |  Which returned -EEXIST.         | |  | |                                  | |  | |- filemap_lock_folio()            | |  | |  Returned the first page locked. | |  | |                                  | |  | |- grab_extent_buffer()            | |  | |  |- atomic_inc_not_zero()        | |  | |  |  Returned false               | |  | |  |- folio_detach_private()       | |  |- folio_detach_private() for X |     |- folio_test_private()      | |     |- folio_test_private() |  Returned true             | |     |  Returned true |- folio_put()               |       |- folio_put()  Now there are two puts on the same folio at folio X, leading to refcount underflow of the folio X, and eventually causing the BUG_ON() on the page->mapping.  The condition is not that easy to hit:  - The release must be triggered for the middle page of an eb If the release is on the same first page of an eb, page lock would kick in and prevent the race.  - folio_detach_private() has a very small race window It's only between folio_test_private() and folio_clear_private().  That's exactly when mapping->i_private_lock is used to prevent such race, and commit 09e6cef19c9f (\"btrfs: refactor alloc_extent_buffer() to allocate-then-attach method\") screwed that up.  At that time, I thought the page lock would kick in as filemap_release_folio() also requires the page to be locked, but forgot the filemap_release_folio() only locks one page, not all pages of an extent buffer.  [FIX] Move all the code requiring i_private_lock into attach_eb_folio_to_filemap(), so that everything is done with proper lock protection.  Furthermore to prevent future problems, add an extra lockdep_assert_locked() to ensure we're holding the proper lock.  To reproducer that is able to hit the race (takes a few minutes with instrumented code inserting delays to alloc_extent_buffer()):  #!/bin/sh drop_caches () { while(true); do echo 3 > /proc/sys/vm/drop_caches echo 1 > /proc/sys/vm/compact_memory done }  run_tar () { while(true); do for x in `seq 1 80` ; do tar cf /dev/zero /mnt > /dev/null & done wait done }  mkfs.btrfs -f -d single -m single ---truncated---",
      "cve": "CVE-2024-38306",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38306",
          "value": "CVE-2024-38306",
          "url": "https://scout.docker.com/v/CVE-2024-38306?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38306?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6a5be4de1bb292f58e73d50267f1cf84478dff84655346d3d20335f73def74dd",
      "category": "container_scanning",
      "message": "CVE-2024-39293 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"xsk: Support redirect to any socket bound to the same umem\"  This reverts commit 2863d665ea41282379f108e4da6c8a2366ba66db.  This patch introduced a potential kernel crash when multiple napi instances redirect to the same AF_XDP socket. By removing the queue_index check, it is possible for multiple napi instances to access the Rx ring at the same time, which will result in a corrupted ring state which can lead to a crash when flushing the rings in __xsk_flush(). This can happen when the linked list of sockets to flush gets corrupted by concurrent accesses. A quick and small fix is not possible, so let us revert this for now.",
      "cve": "CVE-2024-39293",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-39293",
          "value": "CVE-2024-39293",
          "url": "https://scout.docker.com/v/CVE-2024-39293?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-39293?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "39caf36fbded5c51e0b47f5c8a9911dcc53b90db43c02222c2586ff07a79ab8a",
      "category": "container_scanning",
      "message": "CVE-2024-39508 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring/io-wq: Use set_bit() and test_bit() at worker->flags  Utilize set_bit() and test_bit() on worker->flags within io_uring/io-wq to address potential data races.  The structure io_worker->flags may be accessed through various data paths, leading to concurrency issues. When KCSAN is enabled, it reveals data races occurring in io_worker_handle_work and io_wq_activate_free_worker functions.  BUG: KCSAN: data-race in io_worker_handle_work / io_wq_activate_free_worker write to 0xffff8885c4246404 of 4 bytes by task 49071 on cpu 28: io_worker_handle_work (io_uring/io-wq.c:434 io_uring/io-wq.c:569) io_wq_worker (io_uring/io-wq.c:?) <snip>  read to 0xffff8885c4246404 of 4 bytes by task 49024 on cpu 5: io_wq_activate_free_worker (io_uring/io-wq.c:? io_uring/io-wq.c:285) io_wq_enqueue (io_uring/io-wq.c:947) io_queue_iowq (io_uring/io_uring.c:524) io_req_task_submit (io_uring/io_uring.c:1511) io_handle_tw_list (io_uring/io_uring.c:1198) <snip>  Line numbers against commit 18daea77cca6 (\"Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm\").  These races involve writes and reads to the same memory location by different tasks running on different CPUs. To mitigate this, refactor the code to use atomic operations such as set_bit(), test_bit(), and clear_bit() instead of basic \"and\" and \"or\" operations. This ensures thread-safe manipulation of worker flags.  Also, move `create_index` to avoid holes in the structure.",
      "cve": "CVE-2024-39508",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-39508",
          "value": "CVE-2024-39508",
          "url": "https://scout.docker.com/v/CVE-2024-39508?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-39508?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "621f8dc9eeb22dd75edde2443341abfe77df1d4615c203a4bf132e16ba018570",
      "category": "container_scanning",
      "message": "CVE-2024-42107 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: Don't process extts if PTP is disabled  The ice_ptp_extts_event() function can race with ice_ptp_release() and result in a NULL pointer dereference which leads to a kernel panic.  Panic occurs because the ice_ptp_extts_event() function calls ptp_clock_event() with a NULL pointer. The ice driver has already released the PTP clock by the time the interrupt for the next external timestamp event occurs.  To fix this, modify the ice_ptp_extts_event() function to check the PTP state and bail early if PTP is not ready.",
      "cve": "CVE-2024-42107",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42107",
          "value": "CVE-2024-42107",
          "url": "https://scout.docker.com/v/CVE-2024-42107?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42107?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c6c33386e26b10bee634abb36ee86e53bba34e3e29f15b3cc6511d5f1d53650b",
      "category": "container_scanning",
      "message": "CVE-2024-42253 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gpio: pca953x: fix pca953x_irq_bus_sync_unlock race  Ensure that `i2c_lock' is held when setting interrupt latch and mask in pca953x_irq_bus_sync_unlock() in order to avoid races.  The other (non-probe) call site pca953x_gpio_set_multiple() ensures the lock is held before calling pca953x_write_regs().  The problem occurred when a request raced against irq_bus_sync_unlock() approximately once per thousand reboots on an i.MX8MP based system.  * Normal case  0-0022: write register AI|3a {03,02,00,00,01} Input latch P0 0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0 0-0022: write register AI|08 {ff,00,00,00,00} Output P3 0-0022: write register AI|12 {fc,00,00,00,00} Config P3  * Race case  0-0022: write register AI|08 {ff,00,00,00,00} Output P3 0-0022: write register AI|08 {03,02,00,00,01} *** Wrong register *** 0-0022: write register AI|12 {fc,00,00,00,00} Config P3 0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0",
      "cve": "CVE-2024-42253",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42253",
          "value": "CVE-2024-42253",
          "url": "https://scout.docker.com/v/CVE-2024-42253?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42253?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6831ee5f277b4987b157eeff5594f29f598ce8e47d4b824bbf102db2183cc32a",
      "category": "container_scanning",
      "message": "CVE-2024-43866 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Always drain health in shutdown callback  There is no point in recovery during device shutdown. if health work started need to wait for it to avoid races and NULL pointer access.  Hence, drain health WQ on shutdown callback.",
      "cve": "CVE-2024-43866",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43866",
          "value": "CVE-2024-43866",
          "url": "https://scout.docker.com/v/CVE-2024-43866?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43866?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "52429b5de97f01244c615b31ace434083e503a381a0db65fcab1bda801196f53",
      "category": "container_scanning",
      "message": "CVE-2024-46870 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Disable DMCUB timeout for DCN35  [Why] DMCUB can intermittently take longer than expected to process commands.  Old ASIC policy was to continue while logging a diagnostic error - which works fine for ASIC without IPS, but with IPS this could lead to a race condition where we attempt to access DCN state while it's inaccessible, leading to a system hang when the NIU port is not disabled or register accesses that timeout and the display configuration in an undefined state.  [How] We need to investigate why these accesses take longer than expected, but for now we should disable the timeout on DCN35 to avoid this race condition. Since the waits happen only at lower interrupt levels the risk of taking too long at higher IRQ and causing a system watchdog timeout are minimal.",
      "cve": "CVE-2024-46870",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46870",
          "value": "CVE-2024-46870",
          "url": "https://scout.docker.com/v/CVE-2024-46870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "57081afe9600e33d7eb1f0418e2a3f955f48a9ca990d248f99295d8fcd96c661",
      "category": "container_scanning",
      "message": "CVE-2024-49859 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to check atomic_file in f2fs ioctl interfaces  Some f2fs ioctl interfaces like f2fs_ioc_set_pin_file(), f2fs_move_file_range(), and f2fs_defragment_range() missed to check atomic_write status, which may cause potential race issue, fix it.",
      "cve": "CVE-2024-49859",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49859",
          "value": "CVE-2024-49859",
          "url": "https://scout.docker.com/v/CVE-2024-49859?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49859?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b719ab988cc9521a7072241ed7ba20f710af7191a1f65bcfb20209470963defa",
      "category": "container_scanning",
      "message": "CVE-2024-50135 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-pci: fix race condition between reset and nvme_dev_disable()  nvme_dev_disable() modifies the dev->online_queues field, therefore nvme_pci_update_nr_queues() should avoid racing against it, otherwise we could end up passing invalid values to blk_mq_update_nr_hw_queues().  WARNING: CPU: 39 PID: 61303 at drivers/pci/msi/api.c:347 pci_irq_get_affinity+0x187/0x210 Workqueue: nvme-reset-wq nvme_reset_work [nvme] RIP: 0010:pci_irq_get_affinity+0x187/0x210 Call Trace: <TASK> ? blk_mq_pci_map_queues+0x87/0x3c0 ? pci_irq_get_affinity+0x187/0x210 blk_mq_pci_map_queues+0x87/0x3c0 nvme_pci_map_queues+0x189/0x460 [nvme] blk_mq_update_nr_hw_queues+0x2a/0x40 nvme_reset_work+0x1be/0x2a0 [nvme]  Fix the bug by locking the shutdown_lock mutex before using dev->online_queues. Give up if nvme_dev_disable() is running or if it has been executed already.",
      "cve": "CVE-2024-50135",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50135",
          "value": "CVE-2024-50135",
          "url": "https://scout.docker.com/v/CVE-2024-50135?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50135?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "715c55fd654deaaea3bf6d5a2c071d89b566ae83e4cca0fad92b4af1d7c3eb37",
      "category": "container_scanning",
      "message": "CVE-2024-53100 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme: tcp: avoid race between queue_lock lock and destroy  Commit 76d54bf20cdc (\"nvme-tcp: don't access released socket during error recovery\") added a mutex_lock() call for the queue->queue_lock in nvme_tcp_get_address(). However, the mutex_lock() races with mutex_destroy() in nvme_tcp_free_queue(), and causes the WARN below.  DEBUG_LOCKS_WARN_ON(lock->magic != lock) WARNING: CPU: 3 PID: 34077 at kernel/locking/mutex.c:587 __mutex_lock+0xcf0/0x1220 Modules linked in: nvmet_tcp nvmet nvme_tcp nvme_fabrics iw_cm ib_cm ib_core pktcdvd nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables qrtr sunrpc ppdev 9pnet_virtio 9pnet pcspkr netfs parport_pc parport e1000 i2c_piix4 i2c_smbus loop fuse nfnetlink zram bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper xfs drm sym53c8xx floppy nvme scsi_transport_spi nvme_core nvme_auth serio_raw ata_generic pata_acpi dm_multipath qemu_fw_cfg [last unloaded: ib_uverbs] CPU: 3 UID: 0 PID: 34077 Comm: udisksd Not tainted 6.11.0-rc7 #319 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:__mutex_lock+0xcf0/0x1220 Code: 08 84 d2 0f 85 c8 04 00 00 8b 15 ef b6 c8 01 85 d2 0f 85 78 f4 ff ff 48 c7 c6 20 93 ee af 48 c7 c7 60 91 ee af e8 f0 a7 6d fd <0f> 0b e9 5e f4 ff ff 48 b8 00 00 00 00 00 fc ff df 4c 89 f2 48 c1 RSP: 0018:ffff88811305f760 EFLAGS: 00010286 RAX: 0000000000000000 RBX: ffff88812c652058 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000001 RBP: ffff88811305f8b0 R08: 0000000000000001 R09: ffffed1075c36341 R10: ffff8883ae1b1a0b R11: 0000000000010498 R12: 0000000000000000 R13: 0000000000000000 R14: dffffc0000000000 R15: ffff88812c652058 FS:  00007f9713ae4980(0000) GS:ffff8883ae180000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fcd78483c7c CR3: 0000000122c38000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __warn.cold+0x5b/0x1af ? __mutex_lock+0xcf0/0x1220 ? report_bug+0x1ec/0x390 ? handle_bug+0x3c/0x80 ? exc_invalid_op+0x13/0x40 ? asm_exc_invalid_op+0x16/0x20 ? __mutex_lock+0xcf0/0x1220 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] ? __pfx___mutex_lock+0x10/0x10 ? __lock_acquire+0xd6a/0x59e0 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] ? __pfx_nvme_tcp_get_address+0x10/0x10 [nvme_tcp] nvme_sysfs_show_address+0x81/0xc0 [nvme_core] dev_attr_show+0x42/0x80 ? __asan_memset+0x1f/0x40 sysfs_kf_seq_show+0x1f0/0x370 seq_read_iter+0x2cb/0x1130 ? rw_verify_area+0x3b1/0x590 ? __mutex_lock+0x433/0x1220 vfs_read+0x6a6/0xa20 ? lockdep_hardirqs_on+0x78/0x100 ? __pfx_vfs_read+0x10/0x10 ksys_read+0xf7/0x1d0 ? __pfx_ksys_read+0x10/0x10 ? __x64_sys_openat+0x105/0x1d0 do_syscall_64+0x93/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? __pfx_ksys_read+0x10/0x10 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? do_syscall_64+0x9f/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f9713f55cfa Code: 55 48 89 e5 48 83 ec 20 48 89 55 e8 48 89 75 f0 89 7d f8 e8 e8 74 f8 ff 48 8b 55 e8 48 8b 75 f0 4 ---truncated---",
      "cve": "CVE-2024-53100",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53100",
          "value": "CVE-2024-53100",
          "url": "https://scout.docker.com/v/CVE-2024-53100?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53100?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "07f491063fbff168ce4738819b35a9c9e277b7f72a9fc2a66a875d20121e1f09",
      "category": "container_scanning",
      "message": "CVE-2024-53176 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: During unmount, ensure all cached dir instances drop their dentry  The unmount process (cifs_kill_sb() calling close_all_cached_dirs()) can race with various cached directory operations, which ultimately results in dentries not being dropped and these kernel BUGs:  BUG: Dentry ffff88814f37e358{i=1000000000080,n=/}  still in use (2) [unmount of cifs cifs] VFS: Busy inodes after unmount of cifs (cifs) ------------[ cut here ]------------ kernel BUG at fs/super.c:661!  This happens when a cfid is in the process of being cleaned up when, and has been removed from the cfids->entries list, including:  - Receiving a lease break from the server - Server reconnection triggers invalidate_all_cached_dirs(), which removes all the cfids from the list - The laundromat thread decides to expire an old cfid.  To solve these problems, dropping the dentry is done in queued work done in a newly-added cfid_put_wq workqueue, and close_all_cached_dirs() flushes that workqueue after it drops all the dentries of which it's aware. This is a global workqueue (rather than scoped to a mount), but the queued work is minimal.  The final cleanup work for cleaning up a cfid is performed via work queued in the serverclose_wq workqueue; this is done separate from dropping the dentries so that close_all_cached_dirs() doesn't block on any server operations.  Both of these queued works expect to invoked with a cfid reference and a tcon reference to avoid those objects from being freed while the work is ongoing.  While we're here, add proper locking to close_all_cached_dirs(), and locking around the freeing of cfid->dentry.",
      "cve": "CVE-2024-53176",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53176",
          "value": "CVE-2024-53176",
          "url": "https://scout.docker.com/v/CVE-2024-53176?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53176?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d1793fcf58d5264efa2c6f8f87971115c63f5a91c980f3932d03b62fd66fa9bf",
      "category": "container_scanning",
      "message": "CVE-2024-53178 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: Don't leak cfid when reconnect races with open_cached_dir  open_cached_dir() may either race with the tcon reconnection even before compound_send_recv() or directly trigger a reconnection via SMB2_open_init() or SMB_query_info_init().  The reconnection process invokes invalidate_all_cached_dirs() via cifs_mark_open_files_invalid(), which removes all cfids from the cfids->entries list but doesn't drop a ref if has_lease isn't true. This results in the currently-being-constructed cfid not being on the list, but still having a refcount of 2. It leaks if returned from open_cached_dir().  Fix this by setting cfid->has_lease when the ref is actually taken; the cfid will not be used by other threads until it has a valid time.  Addresses these kmemleaks:  unreferenced object 0xffff8881090c4000 (size 1024): comm \"bash\", pid 1860, jiffies 4295126592 hex dump (first 32 bytes): 00 01 00 00 00 00 ad de 22 01 00 00 00 00 ad de  ........\"....... 00 ca 45 22 81 88 ff ff f8 dc 4f 04 81 88 ff ff  ..E\"......O..... backtrace (crc 6f58c20f): [<ffffffff8b895a1e>] __kmalloc_cache_noprof+0x2be/0x350 [<ffffffff8bda06e3>] open_cached_dir+0x993/0x1fb0 [<ffffffff8bdaa750>] cifs_readdir+0x15a0/0x1d50 [<ffffffff8b9a853f>] iterate_dir+0x28f/0x4b0 [<ffffffff8b9a9aed>] __x64_sys_getdents64+0xfd/0x200 [<ffffffff8cf6da05>] do_syscall_64+0x95/0x1a0 [<ffffffff8d00012f>] entry_SYSCALL_64_after_hwframe+0x76/0x7e unreferenced object 0xffff8881044fdcf8 (size 8): comm \"bash\", pid 1860, jiffies 4295126592 hex dump (first 8 bytes): 00 cc cc cc cc cc cc cc                          ........ backtrace (crc 10c106a9): [<ffffffff8b89a3d3>] __kmalloc_node_track_caller_noprof+0x363/0x480 [<ffffffff8b7d7256>] kstrdup+0x36/0x60 [<ffffffff8bda0700>] open_cached_dir+0x9b0/0x1fb0 [<ffffffff8bdaa750>] cifs_readdir+0x15a0/0x1d50 [<ffffffff8b9a853f>] iterate_dir+0x28f/0x4b0 [<ffffffff8b9a9aed>] __x64_sys_getdents64+0xfd/0x200 [<ffffffff8cf6da05>] do_syscall_64+0x95/0x1a0 [<ffffffff8d00012f>] entry_SYSCALL_64_after_hwframe+0x76/0x7e  And addresses these BUG splats when unmounting the SMB filesystem:  BUG: Dentry ffff888140590ba0{i=1000000000080,n=/}  still in use (2) [unmount of cifs cifs] WARNING: CPU: 3 PID: 3433 at fs/dcache.c:1536 umount_check+0xd0/0x100 Modules linked in: CPU: 3 UID: 0 PID: 3433 Comm: bash Not tainted 6.12.0-rc4-g850925a8133c-dirty #49 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 RIP: 0010:umount_check+0xd0/0x100 Code: 8d 7c 24 40 e8 31 5a f4 ff 49 8b 54 24 40 41 56 49 89 e9 45 89 e8 48 89 d9 41 57 48 89 de 48 c7 c7 80 e7 db ac e8 f0 72 9a ff <0f> 0b 58 31 c0 5a 5b 5d 41 5c 41 5d 41 5e 41 5f e9 2b e5 5d 01 41 RSP: 0018:ffff88811cc27978 EFLAGS: 00010286 RAX: 0000000000000000 RBX: ffff888140590ba0 RCX: ffffffffaaf20bae RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff8881f6fb6f40 RBP: ffff8881462ec000 R08: 0000000000000001 R09: ffffed1023984ee3 R10: ffff88811cc2771f R11: 00000000016cfcc0 R12: ffff888134383e08 R13: 0000000000000002 R14: ffff8881462ec668 R15: ffffffffaceab4c0 FS:  00007f23bfa98740(0000) GS:ffff8881f6f80000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000556de4a6f808 CR3: 0000000123c80000 CR4: 0000000000350ef0 Call Trace: <TASK> d_walk+0x6a/0x530 shrink_dcache_for_umount+0x6a/0x200 generic_shutdown_super+0x52/0x2a0 kill_anon_super+0x22/0x40 cifs_kill_sb+0x159/0x1e0 deactivate_locked_super+0x66/0xe0 cleanup_mnt+0x140/0x210 task_work_run+0xfb/0x170 syscall_exit_to_user_mode+0x29f/0x2b0 do_syscall_64+0xa1/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f23bfb93ae7 Code: ff ff ff ff c3 66 0f 1f 44 00 00 48 8b 0d 11 93 0d 00 f7 d8 64 89 01 b8 ff ff ff ff eb bf 0f 1f 44 00 00 b8 50 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d e9 92 0d 00 f7 d8 64 89 ---truncated---",
      "cve": "CVE-2024-53178",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53178",
          "value": "CVE-2024-53178",
          "url": "https://scout.docker.com/v/CVE-2024-53178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e41451085a173080e9ffe1c47e3ddfbc31fb859ea7e111789f97302ae832ada5",
      "category": "container_scanning",
      "message": "CVE-2024-56788 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ethernet: oa_tc6: fix tx skb race condition between reference pointers  There are two skb pointers to manage tx skb's enqueued from n/w stack. waiting_tx_skb pointer points to the tx skb which needs to be processed and ongoing_tx_skb pointer points to the tx skb which is being processed.  SPI thread prepares the tx data chunks from the tx skb pointed by the ongoing_tx_skb pointer. When the tx skb pointed by the ongoing_tx_skb is processed, the tx skb pointed by the waiting_tx_skb is assigned to ongoing_tx_skb and the waiting_tx_skb pointer is assigned with NULL. Whenever there is a new tx skb from n/w stack, it will be assigned to waiting_tx_skb pointer if it is NULL. Enqueuing and processing of a tx skb handled in two different threads.  Consider a scenario where the SPI thread processed an ongoing_tx_skb and it moves next tx skb from waiting_tx_skb pointer to ongoing_tx_skb pointer without doing any NULL check. At this time, if the waiting_tx_skb pointer is NULL then ongoing_tx_skb pointer is also assigned with NULL. After that, if a new tx skb is assigned to waiting_tx_skb pointer by the n/w stack and there is a chance to overwrite the tx skb pointer with NULL in the SPI thread. Finally one of the tx skb will be left as unhandled, resulting packet missing and memory leak.  - Consider the below scenario where the TXC reported from the previous transfer is 10 and ongoing_tx_skb holds an tx ethernet frame which can be transported in 20 TXCs and waiting_tx_skb is still NULL. tx_credits = 10; /* 21 are filled in the previous transfer */ ongoing_tx_skb = 20; waiting_tx_skb = NULL; /* Still NULL */ - So, (tc6->ongoing_tx_skb || tc6->waiting_tx_skb) becomes true. - After oa_tc6_prepare_spi_tx_buf_for_tx_skbs() ongoing_tx_skb = 10; waiting_tx_skb = NULL; /* Still NULL */ - Perform SPI transfer. - Process SPI rx buffer to get the TXC from footers. - Now let's assume previously filled 21 TXCs are freed so we are good to transport the next remaining 10 tx chunks from ongoing_tx_skb. tx_credits = 21; ongoing_tx_skb = 10; waiting_tx_skb = NULL; - So, (tc6->ongoing_tx_skb || tc6->waiting_tx_skb) becomes true again. - In the oa_tc6_prepare_spi_tx_buf_for_tx_skbs() ongoing_tx_skb = NULL; waiting_tx_skb = NULL;  - Now the below bad case might happen,  Thread1 (oa_tc6_start_xmit)\tThread2 (oa_tc6_spi_thread_handler) ---------------------------\t----------------------------------- - if waiting_tx_skb is NULL - if ongoing_tx_skb is NULL - ongoing_tx_skb = waiting_tx_skb - waiting_tx_skb = skb - waiting_tx_skb = NULL ... - ongoing_tx_skb = NULL - if waiting_tx_skb is NULL - waiting_tx_skb = skb  To overcome the above issue, protect the moving of tx skb reference from waiting_tx_skb pointer to ongoing_tx_skb pointer and assigning new tx skb to waiting_tx_skb pointer, so that the other thread can't access the waiting_tx_skb pointer until the current thread completes moving the tx skb reference safely.",
      "cve": "CVE-2024-56788",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56788",
          "value": "CVE-2024-56788",
          "url": "https://scout.docker.com/v/CVE-2024-56788?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56788?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "abea437e9584a9882f0585fd372e8c4f2f8d76dca4abe78b0e64c7899d6cd6c8",
      "category": "container_scanning",
      "message": "CVE-2024-57974 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  udp: Deal with race between UDP socket address change and rehash  If a UDP socket changes its local address while it's receiving datagrams, as a result of connect(), there is a period during which a lookup operation might fail to find it, after the address is changed but before the secondary hash (port and address) and the four-tuple hash (local and remote ports and addresses) are updated.  Secondary hash chains were introduced by commit 30fff9231fad (\"udp: bind() optimisation\") and, as a result, a rehash operation became needed to make a bound socket reachable again after a connect().  This operation was introduced by commit 719f835853a9 (\"udp: add rehash on connect()\") which isn't however a complete fix: the socket will be found once the rehashing completes, but not while it's pending.  This is noticeable with a socat(1) server in UDP4-LISTEN mode, and a client sending datagrams to it. After the server receives the first datagram (cf. _xioopen_ipdgram_listen()), it issues a connect() to the address of the sender, in order to set up a directed flow.  Now, if the client, running on a different CPU thread, happens to send a (subsequent) datagram while the server's socket changes its address, but is not rehashed yet, this will result in a failed lookup and a port unreachable error delivered to the client, as apparent from the following reproducer:  LEN=$(($(cat /proc/sys/net/core/wmem_default) / 4)) dd if=/dev/urandom bs=1 count=${LEN} of=tmp.in  while :; do taskset -c 1 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,trunc & sleep 0.1 || sleep 1 taskset -c 2 socat OPEN:tmp.in UDP4:localhost:1337,shut-null wait done  where the client will eventually get ECONNREFUSED on a write() (typically the second or third one of a given iteration):  2024/11/13 21:28:23 socat[46901] E write(6, 0x556db2e3c000, 8192): Connection refused  This issue was first observed as a seldom failure in Podman's tests checking UDP functionality while using pasta(1) to connect the container's network namespace, which leads us to a reproducer with the lookup error resulting in an ICMP packet on a tap device:  LOCAL_ADDR=\"$(ip -j -4 addr show|jq -rM '.[] | .addr_info[0] | select(.scope == \"global\").local')\"  while :; do ./pasta --config-net -p pasta.pcap -u 1337 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,trunc & sleep 0.2 || sleep 1 socat OPEN:tmp.in UDP4:${LOCAL_ADDR}:1337,shut-null wait cmp tmp.in tmp.out done  Once this fails:  tmp.in tmp.out differ: char 8193, line 29  we can finally have a look at what's going on:  $ tshark -r pasta.pcap 1   0.000000           :: ? ff02::16     ICMPv6 110 Multicast Listener Report Message v2 2   0.168690 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 3   0.168767 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 4   0.168806 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 5   0.168827 c6:47:05:8d:dc:04 ? Broadcast    ARP 42 Who has 88.198.0.161? Tell 88.198.0.164 6   0.168851 9a:55:9a:55:9a:55 ? c6:47:05:8d:dc:04 ARP 42 88.198.0.161 is at 9a:55:9a:55:9a:55 7   0.168875 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 8   0.168896 88.198.0.164 ? 88.198.0.161 ICMP 590 Destination unreachable (Port unreachable) 9   0.168926 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 10   0.168959 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192 11   0.168989 88.198.0.161 ? 88.198.0.164 UDP 4138 60260 ? 1337 Len=4096 12   0.169010 88.198.0.161 ? 88.198.0.164 UDP 42 60260 ? 1337 Len=0  On the third datagram received, the network namespace of the container initiates an ARP lookup to deliver the ICMP message.  In another variant of this reproducer, starting the client with:  strace -f pasta --config-net -u 1337 socat UDP4-LISTEN:1337,null-eof OPEN:tmp.out,create,tru ---truncated---",
      "cve": "CVE-2024-57974",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57974",
          "value": "CVE-2024-57974",
          "url": "https://scout.docker.com/v/CVE-2024-57974?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57974?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4a46cee3b877ddae60cb4aced2a6b449e737c7ffc6fa1f85ea4c965bf406d7a4",
      "category": "container_scanning",
      "message": "CVE-2025-21651 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hns3: don't auto enable misc vector  Currently, there is a time window between misc irq enabled and service task inited. If an interrupte is reported at this time, it will cause warning like below:  [   16.324639] Call trace: [   16.324641]  __queue_delayed_work+0xb8/0xe0 [   16.324643]  mod_delayed_work_on+0x78/0xd0 [   16.324655]  hclge_errhand_task_schedule+0x58/0x90 [hclge] [   16.324662]  hclge_misc_irq_handle+0x168/0x240 [hclge] [   16.324666]  __handle_irq_event_percpu+0x64/0x1e0 [   16.324667]  handle_irq_event+0x80/0x170 [   16.324670]  handle_fasteoi_edge_irq+0x110/0x2bc [   16.324671]  __handle_domain_irq+0x84/0xfc [   16.324673]  gic_handle_irq+0x88/0x2c0 [   16.324674]  el1_irq+0xb8/0x140 [   16.324677]  arch_cpu_idle+0x18/0x40 [   16.324679]  default_idle_call+0x5c/0x1bc [   16.324682]  cpuidle_idle_call+0x18c/0x1c4 [   16.324684]  do_idle+0x174/0x17c [   16.324685]  cpu_startup_entry+0x30/0x6c [   16.324687]  secondary_start_kernel+0x1a4/0x280 [   16.324688] ---[ end trace 6aa0bff672a964aa ]---  So don't auto enable misc vector when request irq..",
      "cve": "CVE-2025-21651",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21651",
          "value": "CVE-2025-21651",
          "url": "https://scout.docker.com/v/CVE-2025-21651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21651?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "be6fbe6a182e5d845abff69dff75c9a1e61da51642fe0adc06618fa6752b2be6",
      "category": "container_scanning",
      "message": "CVE-2025-21947 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix type confusion via race condition when using ipc_msg_send_request  req->handle is allocated using ksmbd_acquire_id(&ipc_ida), based on ida_alloc. req->handle from ksmbd_ipc_login_request and FSCTL_PIPE_TRANSCEIVE ioctl can be same and it could lead to type confusion between messages, resulting in access to unexpected parts of memory after an incorrect delivery. ksmbd check type of ipc response but missing add continue to check next ipc reponse.",
      "cve": "CVE-2025-21947",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21947",
          "value": "CVE-2025-21947",
          "url": "https://scout.docker.com/v/CVE-2025-21947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21947?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5de50689dc43c72788f322142a63f97b89d36bab909d343023cb00fdc8674850",
      "category": "container_scanning",
      "message": "CVE-2022-3523 on ubuntu/linux@5.15.0-161.171",
      "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.",
      "cve": "CVE-2022-3523",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-3523",
          "value": "CVE-2022-3523",
          "url": "https://scout.docker.com/v/CVE-2022-3523?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-3523?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7899911fab0c946327c28226b0c4c1bc686ffa4295607be6d1c3407bca732f44",
      "category": "container_scanning",
      "message": "CVE-2023-27043 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.",
      "cve": "CVE-2023-27043",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-27043",
          "value": "CVE-2023-27043",
          "url": "https://scout.docker.com/v/CVE-2023-27043?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-27043?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2118ae8899213c3a5eecd8aac98bc14dcbd7b968ebf4e3022e182c42d4bb6e8",
      "category": "container_scanning",
      "message": "CVE-2023-40217 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue was discovered in Python before 3.8.18, 3.9.x before 3.9.18, 3.10.x before 3.10.13, and 3.11.x before 3.11.5. It primarily affects servers (such as HTTP servers) that use TLS client authentication. If a TLS server-side socket is created, receives data into the socket buffer, and then is closed quickly, there is a brief window where the SSLSocket instance will detect the socket as \"not connected\" and won't initiate a handshake, but buffered data will still be readable from the socket buffer. This data will not be authenticated if the server-side TLS peer is expecting client certificate authentication, and is indistinguishable from valid TLS stream data. Data is limited in size to the amount that will fit in the buffer. (The TLS connection cannot directly be used for data exfiltration because the vulnerable code path requires that the connection be closed on initialization of the SSLSocket.)",
      "cve": "CVE-2023-40217",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-40217",
          "value": "CVE-2023-40217",
          "url": "https://scout.docker.com/v/CVE-2023-40217?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-40217?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6df8d0aa4f5472018c0353ee294ab87ed6573f6fb2a5d1cf990000cd51b5895a",
      "category": "container_scanning",
      "message": "CVE-2024-47689 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to don't set SB_RDONLY in f2fs_handle_critical_error()  syzbot reports a f2fs bug as below:  ------------[ cut here ]------------ WARNING: CPU: 1 PID: 58 at kernel/rcu/sync.c:177 rcu_sync_dtor+0xcd/0x180 kernel/rcu/sync.c:177 CPU: 1 UID: 0 PID: 58 Comm: kworker/1:2 Not tainted 6.10.0-syzkaller-12562-g1722389b0d86 #0 Workqueue: events destroy_super_work RIP: 0010:rcu_sync_dtor+0xcd/0x180 kernel/rcu/sync.c:177 Call Trace: percpu_free_rwsem+0x41/0x80 kernel/locking/percpu-rwsem.c:42 destroy_super_work+0xec/0x130 fs/super.c:282 process_one_work kernel/workqueue.c:3231 [inline] process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3312 worker_thread+0x86d/0xd40 kernel/workqueue.c:3390 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  As Christian Brauner pointed out [1]: the root cause is f2fs sets SB_RDONLY flag in internal function, rather than setting the flag covered w/ sb->s_umount semaphore via remount procedure, then below race condition causes this bug:  - freeze_super() - sb_wait_write(sb, SB_FREEZE_WRITE) - sb_wait_write(sb, SB_FREEZE_PAGEFAULT) - sb_wait_write(sb, SB_FREEZE_FS) - f2fs_handle_critical_error - sb->s_flags |= SB_RDONLY - thaw_super - thaw_super_locked - sb_rdonly() is true, so it skips sb_freeze_unlock(sb, SB_FREEZE_FS) - deactivate_locked_super  Since f2fs has almost the same logic as ext4 [2] when handling critical error in filesystem if it mounts w/ errors=remount-ro option: - set CP_ERROR_FLAG flag which indicates filesystem is stopped - record errors to superblock - set SB_RDONLY falg Once we set CP_ERROR_FLAG flag, all writable interfaces can detect the flag and stop any further updates on filesystem. So, it is safe to not set SB_RDONLY flag, let's remove the logic and keep in line w/ ext4 [3].  [1] https://lore.kernel.org/all/20240729-himbeeren-funknetz-96e62f9c7aee@brauner [2] https://lore.kernel.org/all/20240729132721.hxih6ehigadqf7wx@quack3 [3] https://lore.kernel.org/linux-ext4/20240805201241.27286-1-jack@suse.cz",
      "cve": "CVE-2024-47689",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47689",
          "value": "CVE-2024-47689",
          "url": "https://scout.docker.com/v/CVE-2024-47689?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47689?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b6542435fb1f436193fbe1c688f033fde6e2bdb7bd6352a2f6ffd22a540b3cb8",
      "category": "container_scanning",
      "message": "CVE-2025-1147 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.",
      "cve": "CVE-2025-1147",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-1147",
          "value": "CVE-2025-1147",
          "url": "https://scout.docker.com/v/CVE-2025-1147?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-1147?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f246f3136dc843e3c2d77c247d6971cb23c5f240627e4ce833081d3dfcfc193d",
      "category": "container_scanning",
      "message": "CVE-2025-55160 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to versions 6.9.13-27 and 7.1.2-1, there is undefined behavior (function-type-mismatch) in splay tree cloning callback. This results in a deterministic abort under UBSan (DoS in sanitizer builds), with no crash in a non-sanitized build. This issue has been patched in versions 6.9.13-27 and 7.1.2-1.",
      "cve": "CVE-2025-55160",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-55160",
          "value": "CVE-2025-55160",
          "url": "https://scout.docker.com/v/CVE-2025-55160?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-55160?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9799e166d1b061731c46dd9ed38c3dab015f60f6143ca74fd08d51ec128dcafe",
      "category": "container_scanning",
      "message": "CVE-2015-7837 on ubuntu/linux@5.15.0-161.171",
      "description": "The Linux kernel, as used in Red Hat Enterprise Linux 7, kernel-rt, and Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended securelevel/secureboot restrictions by leveraging improper handling of secure_boot flag across kexec reboot.",
      "cve": "CVE-2015-7837",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2015-7837",
          "value": "CVE-2015-7837",
          "url": "https://scout.docker.com/v/CVE-2015-7837?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2015-7837?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ebb25758fa38eaadf68ca1283096fa75621c946a794eb7ac0e49a2182485f0c8",
      "category": "container_scanning",
      "message": "CVE-2016-8660 on ubuntu/linux@5.15.0-161.171",
      "description": "The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program, related to a \"page lock order bug in the XFS seek hole/data implementation.\"",
      "cve": "CVE-2016-8660",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2016-8660",
          "value": "CVE-2016-8660",
          "url": "https://scout.docker.com/v/CVE-2016-8660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2016-8660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e55f382585c2df50eb314e6f593d1a7f343e2217e768e5f6244c2db2a6250b2d",
      "category": "container_scanning",
      "message": "CVE-2021-3933 on ubuntu/openexr@2.5.7-1",
      "description": "An integer overflow could occur when OpenEXR processes a crafted file on systems where size_t < 64 bits. This could cause an invalid bytesPerLine and maxBytesPerLine value, which could lead to problems with application stability or lead to other attack paths.",
      "cve": "CVE-2021-3933",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/openexr@2.5.7-1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.5.7-1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3933",
          "value": "CVE-2021-3933",
          "url": "https://scout.docker.com/v/CVE-2021-3933?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3933?s=ubuntu&n=openexr&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6730af667ad9a841bda031d4324bac4bb982bb3b223044189d34b801b8d4fd0e",
      "category": "container_scanning",
      "message": "CVE-2021-4095 on ubuntu/linux@5.15.0-161.171",
      "description": "A NULL pointer dereference was found in the Linux kernel's KVM when dirty ring logging is enabled without an active vCPU context. An unprivileged local attacker on the host may use this flaw to cause a kernel oops condition and thus a denial of service by issuing a KVM_XEN_HVM_SET_ATTR ioctl. This flaw affects Linux kernel versions prior to 5.17-rc1.",
      "cve": "CVE-2021-4095",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-4095",
          "value": "CVE-2021-4095",
          "url": "https://scout.docker.com/v/CVE-2021-4095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-4095?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bb0b2d79a838e6e07e713cd07a79c7d4ed85579428351b8bb53d36249c56519b",
      "category": "container_scanning",
      "message": "CVE-2021-47658 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: fix a potential gpu_metrics_table memory leak  Memory is allocated for gpu_metrics_table in renoir_init_smc_tables(), but not freed in int smu_v12_0_fini_smc_tables(). Free it!",
      "cve": "CVE-2021-47658",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-47658",
          "value": "CVE-2021-47658",
          "url": "https://scout.docker.com/v/CVE-2021-47658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-47658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e29fa5132a39f41df30cc981a663fc686e6351c97731560b0d4c6fd6bc3646f2",
      "category": "container_scanning",
      "message": "CVE-2022-0480 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
      "cve": "CVE-2022-0480",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-0480",
          "value": "CVE-2022-0480",
          "url": "https://scout.docker.com/v/CVE-2022-0480?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-0480?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "89f86c27cb2d70307cbf3aac4fe8d53e56843e1824ba547a23161bb2e98b2052",
      "category": "container_scanning",
      "message": "CVE-2022-38457 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_cmd_res_check' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "cve": "CVE-2022-38457",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-38457",
          "value": "CVE-2022-38457",
          "url": "https://scout.docker.com/v/CVE-2022-38457?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-38457?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c272ef7372838928c3baef2d79d630fc697a5181af3aa8ccb308d38d71a4f4e8",
      "category": "container_scanning",
      "message": "CVE-2022-40133 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_execbuf_tie_context' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "cve": "CVE-2022-40133",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-40133",
          "value": "CVE-2022-40133",
          "url": "https://scout.docker.com/v/CVE-2022-40133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-40133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "23046f93d75d6255be7884752dfafe157b5c32286a690b6f5551f774f405259d",
      "category": "container_scanning",
      "message": "CVE-2022-4543 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw named \"EntryBleed\" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.",
      "cve": "CVE-2022-4543",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-4543",
          "value": "CVE-2022-4543",
          "url": "https://scout.docker.com/v/CVE-2022-4543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-4543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "77639352c20f230375d2e76d3ef8786005a7b79675b228cd65402dd9b23e12c5",
      "category": "container_scanning",
      "message": "CVE-2022-48628 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: drop messages from MDS when unmounting  When unmounting all the dirty buffers will be flushed and after the last osd request is finished the last reference of the i_count will be released. Then it will flush the dirty cap/snap to MDSs, and the unmounting won't wait the possible acks, which will ihold the inodes when updating the metadata locally but makes no sense any more, of this. This will make the evict_inodes() to skip these inodes.  If encrypt is enabled the kernel generate a warning when removing the encrypt keys when the skipped inodes still hold the keyring:  WARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt_destroy_keyring+0x7e/0xd0 CPU: 4 PID: 168846 Comm: umount Tainted: G S  6.1.0-rc5-ceph-g72ead199864c #1 Hardware name: Supermicro SYS-5018R-WR/X10SRW-F, BIOS 2.0 12/17/2015 RIP: 0010:fscrypt_destroy_keyring+0x7e/0xd0 RSP: 0018:ffffc9000b277e28 EFLAGS: 00010202 RAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00 RDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000 RBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000 R10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40 R13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000 FS:  00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> generic_shutdown_super+0x47/0x120 kill_anon_super+0x14/0x30 ceph_kill_sb+0x36/0x90 [ceph] deactivate_locked_super+0x29/0x60 cleanup_mnt+0xb8/0x140 task_work_run+0x67/0xb0 exit_to_user_mode_prepare+0x23d/0x240 syscall_exit_to_user_mode+0x25/0x60 do_syscall_64+0x40/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fd83dc39e9b  Later the kernel will crash when iput() the inodes and dereferencing the \"sb->s_master_keys\", which has been released by the generic_shutdown_super().",
      "cve": "CVE-2022-48628",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48628",
          "value": "CVE-2022-48628",
          "url": "https://scout.docker.com/v/CVE-2022-48628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48628?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "836b4cfac42191149a6039ec7b59288d081729df88806c35ce51b04c4211680f",
      "category": "container_scanning",
      "message": "CVE-2022-48673 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: Fix possible access to freed memory in link clear  After modifying the QP to the Error state, all RX WR would be completed with WC in IB_WC_WR_FLUSH_ERR status. Current implementation does not wait for it is done, but destroy the QP and free the link group directly. So there is a risk that accessing the freed memory in tasklet context.  Here is a crash example:  BUG: unable to handle page fault for address: ffffffff8f220860 #PF: supervisor write access in kernel mode #PF: error_code(0x0002) - not-present page PGD f7300e067 P4D f7300e067 PUD f7300f063 PMD 8c4e45063 PTE 800ffff08c9df060 Oops: 0002 [#1] SMP PTI CPU: 1 PID: 0 Comm: swapper/1 Kdump: loaded Tainted: G S         OE 5.10.0-0607+ #23 Hardware name: Inspur NF5280M4/YZMB-00689-101, BIOS 4.1.20 07/09/2018 RIP: 0010:native_queued_spin_lock_slowpath+0x176/0x1b0 Code: f3 90 48 8b 32 48 85 f6 74 f6 eb d5 c1 ee 12 83 e0 03 83 ee 01 48 c1 e0 05 48 63 f6 48 05 00 c8 02 00 48 03 04 f5 00 09 98 8e <48> 89 10 8b 42 08 85 c0 75 09 f3 90 8b 42 08 85 c0 74 f7 48 8b 32 RSP: 0018:ffffb3b6c001ebd8 EFLAGS: 00010086 RAX: ffffffff8f220860 RBX: 0000000000000246 RCX: 0000000000080000 RDX: ffff91db1f86c800 RSI: 000000000000173c RDI: ffff91db62bace00 RBP: ffff91db62bacc00 R08: 0000000000000000 R09: c00000010000028b R10: 0000000000055198 R11: ffffb3b6c001ea58 R12: ffff91db80e05010 R13: 000000000000000a R14: 0000000000000006 R15: 0000000000000040 FS:  0000000000000000(0000) GS:ffff91db1f840000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffff8f220860 CR3: 00000001f9580004 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> _raw_spin_lock_irqsave+0x30/0x40 mlx5_ib_poll_cq+0x4c/0xc50 [mlx5_ib] smc_wr_rx_tasklet_fn+0x56/0xa0 [smc] tasklet_action_common.isra.21+0x66/0x100 __do_softirq+0xd5/0x29c asm_call_irq_on_stack+0x12/0x20 </IRQ> do_softirq_own_stack+0x37/0x40 irq_exit_rcu+0x9d/0xa0 sysvec_call_function_single+0x34/0x80 asm_sysvec_call_function_single+0x12/0x20",
      "cve": "CVE-2022-48673",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48673",
          "value": "CVE-2022-48673",
          "url": "https://scout.docker.com/v/CVE-2022-48673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "097c8f85afb514aa26169d217187cfb421de1749975bb6e2475ff78b2a1da3ac",
      "category": "container_scanning",
      "message": "CVE-2022-48706 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vdpa: ifcvf: Do proper cleanup if IFCVF init fails  ifcvf_mgmt_dev leaks memory if it is not freed before returning. Call is made to correct return statement so memory does not leak. ifcvf_init_hw does not take care of this so it is needed to do it here.",
      "cve": "CVE-2022-48706",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48706",
          "value": "CVE-2022-48706",
          "url": "https://scout.docker.com/v/CVE-2022-48706?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48706?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7897429a31741a69683dfc24f4424390a5ce9d8c1bdc199696794a2b8b2a969c",
      "category": "container_scanning",
      "message": "CVE-2022-48766 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wrap dcn301_calculate_wm_and_dlg for FPU.  Mirrors the logic for dcn30. Cue lots of WARNs and some kernel panics without this fix.",
      "cve": "CVE-2022-48766",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48766",
          "value": "CVE-2022-48766",
          "url": "https://scout.docker.com/v/CVE-2022-48766?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48766?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "93668800bf1e69f2591067ffd6c15db14e29d18f2cb0b46a2f79378357c3be86",
      "category": "container_scanning",
      "message": "CVE-2022-48887 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/vmwgfx: Remove rcu locks from user resources  User resource lookups used rcu to avoid two extra atomics. Unfortunately the rcu paths were buggy and it was easy to make the driver crash by submitting command buffers from two different threads. Because the lookups never show up in performance profiles replace them with a regular spin lock which fixes the races in accesses to those shared resources.  Fixes kernel oops'es in IGT's vmwgfx execution_buffer stress test and seen crashes with apps using shared resources.",
      "cve": "CVE-2022-48887",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48887",
          "value": "CVE-2022-48887",
          "url": "https://scout.docker.com/v/CVE-2022-48887?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48887?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c8e9acc3ba28d46498a6ee59efed7a4e821c7f9ad558f9cbec06dd65130ac891",
      "category": "container_scanning",
      "message": "CVE-2022-48929 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix crash due to out of bounds access into reg2btf_ids.  When commit e6ac2450d6de (\"bpf: Support bpf program calling kernel function\") added kfunc support, it defined reg2btf_ids as a cheap way to translate the verifier reg type to the appropriate btf_vmlinux BTF ID, however commit c25b2ae13603 (\"bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL\") moved the __BPF_REG_TYPE_MAX from the last member of bpf_reg_type enum to after the base register types, and defined other variants using type flag composition. However, now, the direct usage of reg->type to index into reg2btf_ids may no longer fall into __BPF_REG_TYPE_MAX range, and hence lead to out of bounds access and kernel crash on dereference of bad pointer.",
      "cve": "CVE-2022-48929",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48929",
          "value": "CVE-2022-48929",
          "url": "https://scout.docker.com/v/CVE-2022-48929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9d2050bc97fa578ea313253c84e5e6e25f1c706049b0452d332a9b4cfb198a20",
      "category": "container_scanning",
      "message": "CVE-2022-48976 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: flowtable_offload: fix using __this_cpu_add in preemptible  flow_offload_queue_work() can be called in workqueue without bh disabled, like the call trace showed in my act_ct testing, calling NF_FLOW_TABLE_STAT_INC() there would cause a call trace:  BUG: using __this_cpu_add() in preemptible [00000000] code: kworker/u4:0/138560 caller is flow_offload_queue_work+0xec/0x1b0 [nf_flow_table] Workqueue: act_ct_workqueue tcf_ct_flow_table_cleanup_work [act_ct] Call Trace: <TASK> dump_stack_lvl+0x33/0x46 check_preemption_disabled+0xc3/0xf0 flow_offload_queue_work+0xec/0x1b0 [nf_flow_table] nf_flow_table_iterate+0x138/0x170 [nf_flow_table] nf_flow_table_free+0x140/0x1a0 [nf_flow_table] tcf_ct_flow_table_cleanup_work+0x2f/0x2b0 [act_ct] process_one_work+0x6a3/0x1030 worker_thread+0x8a/0xdf0  This patch fixes it by using NF_FLOW_TABLE_STAT_INC_ATOMIC() instead in flow_offload_queue_work().  Note that for FLOW_CLS_REPLACE branch in flow_offload_queue_work(), it may not be called in preemptible path, but it's good to use NF_FLOW_TABLE_STAT_INC_ATOMIC() for all cases in flow_offload_queue_work().",
      "cve": "CVE-2022-48976",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48976",
          "value": "CVE-2022-48976",
          "url": "https://scout.docker.com/v/CVE-2022-48976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d61d6adb911002c389fadf2d3db45e288ce4f41c032e92cd5165d2f8ced6395f",
      "category": "container_scanning",
      "message": "CVE-2022-48979 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: fix array index out of bound error in DCN32 DML  [Why&How] LinkCapacitySupport array is indexed with the number of voltage states and not the number of max DPPs. Fix the error by changing the array declaration to use the correct (larger) array size of total number of voltage states.",
      "cve": "CVE-2022-48979",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48979",
          "value": "CVE-2022-48979",
          "url": "https://scout.docker.com/v/CVE-2022-48979?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48979?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a6e79e6ce0eb6fa531b54b7e9874b340d95d2b4576e80b05a337b7a14aa1c0ef",
      "category": "container_scanning",
      "message": "CVE-2022-49069 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix by adding FPU protection for dcn30_internal_validate_bw  [Why] Below general protection fault observed when WebGL Aquarium is run for longer duration. If drm debug logs are enabled and set to 0x1f then the issue is observed within 10 minutes of run.  [  100.717056] general protection fault, probably for non-canonical address 0x2d33302d32323032: 0000 [#1] PREEMPT SMP NOPTI [  100.727921] CPU: 3 PID: 1906 Comm: DrmThread Tainted: G        W 5.15.30 #12 d726c6a2d6ebe5cf9223931cbca6892f916fe18b [  100.754419] RIP: 0010:CalculateSwathWidth+0x1f7/0x44f [  100.767109] Code: 00 00 00 f2 42 0f 11 04 f0 48 8b 85 88 00 00 00 f2 42 0f 10 04 f0 48 8b 85 98 00 00 00 f2 42 0f 11 04 f0 48 8b 45 10 0f 57 c0 <f3> 42 0f 2a 04 b0 0f 57 c9 f3 43 0f 2a 0c b4 e8 8c e2 f3 ff 48 8b [  100.781269] RSP: 0018:ffffa9230079eeb0 EFLAGS: 00010246 [  100.812528] RAX: 2d33302d32323032 RBX: 0000000000000500 RCX: 0000000000000000 [  100.819656] RDX: 0000000000000001 RSI: ffff99deb712c49c RDI: 0000000000000000 [  100.826781] RBP: ffffa9230079ef50 R08: ffff99deb712460c R09: ffff99deb712462c [  100.833907] R10: ffff99deb7124940 R11: ffff99deb7124d70 R12: ffff99deb712ae44 [  100.841033] R13: 0000000000000001 R14: 0000000000000000 R15: ffffa9230079f0a0 [  100.848159] FS:  00007af121212640(0000) GS:ffff99deba780000(0000) knlGS:0000000000000000 [  100.856240] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  100.861980] CR2: 0000209000fe1000 CR3: 000000011b18c000 CR4: 0000000000350ee0 [  100.869106] Call Trace: [  100.871555]  <TASK> [  100.873655]  ? asm_sysvec_reschedule_ipi+0x12/0x20 [  100.878449]  CalculateSwathAndDETConfiguration+0x1a3/0x6dd [  100.883937]  dml31_ModeSupportAndSystemConfigurationFull+0x2ce4/0x76da [  100.890467]  ? kallsyms_lookup_buildid+0xc8/0x163 [  100.895173]  ? kallsyms_lookup_buildid+0xc8/0x163 [  100.899874]  ? __sprint_symbol+0x80/0x135 [  100.903883]  ? dm_update_plane_state+0x3f9/0x4d2 [  100.908500]  ? symbol_string+0xb7/0xde [  100.912250]  ? number+0x145/0x29b [  100.915566]  ? vsnprintf+0x341/0x5ff [  100.919141]  ? desc_read_finalized_seq+0x39/0x87 [  100.923755]  ? update_load_avg+0x1b9/0x607 [  100.927849]  ? compute_mst_dsc_configs_for_state+0x7d/0xd5b [  100.933416]  ? fetch_pipe_params+0xa4d/0xd0c [  100.937686]  ? dc_fpu_end+0x3d/0xa8 [  100.941175]  dml_get_voltage_level+0x16b/0x180 [  100.945619]  dcn30_internal_validate_bw+0x10e/0x89b [  100.950495]  ? dcn31_validate_bandwidth+0x68/0x1fc [  100.955285]  ? resource_build_scaling_params+0x98b/0xb8c [  100.960595]  ? dcn31_validate_bandwidth+0x68/0x1fc [  100.965384]  dcn31_validate_bandwidth+0x9a/0x1fc [  100.970001]  dc_validate_global_state+0x238/0x295 [  100.974703]  amdgpu_dm_atomic_check+0x9c1/0xbce [  100.979235]  ? _printk+0x59/0x73 [  100.982467]  drm_atomic_check_only+0x403/0x78b [  100.986912]  drm_mode_atomic_ioctl+0x49b/0x546 [  100.991358]  ? drm_ioctl+0x1c1/0x3b3 [  100.994936]  ? drm_atomic_set_property+0x92a/0x92a [  100.999725]  drm_ioctl_kernel+0xdc/0x149 [  101.003648]  drm_ioctl+0x27f/0x3b3 [  101.007051]  ? drm_atomic_set_property+0x92a/0x92a [  101.011842]  amdgpu_drm_ioctl+0x49/0x7d [  101.015679]  __se_sys_ioctl+0x7c/0xb8 [  101.015685]  do_syscall_64+0x5f/0xb8 [  101.015690]  ? __irq_exit_rcu+0x34/0x96  [How] It calles populate_dml_pipes which uses doubles to initialize. Adding FPU protection avoids context switch and probable loss of vba context as there is potential contention while drm debug logs are enabled.",
      "cve": "CVE-2022-49069",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49069",
          "value": "CVE-2022-49069",
          "url": "https://scout.docker.com/v/CVE-2022-49069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "43a099000cb811d21bb6ba0d39cb162e005534829e9725588c627dd89d68bfaf",
      "category": "container_scanning",
      "message": "CVE-2022-49108 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  clk: mediatek: Fix memory leaks on probe  Handle the error branches to free memory where required.  Addresses-Coverity-ID: 1491825 (\"Resource leak\")",
      "cve": "CVE-2022-49108",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49108",
          "value": "CVE-2022-49108",
          "url": "https://scout.docker.com/v/CVE-2022-49108?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49108?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc29140fbe677a06911114b3c6839e32979939022960d51e078eec094d1be785",
      "category": "container_scanning",
      "message": "CVE-2022-49123 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ath11k: Fix frames flush failure caused by deadlock  We are seeing below warnings:  kernel: [25393.301506] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0 kernel: [25398.421509] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0 kernel: [25398.421831] ath11k_pci 0000:01:00.0: dropping mgmt frame for vdev 0, is_started 0  this means ath11k fails to flush mgmt. frames because wmi_mgmt_tx_work has no chance to run in 5 seconds.  By setting /proc/sys/kernel/hung_task_timeout_secs to 20 and increasing ATH11K_FLUSH_TIMEOUT to 50 we get below warnings:  kernel: [  120.763160] INFO: task wpa_supplicant:924 blocked for more than 20 seconds. kernel: [  120.763169]       Not tainted 5.10.90 #12 kernel: [  120.763177] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. kernel: [  120.763186] task:wpa_supplicant  state:D stack:    0 pid:  924 ppid:     1 flags:0x000043a0 kernel: [  120.763201] Call Trace: kernel: [  120.763214]  __schedule+0x785/0x12fa kernel: [  120.763224]  ? lockdep_hardirqs_on_prepare+0xe2/0x1bb kernel: [  120.763242]  schedule+0x7e/0xa1 kernel: [  120.763253]  schedule_timeout+0x98/0xfe kernel: [  120.763266]  ? run_local_timers+0x4a/0x4a kernel: [  120.763291]  ath11k_mac_flush_tx_complete+0x197/0x2b1 [ath11k 13c3a9bf37790f4ac8103b3decf7ab4008ac314a] kernel: [  120.763306]  ? init_wait_entry+0x2e/0x2e kernel: [  120.763343]  __ieee80211_flush_queues+0x167/0x21f [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763378]  __ieee80211_recalc_idle+0x105/0x125 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763411]  ieee80211_recalc_idle+0x14/0x27 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763441]  ieee80211_free_chanctx+0x77/0xa2 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763473]  __ieee80211_vif_release_channel+0x100/0x131 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763540]  ieee80211_vif_release_channel+0x66/0x81 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763572]  ieee80211_destroy_auth_data+0xa3/0xe6 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763612]  ieee80211_mgd_deauth+0x178/0x29b [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [  120.763654]  cfg80211_mlme_deauth+0x1a8/0x22c [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [  120.763697]  nl80211_deauthenticate+0xfa/0x123 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [  120.763715]  genl_rcv_msg+0x392/0x3c2 kernel: [  120.763750]  ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [  120.763782]  ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [  120.763802]  ? genl_rcv+0x36/0x36 kernel: [  120.763814]  netlink_rcv_skb+0x89/0xf7 kernel: [  120.763829]  genl_rcv+0x28/0x36 kernel: [  120.763840]  netlink_unicast+0x179/0x24b kernel: [  120.763854]  netlink_sendmsg+0x393/0x401 kernel: [  120.763872]  sock_sendmsg+0x72/0x76 kernel: [  120.763886]  ____sys_sendmsg+0x170/0x1e6 kernel: [  120.763897]  ? copy_msghdr_from_user+0x7a/0xa2 kernel: [  120.763914]  ___sys_sendmsg+0x95/0xd1 kernel: [  120.763940]  __sys_sendmsg+0x85/0xbf kernel: [  120.763956]  do_syscall_64+0x43/0x55 kernel: [  120.763966]  entry_SYSCALL_64_after_hwframe+0x44/0xa9 kernel: [  120.763977] RIP: 0033:0x79089f3fcc83 kernel: [  120.763986] RSP: 002b:00007ffe604f0508 EFLAGS: 00000246 ORIG_RAX: 000000000000002e kernel: [  120.763997] RAX: ffffffffffffffda RBX: 000059b40e987690 RCX: 000079089f3fcc83 kernel: [  120.764006] RDX: 0000000000000000 RSI: 00007ffe604f0558 RDI: 0000000000000009 kernel: [  120.764014] RBP: 00007ffe604f0540 R08: 0000000000000004 R09: 0000000000400000 kernel: [  120.764023] R10: 00007ffe604f0638 R11: 0000000000000246 R12: 000059b40ea04980 kernel: [  120.764032] R13: 00007ffe604 ---truncated---",
      "cve": "CVE-2022-49123",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49123",
          "value": "CVE-2022-49123",
          "url": "https://scout.docker.com/v/CVE-2022-49123?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49123?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1c9cd162c67191e6662ef082d1e1eaea696f898c953c0b33b282708c9d8bda2f",
      "category": "container_scanning",
      "message": "CVE-2022-49124 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mce: Work around an erratum on fast string copy instructions  A rare kernel panic scenario can happen when the following conditions are met due to an erratum on fast string copy instructions:  1) An uncorrected error. 2) That error must be in first cache line of a page. 3) Kernel must execute page_copy from the page immediately before that page.  The fast string copy instructions (\"REP; MOVS*\") could consume an uncorrectable memory error in the cache line _right after_ the desired region to copy and raise an MCE.  Bit 0 of MSR_IA32_MISC_ENABLE can be cleared to disable fast string copy and will avoid such spurious machine checks. However, that is less preferable due to the permanent performance impact. Considering memory poison is rare, it's desirable to keep fast string copy enabled until an MCE is seen.  Intel has confirmed the following: 1. The CPU erratum of fast string copy only applies to Skylake, Cascade Lake and Cooper Lake generations.  Directly return from the MCE handler: 2. Will result in complete execution of the \"REP; MOVS*\" with no data loss or corruption. 3. Will not result in another MCE firing on the next poisoned cache line due to \"REP; MOVS*\". 4. Will resume execution from a correct point in code. 5. Will result in the same instruction that triggered the MCE firing a second MCE immediately for any other software recoverable data fetch errors. 6. Is not safe without disabling the fast string copy, as the next fast string copy of the same buffer on the same CPU would result in a PANIC MCE.  This should mitigate the erratum completely with the only caveat that the fast string copy is disabled on the affected hyper thread thus performance degradation.  This is still better than the OS crashing on MCEs raised on an irrelevant process due to \"REP; MOVS*' accesses in a kernel context, e.g., copy_page.   Injected errors on 1st cache line of 8 anonymous pages of process 'proc1' and observed MCE consumption from 'proc2' with no panic (directly returned).  Without the fix, the host panicked within a few minutes on a random 'proc2' process due to kernel access from copy_page.  [ bp: Fix comment style + touch ups, zap an unlikely(), improve the quirk function's readability. ]",
      "cve": "CVE-2022-49124",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49124",
          "value": "CVE-2022-49124",
          "url": "https://scout.docker.com/v/CVE-2022-49124?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49124?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c0f2098d501f033cf1cc81c1bd7c50bb564d2dcfd636cded420afee9eba95746",
      "category": "container_scanning",
      "message": "CVE-2022-49125 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/sprd: fix potential NULL dereference  'drm' could be null in sprd_drm_shutdown, and drm_warn maybe dereference it, remove this warning log.   v1 -> v2: - Split checking platform_get_resource() return value to a separate patch - Use dev_warn() instead of removing the warning log",
      "cve": "CVE-2022-49125",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49125",
          "value": "CVE-2022-49125",
          "url": "https://scout.docker.com/v/CVE-2022-49125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "160423c280cb8110ad9ef6018237d2ce4c441a202b0896b73fc258f980766202",
      "category": "container_scanning",
      "message": "CVE-2022-49133 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: svm range restore work deadlock when process exit  kfd_process_notifier_release flush svm_range_restore_work which calls svm_range_list_lock_and_flush_work to flush deferred_list work, but if deferred_list work mmput release the last user, it will call exit_mmap -> notifier_release, it is deadlock with below backtrace.  Move flush svm_range_restore_work to kfd_process_wq_release to avoid deadlock. Then svm_range_restore_work take task->mm ref to avoid mm is gone while validating and mapping ranges to GPU.  Workqueue: events svm_range_deferred_list_work [amdgpu] Call Trace: wait_for_completion+0x94/0x100 __flush_work+0x12a/0x1e0 __cancel_work_timer+0x10e/0x190 cancel_delayed_work_sync+0x13/0x20 kfd_process_notifier_release+0x98/0x2a0 [amdgpu] __mmu_notifier_release+0x74/0x1f0 exit_mmap+0x170/0x200 mmput+0x5d/0x130 svm_range_deferred_list_work+0x104/0x230 [amdgpu] process_one_work+0x220/0x3c0",
      "cve": "CVE-2022-49133",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49133",
          "value": "CVE-2022-49133",
          "url": "https://scout.docker.com/v/CVE-2022-49133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e3ea3d75bfc87a957571f9dc13ff646ff41df124209f15706ba1195c5d3799bd",
      "category": "container_scanning",
      "message": "CVE-2022-49134 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mlxsw: spectrum: Guard against invalid local ports  When processing events generated by the device's firmware, the driver protects itself from events reported for non-existent local ports, but not for the CPU port (local port 0), which exists, but does not have all the fields as any local port.  This can result in a NULL pointer dereference when trying access 'struct mlxsw_sp_port' fields which are not initialized for CPU port.  Commit 63b08b1f6834 (\"mlxsw: spectrum: Protect driver from buggy firmware\") already handled such issue by bailing early when processing a PUDE event reported for the CPU port.  Generalize the approach by moving the check to a common function and making use of it in all relevant places.",
      "cve": "CVE-2022-49134",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49134",
          "value": "CVE-2022-49134",
          "url": "https://scout.docker.com/v/CVE-2022-49134?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49134?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "331033b87f76fbdc8e839157503331791b7891326d0f2959fc02eb5771cf67f6",
      "category": "container_scanning",
      "message": "CVE-2022-49161 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: mediatek: Fix error handling in mt8183_da7219_max98357_dev_probe  The device_node pointer is returned by of_parse_phandle()  with refcount incremented. We should use of_node_put() on it when done.  This function only calls of_node_put() in the regular path. And it will cause refcount leak in error paths. Fix this by calling of_node_put() in error handling too.",
      "cve": "CVE-2022-49161",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49161",
          "value": "CVE-2022-49161",
          "url": "https://scout.docker.com/v/CVE-2022-49161?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49161?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3af2bebbba43a35fcd7aede26226871805d0a570825a3d7ff6d0de2c1a896532",
      "category": "container_scanning",
      "message": "CVE-2022-49167 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: do not double complete bio on errors during compressed reads  I hit some weird panics while fixing up the error handling from btrfs_lookup_bio_sums().  Turns out the compression path will complete the bio we use if we set up any of the compression bios and then return an error, and then btrfs_submit_data_bio() will also call bio_endio() on the bio.  Fix this by making btrfs_submit_compressed_read() responsible for calling bio_endio() on the bio if there are any errors.  Currently it was only doing it if we created the compression bios, otherwise it was depending on btrfs_submit_data_bio() to do the right thing.  This creates the above problem, so fix up btrfs_submit_compressed_read() to always call bio_endio() in case of an error, and then simply return from btrfs_submit_data_bio() if we had to call btrfs_submit_compressed_read().",
      "cve": "CVE-2022-49167",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49167",
          "value": "CVE-2022-49167",
          "url": "https://scout.docker.com/v/CVE-2022-49167?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49167?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "96282d9f0aa52fcf8638b7455901889a014f8d2f68a75e522de7f4dfcb31ae7f",
      "category": "container_scanning",
      "message": "CVE-2022-49173 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: fsi: Implement a timeout for polling status  The data transfer routines must poll the status register to determine when more data can be shifted in or out. If the hardware gets into a bad state, these polling loops may never exit. Prevent this by returning an error if a timeout is exceeded.",
      "cve": "CVE-2022-49173",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49173",
          "value": "CVE-2022-49173",
          "url": "https://scout.docker.com/v/CVE-2022-49173?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49173?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5783eef5c489a5a003ed2dde96813ca0c45f52a50e488557183b1769dac526b8",
      "category": "container_scanning",
      "message": "CVE-2022-49177 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hwrng: cavium - fix NULL but dereferenced coccicheck error  Fix following coccicheck warning: ./drivers/char/hw_random/cavium-rng-vf.c:182:17-20: ERROR: pdev is NULL but dereferenced.",
      "cve": "CVE-2022-49177",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49177",
          "value": "CVE-2022-49177",
          "url": "https://scout.docker.com/v/CVE-2022-49177?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49177?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4402e6053a084e4698ed276c8f2f9dfb27e94b85e8daa53a1721a012eed37bd8",
      "category": "container_scanning",
      "message": "CVE-2022-49178 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  memstick/mspro_block: fix handling of read-only devices  Use set_disk_ro to propagate the read-only state to the block layer instead of checking for it in ->open and leaking a reference in case of a read-only device.",
      "cve": "CVE-2022-49178",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49178",
          "value": "CVE-2022-49178",
          "url": "https://scout.docker.com/v/CVE-2022-49178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49178?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "92c6d6c2d65c94cfc31f78b0721bb39367d4d5ac764803e7700ea12e681dcf8a",
      "category": "container_scanning",
      "message": "CVE-2022-49203 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix double free during GPU reset on DC streams  [Why] The issue only occurs during the GPU reset code path.  We first backup the current state prior to commiting 0 streams internally from DM to DC. This state backup contains valid link encoder assignments.  DC will clear the link encoder assignments as part of current state (but not the backup, since it was a copied before the commit) and free the extra stream reference it held.  DC requires that the link encoder assignments remain cleared/invalid prior to commiting. Since the backup still has valid assignments we call the interface post reset to clear them. This routine also releases the extra reference that the link encoder interface held - resulting in a double free (and eventually a NULL pointer dereference).  [How] We'll have to do a full DC commit anyway after GPU reset because the stream count previously went to 0.  We don't need to retain the assignment that we had backed up, so just copy off of the now clean current state assignment after the reset has occcurred with the new link_enc_cfg_copy() interface.",
      "cve": "CVE-2022-49203",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49203",
          "value": "CVE-2022-49203",
          "url": "https://scout.docker.com/v/CVE-2022-49203?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49203?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "701e73e686f39dc0381a55131a3bfd68580661c24173b3259bf94ab1bf02f495",
      "category": "container_scanning",
      "message": "CVE-2022-49245 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: rockchip: Fix PM usage reference of rockchip_i2s_tdm_resume  pm_runtime_get_sync will increment pm usage counter even it failed. Forgetting to putting operation will result in reference leak here. We fix it by replacing it with pm_runtime_resume_and_get to keep usage counter balanced.",
      "cve": "CVE-2022-49245",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49245",
          "value": "CVE-2022-49245",
          "url": "https://scout.docker.com/v/CVE-2022-49245?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49245?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "69c825111d653152534e6f6452e134f0db83c0ad31e7a96b8f2da2bbfd664c75",
      "category": "container_scanning",
      "message": "CVE-2022-49296 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: fix possible deadlock when holding Fwb to get inline_data  1, mount with wsync. 2, create a file with O_RDWR, and the request was sent to mds.0:  ceph_atomic_open()--> ceph_mdsc_do_request(openc) finish_open(file, dentry, ceph_open)--> ceph_open()--> ceph_init_file()--> ceph_init_file_info()--> ceph_uninline_data()--> { ... if (inline_version == 1 || /* initial version, no data */ inline_version == CEPH_INLINE_NONE) goto out_unlock; ... }  The inline_version will be 1, which is the initial version for the new create file. And here the ci->i_inline_version will keep with 1, it's buggy.  3, buffer write to the file immediately:  ceph_write_iter()--> ceph_get_caps(file, need=Fw, want=Fb, ...); generic_perform_write()--> a_ops->write_begin()--> ceph_write_begin()--> netfs_write_begin()--> netfs_begin_read()--> netfs_rreq_submit_slice()--> netfs_read_from_server()--> rreq->netfs_ops->issue_read()--> ceph_netfs_issue_read()--> { ... if (ci->i_inline_version != CEPH_INLINE_NONE && ceph_netfs_issue_op_inline(subreq)) return; ... } ceph_put_cap_refs(ci, Fwb);  The ceph_netfs_issue_op_inline() will send a getattr(Fsr) request to mds.1.  4, then the mds.1 will request the rd lock for CInode::filelock from the auth mds.0, the mds.0 will do the CInode::filelock state transation from excl --> sync, but it need to revoke the Fxwb caps back from the clients.  While the kernel client has aleady held the Fwb caps and waiting for the getattr(Fsr).  It's deadlock!  URL: https://tracker.ceph.com/issues/55377",
      "cve": "CVE-2022-49296",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49296",
          "value": "CVE-2022-49296",
          "url": "https://scout.docker.com/v/CVE-2022-49296?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49296?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5fdcbd5dbfe814d6d8bbd6921e9d208d3e61ebbb0fa0e1ff8ac5a60751f55166",
      "category": "container_scanning",
      "message": "CVE-2022-49303 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drivers: staging: rtl8192eu: Fix deadlock in rtw_joinbss_event_prehandle  There is a deadlock in rtw_joinbss_event_prehandle(), which is shown below:  (Thread 1)                |      (Thread 2) | _set_timer() rtw_joinbss_event_prehandle()|  mod_timer() spin_lock_bh() //(1)        |  (wait a time) ...                         | rtw_join_timeout_handler() |  _rtw_join_timeout_handler() del_timer_sync()            |   spin_lock_bh() //(2) (wait timer to stop)        |   ...  We hold pmlmepriv->lock in position (1) of thread 1 and use del_timer_sync() to wait timer to stop, but timer handler also need pmlmepriv->lock in position (2) of thread 2. As a result, rtw_joinbss_event_prehandle() will block forever.  This patch extracts del_timer_sync() from the protection of spin_lock_bh(), which could let timer handler to obtain the needed lock. What`s more, we change spin_lock_bh() to spin_lock_irq() in _rtw_join_timeout_handler() in order to prevent deadlock.",
      "cve": "CVE-2022-49303",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49303",
          "value": "CVE-2022-49303",
          "url": "https://scout.docker.com/v/CVE-2022-49303?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49303?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f4b775027c07ce648c6ad65798ab798fee16a469d9b1006315ed077214950f1e",
      "category": "container_scanning",
      "message": "CVE-2022-49306 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: dwc3: host: Stop setting the ACPI companion  It is no longer needed. The sysdev pointer is now used when assigning the ACPI companions to the xHCI ports and USB devices.  Assigning the ACPI companion here resulted in the fwnode->secondary pointer to be replaced also for the parent dwc3 device since the primary fwnode (the ACPI companion) was shared. That was unintentional and it created potential side effects like resource leaks.",
      "cve": "CVE-2022-49306",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49306",
          "value": "CVE-2022-49306",
          "url": "https://scout.docker.com/v/CVE-2022-49306?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49306?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "498f256b980763630cdcb95720a47823ae4a0859663f4d2cac07aa3494b33346",
      "category": "container_scanning",
      "message": "CVE-2022-49317 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: avoid infinite loop to flush node pages  xfstests/generic/475 can give EIO all the time which give an infinite loop to flush node page like below. Let's avoid it.  [16418.518551] Call Trace: [16418.518553]  ? dm_submit_bio+0x48/0x400 [16418.518574]  ? submit_bio_checks+0x1ac/0x5a0 [16418.525207]  __submit_bio+0x1a9/0x230 [16418.525210]  ? kmem_cache_alloc+0x29e/0x3c0 [16418.525223]  submit_bio_noacct+0xa8/0x2b0 [16418.525226]  submit_bio+0x4d/0x130 [16418.525238]  __submit_bio+0x49/0x310 [f2fs] [16418.525339]  ? bio_add_page+0x6a/0x90 [16418.525344]  f2fs_submit_page_bio+0x134/0x1f0 [f2fs] [16418.525365]  read_node_page+0x125/0x1b0 [f2fs] [16418.525388]  __get_node_page.part.0+0x58/0x3f0 [f2fs] [16418.525409]  __get_node_page+0x2f/0x60 [f2fs] [16418.525431]  f2fs_get_dnode_of_data+0x423/0x860 [f2fs] [16418.525452]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [16418.525458]  ? __mod_memcg_state.part.0+0x2a/0x30 [16418.525465]  ? __mod_memcg_lruvec_state+0x27/0x40 [16418.525467]  ? __xa_set_mark+0x57/0x70 [16418.525472]  f2fs_do_write_data_page+0x10e/0x7b0 [f2fs] [16418.525493]  f2fs_write_single_data_page+0x555/0x830 [f2fs] [16418.525514]  ? sysvec_apic_timer_interrupt+0x4e/0x90 [16418.525518]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [16418.525523]  f2fs_write_cache_pages+0x303/0x880 [f2fs] [16418.525545]  ? blk_flush_plug_list+0x47/0x100 [16418.525548]  f2fs_write_data_pages+0xfd/0x320 [f2fs] [16418.525569]  do_writepages+0xd5/0x210 [16418.525648]  filemap_fdatawrite_wbc+0x7d/0xc0 [16418.525655]  filemap_fdatawrite+0x50/0x70 [16418.525658]  f2fs_sync_dirty_inodes+0xa4/0x230 [f2fs] [16418.525679]  f2fs_write_checkpoint+0x16d/0x1720 [f2fs] [16418.525699]  ? ttwu_do_wakeup+0x1c/0x160 [16418.525709]  ? ttwu_do_activate+0x6d/0xd0 [16418.525711]  ? __wait_for_common+0x11d/0x150 [16418.525715]  kill_f2fs_super+0xca/0x100 [f2fs] [16418.525733]  deactivate_locked_super+0x3b/0xb0 [16418.525739]  deactivate_super+0x40/0x50 [16418.525741]  cleanup_mnt+0x139/0x190 [16418.525747]  __cleanup_mnt+0x12/0x20 [16418.525749]  task_work_run+0x6d/0xa0 [16418.525765]  exit_to_user_mode_prepare+0x1ad/0x1b0 [16418.525771]  syscall_exit_to_user_mode+0x27/0x50 [16418.525774]  do_syscall_64+0x48/0xc0 [16418.525776]  entry_SYSCALL_64_after_hwframe+0x44/0xae",
      "cve": "CVE-2022-49317",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49317",
          "value": "CVE-2022-49317",
          "url": "https://scout.docker.com/v/CVE-2022-49317?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49317?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d33594e0991e7e664df68634a462b9fae4e15e5cdfa9108747418e83b1a23d89",
      "category": "container_scanning",
      "message": "CVE-2022-49333 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: E-Switch, pair only capable devices  OFFLOADS paring using devcom is possible only on devices that support LAG. Filter based on lag capabilities.  This fixes an issue where mlx5_get_next_phys_dev() was called without holding the interface lock.  This issue was found when commit bc4c2f2e0179 (\"net/mlx5: Lag, filter non compatible devices\") added an assert that verifies the interface lock is held.  WARNING: CPU: 9 PID: 1706 at drivers/net/ethernet/mellanox/mlx5/core/dev.c:642 mlx5_get_next_phys_dev+0xd2/0x100 [mlx5_core] Modules linked in: mlx5_vdpa vringh vhost_iotlb vdpa mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_umad ib_ipoib ib_cm ib_uverbs ib_core overlay fuse [last unloaded: mlx5_core] CPU: 9 PID: 1706 Comm: devlink Not tainted 5.18.0-rc7+ #11 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:mlx5_get_next_phys_dev+0xd2/0x100 [mlx5_core] Code: 02 00 75 48 48 8b 85 80 04 00 00 5d c3 31 c0 5d c3 be ff ff ff ff 48 c7 c7 08 41 5b a0 e8 36 87 28 e3 85 c0 0f 85 6f ff ff ff <0f> 0b e9 68 ff ff ff 48 c7 c7 0c 91 cc 84 e8 cb 36 6f e1 e9 4d ff RSP: 0018:ffff88811bf47458 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff88811b398000 RCX: 0000000000000001 RDX: 0000000080000000 RSI: ffffffffa05b4108 RDI: ffff88812daaaa78 RBP: ffff88812d050380 R08: 0000000000000001 R09: ffff88811d6b3437 R10: 0000000000000001 R11: 00000000fddd3581 R12: ffff88815238c000 R13: ffff88812d050380 R14: ffff8881018aa7e0 R15: ffff88811d6b3428 FS:  00007fc82e18ae80(0000) GS:ffff88842e080000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f9630d1b421 CR3: 0000000149802004 CR4: 0000000000370ea0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> mlx5_esw_offloads_devcom_event+0x99/0x3b0 [mlx5_core] mlx5_devcom_send_event+0x167/0x1d0 [mlx5_core] esw_offloads_enable+0x1153/0x1500 [mlx5_core] ? mlx5_esw_offloads_controller_valid+0x170/0x170 [mlx5_core] ? wait_for_completion_io_timeout+0x20/0x20 ? mlx5_rescan_drivers_locked+0x318/0x810 [mlx5_core] mlx5_eswitch_enable_locked+0x586/0xc50 [mlx5_core] ? mlx5_eswitch_disable_pf_vf_vports+0x1d0/0x1d0 [mlx5_core] ? mlx5_esw_try_lock+0x1b/0xb0 [mlx5_core] ? mlx5_eswitch_enable+0x270/0x270 [mlx5_core] ? __debugfs_create_file+0x260/0x3e0 mlx5_devlink_eswitch_mode_set+0x27e/0x870 [mlx5_core] ? mutex_lock_io_nested+0x12c0/0x12c0 ? esw_offloads_disable+0x250/0x250 [mlx5_core] ? devlink_nl_cmd_trap_get_dumpit+0x470/0x470 ? rcu_read_lock_sched_held+0x3f/0x70 devlink_nl_cmd_eswitch_set_doit+0x217/0x620",
      "cve": "CVE-2022-49333",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49333",
          "value": "CVE-2022-49333",
          "url": "https://scout.docker.com/v/CVE-2022-49333?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49333?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "546a225925ddc38c3af9bed7cc7e304f8966ae57a23438b99281a480ae767110",
      "category": "container_scanning",
      "message": "CVE-2022-49342 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ethernet: bgmac: Fix refcount leak in bcma_mdio_mii_register  of_get_child_by_name() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",
      "cve": "CVE-2022-49342",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49342",
          "value": "CVE-2022-49342",
          "url": "https://scout.docker.com/v/CVE-2022-49342?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49342?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4853ae50390d8b02510b6862a65f8a427bd86e3a503f3fcf3ea3a65d19e1b299",
      "category": "container_scanning",
      "message": "CVE-2022-49393 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  misc: fastrpc: fix list iterator in fastrpc_req_mem_unmap_impl  This is another instance of incorrect use of list iterator and checking it for NULL.  The list iterator value 'map' will *always* be set and non-NULL by list_for_each_entry(), so it is incorrect to assume that the iterator value will be NULL if the list is empty (in this case, the check 'if (!map) {' will always be false and never exit as expected).  To fix the bug, use a new variable 'iter' as the list iterator, while use the original variable 'map' as a dedicated pointer to point to the found element.  Without this patch, Kernel crashes with below trace:  Unable to handle kernel access to user memory outside uaccess routines at virtual address 0000ffff7fb03750 ... Call trace: fastrpc_map_create+0x70/0x290 [fastrpc] fastrpc_req_mem_map+0xf0/0x2dc [fastrpc] fastrpc_device_ioctl+0x138/0xc60 [fastrpc] __arm64_sys_ioctl+0xa8/0xec invoke_syscall+0x48/0x114 el0_svc_common.constprop.0+0xd4/0xfc do_el0_svc+0x28/0x90 el0_svc+0x3c/0x130 el0t_64_sync_handler+0xa4/0x130 el0t_64_sync+0x18c/0x190 Code: 14000016 f94000a5 eb05029f 54000260 (b94018a6) ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2022-49393",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49393",
          "value": "CVE-2022-49393",
          "url": "https://scout.docker.com/v/CVE-2022-49393?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49393?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2128b9804cae476c0a59a39f5597c1e1f9fa66eb723af1b75a07cd4a4cb9d332",
      "category": "container_scanning",
      "message": "CVE-2022-49420 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: annotate races around sk->sk_bound_dev_if  UDP sendmsg() is lockless, and reads sk->sk_bound_dev_if while this field can be changed by another thread.  Adds minimal annotations to avoid KCSAN splats for UDP. Following patches will add more annotations to potential lockless readers.  BUG: KCSAN: data-race in __ip6_datagram_connect / udpv6_sendmsg  write to 0xffff888136d47a94 of 4 bytes by task 7681 on cpu 0: __ip6_datagram_connect+0x6e2/0x930 net/ipv6/datagram.c:221 ip6_datagram_connect+0x2a/0x40 net/ipv6/datagram.c:272 inet_dgram_connect+0x107/0x190 net/ipv4/af_inet.c:576 __sys_connect_file net/socket.c:1900 [inline] __sys_connect+0x197/0x1b0 net/socket.c:1917 __do_sys_connect net/socket.c:1927 [inline] __se_sys_connect net/socket.c:1924 [inline] __x64_sys_connect+0x3d/0x50 net/socket.c:1924 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae  read to 0xffff888136d47a94 of 4 bytes by task 7670 on cpu 1: udpv6_sendmsg+0xc60/0x16e0 net/ipv6/udp.c:1436 inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:652 sock_sendmsg_nosec net/socket.c:705 [inline] sock_sendmsg net/socket.c:725 [inline] ____sys_sendmsg+0x39a/0x510 net/socket.c:2413 ___sys_sendmsg net/socket.c:2467 [inline] __sys_sendmmsg+0x267/0x4c0 net/socket.c:2553 __do_sys_sendmmsg net/socket.c:2582 [inline] __se_sys_sendmmsg net/socket.c:2579 [inline] __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2579 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x44/0xae  value changed: 0x00000000 -> 0xffffff9b  Reported by Kernel Concurrency Sanitizer on: CPU: 1 PID: 7670 Comm: syz-executor.3 Tainted: G        W 5.18.0-rc1-syzkaller-dirty #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011  I chose to not add Fixes: tag because race has minor consequences and stable teams busy enough.",
      "cve": "CVE-2022-49420",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49420",
          "value": "CVE-2022-49420",
          "url": "https://scout.docker.com/v/CVE-2022-49420?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49420?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9b59f4c810352d03e6d6cb8ce3924940638470570d1466eeda2015b654c3976f",
      "category": "container_scanning",
      "message": "CVE-2022-49469 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix anon_dev leak in create_subvol()  When btrfs_qgroup_inherit(), btrfs_alloc_tree_block, or btrfs_insert_root() fail in create_subvol(), we return without freeing anon_dev. Reorganize the error handling in create_subvol() to fix this.",
      "cve": "CVE-2022-49469",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49469",
          "value": "CVE-2022-49469",
          "url": "https://scout.docker.com/v/CVE-2022-49469?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49469?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "23e463ca751c4735fd691068e3d16cf347cb392cbf7687a7ee371a342227a7e2",
      "category": "container_scanning",
      "message": "CVE-2022-49476 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mt76: mt7921: fix kernel crash at mt7921_pci_remove  The crash log shown it is possible that mt7921_irq_handler is called while devm_free_irq is being handled so mt76_free_device need to be postponed until devm_free_irq is completed to solve the crash we free the mt76 device too early.  [ 9299.339655] BUG: kernel NULL pointer dereference, address: 0000000000000008 [ 9299.339705] #PF: supervisor read access in kernel mode [ 9299.339735] #PF: error_code(0x0000) - not-present page [ 9299.339768] PGD 0 P4D 0 [ 9299.339786] Oops: 0000 [#1] SMP PTI [ 9299.339812] CPU: 1 PID: 1624 Comm: prepare-suspend Not tainted 5.15.14-1.fc32.qubes.x86_64 #1 [ 9299.339863] Hardware name: Xen HVM domU, BIOS 4.14.3 01/20/2022 [ 9299.339901] RIP: 0010:mt7921_irq_handler+0x1e/0x70 [mt7921e] [ 9299.340048] RSP: 0018:ffffa81b80c27cb0 EFLAGS: 00010082 [ 9299.340081] RAX: 0000000000000000 RBX: ffff98a4cb752020 RCX: ffffffffa96211c5 [ 9299.340123] RDX: 0000000000000000 RSI: 00000000000d4204 RDI: ffff98a4cb752020 [ 9299.340165] RBP: ffff98a4c28a62a4 R08: ffff98a4c37a96c0 R09: 0000000080150011 [ 9299.340207] R10: 0000000040000000 R11: 0000000000000000 R12: ffff98a4c4eaa080 [ 9299.340249] R13: ffff98a4c28a6360 R14: ffff98a4cb752020 R15: ffff98a4c28a6228 [ 9299.340297] FS: 00007260840d3740(0000) GS:ffff98a4ef700000(0000) knlGS:0000000000000000 [ 9299.340345] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 9299.340383] CR2: 0000000000000008 CR3: 0000000004c56001 CR4: 0000000000770ee0 [ 9299.340432] PKRU: 55555554 [ 9299.340449] Call Trace: [ 9299.340467] <TASK> [ 9299.340485] __free_irq+0x221/0x350 [ 9299.340527] free_irq+0x30/0x70 [ 9299.340553] devm_free_irq+0x55/0x80 [ 9299.340579] mt7921_pci_remove+0x2f/0x40 [mt7921e] [ 9299.340616] pci_device_remove+0x3b/0xa0 [ 9299.340651] __device_release_driver+0x17a/0x240 [ 9299.340686] device_driver_detach+0x3c/0xa0 [ 9299.340714] unbind_store+0x113/0x130 [ 9299.340740] kernfs_fop_write_iter+0x124/0x1b0 [ 9299.340775] new_sync_write+0x15c/0x1f0 [ 9299.340806] vfs_write+0x1d2/0x270 [ 9299.340831] ksys_write+0x67/0xe0 [ 9299.340857] do_syscall_64+0x3b/0x90 [ 9299.340887] entry_SYSCALL_64_after_hwframe+0x44/0xae",
      "cve": "CVE-2022-49476",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49476",
          "value": "CVE-2022-49476",
          "url": "https://scout.docker.com/v/CVE-2022-49476?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49476?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eab8f689639c1fe0c6a72bdbef631a7ea705e19e894911580147ddc6f9224b49",
      "category": "container_scanning",
      "message": "CVE-2022-49484 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mt76: mt7915: fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector  Fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector routine if the chip does not support dbdc and the hw reports band_idx set to 1.",
      "cve": "CVE-2022-49484",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49484",
          "value": "CVE-2022-49484",
          "url": "https://scout.docker.com/v/CVE-2022-49484?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49484?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "416cb56633044e9f19093b99898da8233ef217c15d94ec74274f1b255502c660",
      "category": "container_scanning",
      "message": "CVE-2022-49496 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.ko  If the driver support subdev mode, the parameter \"dev->pm.dev\" will be NULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmod mtk-vcodec-dec.ko.  [ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80 [ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14c [ 4380.711509] sp : ffff80000819bc10 [ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000 [ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000 [ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220 [ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020 [ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976 [ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040 [ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000 [ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebc [ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000 [ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208 [ 4380.786031] Call trace: [ 4380.788465]  do_raw_spin_trylock+0x4/0x80 [ 4380.792462]  __pm_runtime_disable+0x2c/0x1b0 [ 4380.796723]  mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec] [ 4380.802466]  platform_remove+0x2c/0x60 [ 4380.806204]  __device_release_driver+0x194/0x250 [ 4380.810810]  driver_detach+0xc8/0x15c [ 4380.814462]  bus_remove_driver+0x5c/0xb0 [ 4380.818375]  driver_unregister+0x34/0x64 [ 4380.822288]  platform_driver_unregister+0x18/0x24 [ 4380.826979]  mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec] [ 4380.833240]  __arm64_sys_delete_module+0x190/0x224 [ 4380.838020]  invoke_syscall+0x48/0x114 [ 4380.841760]  el0_svc_common.constprop.0+0x60/0x11c [ 4380.846540]  do_el0_svc+0x28/0x90 [ 4380.849844]  el0_svc+0x4c/0x100 [ 4380.852975]  el0t_64_sync_handler+0xec/0xf0 [ 4380.857148]  el0t_64_sync+0x190/0x194 [ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004)",
      "cve": "CVE-2022-49496",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49496",
          "value": "CVE-2022-49496",
          "url": "https://scout.docker.com/v/CVE-2022-49496?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49496?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7163e7e000eb0c58dcde29bc8ca0c6659472f7b5e6b401593850f45158b9b44c",
      "category": "container_scanning",
      "message": "CVE-2022-49504 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Inhibit aborts if external loopback plug is inserted  After running a short external loopback test, when the external loopback is removed and a normal cable inserted that is directly connected to a target device, the system oops in the llpfc_set_rrq_active() routine.  When the loopback was inserted an FLOGI was transmit. As we're looped back, we receive the FLOGI request. The FLOGI is ABTS'd as we recognize the same wppn thus understand it's a loopback. However, as the ABTS sends address information the port is not set to (fffffe), the ABTS is dropped on the wire. A short 1 frame loopback test is run and completes before the ABTS times out. The looback is unplugged and the new cable plugged in, and the an FLOGI to the new device occurs and completes. Due to a mixup in ref counting the completion of the new FLOGI releases the fabric ndlp. Then the original ABTS completes and references the released ndlp generating the oops.  Correct by no-op'ing the ABTS when in loopback mode (it will be dropped anyway). Added a flag to track the mode to recognize when it should be no-op'd.",
      "cve": "CVE-2022-49504",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49504",
          "value": "CVE-2022-49504",
          "url": "https://scout.docker.com/v/CVE-2022-49504?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49504?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2d2009e015a211dd51500fa8ba77d2654f4907d20d67af5ae4d2c8b35d00008b",
      "category": "container_scanning",
      "message": "CVE-2022-49516 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: always check VF VSI pointer values  The ice_get_vf_vsi function can return NULL in some cases, such as if handling messages during a reset where the VSI is being removed and recreated.  Several places throughout the driver do not bother to check whether this VSI pointer is valid. Static analysis tools maybe report issues because they detect paths where a potentially NULL pointer could be dereferenced.  Fix this by checking the return value of ice_get_vf_vsi everywhere.",
      "cve": "CVE-2022-49516",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49516",
          "value": "CVE-2022-49516",
          "url": "https://scout.docker.com/v/CVE-2022-49516?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49516?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3b12ab25e1527a39f074a04e45888d8e32e4743a8f961f8dc8fd3d6f3f5cbd0b",
      "category": "container_scanning",
      "message": "CVE-2022-49528 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: i2c: dw9714: Disable the regulator when the driver fails to probe  When the driver fails to probe, we will get the following splat:  [   59.305988] ------------[ cut here ]------------ [   59.306417] WARNING: CPU: 2 PID: 395 at drivers/regulator/core.c:2257 _regulator_put+0x3ec/0x4e0 [   59.310345] RIP: 0010:_regulator_put+0x3ec/0x4e0 [   59.318362] Call Trace: [   59.318582]  <TASK> [   59.318765]  regulator_put+0x1f/0x30 [   59.319058]  devres_release_group+0x319/0x3d0 [   59.319420]  i2c_device_probe+0x766/0x940  Fix this by disabling the regulator in error handling.",
      "cve": "CVE-2022-49528",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49528",
          "value": "CVE-2022-49528",
          "url": "https://scout.docker.com/v/CVE-2022-49528?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49528?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "578fed4f7bf0af873cf618c52d5dd19dc5c286bd0a4db59c8d340a520b3effde",
      "category": "container_scanning",
      "message": "CVE-2022-49529 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu/pm: fix the null pointer while the smu is disabled  It needs to check if the pp_funcs is initialized while release the context, otherwise it will trigger null pointer panic while the software smu is not enabled.  [ 1109.404555] BUG: kernel NULL pointer dereference, address: 0000000000000078 [ 1109.404609] #PF: supervisor read access in kernel mode [ 1109.404638] #PF: error_code(0x0000) - not-present page [ 1109.404657] PGD 0 P4D 0 [ 1109.404672] Oops: 0000 [#1] PREEMPT SMP NOPTI [ 1109.404701] CPU: 7 PID: 9150 Comm: amdgpu_test Tainted: G           OEL 5.16.0-custom #1 [ 1109.404732] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006 [ 1109.404765] RIP: 0010:amdgpu_dpm_force_performance_level+0x1d/0x170 [amdgpu] [ 1109.405109] Code: 5d c3 44 8b a3 f0 80 00 00 eb e5 66 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 48 83 ec 08 4c 8b b7 f0 7d 00 00 <49> 83 7e 78 00 0f 84 f2 00 00 00 80 bf 87 80 00 00 00 48 89 fb 0f [ 1109.405176] RSP: 0018:ffffaf3083ad7c20 EFLAGS: 00010282 [ 1109.405203] RAX: 0000000000000000 RBX: ffff9796b1c14600 RCX: 0000000002862007 [ 1109.405229] RDX: ffff97968591c8c0 RSI: 0000000000000001 RDI: ffff9796a3700000 [ 1109.405260] RBP: ffffaf3083ad7c50 R08: ffffffff9897de00 R09: ffff979688d9db60 [ 1109.405286] R10: 0000000000000000 R11: ffff979688d9db90 R12: 0000000000000001 [ 1109.405316] R13: ffff9796a3700000 R14: 0000000000000000 R15: ffff9796a3708fc0 [ 1109.405345] FS:  00007ff055cff180(0000) GS:ffff9796bfdc0000(0000) knlGS:0000000000000000 [ 1109.405378] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1109.405400] CR2: 0000000000000078 CR3: 000000000a394000 CR4: 00000000000506e0 [ 1109.405434] Call Trace: [ 1109.405445]  <TASK> [ 1109.405456]  ? delete_object_full+0x1d/0x20 [ 1109.405480]  amdgpu_ctx_set_stable_pstate+0x7c/0xa0 [amdgpu] [ 1109.405698]  amdgpu_ctx_fini.part.0+0xcb/0x100 [amdgpu] [ 1109.405911]  amdgpu_ctx_do_release+0x71/0x80 [amdgpu] [ 1109.406121]  amdgpu_ctx_ioctl+0x52d/0x550 [amdgpu] [ 1109.406327]  ? _raw_spin_unlock+0x1a/0x30 [ 1109.406354]  ? drm_gem_handle_delete+0x81/0xb0 [drm] [ 1109.406400]  ? amdgpu_ctx_get_entity+0x2c0/0x2c0 [amdgpu] [ 1109.406609]  drm_ioctl_kernel+0xb6/0x140 [drm]",
      "cve": "CVE-2022-49529",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49529",
          "value": "CVE-2022-49529",
          "url": "https://scout.docker.com/v/CVE-2022-49529?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49529?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "82b57d795776a8a1fdaf567133dce302849e62b61233bc90e2598d03765ff68f",
      "category": "container_scanning",
      "message": "CVE-2022-49531 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  loop: implement ->free_disk  Ensure that the lo_device which is stored in the gendisk private data is valid until the gendisk is freed.  Currently the loop driver uses a lot of effort to make sure a device is not freed when it is still in use, but to to fix a potential deadlock this will be relaxed a bit soon.",
      "cve": "CVE-2022-49531",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49531",
          "value": "CVE-2022-49531",
          "url": "https://scout.docker.com/v/CVE-2022-49531?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49531?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6e158e9945832b977b671dc133ae74b27321b9ac087b26681cc015611e21ff14",
      "category": "container_scanning",
      "message": "CVE-2022-49533 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ath11k: Change max no of active probe SSID and BSSID to fw capability  The maximum number of SSIDs in a for active probe requests is currently reported as 16 (WLAN_SCAN_PARAMS_MAX_SSID) when registering the driver. The scan_req_params structure only has the capacity to hold 10 SSIDs. This leads to a buffer overflow which can be triggered from wpa_supplicant in userspace. When copying the SSIDs into the scan_req_params structure in the ath11k_mac_op_hw_scan route, it can overwrite the extraie pointer.  Firmware supports 16 ssid * 4 bssid, for each ssid 4 bssid combo probe request will be sent, so totally 64 probe requests supported. So set both max ssid and bssid to 16 and 4 respectively. Remove the redundant macros of ssid and bssid.  Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01300-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2022-49533",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49533",
          "value": "CVE-2022-49533",
          "url": "https://scout.docker.com/v/CVE-2022-49533?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49533?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "45f61a739711a063d3f8e8237a67bb137af4e5814d99fca10785f7937d09e8c5",
      "category": "container_scanning",
      "message": "CVE-2022-49534 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Protect memory leak for NPIV ports sending PLOGI_RJT  There is a potential memory leak in lpfc_ignore_els_cmpl() and lpfc_els_rsp_reject() that was allocated from NPIV PLOGI_RJT (lpfc_rcv_plogi()'s login_mbox).  Check if cmdiocb->context_un.mbox was allocated in lpfc_ignore_els_cmpl(), and then free it back to phba->mbox_mem_pool along with mbox->ctx_buf for service parameters.  For lpfc_els_rsp_reject() failure, free both the ctx_buf for service parameters and the login_mbox.",
      "cve": "CVE-2022-49534",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49534",
          "value": "CVE-2022-49534",
          "url": "https://scout.docker.com/v/CVE-2022-49534?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49534?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "82de709dcc54766fb55075bcb75d68df597e0fba8b1c5aef38ef036538a9e00d",
      "category": "container_scanning",
      "message": "CVE-2022-49539 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rtw89: ser: fix CAM leaks occurring in L2 reset  The CAM, meaning address CAM and bssid CAM here, will get leaks during SER (system error recover) L2 reset process and ieee80211_restart_hw() which is called by L2 reset process eventually.  The normal flow would be like -> add interface (acquire 1) -> enter ips (release 1) -> leave ips (acquire 1) -> connection (occupy 1) <(A) 1 leak after L2 reset if non-sec connection>  The ieee80211_restart_hw() flow (under connection) -> ieee80211 reconfig -> add interface (acquire 1) -> leave ips (acquire 1) -> connection (occupy (A) + 2) <(B) 1 more leak>  Originally, CAM is released before HW restart only if connection is under security. Now, release CAM whatever connection it is to fix leak in (A). OTOH, check if CAM is already valid to avoid acquiring multiple times to fix (B).  Besides, if AP mode, release address CAM of all stations before HW restart.",
      "cve": "CVE-2022-49539",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49539",
          "value": "CVE-2022-49539",
          "url": "https://scout.docker.com/v/CVE-2022-49539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49539?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bfaaf7971f0eaa395316366b5634ca5602cc580fa8f0c81be08ab1e628a01c3b",
      "category": "container_scanning",
      "message": "CVE-2022-49543 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ath11k: fix the warning of dev_wake in mhi_pm_disable_transition()  When test device recovery with below command, it has warning in message as below. echo assert > /sys/kernel/debug/ath11k/wcn6855\\ hw2.0/simulate_fw_crash echo assert > /sys/kernel/debug/ath11k/qca6390\\ hw2.0/simulate_fw_crash  warning message: [ 1965.642121] ath11k_pci 0000:06:00.0: simulating firmware assert crash [ 1968.471364] ieee80211 phy0: Hardware restart was requested [ 1968.511305] ------------[ cut here ]------------ [ 1968.511368] WARNING: CPU: 3 PID: 1546 at drivers/bus/mhi/core/pm.c:505 mhi_pm_disable_transition+0xb37/0xda0 [mhi] [ 1968.511443] Modules linked in: ath11k_pci ath11k mac80211 libarc4 cfg80211 qmi_helpers qrtr_mhi mhi qrtr nvme nvme_core [ 1968.511563] CPU: 3 PID: 1546 Comm: kworker/u17:0 Kdump: loaded Tainted: G        W         5.17.0-rc3-wt-ath+ #579 [ 1968.511629] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021 [ 1968.511704] Workqueue: mhi_hiprio_wq mhi_pm_st_worker [mhi] [ 1968.511787] RIP: 0010:mhi_pm_disable_transition+0xb37/0xda0 [mhi] [ 1968.511870] Code: a9 fe ff ff 4c 89 ff 44 89 04 24 e8 03 46 f6 e5 44 8b 04 24 41 83 f8 01 0f 84 21 fe ff ff e9 4c fd ff ff 0f 0b e9 af f8 ff ff <0f> 0b e9 5c f8 ff ff 48 89 df e8 da 9e ee e3 e9 12 fd ff ff 4c 89 [ 1968.511923] RSP: 0018:ffffc900024efbf0 EFLAGS: 00010286 [ 1968.511969] RAX: 00000000ffffffff RBX: ffff88811d241250 RCX: ffffffffc0176922 [ 1968.512014] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff888118a90a24 [ 1968.512059] RBP: ffff888118a90800 R08: 0000000000000000 R09: ffff888118a90a27 [ 1968.512102] R10: ffffed1023152144 R11: 0000000000000001 R12: ffff888118a908ac [ 1968.512229] R13: ffff888118a90928 R14: dffffc0000000000 R15: ffff888118a90a24 [ 1968.512310] FS:  0000000000000000(0000) GS:ffff888234200000(0000) knlGS:0000000000000000 [ 1968.512405] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1968.512493] CR2: 00007f5538f443a8 CR3: 000000016dc28001 CR4: 00000000003706e0 [ 1968.512587] Call Trace: [ 1968.512672]  <TASK> [ 1968.512751]  ? _raw_spin_unlock_irq+0x1f/0x40 [ 1968.512859]  mhi_pm_st_worker+0x3ac/0x790 [mhi] [ 1968.512959]  ? mhi_pm_mission_mode_transition.isra.0+0x7d0/0x7d0 [mhi] [ 1968.513063]  process_one_work+0x86a/0x1400 [ 1968.513184]  ? pwq_dec_nr_in_flight+0x230/0x230 [ 1968.513312]  ? move_linked_works+0x125/0x290 [ 1968.513416]  worker_thread+0x6db/0xf60 [ 1968.513536]  ? process_one_work+0x1400/0x1400 [ 1968.513627]  kthread+0x241/0x2d0 [ 1968.513733]  ? kthread_complete_and_exit+0x20/0x20 [ 1968.513821]  ret_from_fork+0x22/0x30 [ 1968.513924]  </TASK>  Reason is mhi_deassert_dev_wake() from mhi_device_put() is called but mhi_assert_dev_wake() from __mhi_device_get_sync() is not called in progress of recovery. Commit 8e0559921f9a (\"bus: mhi: core: Skip device wake in error or shutdown state\") add check for the pm_state of mhi in __mhi_device_get_sync(), and the pm_state is not the normal state untill recovery is completed, so it leads the dev_wake is not 0 and above warning print in mhi_pm_disable_transition() while checking mhi_cntrl->dev_wake.  Add check in ath11k_pci_write32()/ath11k_pci_read32() to skip call mhi_device_put() if mhi_device_get_sync() does not really do wake, then the warning gone.  Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
      "cve": "CVE-2022-49543",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49543",
          "value": "CVE-2022-49543",
          "url": "https://scout.docker.com/v/CVE-2022-49543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "59bc8f785c0c2d4d39238efb87cc2e03c306f595439ce0ba1d50927eb40bba52",
      "category": "container_scanning",
      "message": "CVE-2022-49547 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix deadlock between concurrent dio writes when low on free data space  When reserving data space for a direct IO write we can end up deadlocking if we have multiple tasks attempting a write to the same file range, there are multiple extents covered by that file range, we are low on available space for data and the writes don't expand the inode's i_size.  The deadlock can happen like this:  1) We have a file with an i_size of 1M, at offset 0 it has an extent with a size of 128K and at offset 128K it has another extent also with a size of 128K;  2) Task A does a direct IO write against file range [0, 256K), and because the write is within the i_size boundary, it takes the inode's lock (VFS level) in shared mode;  3) Task A locks the file range [0, 256K) at btrfs_dio_iomap_begin(), and then gets the extent map for the extent covering the range [0, 128K). At btrfs_get_blocks_direct_write(), it creates an ordered extent for that file range ([0, 128K));  4) Before returning from btrfs_dio_iomap_begin(), it unlocks the file range [0, 256K);  5) Task A executes btrfs_dio_iomap_begin() again, this time for the file range [128K, 256K), and locks the file range [128K, 256K);  6) Task B starts a direct IO write against file range [0, 256K) as well. It also locks the inode in shared mode, as it's within the i_size limit, and then tries to lock file range [0, 256K). It is able to lock the subrange [0, 128K) but then blocks waiting for the range [128K, 256K), as it is currently locked by task A;  7) Task A enters btrfs_get_blocks_direct_write() and tries to reserve data space. Because we are low on available free space, it triggers the async data reclaim task, and waits for it to reserve data space;  8) The async reclaim task decides to wait for all existing ordered extents to complete (through btrfs_wait_ordered_roots()). It finds the ordered extent previously created by task A for the file range [0, 128K) and waits for it to complete;  9) The ordered extent for the file range [0, 128K) can not complete because it blocks at btrfs_finish_ordered_io() when trying to lock the file range [0, 128K).  This results in a deadlock, because:  - task B is holding the file range [0, 128K) locked, waiting for the range [128K, 256K) to be unlocked by task A;  - task A is holding the file range [128K, 256K) locked and it's waiting for the async data reclaim task to satisfy its space reservation request;  - the async data reclaim task is waiting for ordered extent [0, 128K) to complete, but the ordered extent can not complete because the file range [0, 128K) is currently locked by task B, which is waiting on task A to unlock file range [128K, 256K) and task A waiting on the async data reclaim task.  This results in a deadlock between 4 task: task A, task B, the async data reclaim task and the task doing ordered extent completion (a work queue task).  This type of deadlock can sporadically be triggered by the test case generic/300 from fstests, and results in a stack trace like the following:  [12084.033689] INFO: task kworker/u16:7:123749 blocked for more than 241 seconds. [12084.034877]       Not tainted 5.18.0-rc2-btrfs-next-115 #1 [12084.035562] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [12084.036548] task:kworker/u16:7   state:D stack:    0 pid:123749 ppid: 2 flags:0x00004000 [12084.036554] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs] [12084.036599] Call Trace: [12084.036601]  <TASK> [12084.036606]  __schedule+0x3cb/0xed0 [12084.036616]  schedule+0x4e/0xb0 [12084.036620]  btrfs_start_ordered_extent+0x109/0x1c0 [btrfs] [12084.036651]  ? prepare_to_wait_exclusive+0xc0/0xc0 [12084.036659]  btrfs_run_ordered_extent_work+0x1a/0x30 [btrfs] [12084.036688]  btrfs_work_helper+0xf8/0x400 [btrfs] [12084.0367 ---truncated---",
      "cve": "CVE-2022-49547",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49547",
          "value": "CVE-2022-49547",
          "url": "https://scout.docker.com/v/CVE-2022-49547?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49547?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f93dadcbb1c10398b7d2ad4319fd89b8de96bf1f2f18345b0d891542d7f4e52a",
      "category": "container_scanning",
      "message": "CVE-2022-49552 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix combination of jit blinding and pointers to bpf subprogs.  The combination of jit blinding and pointers to bpf subprogs causes: [   36.989548] BUG: unable to handle page fault for address: 0000000100000001 [   36.990342] #PF: supervisor instruction fetch in kernel mode [   36.990968] #PF: error_code(0x0010) - not-present page [   36.994859] RIP: 0010:0x100000001 [   36.995209] Code: Unable to access opcode bytes at RIP 0xffffffd7. [   37.004091] Call Trace: [   37.004351]  <TASK> [   37.004576]  ? bpf_loop+0x4d/0x70 [   37.004932]  ? bpf_prog_3899083f75e4c5de_F+0xe3/0x13b  The jit blinding logic didn't recognize that ld_imm64 with an address of bpf subprogram is a special instruction and proceeded to randomize it. By itself it wouldn't have been an issue, but jit_subprogs() logic relies on two step process to JIT all subprogs and then JIT them again when addresses of all subprogs are known. Blinding process in the first JIT phase caused second JIT to miss adjustment of special ld_imm64.  Fix this issue by ignoring special ld_imm64 instructions that don't have user controlled constants and shouldn't be blinded.",
      "cve": "CVE-2022-49552",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49552",
          "value": "CVE-2022-49552",
          "url": "https://scout.docker.com/v/CVE-2022-49552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49552?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2e4e46667602eb504673bd6baa863969ae5935a2494bcd767b669026d461bbf2",
      "category": "container_scanning",
      "message": "CVE-2022-49562 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86: Use __try_cmpxchg_user() to update guest PTE A/D bits  Use the recently introduced __try_cmpxchg_user() to update guest PTE A/D bits instead of mapping the PTE into kernel address space.  The VM_PFNMAP path is broken as it assumes that vm_pgoff is the base pfn of the mapped VMA range, which is conceptually wrong as vm_pgoff is the offset relative to the file and has nothing to do with the pfn.  The horrific hack worked for the original use case (backing guest memory with /dev/mem), but leads to accessing \"random\" pfns for pretty much any other VM_PFNMAP case.",
      "cve": "CVE-2022-49562",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49562",
          "value": "CVE-2022-49562",
          "url": "https://scout.docker.com/v/CVE-2022-49562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49562?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "968154849c3e0b954ec71ef65797aa148c806f6eec469a9bda30888e7db2f654",
      "category": "container_scanning",
      "message": "CVE-2022-49699 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  filemap: Handle sibling entries in filemap_get_read_batch()  If a read races with an invalidation followed by another read, it is possible for a folio to be replaced with a higher-order folio.  If that happens, we'll see a sibling entry for the new folio in the next iteration of the loop.  This manifests as a NULL pointer dereference while holding the RCU read lock.  Handle this by simply returning.  The next call will find the new folio and handle it correctly.  The other ways of handling this rare race are more complex and it's just not worth it.",
      "cve": "CVE-2022-49699",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49699",
          "value": "CVE-2022-49699",
          "url": "https://scout.docker.com/v/CVE-2022-49699?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49699?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bb29d60ff6c869962b65d830d22cff2bd5a5145aa865502f566d13eb48b12639",
      "category": "container_scanning",
      "message": "CVE-2022-49742 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: initialize locks earlier in f2fs_fill_super()  syzbot is reporting lockdep warning at f2fs_handle_error() [1], for spin_lock(&sbi->error_lock) is called before spin_lock_init() is called. For safe locking in error handling, move initialization of locks (and obvious structures) in f2fs_fill_super() to immediately after memory allocation.",
      "cve": "CVE-2022-49742",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49742",
          "value": "CVE-2022-49742",
          "url": "https://scout.docker.com/v/CVE-2022-49742?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49742?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "473eb4d1b2dcda8bbb72599d9eccb27d0adf494144add14359086d7d7f970e64",
      "category": "container_scanning",
      "message": "CVE-2022-49750 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpufreq: CPPC: Add u64 casts to avoid overflowing  The fields of the _CPC object are unsigned 32-bits values. To avoid overflows while using _CPC's values, add 'u64' casts.",
      "cve": "CVE-2022-49750",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49750",
          "value": "CVE-2022-49750",
          "url": "https://scout.docker.com/v/CVE-2022-49750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49750?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3e62687f053281690b9b47819fc3a28f58546c9254e2912de9e14b61639b56bb",
      "category": "container_scanning",
      "message": "CVE-2022-49759 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  VMCI: Use threaded irqs instead of tasklets  The vmci_dispatch_dgs() tasklet function calls vmci_read_data() which uses wait_event() resulting in invalid sleep in an atomic context (and therefore potentially in a deadlock).  Use threaded irqs to fix this issue and completely remove usage of tasklets.  [   20.264639] BUG: sleeping function called from invalid context at drivers/misc/vmw_vmci/vmci_guest.c:145 [   20.264643] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 762, name: vmtoolsd [   20.264645] preempt_count: 101, expected: 0 [   20.264646] RCU nest depth: 0, expected: 0 [   20.264647] 1 lock held by vmtoolsd/762: [   20.264648]  #0: ffff0000874ae440 (sk_lock-AF_VSOCK){+.+.}-{0:0}, at: vsock_connect+0x60/0x330 [vsock] [   20.264658] Preemption disabled at: [   20.264659] [<ffff80000151d7d8>] vmci_send_datagram+0x44/0xa0 [vmw_vmci] [   20.264665] CPU: 0 PID: 762 Comm: vmtoolsd Not tainted 5.19.0-0.rc8.20220727git39c3c396f813.60.fc37.aarch64 #1 [   20.264667] Hardware name: VMware, Inc. VBSA/VBSA, BIOS VEFI 12/31/2020 [   20.264668] Call trace: [   20.264669]  dump_backtrace+0xc4/0x130 [   20.264672]  show_stack+0x24/0x80 [   20.264673]  dump_stack_lvl+0x88/0xb4 [   20.264676]  dump_stack+0x18/0x34 [   20.264677]  __might_resched+0x1a0/0x280 [   20.264679]  __might_sleep+0x58/0x90 [   20.264681]  vmci_read_data+0x74/0x120 [vmw_vmci] [   20.264683]  vmci_dispatch_dgs+0x64/0x204 [vmw_vmci] [   20.264686]  tasklet_action_common.constprop.0+0x13c/0x150 [   20.264688]  tasklet_action+0x40/0x50 [   20.264689]  __do_softirq+0x23c/0x6b4 [   20.264690]  __irq_exit_rcu+0x104/0x214 [   20.264691]  irq_exit_rcu+0x1c/0x50 [   20.264693]  el1_interrupt+0x38/0x6c [   20.264695]  el1h_64_irq_handler+0x18/0x24 [   20.264696]  el1h_64_irq+0x68/0x6c [   20.264697]  preempt_count_sub+0xa4/0xe0 [   20.264698]  _raw_spin_unlock_irqrestore+0x64/0xb0 [   20.264701]  vmci_send_datagram+0x7c/0xa0 [vmw_vmci] [   20.264703]  vmci_datagram_dispatch+0x84/0x100 [vmw_vmci] [   20.264706]  vmci_datagram_send+0x2c/0x40 [vmw_vmci] [   20.264709]  vmci_transport_send_control_pkt+0xb8/0x120 [vmw_vsock_vmci_transport] [   20.264711]  vmci_transport_connect+0x40/0x7c [vmw_vsock_vmci_transport] [   20.264713]  vsock_connect+0x278/0x330 [vsock] [   20.264715]  __sys_connect_file+0x8c/0xc0 [   20.264718]  __sys_connect+0x84/0xb4 [   20.264720]  __arm64_sys_connect+0x2c/0x3c [   20.264721]  invoke_syscall+0x78/0x100 [   20.264723]  el0_svc_common.constprop.0+0x68/0x124 [   20.264724]  do_el0_svc+0x38/0x4c [   20.264725]  el0_svc+0x60/0x180 [   20.264726]  el0t_64_sync_handler+0x11c/0x150 [   20.264728]  el0t_64_sync+0x190/0x194",
      "cve": "CVE-2022-49759",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49759",
          "value": "CVE-2022-49759",
          "url": "https://scout.docker.com/v/CVE-2022-49759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b88b25d166641abc0306827e33a339dd0b92b2bec9d0055dd6877f5569eb0769",
      "category": "container_scanning",
      "message": "CVE-2022-49901 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  blk-mq: Fix kmemleak in blk_mq_init_allocated_queue  There is a kmemleak caused by modprobe null_blk.ko  unreferenced object 0xffff8881acb1f000 (size 1024): comm \"modprobe\", pid 836, jiffies 4294971190 (age 27.068s) hex dump (first 32 bytes): 00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N.......... ff ff ff ff ff ff ff ff 00 53 99 9e ff ff ff ff  .........S...... backtrace: [<000000004a10c249>] kmalloc_node_trace+0x22/0x60 [<00000000648f7950>] blk_mq_alloc_and_init_hctx+0x289/0x350 [<00000000af06de0e>] blk_mq_realloc_hw_ctxs+0x2fe/0x3d0 [<00000000e00c1872>] blk_mq_init_allocated_queue+0x48c/0x1440 [<00000000d16b4e68>] __blk_mq_alloc_disk+0xc8/0x1c0 [<00000000d10c98c3>] 0xffffffffc450d69d [<00000000b9299f48>] 0xffffffffc4538392 [<0000000061c39ed6>] do_one_initcall+0xd0/0x4f0 [<00000000b389383b>] do_init_module+0x1a4/0x680 [<0000000087cf3542>] load_module+0x6249/0x7110 [<00000000beba61b8>] __do_sys_finit_module+0x140/0x200 [<00000000fdcfff51>] do_syscall_64+0x35/0x80 [<000000003c0f1f71>] entry_SYSCALL_64_after_hwframe+0x46/0xb0  That is because q->ma_ops is set to NULL before blk_release_queue is called.  blk_mq_init_queue_data blk_mq_init_allocated_queue blk_mq_realloc_hw_ctxs for (i = 0; i < set->nr_hw_queues; i++) { old_hctx = xa_load(&q->hctx_table, i); if (!blk_mq_alloc_and_init_hctx(.., i, ..))\t\t[1] if (!old_hctx) break;  xa_for_each_start(&q->hctx_table, j, hctx, j) blk_mq_exit_hctx(q, set, hctx, j); \t\t\t[2]  if (!q->nr_hw_queues)\t\t\t\t\t[3] goto err_hctxs;  err_exit: q->mq_ops = NULL;\t\t\t  \t\t\t[4]  blk_put_queue blk_release_queue if (queue_is_mq(q))\t\t\t\t\t[5] blk_mq_release(q);  [1]: blk_mq_alloc_and_init_hctx failed at i != 0. [2]: The hctxs allocated by [1] are moved to q->unused_hctx_list and will be cleaned up in blk_mq_release. [3]: q->nr_hw_queues is 0. [4]: Set q->mq_ops to NULL. [5]: queue_is_mq returns false due to [4]. And blk_mq_release will not be called. The hctxs in q->unused_hctx_list are leaked.  To fix it, call blk_release_queue in exception path.",
      "cve": "CVE-2022-49901",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49901",
          "value": "CVE-2022-49901",
          "url": "https://scout.docker.com/v/CVE-2022-49901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5dbc6fb19152a91d8e6a0b083b5820e0b18de914217faf8adee6699653464920",
      "category": "container_scanning",
      "message": "CVE-2023-0160 on ubuntu/linux@5.15.0-161.171",
      "description": "A deadlock flaw was found in the Linux kernels BPF subsystem. This flaw allows a local user to potentially crash the system.",
      "cve": "CVE-2023-0160",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-0160",
          "value": "CVE-2023-0160",
          "url": "https://scout.docker.com/v/CVE-2023-0160?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-0160?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9dad718897b27fa54e1f9c8bf26160e7ca250a23b58e2fbc5cc1e5102a32c906",
      "category": "container_scanning",
      "message": "CVE-2023-31082 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel. Note: This has been disputed by 3rd parties as not a valid vulnerability.",
      "cve": "CVE-2023-31082",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-31082",
          "value": "CVE-2023-31082",
          "url": "https://scout.docker.com/v/CVE-2023-31082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-31082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "afef83806c4f64ddbd058533962b026cd714fec09a82677aad0b40c8293b825c",
      "category": "container_scanning",
      "message": "CVE-2023-3195 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A stack-based buffer overflow issue was found in ImageMagick's coders/tiff.c. This flaw allows an attacker to trick the user into opening a specially crafted malicious tiff file, causing an application to crash, resulting in a denial of service.",
      "cve": "CVE-2023-3195",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-3195",
          "value": "CVE-2023-3195",
          "url": "https://scout.docker.com/v/CVE-2023-3195?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-3195?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9225ff656466438739ae400a12c0e30161cb0569827e6b520411a0701bc3cd4a",
      "category": "container_scanning",
      "message": "CVE-2023-3428 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A heap-based buffer overflow vulnerability was found  in coders/tiff.c in ImageMagick. This issue may allow a local attacker to trick the user into opening a specially crafted file, resulting in an application crash and denial of service.",
      "cve": "CVE-2023-3428",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-3428",
          "value": "CVE-2023-3428",
          "url": "https://scout.docker.com/v/CVE-2023-3428?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-3428?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2c8cbab0cb9d21217d3030aa759cda1f41d990708fe782b015062ebd51a93be8",
      "category": "container_scanning",
      "message": "CVE-2023-52485 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before sending a command  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] For functions that execute within a DC context or DC lock we can wrap the direct calls to dm_execute_dmub_cmd/list with code that exits idle power optimizations and reallows once we're done with the command submission on success.  For DM direct submissions the DM will need to manage the enter/exit sequencing manually.  We cannot invoke a DMCUB command directly within the DM execution helper or we can deadlock.",
      "cve": "CVE-2023-52485",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52485",
          "value": "CVE-2023-52485",
          "url": "https://scout.docker.com/v/CVE-2023-52485?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52485?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f7ca969266b73e00507aae7e19011364e6d8fd5b0bbd1019410c9146528c25af",
      "category": "container_scanning",
      "message": "CVE-2023-52569 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: remove BUG() after failure to insert delayed dir index item  Instead of calling BUG() when we fail to insert a delayed dir index item into the delayed node's tree, we can just release all the resources we have allocated/acquired before and return the error to the caller. This is fine because all existing call chains undo anything they have done before calling btrfs_insert_delayed_dir_index() or BUG_ON (when creating pending snapshots in the transaction commit path).  So remove the BUG() call and do proper error handling.  This relates to a syzbot report linked below, but does not fix it because it only prevents hitting a BUG(), it does not fix the issue where somehow we attempt to use twice the same index number for different index items.",
      "cve": "CVE-2023-52569",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52569",
          "value": "CVE-2023-52569",
          "url": "https://scout.docker.com/v/CVE-2023-52569?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52569?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2be771351179de104aca43ca905f5bf98f6a578e4e71d4a3d0ac9451fcfde66b",
      "category": "container_scanning",
      "message": "CVE-2023-52582 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfs: Only call folio_start_fscache() one time for each folio  If a network filesystem using netfs implements a clamp_length() function, it can set subrequest lengths smaller than a page size.  When we loop through the folios in netfs_rreq_unlock_folios() to set any folios to be written back, we need to make sure we only call folio_start_fscache() once for each folio.  Otherwise, this simple testcase:  mount -o fsc,rsize=1024,wsize=1024 127.0.0.1:/export /mnt/nfs dd if=/dev/zero of=/mnt/nfs/file.bin bs=4096 count=1 1+0 records in 1+0 records out 4096 bytes (4.1 kB, 4.0 KiB) copied, 0.0126359 s, 324 kB/s echo 3 > /proc/sys/vm/drop_caches cat /mnt/nfs/file.bin > /dev/null  will trigger an oops similar to the following:  page dumped because: VM_BUG_ON_FOLIO(folio_test_private_2(folio)) ------------[ cut here ]------------ kernel BUG at include/linux/netfs.h:44! ... CPU: 5 PID: 134 Comm: kworker/u16:5 Kdump: loaded Not tainted 6.4.0-rc5 ... RIP: 0010:netfs_rreq_unlock_folios+0x68e/0x730 [netfs] ... Call Trace: netfs_rreq_assess+0x497/0x660 [netfs] netfs_subreq_terminated+0x32b/0x610 [netfs] nfs_netfs_read_completion+0x14e/0x1a0 [nfs] nfs_read_completion+0x2f9/0x330 [nfs] rpc_free_task+0x72/0xa0 [sunrpc] rpc_async_release+0x46/0x70 [sunrpc] process_one_work+0x3bd/0x710 worker_thread+0x89/0x610 kthread+0x181/0x1c0 ret_from_fork+0x29/0x50",
      "cve": "CVE-2023-52582",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52582",
          "value": "CVE-2023-52582",
          "url": "https://scout.docker.com/v/CVE-2023-52582?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52582?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "448efa33c26052a4c679f6f1f6fe65cb4899530dfbf17567f969820e4d1f241a",
      "category": "container_scanning",
      "message": "CVE-2023-52590 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ocfs2: Avoid touching renamed directory if parent does not change  The VFS will not be locking moved directory if its parent does not change. Change ocfs2 rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
      "cve": "CVE-2023-52590",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52590",
          "value": "CVE-2023-52590",
          "url": "https://scout.docker.com/v/CVE-2023-52590?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52590?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2e03de23a9ee68e472f7ab1c435e449fc171ca63e846eec153acafac7504d698",
      "category": "container_scanning",
      "message": "CVE-2023-52625 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Refactor DMCUB enter/exit idle interface  [Why] We can hang in place trying to send commands when the DMCUB isn't powered on.  [How] We need to exit out of the idle state prior to sending a command, but the process that performs the exit also invokes a command itself.  Fixing this issue involves the following:  1. Using a software state to track whether or not we need to start the process to exit idle or notify idle.  It's possible for the hardware to have exited an idle state without driver knowledge, but entering one is always restricted to a driver allow - which makes the SW state vs HW state mismatch issue purely one of optimization, which should seldomly be hit, if at all.  2. Refactor any instances of exit/notify idle to use a single wrapper that maintains this SW state.  This works simialr to dc_allow_idle_optimizations, but works at the DMCUB level and makes sure the state is marked prior to any notify/exit idle so we don't enter an infinite loop.  3. Make sure we exit out of idle prior to sending any commands or waiting for DMCUB idle.  This patch takes care of 1/2. A future patch will take care of wrapping DMCUB command submission with calls to this new interface.",
      "cve": "CVE-2023-52625",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52625",
          "value": "CVE-2023-52625",
          "url": "https://scout.docker.com/v/CVE-2023-52625?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52625?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec4c439449655128d3ac162c085958b95064d43c0848e759837a19cf42364f2b",
      "category": "container_scanning",
      "message": "CVE-2023-52632 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Fix lock dependency warning with srcu  ====================================================== WARNING: possible circular locking dependency detected 6.5.0-kfd-yangp #2289 Not tainted ------------------------------------------------------ kworker/0:2/996 is trying to acquire lock: (srcu){.+.+}-{0:0}, at: __synchronize_srcu+0x5/0x1a0  but task is already holding lock: ((work_completion)(&svms->deferred_list_work)){+.+.}-{0:0}, at: process_one_work+0x211/0x560  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #3 ((work_completion)(&svms->deferred_list_work)){+.+.}-{0:0}: __flush_work+0x88/0x4f0 svm_range_list_lock_and_flush_work+0x3d/0x110 [amdgpu] svm_range_set_attr+0xd6/0x14c0 [amdgpu] kfd_ioctl+0x1d1/0x630 [amdgpu] __x64_sys_ioctl+0x88/0xc0  -> #2 (&info->lock#2){+.+.}-{3:3}: __mutex_lock+0x99/0xc70 amdgpu_amdkfd_gpuvm_restore_process_bos+0x54/0x740 [amdgpu] restore_process_helper+0x22/0x80 [amdgpu] restore_process_worker+0x2d/0xa0 [amdgpu] process_one_work+0x29b/0x560 worker_thread+0x3d/0x3d0  -> #1 ((work_completion)(&(&process->restore_work)->work)){+.+.}-{0:0}: __flush_work+0x88/0x4f0 __cancel_work_timer+0x12c/0x1c0 kfd_process_notifier_release_internal+0x37/0x1f0 [amdgpu] __mmu_notifier_release+0xad/0x240 exit_mmap+0x6a/0x3a0 mmput+0x6a/0x120 do_exit+0x322/0xb90 do_group_exit+0x37/0xa0 __x64_sys_exit_group+0x18/0x20 do_syscall_64+0x38/0x80  -> #0 (srcu){.+.+}-{0:0}: __lock_acquire+0x1521/0x2510 lock_sync+0x5f/0x90 __synchronize_srcu+0x4f/0x1a0 __mmu_notifier_release+0x128/0x240 exit_mmap+0x6a/0x3a0 mmput+0x6a/0x120 svm_range_deferred_list_work+0x19f/0x350 [amdgpu] process_one_work+0x29b/0x560 worker_thread+0x3d/0x3d0  other info that might help us debug this: Chain exists of: srcu --> &info->lock#2 --> (work_completion)(&svms->deferred_list_work)  Possible unsafe locking scenario:  CPU0                    CPU1 ----                    ---- lock((work_completion)(&svms->deferred_list_work)); lock(&info->lock#2); lock((work_completion)(&svms->deferred_list_work)); sync(srcu);",
      "cve": "CVE-2023-52632",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52632",
          "value": "CVE-2023-52632",
          "url": "https://scout.docker.com/v/CVE-2023-52632?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52632?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "63a18c0d5413a74626653c9d2fd61b40d9db74d1adfb303c3ad453b3f0f3a9c3",
      "category": "container_scanning",
      "message": "CVE-2023-52634 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix disable_otg_wa logic  [Why] When switching to another HDMI mode, we are unnecesarilly disabling/enabling FIFO causing both HPO and DIG registers to be set at the same time when only HPO is supposed to be set.  This can lead to a system hang the next time we change refresh rates as there are cases when we don't disable OTG/FIFO but FIFO is enabled when it isn't supposed to be.  [How] Removing the enable/disable FIFO entirely.",
      "cve": "CVE-2023-52634",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52634",
          "value": "CVE-2023-52634",
          "url": "https://scout.docker.com/v/CVE-2023-52634?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52634?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db3d7a55f5c5c82314bfea6b640c126226cb1f167f4b6d8caee90e3f9fa2cf10",
      "category": "container_scanning",
      "message": "CVE-2023-52648 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/vmwgfx: Unmap the surface before resetting it on a plane state  Switch to a new plane state requires unreferencing of all held surfaces. In the work required for mob cursors the mapped surfaces started being cached but the variable indicating whether the surface is currently mapped was not being reset. This leads to crashes as the duplicated state, incorrectly, indicates the that surface is mapped even when no surface is present. That's because after unreferencing the surface it's perfectly possible for the plane to be backed by a bo instead of a surface.  Reset the surface mapped flag when unreferencing the plane state surface to fix null derefs in cleanup. Fixes crashes in KDE KWin 6.0 on Wayland:  Oops: 0000 [#1] PREEMPT SMP PTI CPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx] Code: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f> RSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600 RBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920 R10: 0000000000000003 R11: ffff969e7feb3b10 R12: 0000000000000000 R13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00 FS:  00007f1e8f1b4180(0000) GS:ffff969e75f00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? exc_page_fault+0x7f/0x180 ? asm_exc_page_fault+0x26/0x30 ? vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx] drm_atomic_helper_cleanup_planes+0x9b/0xc0 commit_tail+0xd1/0x130 drm_atomic_helper_commit+0x11a/0x140 drm_atomic_commit+0x97/0xd0 ? __pfx___drm_printfn_info+0x10/0x10 drm_atomic_helper_update_plane+0xf5/0x160 drm_mode_cursor_universal+0x10e/0x270 drm_mode_cursor_common+0x102/0x230 ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10 drm_ioctl_kernel+0xb2/0x110 drm_ioctl+0x26d/0x4b0 ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10 ? __pfx_drm_ioctl+0x10/0x10 vmw_generic_ioctl+0xa4/0x110 [vmwgfx] __x64_sys_ioctl+0x94/0xd0 do_syscall_64+0x61/0xe0 ? __x64_sys_ioctl+0xaf/0xd0 ? syscall_exit_to_user_mode+0x2b/0x40 ? do_syscall_64+0x70/0xe0 ? __x64_sys_ioctl+0xaf/0xd0 ? syscall_exit_to_user_mode+0x2b/0x40 ? do_syscall_64+0x70/0xe0 ? exc_page_fault+0x7f/0x180 entry_SYSCALL_64_after_hwframe+0x6e/0x76 RIP: 0033:0x7f1e93f279ed Code: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff f> RSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 000055db876ed2c0 RCX: 00007f1e93f279ed RDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015 RBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007 R10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0 R13: 00000000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790 </TASK> Modules linked in: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_ine> CR2: 0000000000000028 ---[ end trace 0000000000000000 ]--- RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx] Code: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f> RSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027 RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600 RBP: ffff969d4143 ---truncated---",
      "cve": "CVE-2023-52648",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52648",
          "value": "CVE-2023-52648",
          "url": "https://scout.docker.com/v/CVE-2023-52648?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52648?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "02f8509f6d266ff1506967a4d7911ef0509cc03a8b333c21cdaedf8bec14ce5f",
      "category": "container_scanning",
      "message": "CVE-2023-52657 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/amd/pm: resolve reboot exception for si oland\"  This reverts commit e490d60a2f76bff636c68ce4fe34c1b6c34bbd86.  This causes hangs on SI when DC is enabled and errors on driver reboot and power off cycles.",
      "cve": "CVE-2023-52657",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52657",
          "value": "CVE-2023-52657",
          "url": "https://scout.docker.com/v/CVE-2023-52657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f46327af0caf57642924e4a0abfeffe8387122d74df7ef9abf1da75703e3a44d",
      "category": "container_scanning",
      "message": "CVE-2023-52660 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: rkisp1: Fix IRQ handling due to shared interrupts  The driver requests the interrupts as IRQF_SHARED, so the interrupt handlers can be called at any time. If such a call happens while the ISP is powered down, the SoC will hang as the driver tries to access the ISP registers.  This can be reproduced even without the platform sharing the IRQ line: Enable CONFIG_DEBUG_SHIRQ and unload the driver, and the board will hang.  Fix this by adding a new field, 'irqs_enabled', which is used to bail out from the interrupt handler when the ISP is not operational.",
      "cve": "CVE-2023-52660",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52660",
          "value": "CVE-2023-52660",
          "url": "https://scout.docker.com/v/CVE-2023-52660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f50de162878e0399d57c2692a0d3978fcb4ea82056d77742076d6084c1138ae6",
      "category": "container_scanning",
      "message": "CVE-2023-52671 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix hang/underflow when transitioning to ODM4:1  [Why] Under some circumstances, disabling an OPTC and attempting to reclaim its OPP(s) for a different OPTC could cause a hang/underflow due to OPPs not being properly disconnected from the disabled OPTC.  [How] Ensure that all OPPs are unassigned from an OPTC when it gets disabled.",
      "cve": "CVE-2023-52671",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52671",
          "value": "CVE-2023-52671",
          "url": "https://scout.docker.com/v/CVE-2023-52671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "be47d3110ed4b73f750903dfc38c3db47909b2d7f37e9562c5b8eff43fb11efd",
      "category": "container_scanning",
      "message": "CVE-2023-52673 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix a debugfs null pointer error  [WHY & HOW] Check whether get_subvp_en() callback exists before calling it.",
      "cve": "CVE-2023-52673",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52673",
          "value": "CVE-2023-52673",
          "url": "https://scout.docker.com/v/CVE-2023-52673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "06da2e68f2c8bff45babda38210025fefb2e80aa83990f7f4616802200776ae6",
      "category": "container_scanning",
      "message": "CVE-2023-52676 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Guard stack limits against 32bit overflow  This patch promotes the arithmetic around checking stack bounds to be done in the 64-bit domain, instead of the current 32bit. The arithmetic implies adding together a 64-bit register with a int offset. The register was checked to be below 1<<29 when it was variable, but not when it was fixed. The offset either comes from an instruction (in which case it is 16 bit), from another register (in which case the caller checked it to be below 1<<29 [1]), or from the size of an argument to a kfunc (in which case it can be a u32 [2]). Between the register being inconsistently checked to be below 1<<29, and the offset being up to an u32, it appears that we were open to overflowing the `int`s which were currently used for arithmetic.  [1] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L7494-L7498 [2] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L11904",
      "cve": "CVE-2023-52676",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52676",
          "value": "CVE-2023-52676",
          "url": "https://scout.docker.com/v/CVE-2023-52676?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52676?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cbca42300489a47262f02173b90fb2af630cadef587252ab4c86792e30a78912",
      "category": "container_scanning",
      "message": "CVE-2023-52700 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tipc: fix kernel warning when sending SYN message  When sending a SYN message, this kernel stack trace is observed:  ... [   13.396352] RIP: 0010:_copy_from_iter+0xb4/0x550 ... [   13.398494] Call Trace: [   13.398630]  <TASK> [   13.398630]  ? __alloc_skb+0xed/0x1a0 [   13.398630]  tipc_msg_build+0x12c/0x670 [tipc] [   13.398630]  ? shmem_add_to_page_cache.isra.71+0x151/0x290 [   13.398630]  __tipc_sendmsg+0x2d1/0x710 [tipc] [   13.398630]  ? tipc_connect+0x1d9/0x230 [tipc] [   13.398630]  ? __local_bh_enable_ip+0x37/0x80 [   13.398630]  tipc_connect+0x1d9/0x230 [tipc] [   13.398630]  ? __sys_connect+0x9f/0xd0 [   13.398630]  __sys_connect+0x9f/0xd0 [   13.398630]  ? preempt_count_add+0x4d/0xa0 [   13.398630]  ? fpregs_assert_state_consistent+0x22/0x50 [   13.398630]  __x64_sys_connect+0x16/0x20 [   13.398630]  do_syscall_64+0x42/0x90 [   13.398630]  entry_SYSCALL_64_after_hwframe+0x63/0xcd  It is because commit a41dad905e5a (\"iov_iter: saner checks for attempt to copy to/from iterator\") has introduced sanity check for copying from/to iov iterator. Lacking of copy direction from the iterator viewpoint would lead to kernel stack trace like above.  This commit fixes this issue by initializing the iov iterator with the correct copy direction when sending SYN or ACK without data.",
      "cve": "CVE-2023-52700",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52700",
          "value": "CVE-2023-52700",
          "url": "https://scout.docker.com/v/CVE-2023-52700?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52700?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f4249b018316cb76444a926d7ab9c56d3e3c8aa9ebb385e686c4498146fc2fcb",
      "category": "container_scanning",
      "message": "CVE-2023-52732 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ceph: blocklist the kclient when receiving corrupted snap trace  When received corrupted snap trace we don't know what exactly has happened in MDS side. And we shouldn't continue IOs and metadatas access to MDS, which may corrupt or get incorrect contents.  This patch will just block all the further IO/MDS requests immediately and then evict the kclient itself.  The reason why we still need to evict the kclient just after blocking all the further IOs is that the MDS could revoke the caps faster.",
      "cve": "CVE-2023-52732",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52732",
          "value": "CVE-2023-52732",
          "url": "https://scout.docker.com/v/CVE-2023-52732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52732?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2efc560c5fef72dc7f71c9b3e159c506de5a3cbe86749ed6af4430a59724afca",
      "category": "container_scanning",
      "message": "CVE-2023-52737 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: lock the inode in shared mode before starting fiemap  Currently fiemap does not take the inode's lock (VFS lock), it only locks a file range in the inode's io tree. This however can lead to a deadlock if we have a concurrent fsync on the file and fiemap code triggers a fault when accessing the user space buffer with fiemap_fill_next_extent(). The deadlock happens on the inode's i_mmap_lock semaphore, which is taken both by fsync and btrfs_page_mkwrite(). This deadlock was recently reported by syzbot and triggers a trace like the following:  task:syz-executor361 state:D stack:20264 pid:5668  ppid:5119 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5293 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6606 schedule+0xcb/0x190 kernel/sched/core.c:6682 wait_on_state fs/btrfs/extent-io-tree.c:707 [inline] wait_extent_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c:751 lock_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c:1742 find_lock_delalloc_range+0x4e6/0x9c0 fs/btrfs/extent_io.c:488 writepage_delalloc+0x1ef/0x540 fs/btrfs/extent_io.c:1863 __extent_writepage+0x736/0x14e0 fs/btrfs/extent_io.c:2174 extent_write_cache_pages+0x983/0x1220 fs/btrfs/extent_io.c:3091 extent_writepages+0x219/0x540 fs/btrfs/extent_io.c:3211 do_writepages+0x3c3/0x680 mm/page-writeback.c:2581 filemap_fdatawrite_wbc+0x11e/0x170 mm/filemap.c:388 __filemap_fdatawrite_range mm/filemap.c:421 [inline] filemap_fdatawrite_range+0x175/0x200 mm/filemap.c:439 btrfs_fdatawrite_range fs/btrfs/file.c:3850 [inline] start_ordered_ops fs/btrfs/file.c:1737 [inline] btrfs_sync_file+0x4ff/0x1190 fs/btrfs/file.c:1839 generic_write_sync include/linux/fs.h:2885 [inline] btrfs_do_write_iter+0xcd3/0x1280 fs/btrfs/file.c:1684 call_write_iter include/linux/fs.h:2189 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x7dc/0xc50 fs/read_write.c:584 ksys_write+0x177/0x2a0 fs/read_write.c:637 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f7d4054e9b9 RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9 RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006 RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69 R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8 </TASK> INFO: task syz-executor361:5697 blocked for more than 145 seconds. Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:syz-executor361 state:D stack:21216 pid:5697  ppid:5119 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5293 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6606 schedule+0xcb/0x190 kernel/sched/core.c:6682 rwsem_down_read_slowpath+0x5f9/0x930 kernel/locking/rwsem.c:1095 __down_read_common+0x54/0x2a0 kernel/locking/rwsem.c:1260 btrfs_page_mkwrite+0x417/0xc80 fs/btrfs/inode.c:8526 do_page_mkwrite+0x19e/0x5e0 mm/memory.c:2947 wp_page_shared+0x15e/0x380 mm/memory.c:3295 handle_pte_fault mm/memory.c:4949 [inline] __handle_mm_fault mm/memory.c:5073 [inline] handle_mm_fault+0x1b79/0x26b0 mm/memory.c:5219 do_user_addr_fault+0x69b/0xcb0 arch/x86/mm/fault.c:1428 handle_page_fault arch/x86/mm/fault.c:1519 [inline] exc_page_fault+0x7a/0x110 arch/x86/mm/fault.c:1575 asm_exc_page_fault+0x22/0x30 arch/x86/include/asm/idtentry.h:570 RIP: 0010:copy_user_short_string+0xd/0x40 arch/x86/lib/copy_user_64.S:233 Code: 74 0a 89 (...) RSP: 0018:ffffc9000570f330 EFLAGS: 000502 ---truncated---",
      "cve": "CVE-2023-52737",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52737",
          "value": "CVE-2023-52737",
          "url": "https://scout.docker.com/v/CVE-2023-52737?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52737?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "241623773fd0bc9d4bf93316cd8c49cf22de6062c3aef8e0954a629058887fbb",
      "category": "container_scanning",
      "message": "CVE-2023-52761 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: VMAP_STACK overflow detection thread-safe  commit 31da94c25aea (\"riscv: add VMAP_STACK overflow detection\") added support for CONFIG_VMAP_STACK. If overflow is detected, CPU switches to `shadow_stack` temporarily before switching finally to per-cpu `overflow_stack`.  If two CPUs/harts are racing and end up in over flowing kernel stack, one or both will end up corrupting each other state because `shadow_stack` is not per-cpu. This patch optimizes per-cpu overflow stack switch by directly picking per-cpu `overflow_stack` and gets rid of `shadow_stack`.  Following are the changes in this patch  - Defines an asm macro to obtain per-cpu symbols in destination register. - In entry.S, when overflow is detected, per-cpu overflow stack is located using per-cpu asm macro. Computing per-cpu symbol requires a temporary register. x31 is saved away into CSR_SCRATCH (CSR_SCRATCH is anyways zero since we're in kernel).  Please see Links for additional relevant disccussion and alternative solution.  Tested by `echo EXHAUST_STACK > /sys/kernel/debug/provoke-crash/DIRECT` Kernel crash log below  Insufficient stack space to handle exception!/debug/provoke-crash/DIRECT Task stack:     [0xff20000010a98000..0xff20000010a9c000] Overflow stack: [0xff600001f7d98370..0xff600001f7d99370] CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34 Hardware name: riscv-virtio,qemu (DT) epc : __memset+0x60/0xfc ra : recursive_loop+0x48/0xc6 [lkdtm] epc : ffffffff808de0e4 ra : ffffffff0163a752 sp : ff20000010a97e80 gp : ffffffff815c0330 tp : ff600000820ea280 t0 : ff20000010a97e88 t1 : 000000000000002e t2 : 3233206874706564 s0 : ff20000010a982b0 s1 : 0000000000000012 a0 : ff20000010a97e88 a1 : 0000000000000000 a2 : 0000000000000400 a3 : ff20000010a98288 a4 : 0000000000000000 a5 : 0000000000000000 a6 : fffffffffffe43f0 a7 : 00007fffffffffff s2 : ff20000010a97e88 s3 : ffffffff01644680 s4 : ff20000010a9be90 s5 : ff600000842ba6c0 s6 : 00aaaaaac29e42b0 s7 : 00fffffff0aa3684 s8 : 00aaaaaac2978040 s9 : 0000000000000065 s10: 00ffffff8a7cad10 s11: 00ffffff8a76a4e0 t3 : ffffffff815dbaf4 t4 : ffffffff815dbaf4 t5 : ffffffff815dbab8 t6 : ff20000010a9bb48 status: 0000000200000120 badaddr: ff20000010a97e88 cause: 000000000000000f Kernel panic - not syncing: Kernel stack overflow CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34 Hardware name: riscv-virtio,qemu (DT) Call Trace: [<ffffffff80006754>] dump_backtrace+0x30/0x38 [<ffffffff808de798>] show_stack+0x40/0x4c [<ffffffff808ea2a8>] dump_stack_lvl+0x44/0x5c [<ffffffff808ea2d8>] dump_stack+0x18/0x20 [<ffffffff808dec06>] panic+0x126/0x2fe [<ffffffff800065ea>] walk_stackframe+0x0/0xf0 [<ffffffff0163a752>] recursive_loop+0x48/0xc6 [lkdtm] SMP: stopping secondary CPUs ---[ end Kernel panic - not syncing: Kernel stack overflow ]---",
      "cve": "CVE-2023-52761",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52761",
          "value": "CVE-2023-52761",
          "url": "https://scout.docker.com/v/CVE-2023-52761?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52761?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f3a66bc26f9602b3c41b646be9a4b65a7afe7a13a7d9d071e57ec8ab4aeae2c7",
      "category": "container_scanning",
      "message": "CVE-2023-52831 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpu/hotplug: Don't offline the last non-isolated CPU  If a system has isolated CPUs via the \"isolcpus=\" command line parameter, then an attempt to offline the last housekeeping CPU will result in a WARN_ON() when rebuilding the scheduler domains and a subsequent panic due to and unhandled empty CPU mas in partition_sched_domains_locked().  cpuset_hotplug_workfn() rebuild_sched_domains_locked() ndoms = generate_sched_domains(&doms, &attr); cpumask_and(doms[0], top_cpuset.effective_cpus, housekeeping_cpumask(HK_FLAG_DOMAIN));  Thus results in an empty CPU mask which triggers the warning and then the subsequent crash:  WARNING: CPU: 4 PID: 80 at kernel/sched/topology.c:2366 build_sched_domains+0x120c/0x1408 Call trace: build_sched_domains+0x120c/0x1408 partition_sched_domains_locked+0x234/0x880 rebuild_sched_domains_locked+0x37c/0x798 rebuild_sched_domains+0x30/0x58 cpuset_hotplug_workfn+0x2a8/0x930  Unable to handle kernel paging request at virtual address fffe80027ab37080 partition_sched_domains_locked+0x318/0x880 rebuild_sched_domains_locked+0x37c/0x798  Aside of the resulting crash, it does not make any sense to offline the last last housekeeping CPU.  Prevent this by masking out the non-housekeeping CPUs when selecting a target CPU for initiating the CPU unplug operation via the work queue.",
      "cve": "CVE-2023-52831",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52831",
          "value": "CVE-2023-52831",
          "url": "https://scout.docker.com/v/CVE-2023-52831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d87d007a52a3357ac54f97d728a405886323241b012d0505aaea368e3f9b8e10",
      "category": "container_scanning",
      "message": "CVE-2023-52857 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/mediatek: Fix coverity issue with unintentional integer overflow  1. Instead of multiplying 2 variable of different types. Change to assign a value of one variable and then multiply the other variable.  2. Add a int variable for multiplier calculation instead of calculating different types multiplier with dma_addr_t variable directly.",
      "cve": "CVE-2023-52857",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52857",
          "value": "CVE-2023-52857",
          "url": "https://scout.docker.com/v/CVE-2023-52857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f2b6ddf9039f27e209d5334cef4c06f7583abcf77a411547e15a7f213064018a",
      "category": "container_scanning",
      "message": "CVE-2023-52879 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tracing: Have trace_event_file have ref counters  The following can crash the kernel:  # cd /sys/kernel/tracing # echo 'p:sched schedule' > kprobe_events # exec 5>>events/kprobes/sched/enable # > kprobe_events # exec 5>&-  The above commands:  1. Change directory to the tracefs directory 2. Create a kprobe event (doesn't matter what one) 3. Open bash file descriptor 5 on the enable file of the kprobe event 4. Delete the kprobe event (removes the files too) 5. Close the bash file descriptor 5  The above causes a crash!  BUG: kernel NULL pointer dereference, address: 0000000000000028 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 6 PID: 877 Comm: bash Not tainted 6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty #186 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 RIP: 0010:tracing_release_file_tr+0xc/0x50  What happens here is that the kprobe event creates a trace_event_file \"file\" descriptor that represents the file in tracefs to the event. It maintains state of the event (is it enabled for the given instance?). Opening the \"enable\" file gets a reference to the event \"file\" descriptor via the open file descriptor. When the kprobe event is deleted, the file is also deleted from the tracefs system which also frees the event \"file\" descriptor.  But as the tracefs file is still opened by user space, it will not be totally removed until the final dput() is called on it. But this is not true with the event \"file\" descriptor that is already freed. If the user does a write to or simply closes the file descriptor it will reference the event \"file\" descriptor that was just freed, causing a use-after-free bug.  To solve this, add a ref count to the event \"file\" descriptor as well as a new flag called \"FREED\". The \"file\" will not be freed until the last reference is released. But the FREE flag will be set when the event is removed to prevent any more modifications to that event from happening, even if there's still a reference to the event \"file\" descriptor.",
      "cve": "CVE-2023-52879",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52879",
          "value": "CVE-2023-52879",
          "url": "https://scout.docker.com/v/CVE-2023-52879?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52879?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e747d8de238f0e929286ddd08834617fdb2842afb93a65d7d3272c2c9f34400c",
      "category": "container_scanning",
      "message": "CVE-2023-52888 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: Only free buffer VA that is not NULL  In the MediaTek vcodec driver, while mtk_vcodec_mem_free() is mostly called only when the buffer to free exists, there are some instances that didn't do the check and triggered warnings in practice.  We believe those checks were forgotten unintentionally. Add the checks back to fix the warnings.",
      "cve": "CVE-2023-52888",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52888",
          "value": "CVE-2023-52888",
          "url": "https://scout.docker.com/v/CVE-2023-52888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1b907086cf852409718fb0c5fb87edc59271d6d72bc3afc064dfa7fa2466f2f",
      "category": "container_scanning",
      "message": "CVE-2023-52905 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  octeontx2-pf: Fix resource leakage in VF driver unbind  resources allocated like mcam entries to support the Ntuple feature and hash tables for the tc feature are not getting freed in driver unbind. This patch fixes the issue.",
      "cve": "CVE-2023-52905",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52905",
          "value": "CVE-2023-52905",
          "url": "https://scout.docker.com/v/CVE-2023-52905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0101caf43b238da8efae6aaf447b0c090431131981381da148848ccecfeaf353",
      "category": "container_scanning",
      "message": "CVE-2023-52920 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: support non-r10 register spill/fill to/from stack in precision tracking  Use instruction (jump) history to record instructions that performed register spill/fill to/from stack, regardless if this was done through read-only r10 register, or any other register after copying r10 into it *and* potentially adjusting offset.  To make this work reliably, we push extra per-instruction flags into instruction history, encoding stack slot index (spi) and stack frame number in extra 10 bit flags we take away from prev_idx in instruction history. We don't touch idx field for maximum performance, as it's checked most frequently during backtracking.  This change removes basically the last remaining practical limitation of precision backtracking logic in BPF verifier. It fixes known deficiencies, but also opens up new opportunities to reduce number of verified states, explored in the subsequent patches.  There are only three differences in selftests' BPF object files according to veristat, all in the positive direction (less states).  File                                    Program        Insns (A)  Insns (B) Insns  (DIFF)  States (A)  States (B)  States (DIFF) --------------------------------------  -------------  ---------  --------- -------------  ----------  ----------  ------------- test_cls_redirect_dynptr.bpf.linked3.o  cls_redirect        2987       2864 -123 (-4.12%)         240         231    -9 (-3.75%) xdp_synproxy_kern.bpf.linked3.o         syncookie_tc       82848      82661 -187 (-0.23%)        5107        5073   -34 (-0.67%) xdp_synproxy_kern.bpf.linked3.o         syncookie_xdp      85116      84964 -152 (-0.18%)        5162        5130   -32 (-0.62%)  Note, I avoided renaming jmp_history to more generic insn_hist to minimize number of lines changed and potential merge conflicts between bpf and bpf-next trees.  Notice also cur_hist_entry pointer reset to NULL at the beginning of instruction verification loop. This pointer avoids the problem of relying on last jump history entry's insn_idx to determine whether we already have entry for current instruction or not. It can happen that we added jump history entry because current instruction is_jmp_point(), but also we need to add instruction flags for stack access. In this case, we don't want to entries, so we need to reuse last added entry, if it is present.  Relying on insn_idx comparison has the same ambiguity problem as the one that was fixed recently in [0], so we avoid that.  [0] https://patchwork.kernel.org/project/netdevbpf/patch/20231110002638.4168352-3-andrii@kernel.org/",
      "cve": "CVE-2023-52920",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52920",
          "value": "CVE-2023-52920",
          "url": "https://scout.docker.com/v/CVE-2023-52920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1103b9d903a1b60ab8474323f66bf40b70c9a8521057990162f99e508d720322",
      "category": "container_scanning",
      "message": "CVE-2023-52939 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: memcg: fix NULL pointer in mem_cgroup_track_foreign_dirty_slowpath()  As commit 18365225f044 (\"hwpoison, memcg: forcibly uncharge LRU pages\"), hwpoison will forcibly uncharg a LRU hwpoisoned page, the folio_memcg could be NULl, then, mem_cgroup_track_foreign_dirty_slowpath() could occurs a NULL pointer dereference, let's do not record the foreign writebacks for folio memcg is null in mem_cgroup_track_foreign_dirty() to fix it.",
      "cve": "CVE-2023-52939",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52939",
          "value": "CVE-2023-52939",
          "url": "https://scout.docker.com/v/CVE-2023-52939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "415a9d4e1f9f08ff6a0255ee109108791eb7771d0736da7a25d484a8d637acae",
      "category": "container_scanning",
      "message": "CVE-2023-53001 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/drm_vma_manager: Add drm_vma_node_allow_once()  Currently there is no easy way for a drm driver to safely check and allow drm_vma_offset_node for a drm file just once. Allow drm drivers to call non-refcounted version of drm_vma_node_allow() so that a driver doesn't need to keep track of each drm_vma_node_allow() to call subsequent drm_vma_node_revoke() to prevent memory leak.",
      "cve": "CVE-2023-53001",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53001",
          "value": "CVE-2023-53001",
          "url": "https://scout.docker.com/v/CVE-2023-53001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0ae35e8f9cf5b515ced8871b6a634bc8c47ebbd43e4a6847d7a2db882692f92a",
      "category": "container_scanning",
      "message": "CVE-2023-53002 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/i915: Fix a memory leak with reused mmap_offset  drm_vma_node_allow() and drm_vma_node_revoke() should be called in balanced pairs. We call drm_vma_node_allow() once per-file everytime a user calls mmap_offset, but only call drm_vma_node_revoke once per-file on each mmap_offset. As the mmap_offset is reused by the client, the per-file vm_count may remain non-zero and the rbtree leaked.  Call drm_vma_node_allow_once() instead to prevent that memory leak.",
      "cve": "CVE-2023-53002",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53002",
          "value": "CVE-2023-53002",
          "url": "https://scout.docker.com/v/CVE-2023-53002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c1c24c29824ea8c3feb5dd2ec5353a732fcea3de45b67169ef8e02efd05453ff",
      "category": "container_scanning",
      "message": "CVE-2023-53008 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cifs: fix potential memory leaks in session setup  Make sure to free cifs_ses::auth_key.response before allocating it as we might end up leaking memory in reconnect or mounting.",
      "cve": "CVE-2023-53008",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-53008",
          "value": "CVE-2023-53008",
          "url": "https://scout.docker.com/v/CVE-2023-53008?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-53008?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "76e965b8bc81ecd7982b9bcd849bf3ea5f20bcd05513291e15de08731f27d43d",
      "category": "container_scanning",
      "message": "CVE-2023-5341 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A heap use-after-free flaw was found in coders/bmp.c in ImageMagick.",
      "cve": "CVE-2023-5341",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-5341",
          "value": "CVE-2023-5341",
          "url": "https://scout.docker.com/v/CVE-2023-5341?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-5341?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "80bfba579f511a27c7ac4783a485c6974d9a51bd5719986404cc5dcdf02d0579",
      "category": "container_scanning",
      "message": "CVE-2024-26595 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path  When calling mlxsw_sp_acl_tcam_region_destroy() from an error path after failing to attach the region to an ACL group, we hit a NULL pointer dereference upon 'region->group->tcam' [1].  Fix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] RIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0 [...] Call Trace: mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20 mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0 mlxsw_sp_acl_rule_add+0x47/0x240 mlxsw_sp_flower_replace+0x1a9/0x1d0 tc_setup_cb_add+0xdc/0x1c0 fl_hw_replace_filter+0x146/0x1f0 fl_change+0xc17/0x1360 tc_new_tfilter+0x472/0xb90 rtnetlink_rcv_msg+0x313/0x3b0 netlink_rcv_skb+0x58/0x100 netlink_unicast+0x244/0x390 netlink_sendmsg+0x1e4/0x440 ____sys_sendmsg+0x164/0x260 ___sys_sendmsg+0x9a/0xe0 __sys_sendmsg+0x7a/0xc0 do_syscall_64+0x40/0xe0 entry_SYSCALL_64_after_hwframe+0x63/0x6b",
      "cve": "CVE-2024-26595",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26595",
          "value": "CVE-2024-26595",
          "url": "https://scout.docker.com/v/CVE-2024-26595?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26595?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6cc2b68f156cb0c710457ed248689aff716f314aa2d2ff269b6bb29e566beecb",
      "category": "container_scanning",
      "message": "CVE-2024-26605 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI/ASPM: Fix deadlock when enabling ASPM  A last minute revert in 6.7-final introduced a potential deadlock when enabling ASPM during probe of Qualcomm PCIe controllers as reported by lockdep:  ============================================ WARNING: possible recursive locking detected 6.7.0 #40 Not tainted -------------------------------------------- kworker/u16:5/90 is trying to acquire lock: ffffacfa78ced000 (pci_bus_sem){++++}-{3:3}, at: pcie_aspm_pm_state_change+0x58/0xdc  but task is already holding lock: ffffacfa78ced000 (pci_bus_sem){++++}-{3:3}, at: pci_walk_bus+0x34/0xbc  other info that might help us debug this: Possible unsafe locking scenario:  CPU0 ---- lock(pci_bus_sem); lock(pci_bus_sem);  *** DEADLOCK ***  Call trace: print_deadlock_bug+0x25c/0x348 __lock_acquire+0x10a4/0x2064 lock_acquire+0x1e8/0x318 down_read+0x60/0x184 pcie_aspm_pm_state_change+0x58/0xdc pci_set_full_power_state+0xa8/0x114 pci_set_power_state+0xc4/0x120 qcom_pcie_enable_aspm+0x1c/0x3c [pcie_qcom] pci_walk_bus+0x64/0xbc qcom_pcie_host_post_init_2_7_0+0x28/0x34 [pcie_qcom]  The deadlock can easily be reproduced on machines like the Lenovo ThinkPad X13s by adding a delay to increase the race window during asynchronous probe where another thread can take a write lock.  Add a new pci_set_power_state_locked() and associated helper functions that can be called with the PCI bus semaphore held to avoid taking the read lock twice.",
      "cve": "CVE-2024-26605",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26605",
          "value": "CVE-2024-26605",
          "url": "https://scout.docker.com/v/CVE-2024-26605?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26605?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "97ad47d10c037e08e2f92cbac4eaa6b8ec6686fc3ea90d98fa149aea897c0e31",
      "category": "container_scanning",
      "message": "CVE-2024-26647 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'  In link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc' was dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc' NULL pointer check.  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",
      "cve": "CVE-2024-26647",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26647",
          "value": "CVE-2024-26647",
          "url": "https://scout.docker.com/v/CVE-2024-26647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "77a1ae5d0dfcd839000bc4f35ff14d0aa904f5c5a82176a9fd669e5d83c51cdc",
      "category": "container_scanning",
      "message": "CVE-2024-26656 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix use-after-free bug  The bug can be triggered by sending a single amdgpu_gem_userptr_ioctl to the AMDGPU DRM driver on any ASICs with an invalid address and size. The bug was reported by Joonkyo Jung <joonkyoj@yonsei.ac.kr>. For example the following code:  static void Syzkaller1(int fd) { struct drm_amdgpu_gem_userptr arg; int ret;  arg.addr = 0xffffffffffff0000; arg.size = 0x80000000; /*2 Gb*/ arg.flags = 0x7; ret = drmIoctl(fd, 0xc1186451/*amdgpu_gem_userptr_ioctl*/, &arg); }  Due to the address and size are not valid there is a failure in amdgpu_hmm_register->mmu_interval_notifier_insert->__mmu_interval_notifier_insert-> check_shl_overflow, but we even the amdgpu_hmm_register failure we still call amdgpu_hmm_unregister into  amdgpu_gem_object_free which causes access to a bad address. The following stack is below when the issue is reproduced when Kazan is enabled:  [  +0.000014] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020 [  +0.000009] RIP: 0010:mmu_interval_notifier_remove+0x327/0x340 [  +0.000017] Code: ff ff 49 89 44 24 08 48 b8 00 01 00 00 00 00 ad de 4c 89 f7 49 89 47 40 48 83 c0 22 49 89 47 48 e8 ce d1 2d 01 e9 32 ff ff ff <0f> 0b e9 16 ff ff ff 4c 89 ef e8 fa 14 b3 ff e9 36 ff ff ff e8 80 [  +0.000014] RSP: 0018:ffffc90002657988 EFLAGS: 00010246 [  +0.000013] RAX: 0000000000000000 RBX: 1ffff920004caf35 RCX: ffffffff8160565b [  +0.000011] RDX: dffffc0000000000 RSI: 0000000000000004 RDI: ffff8881a9f78260 [  +0.000010] RBP: ffffc90002657a70 R08: 0000000000000001 R09: fffff520004caf25 [  +0.000010] R10: 0000000000000003 R11: ffffffff8161d1d6 R12: ffff88810e988c00 [  +0.000010] R13: ffff888126fb5a00 R14: ffff88810e988c0c R15: ffff8881a9f78260 [  +0.000011] FS:  00007ff9ec848540(0000) GS:ffff8883cc880000(0000) knlGS:0000000000000000 [  +0.000012] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  +0.000010] CR2: 000055b3f7e14328 CR3: 00000001b5770000 CR4: 0000000000350ef0 [  +0.000010] Call Trace: [  +0.000006]  <TASK> [  +0.000007]  ? show_regs+0x6a/0x80 [  +0.000018]  ? __warn+0xa5/0x1b0 [  +0.000019]  ? mmu_interval_notifier_remove+0x327/0x340 [  +0.000018]  ? report_bug+0x24a/0x290 [  +0.000022]  ? handle_bug+0x46/0x90 [  +0.000015]  ? exc_invalid_op+0x19/0x50 [  +0.000016]  ? asm_exc_invalid_op+0x1b/0x20 [  +0.000017]  ? kasan_save_stack+0x26/0x50 [  +0.000017]  ? mmu_interval_notifier_remove+0x23b/0x340 [  +0.000019]  ? mmu_interval_notifier_remove+0x327/0x340 [  +0.000019]  ? mmu_interval_notifier_remove+0x23b/0x340 [  +0.000020]  ? __pfx_mmu_interval_notifier_remove+0x10/0x10 [  +0.000017]  ? kasan_save_alloc_info+0x1e/0x30 [  +0.000018]  ? srso_return_thunk+0x5/0x5f [  +0.000014]  ? __kasan_kmalloc+0xb1/0xc0 [  +0.000018]  ? srso_return_thunk+0x5/0x5f [  +0.000013]  ? __kasan_check_read+0x11/0x20 [  +0.000020]  amdgpu_hmm_unregister+0x34/0x50 [amdgpu] [  +0.004695]  amdgpu_gem_object_free+0x66/0xa0 [amdgpu] [  +0.004534]  ? __pfx_amdgpu_gem_object_free+0x10/0x10 [amdgpu] [  +0.004291]  ? do_syscall_64+0x5f/0xe0 [  +0.000023]  ? srso_return_thunk+0x5/0x5f [  +0.000017]  drm_gem_object_free+0x3b/0x50 [drm] [  +0.000489]  amdgpu_gem_userptr_ioctl+0x306/0x500 [amdgpu] [  +0.004295]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [  +0.004270]  ? srso_return_thunk+0x5/0x5f [  +0.000014]  ? __this_cpu_preempt_check+0x13/0x20 [  +0.000015]  ? srso_return_thunk+0x5/0x5f [  +0.000013]  ? sysvec_apic_timer_interrupt+0x57/0xc0 [  +0.000020]  ? srso_return_thunk+0x5/0x5f [  +0.000014]  ? asm_sysvec_apic_timer_interrupt+0x1b/0x20 [  +0.000022]  ? drm_ioctl_kernel+0x17b/0x1f0 [drm] [  +0.000496]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [  +0.004272]  ? drm_ioctl_kernel+0x190/0x1f0 [drm] [  +0.000492]  drm_ioctl_kernel+0x140/0x1f0 [drm] [  +0.000497]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [  +0.004297]  ? __pfx_drm_ioctl_kernel+0x10/0x10 [d ---truncated---",
      "cve": "CVE-2024-26656",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26656",
          "value": "CVE-2024-26656",
          "url": "https://scout.docker.com/v/CVE-2024-26656?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26656?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a2c38057ada22c628e69ceda0fa320010f6742306c081b88dd890eb3a408e431",
      "category": "container_scanning",
      "message": "CVE-2024-26658 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bcachefs: grab s_umount only if snapshotting  When I was testing mongodb over bcachefs with compression, there is a lockdep warning when snapshotting mongodb data volume.  $ cat test.sh prog=bcachefs  $prog subvolume create /mnt/data $prog subvolume create /mnt/data/snapshots  while true;do $prog subvolume snapshot /mnt/data /mnt/data/snapshots/$(date +%s) sleep 1s done  $ cat /etc/mongodb.conf systemLog: destination: file logAppend: true path: /mnt/data/mongod.log  storage: dbPath: /mnt/data/  lockdep reports: [ 3437.452330] ====================================================== [ 3437.452750] WARNING: possible circular locking dependency detected [ 3437.453168] 6.7.0-rc7-custom+ #85 Tainted: G            E [ 3437.453562] ------------------------------------------------------ [ 3437.453981] bcachefs/35533 is trying to acquire lock: [ 3437.454325] ffffa0a02b2b1418 (sb_writers#10){.+.+}-{0:0}, at: filename_create+0x62/0x190 [ 3437.454875] but task is already holding lock: [ 3437.455268] ffffa0a02b2b10e0 (&type->s_umount_key#48){.+.+}-{3:3}, at: bch2_fs_file_ioctl+0x232/0xc90 [bcachefs] [ 3437.456009] which lock already depends on the new lock.  [ 3437.456553] the existing dependency chain (in reverse order) is: [ 3437.457054] -> #3 (&type->s_umount_key#48){.+.+}-{3:3}: [ 3437.457507]        down_read+0x3e/0x170 [ 3437.457772]        bch2_fs_file_ioctl+0x232/0xc90 [bcachefs] [ 3437.458206]        __x64_sys_ioctl+0x93/0xd0 [ 3437.458498]        do_syscall_64+0x42/0xf0 [ 3437.458779]        entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 3437.459155] -> #2 (&c->snapshot_create_lock){++++}-{3:3}: [ 3437.459615]        down_read+0x3e/0x170 [ 3437.459878]        bch2_truncate+0x82/0x110 [bcachefs] [ 3437.460276]        bchfs_truncate+0x254/0x3c0 [bcachefs] [ 3437.460686]        notify_change+0x1f1/0x4a0 [ 3437.461283]        do_truncate+0x7f/0xd0 [ 3437.461555]        path_openat+0xa57/0xce0 [ 3437.461836]        do_filp_open+0xb4/0x160 [ 3437.462116]        do_sys_openat2+0x91/0xc0 [ 3437.462402]        __x64_sys_openat+0x53/0xa0 [ 3437.462701]        do_syscall_64+0x42/0xf0 [ 3437.462982]        entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 3437.463359] -> #1 (&sb->s_type->i_mutex_key#15){+.+.}-{3:3}: [ 3437.463843]        down_write+0x3b/0xc0 [ 3437.464223]        bch2_write_iter+0x5b/0xcc0 [bcachefs] [ 3437.464493]        vfs_write+0x21b/0x4c0 [ 3437.464653]        ksys_write+0x69/0xf0 [ 3437.464839]        do_syscall_64+0x42/0xf0 [ 3437.465009]        entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 3437.465231] -> #0 (sb_writers#10){.+.+}-{0:0}: [ 3437.465471]        __lock_acquire+0x1455/0x21b0 [ 3437.465656]        lock_acquire+0xc6/0x2b0 [ 3437.465822]        mnt_want_write+0x46/0x1a0 [ 3437.465996]        filename_create+0x62/0x190 [ 3437.466175]        user_path_create+0x2d/0x50 [ 3437.466352]        bch2_fs_file_ioctl+0x2ec/0xc90 [bcachefs] [ 3437.466617]        __x64_sys_ioctl+0x93/0xd0 [ 3437.466791]        do_syscall_64+0x42/0xf0 [ 3437.466957]        entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 3437.467180] other info that might help us debug this:  [ 3437.469670] 2 locks held by bcachefs/35533: other info that might help us debug this:  [ 3437.467507] Chain exists of: sb_writers#10 --> &c->snapshot_create_lock --> &type->s_umount_key#48  [ 3437.467979]  Possible unsafe locking scenario:  [ 3437.468223]        CPU0                    CPU1 [ 3437.468405]        ----                    ---- [ 3437.468585]   rlock(&type->s_umount_key#48); [ 3437.468758] lock(&c->snapshot_create_lock); [ 3437.469030]                                lock(&type->s_umount_key#48); [ 3437.469291]   rlock(sb_writers#10); [ 3437.469434] *** DEADLOCK ***  [ 3437.469 ---truncated---",
      "cve": "CVE-2024-26658",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26658",
          "value": "CVE-2024-26658",
          "url": "https://scout.docker.com/v/CVE-2024-26658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d103d8daa497a82f4104668471dc6a537e9de7390784cd7e3bd391bf6b86b9e1",
      "category": "container_scanning",
      "message": "CVE-2024-26691 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Fix circular locking dependency  The rule inside kvm enforces that the vcpu->mutex is taken *inside* kvm->lock. The rule is violated by the pkvm_create_hyp_vm() which acquires the kvm->lock while already holding the vcpu->mutex lock from kvm_vcpu_ioctl(). Avoid the circular locking dependency altogether by protecting the hyp vm handle with the config_lock, much like we already do for other forms of VM-scoped data.",
      "cve": "CVE-2024-26691",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26691",
          "value": "CVE-2024-26691",
          "url": "https://scout.docker.com/v/CVE-2024-26691?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26691?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f89d17b372a0660787e1aeff70100ee8515c0e1aadd24f70e81757336808328",
      "category": "container_scanning",
      "message": "CVE-2024-26714 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  interconnect: qcom: sc8180x: Mark CO0 BCM keepalive  The CO0 BCM needs to be up at all times, otherwise some hardware (like the UFS controller) loses its connection to the rest of the SoC, resulting in a hang of the platform, accompanied by a spectacular logspam.  Mark it as keepalive to prevent such cases.",
      "cve": "CVE-2024-26714",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26714",
          "value": "CVE-2024-26714",
          "url": "https://scout.docker.com/v/CVE-2024-26714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1cce0351c9ac40ceea45c2ef6d8811ed6d64a90972a08c0abe6031f811a7a955",
      "category": "container_scanning",
      "message": "CVE-2024-26719 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nouveau: offload fence uevents work to workqueue  This should break the deadlock between the fctx lock and the irq lock.  This offloads the processing off the work from the irq into a workqueue.",
      "cve": "CVE-2024-26719",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26719",
          "value": "CVE-2024-26719",
          "url": "https://scout.docker.com/v/CVE-2024-26719?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26719?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7aed4ba218cfcbd5a925ac8173a6baef0ab6e7ad1564205629252140d20709ec",
      "category": "container_scanning",
      "message": "CVE-2024-26740 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: act_mirred: use the backlog for mirred ingress  The test Davide added in commit ca22da2fbd69 (\"act_mirred: use the backlog for nested calls to mirred ingress\") hangs our testing VMs every 10 or so runs, with the familiar tcp_v4_rcv -> tcp_v4_rcv deadlock reported by lockdep.  The problem as previously described by Davide (see Link) is that if we reverse flow of traffic with the redirect (egress -> ingress) we may reach the same socket which generated the packet. And we may still be holding its socket lock. The common solution to such deadlocks is to put the packet in the Rx backlog, rather than run the Rx path inline. Do that for all egress -> ingress reversals, not just once we started to nest mirred calls.  In the past there was a concern that the backlog indirection will lead to loss of error reporting / less accurate stats. But the current workaround does not seem to address the issue.",
      "cve": "CVE-2024-26740",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26740",
          "value": "CVE-2024-26740",
          "url": "https://scout.docker.com/v/CVE-2024-26740?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26740?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "45e641caaa354dfc5c4efab353ddb9367a0ab343c1be901c333655d344f2a66e",
      "category": "container_scanning",
      "message": "CVE-2024-26756 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md: Don't register sync_thread for reshape directly  Currently, if reshape is interrupted, then reassemble the array will register sync_thread directly from pers->run(), in this case 'MD_RECOVERY_RUNNING' is set directly, however, there is no guarantee that md_do_sync() will be executed, hence stop_sync_thread() will hang because 'MD_RECOVERY_RUNNING' can't be cleared.  Last patch make sure that md_do_sync() will set MD_RECOVERY_DONE, however, following hang can still be triggered by dm-raid test shell/lvconvert-raid-reshape.sh occasionally:  [root@fedora ~]# cat /proc/1982/stack [<0>] stop_sync_thread+0x1ab/0x270 [md_mod] [<0>] md_frozen_sync_thread+0x5c/0xa0 [md_mod] [<0>] raid_presuspend+0x1e/0x70 [dm_raid] [<0>] dm_table_presuspend_targets+0x40/0xb0 [dm_mod] [<0>] __dm_destroy+0x2a5/0x310 [dm_mod] [<0>] dm_destroy+0x16/0x30 [dm_mod] [<0>] dev_remove+0x165/0x290 [dm_mod] [<0>] ctl_ioctl+0x4bb/0x7b0 [dm_mod] [<0>] dm_ctl_ioctl+0x11/0x20 [dm_mod] [<0>] vfs_ioctl+0x21/0x60 [<0>] __x64_sys_ioctl+0xb9/0xe0 [<0>] do_syscall_64+0xc6/0x230 [<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74  Meanwhile mddev->recovery is: MD_RECOVERY_RUNNING | MD_RECOVERY_INTR | MD_RECOVERY_RESHAPE | MD_RECOVERY_FROZEN  Fix this problem by remove the code to register sync_thread directly from raid10 and raid5. And let md_check_recovery() to register sync_thread.",
      "cve": "CVE-2024-26756",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26756",
          "value": "CVE-2024-26756",
          "url": "https://scout.docker.com/v/CVE-2024-26756?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26756?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "382bb50bb0192b6e042c952c16cd107d62ce8aa1d06ca1e94550abb73e6f67c5",
      "category": "container_scanning",
      "message": "CVE-2024-26759 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/swap: fix race when skipping swapcache  When skipping swapcache for SWP_SYNCHRONOUS_IO, if two or more threads swapin the same entry at the same time, they get different pages (A, B). Before one thread (T0) finishes the swapin and installs page (A) to the PTE, another thread (T1) could finish swapin of page (B), swap_free the entry, then swap out the possibly modified page reusing the same entry. It breaks the pte_same check in (T0) because PTE value is unchanged, causing ABA problem.  Thread (T0) will install a stalled page (A) into the PTE and cause data corruption.  One possible callstack is like this:  CPU0                                 CPU1 ----                                 ---- do_swap_page()                       do_swap_page() with same entry <direct swapin path>                 <direct swapin path> <alloc page A>                       <alloc page B> swap_read_folio() <- read to page A  swap_read_folio() <- read to page B <slow on later locks or interrupt>   <finished swapin first> ...                                  set_pte_at() swap_free() <- entry is free <write to page B, now page A stalled> <swap out page B to same swap entry> pte_same() <- Check pass, PTE seems unchanged, but page A is stalled! swap_free() <- page B content lost! set_pte_at() <- staled page A installed!  And besides, for ZRAM, swap_free() allows the swap device to discard the entry content, so even if page (B) is not modified, if swap_read_folio() on CPU0 happens later than swap_free() on CPU1, it may also cause data loss.  To fix this, reuse swapcache_prepare which will pin the swap entry using the cache flag, and allow only one thread to swap it in, also prevent any parallel code from putting the entry in the cache.  Release the pin after PT unlocked.  Racers just loop and wait since it's a rare and very short event.  A schedule_timeout_uninterruptible(1) call is added to avoid repeated page faults wasting too much CPU, causing livelock or adding too much noise to perf statistics.  A similar livelock issue was described in commit 029c4628b2eb (\"mm: swap: get rid of livelock in swapin readahead\")  Reproducer:  This race issue can be triggered easily using a well constructed reproducer and patched brd (with a delay in read path) [1]:  With latest 6.8 mainline, race caused data loss can be observed easily: $ gcc -g -lpthread test-thread-swap-race.c && ./a.out Polulating 32MB of memory region... Keep swapping out... Starting round 0... Spawning 65536 workers... 32746 workers spawned, wait for done... Round 0: Error on 0x5aa00, expected 32746, got 32743, 3 data loss! Round 0: Error on 0x395200, expected 32746, got 32743, 3 data loss! Round 0: Error on 0x3fd000, expected 32746, got 32737, 9 data loss! Round 0 Failed, 15 data loss!  This reproducer spawns multiple threads sharing the same memory region using a small swap device.  Every two threads updates mapped pages one by one in opposite direction trying to create a race, with one dedicated thread keep swapping out the data out using madvise.  The reproducer created a reproduce rate of about once every 5 minutes, so the race should be totally possible in production.  After this patch, I ran the reproducer for over a few hundred rounds and no data loss observed.  Performance overhead is minimal, microbenchmark swapin 10G from 32G zram:  Before:     10934698 us After:      11157121 us Cached:     13155355 us (Dropping SWP_SYNCHRONOUS_IO flag)  [kasong@tencent.com: v4]",
      "cve": "CVE-2024-26759",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26759",
          "value": "CVE-2024-26759",
          "url": "https://scout.docker.com/v/CVE-2024-26759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26759?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c73ed3ef8d78c622ab04610744baa0877b1ea0801db0b8d1e7642e95f4972ffc",
      "category": "container_scanning",
      "message": "CVE-2024-26767 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: fixed integer types and null check locations  [why]: issues fixed: - comparison with wider integer type in loop condition which can cause infinite loops - pointer dereference before null check",
      "cve": "CVE-2024-26767",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26767",
          "value": "CVE-2024-26767",
          "url": "https://scout.docker.com/v/CVE-2024-26767?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26767?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dba25ce0e4df7e1b8291036efb7c2bf2825729f03cc2261a314683f427a855dc",
      "category": "container_scanning",
      "message": "CVE-2024-26770 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: nvidia-shield: Add missing null pointer checks to LED initialization  devm_kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure. Ensure the allocation was successful by checking the pointer validity.  [jkosina@suse.com: tweak changelog a bit]",
      "cve": "CVE-2024-26770",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26770",
          "value": "CVE-2024-26770",
          "url": "https://scout.docker.com/v/CVE-2024-26770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a490b593b043c8697aada3b0a99f028eddb614f7f6398447f352b2d36bc43a24",
      "category": "container_scanning",
      "message": "CVE-2024-26807 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Both cadence-quadspi ->runtime_suspend() and ->runtime_resume() implementations start with:  struct cqspi_st *cqspi = dev_get_drvdata(dev); struct spi_controller *host = dev_get_drvdata(dev);  This obviously cannot be correct, unless \"struct cqspi_st\" is the first member of \" struct spi_controller\", or the other way around, but it is not the case. \"struct spi_controller\" is allocated by devm_spi_alloc_host(), which allocates an extra amount of memory for private data, used to store \"struct cqspi_st\".  The ->probe() function of the cadence-quadspi driver then sets the device drvdata to store the address of the \"struct cqspi_st\" structure. Therefore:  struct cqspi_st *cqspi = dev_get_drvdata(dev);  is correct, but:  struct spi_controller *host = dev_get_drvdata(dev);  is not, as it makes \"host\" point not to a \"struct spi_controller\" but to the same \"struct cqspi_st\" structure as above.  This obviously leads to bad things (memory corruption, kernel crashes) directly during ->probe(), as ->probe() enables the device using PM runtime, leading the ->runtime_resume() hook being called, which in turns calls spi_controller_resume() with the wrong pointer.  This has at least been reported [0] to cause a kernel crash, but the exact behavior will depend on the memory contents.  [0] https://lore.kernel.org/all/20240226121803.5a7r5wkpbbowcxgx@dhruva/  This issue potentially affects all platforms that are currently using the cadence-quadspi driver.",
      "cve": "CVE-2024-26807",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26807",
          "value": "CVE-2024-26807",
          "url": "https://scout.docker.com/v/CVE-2024-26807?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26807?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ca40226b474d857994918ee815604af82ce66a40804d2a92067ef2f98e4bff15",
      "category": "container_scanning",
      "message": "CVE-2024-26844 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: Fix WARNING in _copy_from_iter  Syzkaller reports a warning in _copy_from_iter because an iov_iter is supposedly used in the wrong direction. The reason is that syzcaller managed to generate a request with a transfer direction of SG_DXFER_TO_FROM_DEV. This instructs the kernel to copy user buffers into the kernel, read into the copied buffers and then copy the data back to user space.  Thus the iovec is used in both directions.  Detect this situation in the block layer and construct a new iterator with the correct direction for the copy-in.",
      "cve": "CVE-2024-26844",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26844",
          "value": "CVE-2024-26844",
          "url": "https://scout.docker.com/v/CVE-2024-26844?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26844?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "237c179f226059f99c1ae402ac8673afd821f3d80281bad578b9c87f29985fff",
      "category": "container_scanning",
      "message": "CVE-2024-26853 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  igc: avoid returning frame twice in XDP_REDIRECT  When a frame can not be transmitted in XDP_REDIRECT (e.g. due to a full queue), it is necessary to free it by calling xdp_return_frame_rx_napi.  However, this is the responsibility of the caller of the ndo_xdp_xmit (see for example bq_xmit_all in kernel/bpf/devmap.c) and thus calling it inside igc_xdp_xmit (which is the ndo_xdp_xmit of the igc driver) as well will lead to memory corruption.  In fact, bq_xmit_all expects that it can return all frames after the last successfully transmitted one. Therefore, break for the first not transmitted frame, but do not call xdp_return_frame_rx_napi in igc_xdp_xmit. This is equally implemented in other Intel drivers such as the igb.  There are two alternatives to this that were rejected: 1. Return num_frames as all the frames would have been transmitted and release them inside igc_xdp_xmit. While it might work technically, it is not what the return value is meant to represent (i.e. the number of SUCCESSFULLY transmitted packets). 2. Rework kernel/bpf/devmap.c and all drivers to support non-consecutively dropped packets. Besides being complex, it likely has a negative performance impact without a significant gain since it is anyway unlikely that the next frame can be transmitted if the previous one was dropped.  The memory corruption can be reproduced with the following script which leads to a kernel panic after a few seconds.  It basically generates more traffic than a i225 NIC can transmit and pushes it via XDP_REDIRECT from a virtual interface to the physical interface where frames get dropped.  #!/bin/bash INTERFACE=enp4s0 INTERFACE_IDX=`cat /sys/class/net/$INTERFACE/ifindex`  sudo ip link add dev veth1 type veth peer name veth2 sudo ip link set up $INTERFACE sudo ip link set up veth1 sudo ip link set up veth2  cat << EOF > redirect.bpf.c  SEC(\"prog\") int redirect(struct xdp_md *ctx) { return bpf_redirect($INTERFACE_IDX, 0); }  char _license[] SEC(\"license\") = \"GPL\"; EOF clang -O2 -g -Wall -target bpf -c redirect.bpf.c -o redirect.bpf.o sudo ip link set veth2 xdp obj redirect.bpf.o  cat << EOF > pass.bpf.c  SEC(\"prog\") int pass(struct xdp_md *ctx) { return XDP_PASS; }  char _license[] SEC(\"license\") = \"GPL\"; EOF clang -O2 -g -Wall -target bpf -c pass.bpf.c -o pass.bpf.o sudo ip link set $INTERFACE xdp obj pass.bpf.o  cat << EOF > trafgen.cfg  { /* Ethernet Header */ 0xe8, 0x6a, 0x64, 0x41, 0xbf, 0x46, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, const16(ETH_P_IP),  /* IPv4 Header */ 0b01000101, 0,   # IPv4 version, IHL, TOS const16(1028),   # IPv4 total length (UDP length + 20 bytes (IP header)) const16(2),      # IPv4 ident 0b01000000, 0,   # IPv4 flags, fragmentation off 64,              # IPv4 TTL 17,              # Protocol UDP csumip(14, 33),  # IPv4 checksum  /* UDP Header */ 10,  0, 1, 1,    # IP Src - adapt as needed 10,  0, 1, 2,    # IP Dest - adapt as needed const16(6666),   # UDP Src Port const16(6666),   # UDP Dest Port const16(1008),   # UDP length (UDP header 8 bytes + payload length) csumudp(14, 34), # UDP checksum  /* Payload */ fill('W', 1000), } EOF  sudo trafgen -i trafgen.cfg -b3000MB -o veth1 --cpp",
      "cve": "CVE-2024-26853",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26853",
          "value": "CVE-2024-26853",
          "url": "https://scout.docker.com/v/CVE-2024-26853?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26853?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "632514e266c210cdd69b7cf82989492bf399b9177866207ce1b25912933565ed",
      "category": "container_scanning",
      "message": "CVE-2024-26866 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: lpspi: Avoid potential use-after-free in probe()  fsl_lpspi_probe() is allocating/disposing memory manually with spi_alloc_host()/spi_alloc_target(), but uses devm_spi_register_controller(). In case of error after the latter call the memory will be explicitly freed in the probe function by spi_controller_put() call, but used afterwards by \"devm\" management outside probe() (spi_unregister_controller() <- devm_spi_unregister() below).  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000070 ... Call trace: kernfs_find_ns kernfs_find_and_get_ns sysfs_remove_group sysfs_remove_groups device_remove_attrs device_del spi_unregister_controller devm_spi_unregister release_nodes devres_release_all really_probe driver_probe_device __device_attach_driver bus_for_each_drv __device_attach device_initial_probe bus_probe_device deferred_probe_work_func process_one_work worker_thread kthread ret_from_fork",
      "cve": "CVE-2024-26866",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26866",
          "value": "CVE-2024-26866",
          "url": "https://scout.docker.com/v/CVE-2024-26866?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26866?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1b2334b1e74c722da025d0f0a1bf3c391752adef8471c38cef37554c0be6f475",
      "category": "container_scanning",
      "message": "CVE-2024-26876 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/bridge: adv7511: fix crash on irq during probe  Moved IRQ registration down to end of adv7511_probe().  If an IRQ already is pending during adv7511_probe (before adv7511_cec_init) then cec_received_msg_ts could crash using uninitialized data:  Unable to handle kernel read from unreadable memory at virtual address 00000000000003d5 Internal error: Oops: 96000004 [#1] PREEMPT_RT SMP Call trace: cec_received_msg_ts+0x48/0x990 [cec] adv7511_cec_irq_process+0x1cc/0x308 [adv7511] adv7511_irq_process+0xd8/0x120 [adv7511] adv7511_irq_handler+0x1c/0x30 [adv7511] irq_thread_fn+0x30/0xa0 irq_thread+0x14c/0x238 kthread+0x190/0x1a8",
      "cve": "CVE-2024-26876",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26876",
          "value": "CVE-2024-26876",
          "url": "https://scout.docker.com/v/CVE-2024-26876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "86f3ab069f115a7512e1709536fd15cdc7f56d3f637b31cf3df1115a93777a81",
      "category": "container_scanning",
      "message": "CVE-2024-26938 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/i915/bios: Tolerate devdata==NULL in intel_bios_encoder_supports_dp_dual_mode()  If we have no VBT, or the VBT didn't declare the encoder in question, we won't have the 'devdata' for the encoder. Instead of oopsing just bail early.  We won't be able to tell whether the port is DP++ or not, but so be it.  (cherry picked from commit 26410896206342c8a80d2b027923e9ee7d33b733)",
      "cve": "CVE-2024-26938",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26938",
          "value": "CVE-2024-26938",
          "url": "https://scout.docker.com/v/CVE-2024-26938?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26938?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4039b4d0ce47dc76397e967795470f84e8d94d89e6afb70ba8a6e711b0123dc6",
      "category": "container_scanning",
      "message": "CVE-2024-26948 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add a dc_state NULL check in dc_state_release  [How] Check wheather state is NULL before releasing it.",
      "cve": "CVE-2024-26948",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26948",
          "value": "CVE-2024-26948",
          "url": "https://scout.docker.com/v/CVE-2024-26948?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26948?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7c501b2fe8fe44bdbc926e4ac740541f9e8852e928150a7eaff5e68a36c17155",
      "category": "container_scanning",
      "message": "CVE-2024-26953 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: esp: fix bad handling of pages from page_pool  When the skb is reorganized during esp_output (!esp->inline), the pages coming from the original skb fragments are supposed to be released back to the system through put_page. But if the skb fragment pages are originating from a page_pool, calling put_page on them will trigger a page_pool leak which will eventually result in a crash.  This leak can be easily observed when using CONFIG_DEBUG_VM and doing ipsec + gre (non offloaded) forwarding:  BUG: Bad page state in process ksoftirqd/16  pfn:1451b6 page:00000000de2b8d32 refcount:0 mapcount:0 mapping:0000000000000000 index:0x1451b6000 pfn:0x1451b6 flags: 0x200000000000000(node=0|zone=2) page_type: 0xffffffff() raw: 0200000000000000 dead000000000040 ffff88810d23c000 0000000000000000 raw: 00000001451b6000 0000000000000001 00000000ffffffff 0000000000000000 page dumped because: page_pool leak Modules linked in: ip_gre gre mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat nf_nat xt_addrtype br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay zram zsmalloc fuse [last unloaded: mlx5_core] CPU: 16 PID: 96 Comm: ksoftirqd/16 Not tainted 6.8.0-rc4+ #22 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x36/0x50 bad_page+0x70/0xf0 free_unref_page_prepare+0x27a/0x460 free_unref_page+0x38/0x120 esp_ssg_unref.isra.0+0x15f/0x200 esp_output_tail+0x66d/0x780 esp_xmit+0x2c5/0x360 validate_xmit_xfrm+0x313/0x370 ? validate_xmit_skb+0x1d/0x330 validate_xmit_skb_list+0x4c/0x70 sch_direct_xmit+0x23e/0x350 __dev_queue_xmit+0x337/0xba0 ? nf_hook_slow+0x3f/0xd0 ip_finish_output2+0x25e/0x580 iptunnel_xmit+0x19b/0x240 ip_tunnel_xmit+0x5fb/0xb60 ipgre_xmit+0x14d/0x280 [ip_gre] dev_hard_start_xmit+0xc3/0x1c0 __dev_queue_xmit+0x208/0xba0 ? nf_hook_slow+0x3f/0xd0 ip_finish_output2+0x1ca/0x580 ip_sublist_rcv_finish+0x32/0x40 ip_sublist_rcv+0x1b2/0x1f0 ? ip_rcv_finish_core.constprop.0+0x460/0x460 ip_list_rcv+0x103/0x130 __netif_receive_skb_list_core+0x181/0x1e0 netif_receive_skb_list_internal+0x1b3/0x2c0 napi_gro_receive+0xc8/0x200 gro_cell_poll+0x52/0x90 __napi_poll+0x25/0x1a0 net_rx_action+0x28e/0x300 __do_softirq+0xc3/0x276 ? sort_range+0x20/0x20 run_ksoftirqd+0x1e/0x30 smpboot_thread_fn+0xa6/0x130 kthread+0xcd/0x100 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork+0x31/0x50 ? kthread_complete_and_exit+0x20/0x20 ret_from_fork_asm+0x11/0x20 </TASK>  The suggested fix is to introduce a new wrapper (skb_page_unref) that covers page refcounting for page_pool pages as well.",
      "cve": "CVE-2024-26953",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26953",
          "value": "CVE-2024-26953",
          "url": "https://scout.docker.com/v/CVE-2024-26953?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26953?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ad93830630573aa87957a636f5a8643f37a8db7c3c4b53b359eb1c1e20c521c1",
      "category": "container_scanning",
      "message": "CVE-2024-27002 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  clk: mediatek: Do a runtime PM get on controllers during probe  mt8183-mfgcfg has a mutual dependency with genpd during the probing stage, which leads to a deadlock in the following call stack:  CPU0:  genpd_lock --> clk_prepare_lock genpd_power_off_work_fn() genpd_lock() generic_pm_domain::power_off() clk_unprepare() clk_prepare_lock()  CPU1: clk_prepare_lock --> genpd_lock clk_register() __clk_core_init() clk_prepare_lock() clk_pm_runtime_get() genpd_lock()  Do a runtime PM get at the probe function to make sure clk_register() won't acquire the genpd lock. Instead of only modifying mt8183-mfgcfg, do this on all mediatek clock controller probings because we don't believe this would cause any regression.  Verified on MT8183 and MT8192 Chromebooks.",
      "cve": "CVE-2024-27002",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27002",
          "value": "CVE-2024-27002",
          "url": "https://scout.docker.com/v/CVE-2024-27002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27002?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "84689af287b00064e3be5059a3e6f391424098b40df9e7849bd7533aa7d7b86c",
      "category": "container_scanning",
      "message": "CVE-2024-27014 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Prevent deadlock while disabling aRFS  When disabling aRFS under the `priv->state_lock`, any scheduled aRFS works are canceled using the `cancel_work_sync` function, which waits for the work to end if it has already started. However, while waiting for the work handler, the handler will try to acquire the `state_lock` which is already acquired.  The worker acquires the lock to delete the rules if the state is down, which is not the worker's responsibility since disabling aRFS deletes the rules.  Add an aRFS state variable, which indicates whether the aRFS is enabled and prevent adding rules when the aRFS is disabled.  Kernel log:  ====================================================== WARNING: possible circular locking dependency detected 6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted: G          I ------------------------------------------------------ ethtool/386089 is trying to acquire lock: ffff88810f21ce68 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}, at: __flush_work+0x74/0x4e0  but task is already holding lock: ffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #1 (&priv->state_lock){+.+.}-{3:3}: __mutex_lock+0x80/0xc90 arfs_handle_work+0x4b/0x3b0 [mlx5_core] process_one_work+0x1dc/0x4a0 worker_thread+0x1bf/0x3c0 kthread+0xd7/0x100 ret_from_fork+0x2d/0x50 ret_from_fork_asm+0x11/0x20  -> #0 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}: __lock_acquire+0x17b4/0x2c80 lock_acquire+0xd0/0x2b0 __flush_work+0x7a/0x4e0 __cancel_work_timer+0x131/0x1c0 arfs_del_rules+0x143/0x1e0 [mlx5_core] mlx5e_arfs_disable+0x1b/0x30 [mlx5_core] mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core] ethnl_set_channels+0x28f/0x3b0 ethnl_default_set_doit+0xec/0x240 genl_family_rcv_msg_doit+0xd0/0x120 genl_rcv_msg+0x188/0x2c0 netlink_rcv_skb+0x54/0x100 genl_rcv+0x24/0x40 netlink_unicast+0x1a1/0x270 netlink_sendmsg+0x214/0x460 __sock_sendmsg+0x38/0x60 __sys_sendto+0x113/0x170 __x64_sys_sendto+0x20/0x30 do_syscall_64+0x40/0xe0 entry_SYSCALL_64_after_hwframe+0x46/0x4e  other info that might help us debug this:  Possible unsafe locking scenario:  CPU0                    CPU1 ----                    ---- lock(&priv->state_lock); lock((work_completion)(&rule->arfs_work)); lock(&priv->state_lock); lock((work_completion)(&rule->arfs_work));  *** DEADLOCK ***  3 locks held by ethtool/386089: #0: ffffffff82ea7210 (cb_lock){++++}-{3:3}, at: genl_rcv+0x15/0x40 #1: ffffffff82e94c88 (rtnl_mutex){+.+.}-{3:3}, at: ethnl_default_set_doit+0xd3/0x240 #2: ffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3}, at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]  stack backtrace: CPU: 15 PID: 386089 Comm: ethtool Tainted: G          I 6.7.0-rc4_net_next_mlx5_5483eb2 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x60/0xa0 check_noncircular+0x144/0x160 __lock_acquire+0x17b4/0x2c80 lock_acquire+0xd0/0x2b0 ? __flush_work+0x74/0x4e0 ? save_trace+0x3e/0x360 ? __flush_work+0x74/0x4e0 __flush_work+0x7a/0x4e0 ? __flush_work+0x74/0x4e0 ? __lock_acquire+0xa78/0x2c80 ? lock_acquire+0xd0/0x2b0 ? mark_held_locks+0x49/0x70 __cancel_work_timer+0x131/0x1c0 ? mark_held_locks+0x49/0x70 arfs_del_rules+0x143/0x1e0 [mlx5_core] mlx5e_arfs_disable+0x1b/0x30 [mlx5_core] mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core] ethnl_set_channels+0x28f/0x3b0 ethnl_default_set_doit+0xec/0x240 genl_family_rcv_msg_doit+0xd0/0x120 genl_rcv_msg+0x188/0x2c0 ? ethn ---truncated---",
      "cve": "CVE-2024-27014",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27014",
          "value": "CVE-2024-27014",
          "url": "https://scout.docker.com/v/CVE-2024-27014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4ada36b7d5305e101c402e8a1d9d36cdadc5f82d7b635681019400f5f7a44141",
      "category": "container_scanning",
      "message": "CVE-2024-27025 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nbd: null check for nla_nest_start  nla_nest_start() may fail and return NULL. Insert a check and set errno based on other call sites within the same source code.",
      "cve": "CVE-2024-27025",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27025",
          "value": "CVE-2024-27025",
          "url": "https://scout.docker.com/v/CVE-2024-27025?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27025?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "899a04e58ae1f3a84fcfd1a392634b4a8a8d54db71af2b514dc738f0be6a1443",
      "category": "container_scanning",
      "message": "CVE-2024-27035 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: compress: fix to guarantee persisting compressed blocks by CP  If data block in compressed cluster is not persisted with metadata during checkpoint, after SPOR, the data may be corrupted, let's guarantee to write compressed page by checkpoint.",
      "cve": "CVE-2024-27035",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27035",
          "value": "CVE-2024-27035",
          "url": "https://scout.docker.com/v/CVE-2024-27035?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27035?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fcaff9cbd4cd83e137ca15a620a17cba9fc3370c47dd1d64fee251709f54516c",
      "category": "container_scanning",
      "message": "CVE-2024-27056 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: ensure offloading TID queue exists  The resume code path assumes that the TX queue for the offloading TID has been configured. At resume time it then tries to sync the write pointer as it may have been updated by the firmware.  In the unusual event that no packets have been send on TID 0, the queue will not have been allocated and this causes a crash. Fix this by ensuring the queue exist at suspend time.",
      "cve": "CVE-2024-27056",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27056",
          "value": "CVE-2024-27056",
          "url": "https://scout.docker.com/v/CVE-2024-27056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ac07dbd760200ebc6857bff00c87915e2f6b89c24bbb0eb9176403b270730085",
      "category": "container_scanning",
      "message": "CVE-2024-27057 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: ipc4-pcm: Workaround for crashed firmware on system suspend  When the system is suspended while audio is active, the sof_ipc4_pcm_hw_free() is invoked to reset the pipelines since during suspend the DSP is turned off, streams will be re-started after resume.  If the firmware crashes during while audio is running (or when we reset the stream before suspend) then the sof_ipc4_set_multi_pipeline_state() will fail with IPC error and the state change is interrupted. This will cause misalignment between the kernel and firmware state on next DSP boot resulting errors returned by firmware for IPC messages, eventually failing the audio resume. On stream close the errors are ignored so the kernel state will be corrected on the next DSP boot, so the second boot after the DSP panic.  If sof_ipc4_trigger_pipelines() is called from sof_ipc4_pcm_hw_free() then state parameter is SOF_IPC4_PIPE_RESET and only in this case.  Treat a forced pipeline reset similarly to how we treat a pcm_free by ignoring error on state sending to allow the kernel's state to be consistent with the state the firmware will have after the next boot.",
      "cve": "CVE-2024-27057",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27057",
          "value": "CVE-2024-27057",
          "url": "https://scout.docker.com/v/CVE-2024-27057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27057?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "edf095bd0dc432605b4aa24110a3e8887aa283f234707b3b8f9efbef91b75e1f",
      "category": "container_scanning",
      "message": "CVE-2024-27389 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  pstore: inode: Only d_invalidate() is needed  Unloading a modular pstore backend with records in pstorefs would trigger the dput() double-drop warning:  WARNING: CPU: 0 PID: 2569 at fs/dcache.c:762 dput.part.0+0x3f3/0x410  Using the combo of d_drop()/dput() (as mentioned in Documentation/filesystems/vfs.rst) isn't the right approach here, and leads to the reference counting problem seen above. Use d_invalidate() and update the code to not bother checking for error codes that can never happen.  ---",
      "cve": "CVE-2024-27389",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27389",
          "value": "CVE-2024-27389",
          "url": "https://scout.docker.com/v/CVE-2024-27389?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27389?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d01aa3acb8d0de774cff5594bcef8cc64d86481e23832dbff93135ea242bce7",
      "category": "container_scanning",
      "message": "CVE-2024-27418 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: mctp: take ownership of skb in mctp_local_output  Currently, mctp_local_output only takes ownership of skb on success, and we may leak an skb if mctp_local_output fails in specific states; the skb ownership isn't transferred until the actual output routing occurs.  Instead, make mctp_local_output free the skb on all error paths up to the route action, so it always consumes the passed skb.",
      "cve": "CVE-2024-27418",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27418",
          "value": "CVE-2024-27418",
          "url": "https://scout.docker.com/v/CVE-2024-27418?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27418?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "baacf329dedd326ef4640aa0871a502dd0773fb77c3ac465e6d40a94f36c639d",
      "category": "container_scanning",
      "message": "CVE-2024-27435 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme: fix reconnection fail due to reserved tag allocation  We found a issue on production environment while using NVMe over RDMA, admin_q reconnect failed forever while remote target and network is ok. After dig into it, we found it may caused by a ABBA deadlock due to tag allocation. In my case, the tag was hold by a keep alive request waiting inside admin_q, as we quiesced admin_q while reset ctrl, so the request maked as idle and will not process before reset success. As fabric_q shares tagset with admin_q, while reconnect remote target, we need a tag for connect command, but the only one reserved tag was held by keep alive command which waiting inside admin_q. As a result, we failed to reconnect admin_q forever. In order to fix this issue, I think we should keep two reserved tags for admin queue.",
      "cve": "CVE-2024-27435",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-27435",
          "value": "CVE-2024-27435",
          "url": "https://scout.docker.com/v/CVE-2024-27435?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-27435?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "09c415e3ef90d560a43630c6ca0b21e498ff5a79ac0c10398017d57e614441de",
      "category": "container_scanning",
      "message": "CVE-2024-35784 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix deadlock with fiemap and extent locking  While working on the patchset to remove extent locking I got a lockdep splat with fiemap and pagefaulting with my new extent lock replacement lock.  This deadlock exists with our normal code, we just don't have lockdep annotations with the extent locking so we've never noticed it.  Since we're copying the fiemap extent to user space on every iteration we have the chance of pagefaulting.  Because we hold the extent lock for the entire range we could mkwrite into a range in the file that we have mmap'ed.  This would deadlock with the following stack trace  [<0>] lock_extent+0x28d/0x2f0 [<0>] btrfs_page_mkwrite+0x273/0x8a0 [<0>] do_page_mkwrite+0x50/0xb0 [<0>] do_fault+0xc1/0x7b0 [<0>] __handle_mm_fault+0x2fa/0x460 [<0>] handle_mm_fault+0xa4/0x330 [<0>] do_user_addr_fault+0x1f4/0x800 [<0>] exc_page_fault+0x7c/0x1e0 [<0>] asm_exc_page_fault+0x26/0x30 [<0>] rep_movs_alternative+0x33/0x70 [<0>] _copy_to_user+0x49/0x70 [<0>] fiemap_fill_next_extent+0xc8/0x120 [<0>] emit_fiemap_extent+0x4d/0xa0 [<0>] extent_fiemap+0x7f8/0xad0 [<0>] btrfs_fiemap+0x49/0x80 [<0>] __x64_sys_ioctl+0x3e1/0xb50 [<0>] do_syscall_64+0x94/0x1a0 [<0>] entry_SYSCALL_64_after_hwframe+0x6e/0x76  I wrote an fstest to reproduce this deadlock without my replacement lock and verified that the deadlock exists with our existing locking.  To fix this simply don't take the extent lock for the entire duration of the fiemap.  This is safe in general because we keep track of where we are when we're searching the tree, so if an ordered extent updates in the middle of our fiemap call we'll still emit the correct extents because we know what offset we were on before.  The only place we maintain the lock is searching delalloc.  Since the delalloc stuff can change during writeback we want to lock the extent range so we have a consistent view of delalloc at the time we're checking to see if we need to set the delalloc flag.  With this patch applied we no longer deadlock with my testcase.",
      "cve": "CVE-2024-35784",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35784",
          "value": "CVE-2024-35784",
          "url": "https://scout.docker.com/v/CVE-2024-35784?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35784?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4d6af44a786803353ae688ac1890b6653e2ad9f8677136b99eae0acce9d49d80",
      "category": "container_scanning",
      "message": "CVE-2024-35794 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm-raid: really frozen sync_thread during suspend  1) commit f52f5c71f3d4 (\"md: fix stopping sync thread\") remove MD_RECOVERY_FROZEN from __md_stop_writes() and doesn't realize that dm-raid relies on __md_stop_writes() to frozen sync_thread indirectly. Fix this problem by adding MD_RECOVERY_FROZEN in md_stop_writes(), and since stop_sync_thread() is only used for dm-raid in this case, also move stop_sync_thread() to md_stop_writes(). 2) The flag MD_RECOVERY_FROZEN doesn't mean that sync thread is frozen, it only prevent new sync_thread to start, and it can't stop the running sync thread; In order to frozen sync_thread, after seting the flag, stop_sync_thread() should be used. 3) The flag MD_RECOVERY_FROZEN doesn't mean that writes are stopped, use it as condition for md_stop_writes() in raid_postsuspend() doesn't look correct. Consider that reentrant stop_sync_thread() do nothing, always call md_stop_writes() in raid_postsuspend(). 4) raid_message can set/clear the flag MD_RECOVERY_FROZEN at anytime, and if MD_RECOVERY_FROZEN is cleared while the array is suspended, new sync_thread can start unexpected. Fix this by disallow raid_message() to change sync_thread status during suspend.  Note that after commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), the test shell/lvconvert-raid-reshape.sh start to hang in stop_sync_thread(), and with previous fixes, the test won't hang there anymore, however, the test will still fail and complain that ext4 is corrupted. And with this patch, the test won't hang due to stop_sync_thread() or fail due to ext4 is corrupted anymore. However, there is still a deadlock related to dm-raid456 that will be fixed in following patches.",
      "cve": "CVE-2024-35794",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35794",
          "value": "CVE-2024-35794",
          "url": "https://scout.docker.com/v/CVE-2024-35794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0fb3dcd075ab782963417a80493ef16bce303ea5ec0a4d5965c35f2ddf4c6fee",
      "category": "container_scanning",
      "message": "CVE-2024-35799 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Prevent crash when disable stream  [Why] Disabling stream encoder invokes a function that no longer exists.  [How] Check if the function declaration is NULL in disable stream encoder.",
      "cve": "CVE-2024-35799",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35799",
          "value": "CVE-2024-35799",
          "url": "https://scout.docker.com/v/CVE-2024-35799?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35799?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "37310fa7d230a81f19b84b8f1b5664cc63d174464849540ce99f27dc3a5d1559",
      "category": "container_scanning",
      "message": "CVE-2024-35801 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/fpu: Keep xfd_state in sync with MSR_IA32_XFD  Commit 672365477ae8 (\"x86/fpu: Update XFD state where required\") and commit 8bf26758ca96 (\"x86/fpu: Add XFD state to fpstate\") introduced a per CPU variable xfd_state to keep the MSR_IA32_XFD value cached, in order to avoid unnecessary writes to the MSR.  On CPU hotplug MSR_IA32_XFD is reset to the init_fpstate.xfd, which wipes out any stale state. But the per CPU cached xfd value is not reset, which brings them out of sync.  As a consequence a subsequent xfd_update_state() might fail to update the MSR which in turn can result in XRSTOR raising a #NM in kernel space, which crashes the kernel.  To fix this, introduce xfd_set_state() to write xfd_state together with MSR_IA32_XFD, and use it in all places that set MSR_IA32_XFD.",
      "cve": "CVE-2024-35801",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35801",
          "value": "CVE-2024-35801",
          "url": "https://scout.docker.com/v/CVE-2024-35801?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35801?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "107b30292b18476bff165d41e0663235d2e63b0e8cf9b4703e34624008262d2b",
      "category": "container_scanning",
      "message": "CVE-2024-35803 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/efistub: Call mixed mode boot services on the firmware's stack  Normally, the EFI stub calls into the EFI boot services using the stack that was live when the stub was entered. According to the UEFI spec, this stack needs to be at least 128k in size - this might seem large but all asynchronous processing and event handling in EFI runs from the same stack and so quite a lot of space may be used in practice.  In mixed mode, the situation is a bit different: the bootloader calls the 32-bit EFI stub entry point, which calls the decompressor's 32-bit entry point, where the boot stack is set up, using a fixed allocation of 16k. This stack is still in use when the EFI stub is started in 64-bit mode, and so all calls back into the EFI firmware will be using the decompressor's limited boot stack.  Due to the placement of the boot stack right after the boot heap, any stack overruns have gone unnoticed. However, commit  5c4feadb0011983b (\"x86/decompressor: Move global symbol references to C code\")  moved the definition of the boot heap into C code, and now the boot stack is placed right at the base of BSS, where any overruns will corrupt the end of the .data section.  While it would be possible to work around this by increasing the size of the boot stack, doing so would affect all x86 systems, and mixed mode systems are a tiny (and shrinking) fraction of the x86 installed base.  So instead, record the firmware stack pointer value when entering from the 32-bit firmware, and switch to this stack every time a EFI boot service call is made.",
      "cve": "CVE-2024-35803",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35803",
          "value": "CVE-2024-35803",
          "url": "https://scout.docker.com/v/CVE-2024-35803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc710519080af6589255e3e5def5a4572a65132a489cbaf1790151c79355d805",
      "category": "container_scanning",
      "message": "CVE-2024-35808 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md/dm-raid: don't call md_reap_sync_thread() directly  Currently md_reap_sync_thread() is called from raid_message() directly without holding 'reconfig_mutex', this is definitely unsafe because md_reap_sync_thread() can change many fields that is protected by 'reconfig_mutex'.  However, hold 'reconfig_mutex' here is still problematic because this will cause deadlock, for example, commit 130443d60b1b (\"md: refactor idle/frozen_sync_thread() to fix deadlock\").  Fix this problem by using stop_sync_thread() to unregister sync_thread, like md/raid did.",
      "cve": "CVE-2024-35808",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35808",
          "value": "CVE-2024-35808",
          "url": "https://scout.docker.com/v/CVE-2024-35808?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35808?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "af7fdc1a310a71081266d5c1806048e78d82bf4e5df0fcc19972d81a96089583",
      "category": "container_scanning",
      "message": "CVE-2024-35826 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: Fix page refcounts for unaligned buffers in __bio_release_pages()  Fix an incorrect number of pages being released for buffers that do not start at the beginning of a page.",
      "cve": "CVE-2024-35826",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35826",
          "value": "CVE-2024-35826",
          "url": "https://scout.docker.com/v/CVE-2024-35826?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35826?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d763fa347914f5dbc0ef901e3f41afb0bac32907243e20b35db454a1f1f239d2",
      "category": "container_scanning",
      "message": "CVE-2024-35832 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bcachefs: kvfree bch_fs::snapshots in bch2_fs_snapshots_exit  bch_fs::snapshots is allocated by kvzalloc in __snapshot_t_mut. It should be freed by kvfree not kfree. Or umount will triger:  [  406.829178 ] BUG: unable to handle page fault for address: ffffe7b487148008 [  406.830676 ] #PF: supervisor read access in kernel mode [  406.831643 ] #PF: error_code(0x0000) - not-present page [  406.832487 ] PGD 0 P4D 0 [  406.832898 ] Oops: 0000 [#1] PREEMPT SMP PTI [  406.833512 ] CPU: 2 PID: 1754 Comm: umount Kdump: loaded Tainted: G OE      6.7.0-rc7-custom+ #90 [  406.834746 ] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014 [  406.835796 ] RIP: 0010:kfree+0x62/0x140 [  406.836197 ] Code: 80 48 01 d8 0f 82 e9 00 00 00 48 c7 c2 00 00 00 80 48 2b 15 78 9f 1f 01 48 01 d0 48 c1 e8 0c 48 c1 e0 06 48 03 05 56 9f 1f 01 <48> 8b 50 08 48 89 c7 f6 c2 01 0f 85 b0 00 00 00 66 90 48 8b 07 f6 [  406.837810 ] RSP: 0018:ffffb9d641607e48 EFLAGS: 00010286 [  406.838213 ] RAX: ffffe7b487148000 RBX: ffffb9d645200000 RCX: ffffb9d641607dc4 [  406.838738 ] RDX: 000065bb00000000 RSI: ffffffffc0d88b84 RDI: ffffb9d645200000 [  406.839217 ] RBP: ffff9a4625d00068 R08: 0000000000000001 R09: 0000000000000001 [  406.839650 ] R10: 0000000000000001 R11: 000000000000001f R12: ffff9a4625d4da80 [  406.840055 ] R13: ffff9a4625d00000 R14: ffffffffc0e2eb20 R15: 0000000000000000 [  406.840451 ] FS:  00007f0a264ffb80(0000) GS:ffff9a4e2d500000(0000) knlGS:0000000000000000 [  406.840851 ] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  406.841125 ] CR2: ffffe7b487148008 CR3: 000000018c4d2000 CR4: 00000000000006f0 [  406.841464 ] Call Trace: [  406.841583 ]  <TASK> [  406.841682 ]  ? __die+0x1f/0x70 [  406.841828 ]  ? page_fault_oops+0x159/0x470 [  406.842014 ]  ? fixup_exception+0x22/0x310 [  406.842198 ]  ? exc_page_fault+0x1ed/0x200 [  406.842382 ]  ? asm_exc_page_fault+0x22/0x30 [  406.842574 ]  ? bch2_fs_release+0x54/0x280 [bcachefs] [  406.842842 ]  ? kfree+0x62/0x140 [  406.842988 ]  ? kfree+0x104/0x140 [  406.843138 ]  bch2_fs_release+0x54/0x280 [bcachefs] [  406.843390 ]  kobject_put+0xb7/0x170 [  406.843552 ]  deactivate_locked_super+0x2f/0xa0 [  406.843756 ]  cleanup_mnt+0xba/0x150 [  406.843917 ]  task_work_run+0x59/0xa0 [  406.844083 ]  exit_to_user_mode_prepare+0x197/0x1a0 [  406.844302 ]  syscall_exit_to_user_mode+0x16/0x40 [  406.844510 ]  do_syscall_64+0x4e/0xf0 [  406.844675 ]  entry_SYSCALL_64_after_hwframe+0x6e/0x76 [  406.844907 ] RIP: 0033:0x7f0a2664e4fb",
      "cve": "CVE-2024-35832",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35832",
          "value": "CVE-2024-35832",
          "url": "https://scout.docker.com/v/CVE-2024-35832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "65ddb01e1232c8a97f24f6d1e14829be98422cca2d98ebd84221b2391e9bbd6c",
      "category": "container_scanning",
      "message": "CVE-2024-35839 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: bridge: replace physindev with physinif in nf_bridge_info  An skb can be added to a neigh->arp_queue while waiting for an arp reply. Where original skb's skb->dev can be different to neigh's neigh->dev. For instance in case of bridging dnated skb from one veth to another, the skb would be added to a neigh->arp_queue of the bridge.  As skb->dev can be reset back to nf_bridge->physindev and used, and as there is no explicit mechanism that prevents this physindev from been freed under us (for instance neigh_flush_dev doesn't cleanup skbs from different device's neigh queue) we can crash on e.g. this stack:  arp_process neigh_update skb = __skb_dequeue(&neigh->arp_queue) neigh_resolve_output(..., skb) ... br_nf_dev_xmit br_nf_pre_routing_finish_bridge_slow skb->dev = nf_bridge->physindev br_handle_frame_finish  Let's use plain ifindex instead of net_device link. To peek into the original net_device we will use dev_get_by_index_rcu(). Thus either we get device and are safe to use it or we don't get it and drop skb.",
      "cve": "CVE-2024-35839",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35839",
          "value": "CVE-2024-35839",
          "url": "https://scout.docker.com/v/CVE-2024-35839?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35839?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "09376bbcb74bbddeb813b0f71f73c3a860b71a50f7960343dd38ee25d3306d82",
      "category": "container_scanning",
      "message": "CVE-2024-35875 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/coco: Require seeding RNG with RDRAND on CoCo systems  There are few uses of CoCo that don't rely on working cryptography and hence a working RNG. Unfortunately, the CoCo threat model means that the VM host cannot be trusted and may actively work against guests to extract secrets or manipulate computation. Since a malicious host can modify or observe nearly all inputs to guests, the only remaining source of entropy for CoCo guests is RDRAND.  If RDRAND is broken -- due to CPU hardware fault -- the RNG as a whole is meant to gracefully continue on gathering entropy from other sources, but since there aren't other sources on CoCo, this is catastrophic. This is mostly a concern at boot time when initially seeding the RNG, as after that the consequences of a broken RDRAND are much more theoretical.  So, try at boot to seed the RNG using 256 bits of RDRAND output. If this fails, panic(). This will also trigger if the system is booted without RDRAND, as RDRAND is essential for a safe CoCo boot.  Add this deliberately to be \"just a CoCo x86 driver feature\" and not part of the RNG itself. Many device drivers and platforms have some desire to contribute something to the RNG, and add_device_randomness() is specifically meant for this purpose.  Any driver can call it with seed data of any quality, or even garbage quality, and it can only possibly make the quality of the RNG better or have no effect, but can never make it worse.  Rather than trying to build something into the core of the RNG, consider the particular CoCo issue just a CoCo issue, and therefore separate it all out into driver (well, arch/platform) code.  [ bp: Massage commit message. ]",
      "cve": "CVE-2024-35875",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35875",
          "value": "CVE-2024-35875",
          "url": "https://scout.docker.com/v/CVE-2024-35875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cd6dc34c6a6130fed622168cfc3e40eb7ffe5613ef28217436e24b2963eb3627",
      "category": "container_scanning",
      "message": "CVE-2024-35908 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tls: get psock ref after taking rxlock to avoid leak  At the start of tls_sw_recvmsg, we take a reference on the psock, and then call tls_rx_reader_lock. If that fails, we return directly without releasing the reference.  Instead of adding a new label, just take the reference after locking has succeeded, since we don't need it before.",
      "cve": "CVE-2024-35908",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35908",
          "value": "CVE-2024-35908",
          "url": "https://scout.docker.com/v/CVE-2024-35908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a8376f3116fa0c3ec3d2f59fcb27068f7071521c96257eb17a525519a874c806",
      "category": "container_scanning",
      "message": "CVE-2024-35924 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: typec: ucsi: Limit read size on v1.2  Between UCSI 1.2 and UCSI 2.0, the size of the MESSAGE_IN region was increased from 16 to 256. In order to avoid overflowing reads for older systems, add a mechanism to use the read UCSI version to truncate read sizes on UCSI v1.2.",
      "cve": "CVE-2024-35924",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35924",
          "value": "CVE-2024-35924",
          "url": "https://scout.docker.com/v/CVE-2024-35924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5feafbebdaa4dc813f940feee88240c956dff2a0633d14d3eb03f6f21ca61372",
      "category": "container_scanning",
      "message": "CVE-2024-35926 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: iaa - Fix async_disable descriptor leak  The disable_async paths of iaa_compress/decompress() don't free idxd descriptors in the async_disable case. Currently this only happens in the testcases where req->dst is set to null. Add a test to free them in those paths.",
      "cve": "CVE-2024-35926",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35926",
          "value": "CVE-2024-35926",
          "url": "https://scout.docker.com/v/CVE-2024-35926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9bdb5727fab93b6208352f5b43a01dbaa68a22e0274a4f2d7f71e4a38883b0fa",
      "category": "container_scanning",
      "message": "CVE-2024-35931 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Skip do PCI error slot reset during RAS recovery  Why: The PCI error slot reset maybe triggered after inject ue to UMC multi times, this caused system hang. [  557.371857] amdgpu 0000:af:00.0: amdgpu: GPU reset succeeded, trying to resume [  557.373718] [drm] PCIE GART of 512M enabled. [  557.373722] [drm] PTB located at 0x0000031FED700000 [  557.373788] [drm] VRAM is lost due to GPU reset! [  557.373789] [drm] PSP is resuming... [  557.547012] mlx5_core 0000:55:00.0: mlx5_pci_err_detected Device state = 1 pci_status: 0. Exit, result = 3, need reset [  557.547067] [drm] PCI error: detected callback, state(1)!! [  557.547069] [drm] No support for XGMI hive yet... [  557.548125] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 0. Enter [  557.607763] mlx5_core 0000:55:00.0: wait vital counter value 0x16b5b after 1 iterations [  557.607777] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 1. Exit, err = 0, result = 5, recovered [  557.610492] [drm] PCI error: slot reset callback!! ... [  560.689382] amdgpu 0000:3f:00.0: amdgpu: GPU reset(2) succeeded! [  560.689546] amdgpu 0000:5a:00.0: amdgpu: GPU reset(2) succeeded! [  560.689562] general protection fault, probably for non-canonical address 0x5f080b54534f611f: 0000 [#1] SMP NOPTI [  560.701008] CPU: 16 PID: 2361 Comm: kworker/u448:9 Tainted: G OE     5.15.0-91-generic #101-Ubuntu [  560.712057] Hardware name: Microsoft C278A/C278A, BIOS C2789.5.BS.1C11.AG.1 11/08/2023 [  560.720959] Workqueue: amdgpu-reset-hive amdgpu_ras_do_recovery [amdgpu] [  560.728887] RIP: 0010:amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu] [  560.736891] Code: ff 41 89 c6 e9 1b ff ff ff 44 0f b6 45 b0 e9 4f ff ff ff be 01 00 00 00 4c 89 e7 e8 76 c9 8b ff 44 0f b6 45 b0 e9 3c fd ff ff <48> 83 ba 18 02 00 00 00 0f 84 6a f8 ff ff 48 8d 7a 78 be 01 00 00 [  560.757967] RSP: 0018:ffa0000032e53d80 EFLAGS: 00010202 [  560.763848] RAX: ffa00000001dfd10 RBX: ffa0000000197090 RCX: ffa0000032e53db0 [  560.771856] RDX: 5f080b54534f5f07 RSI: 0000000000000000 RDI: ff11000128100010 [  560.779867] RBP: ffa0000032e53df0 R08: 0000000000000000 R09: ffffffffffe77f08 [  560.787879] R10: 0000000000ffff0a R11: 0000000000000001 R12: 0000000000000000 [  560.795889] R13: ffa0000032e53e00 R14: 0000000000000000 R15: 0000000000000000 [  560.803889] FS:  0000000000000000(0000) GS:ff11007e7e800000(0000) knlGS:0000000000000000 [  560.812973] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  560.819422] CR2: 000055a04c118e68 CR3: 0000000007410005 CR4: 0000000000771ee0 [  560.827433] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [  560.835433] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400 [  560.843444] PKRU: 55555554 [  560.846480] Call Trace: [  560.849225]  <TASK> [  560.851580]  ? show_trace_log_lvl+0x1d6/0x2ea [  560.856488]  ? show_trace_log_lvl+0x1d6/0x2ea [  560.861379]  ? amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu] [  560.867778]  ? show_regs.part.0+0x23/0x29 [  560.872293]  ? __die_body.cold+0x8/0xd [  560.876502]  ? die_addr+0x3e/0x60 [  560.880238]  ? exc_general_protection+0x1c5/0x410 [  560.885532]  ? asm_exc_general_protection+0x27/0x30 [  560.891025]  ? amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu] [  560.898323]  amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu] [  560.904520]  process_one_work+0x228/0x3d0 How: In RAS recovery, mode-1 reset is issued from RAS fatal error handling and expected all the nodes in a hive to be reset. no need to issue another mode-1 during this procedure.",
      "cve": "CVE-2024-35931",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35931",
          "value": "CVE-2024-35931",
          "url": "https://scout.docker.com/v/CVE-2024-35931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "392c620a10ee039c36b14ef165accd116ecaa188a426239184eb32068019313f",
      "category": "container_scanning",
      "message": "CVE-2024-35942 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  pmdomain: imx8mp-blk-ctrl: imx8mp_blk: Add fdcc clock to hdmimix domain  According to i.MX8MP RM and HDMI ADD, the fdcc clock is part of hdmi rx verification IP that should not enable for HDMI TX. But actually if the clock is disabled before HDMI/LCDIF probe, LCDIF will not get pixel clock from HDMI PHY and print the error logs:  [CRTC:39:crtc-2] vblank wait timed out WARNING: CPU: 2 PID: 9 at drivers/gpu/drm/drm_atomic_helper.c:1634 drm_atomic_helper_wait_for_vblanks.part.0+0x23c/0x260  Add fdcc clock to LCDIF and HDMI TX power domains to fix the issue.",
      "cve": "CVE-2024-35942",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35942",
          "value": "CVE-2024-35942",
          "url": "https://scout.docker.com/v/CVE-2024-35942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35942?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "05226d27ea1af88dd91c243e661107edcf9daf1643d75722ab6a30b32652e529",
      "category": "container_scanning",
      "message": "CVE-2024-35945 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: phy: phy_device: Prevent nullptr exceptions on ISR  If phydev->irq is set unconditionally, check for valid interrupt handler or fall back to polling mode to prevent nullptr exceptions in interrupt service routine.",
      "cve": "CVE-2024-35945",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35945",
          "value": "CVE-2024-35945",
          "url": "https://scout.docker.com/v/CVE-2024-35945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "473b14e5633b4cbf1af03db7483c073b6b948117aa34fe32ea0fd8d9aaf0b64c",
      "category": "container_scanning",
      "message": "CVE-2024-35946 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: fix null pointer access when abort scan  During cancel scan we might use vif that weren't scanning. Fix this by using the actual scanning vif.",
      "cve": "CVE-2024-35946",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35946",
          "value": "CVE-2024-35946",
          "url": "https://scout.docker.com/v/CVE-2024-35946?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35946?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0f06af339f877912690a4d5f9c1e62ac66b15f7057516d39fb96e0477e7ea108",
      "category": "container_scanning",
      "message": "CVE-2024-35956 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operations  Create subvolume, create snapshot and delete subvolume all use btrfs_subvolume_reserve_metadata() to reserve metadata for the changes done to the parent subvolume's fs tree, which cannot be mediated in the normal way via start_transaction. When quota groups (squota or qgroups) are enabled, this reserves qgroup metadata of type PREALLOC. Once the operation is associated to a transaction, we convert PREALLOC to PERTRANS, which gets cleared in bulk at the end of the transaction.  However, the error paths of these three operations were not implementing this lifecycle correctly. They unconditionally converted the PREALLOC to PERTRANS in a generic cleanup step regardless of errors or whether the operation was fully associated to a transaction or not. This resulted in error paths occasionally converting this rsv to PERTRANS without calling record_root_in_trans successfully, which meant that unless that root got recorded in the transaction by some other thread, the end of the transaction would not free that root's PERTRANS, leaking it. Ultimately, this resulted in hitting a WARN in CONFIG_BTRFS_DEBUG builds at unmount for the leaked reservation.  The fix is to ensure that every qgroup PREALLOC reservation observes the following properties:  1. any failure before record_root_in_trans is called successfully results in freeing the PREALLOC reservation. 2. after record_root_in_trans, we convert to PERTRANS, and now the transaction owns freeing the reservation.  This patch enforces those properties on the three operations. Without it, generic/269 with squotas enabled at mkfs time would fail in ~5-10 runs on my system. With this patch, it ran successfully 1000 times in a row.",
      "cve": "CVE-2024-35956",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35956",
          "value": "CVE-2024-35956",
          "url": "https://scout.docker.com/v/CVE-2024-35956?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35956?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "204aa24a9215a6779c910b5dea46372d4189db21fdfd5f482ad8b875d56c4479",
      "category": "container_scanning",
      "message": "CVE-2024-35959 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Fix mlx5e_priv_init() cleanup flow  When mlx5e_priv_init() fails, the cleanup flow calls mlx5e_selq_cleanup which calls mlx5e_selq_apply() that assures that the `priv->state_lock` is held using lockdep_is_held().  Acquire the state_lock in mlx5e_selq_cleanup().  Kernel log: ============================= WARNING: suspicious RCU usage 6.8.0-rc3_net_next_841a9b5 #1 Not tainted ----------------------------- drivers/net/ethernet/mellanox/mlx5/core/en/selq.c:124 suspicious rcu_dereference_protected() usage!  other info that might help us debug this:  rcu_scheduler_active = 2, debug_locks = 1 2 locks held by systemd-modules/293: #0: ffffffffa05067b0 (devices_rwsem){++++}-{3:3}, at: ib_register_client+0x109/0x1b0 [ib_core] #1: ffff8881096c65c0 (&device->client_data_rwsem){++++}-{3:3}, at: add_client_context+0x104/0x1c0 [ib_core]  stack backtrace: CPU: 4 PID: 293 Comm: systemd-modules Not tainted 6.8.0-rc3_net_next_841a9b5 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x8a/0xa0 lockdep_rcu_suspicious+0x154/0x1a0 mlx5e_selq_apply+0x94/0xa0 [mlx5_core] mlx5e_selq_cleanup+0x3a/0x60 [mlx5_core] mlx5e_priv_init+0x2be/0x2f0 [mlx5_core] mlx5_rdma_setup_rn+0x7c/0x1a0 [mlx5_core] rdma_init_netdev+0x4e/0x80 [ib_core] ? mlx5_rdma_netdev_free+0x70/0x70 [mlx5_core] ipoib_intf_init+0x64/0x550 [ib_ipoib] ipoib_intf_alloc+0x4e/0xc0 [ib_ipoib] ipoib_add_one+0xb0/0x360 [ib_ipoib] add_client_context+0x112/0x1c0 [ib_core] ib_register_client+0x166/0x1b0 [ib_core] ? 0xffffffffa0573000 ipoib_init_module+0xeb/0x1a0 [ib_ipoib] do_one_initcall+0x61/0x250 do_init_module+0x8a/0x270 init_module_from_file+0x8b/0xd0 idempotent_init_module+0x17d/0x230 __x64_sys_finit_module+0x61/0xb0 do_syscall_64+0x71/0x140 entry_SYSCALL_64_after_hwframe+0x46/0x4e </TASK>",
      "cve": "CVE-2024-35959",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35959",
          "value": "CVE-2024-35959",
          "url": "https://scout.docker.com/v/CVE-2024-35959?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35959?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a0f78806a8be9d8ba45eb70e55f71be010ee75b7b56bc47baa1147ab0a80f4d1",
      "category": "container_scanning",
      "message": "CVE-2024-35971 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ks8851: Handle softirqs at the end of IRQ thread to fix hang  The ks8851_irq() thread may call ks8851_rx_pkts() in case there are any packets in the MAC FIFO, which calls netif_rx(). This netif_rx() implementation is guarded by local_bh_disable() and local_bh_enable(). The local_bh_enable() may call do_softirq() to run softirqs in case any are pending. One of the softirqs is net_rx_action, which ultimately reaches the driver .start_xmit callback. If that happens, the system hangs. The entire call chain is below:  ks8851_start_xmit_par from netdev_start_xmit netdev_start_xmit from dev_hard_start_xmit dev_hard_start_xmit from sch_direct_xmit sch_direct_xmit from __dev_queue_xmit __dev_queue_xmit from __neigh_update __neigh_update from neigh_update neigh_update from arp_process.constprop.0 arp_process.constprop.0 from __netif_receive_skb_one_core __netif_receive_skb_one_core from process_backlog process_backlog from __napi_poll.constprop.0 __napi_poll.constprop.0 from net_rx_action net_rx_action from __do_softirq __do_softirq from call_with_stack call_with_stack from do_softirq do_softirq from __local_bh_enable_ip __local_bh_enable_ip from netif_rx netif_rx from ks8851_irq ks8851_irq from irq_thread_fn irq_thread_fn from irq_thread irq_thread from kthread kthread from ret_from_fork  The hang happens because ks8851_irq() first locks a spinlock in ks8851_par.c ks8851_lock_par() spin_lock_irqsave(&ksp->lock, ...) and with that spinlock locked, calls netif_rx(). Once the execution reaches ks8851_start_xmit_par(), it calls ks8851_lock_par() again which attempts to claim the already locked spinlock again, and the hang happens.  Move the do_softirq() call outside of the spinlock protected section of ks8851_irq() by disabling BHs around the entire spinlock protected section of ks8851_irq() handler. Place local_bh_enable() outside of the spinlock protected section, so that it can trigger do_softirq() without the ks8851_par.c ks8851_lock_par() spinlock being held, and safely call ks8851_start_xmit_par() without attempting to lock the already locked spinlock.  Since ks8851_irq() is protected by local_bh_disable()/local_bh_enable() now, replace netif_rx() with __netif_rx() which is not duplicating the local_bh_disable()/local_bh_enable() calls.",
      "cve": "CVE-2024-35971",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35971",
          "value": "CVE-2024-35971",
          "url": "https://scout.docker.com/v/CVE-2024-35971?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35971?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "34b4ad465e7a7613fee7aafc469d01ac7bddda866148673a87e1b7d74066f071",
      "category": "container_scanning",
      "message": "CVE-2024-35995 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ACPI: CPPC: Use access_width over bit_width for system memory accesses  To align with ACPI 6.3+, since bit_width can be any 8-bit value, it cannot be depended on to be always on a clean 8b boundary. This was uncovered on the Cobalt 100 platform.  SError Interrupt on CPU26, code 0xbe000011 -- SError CPU: 26 PID: 1510 Comm: systemd-udevd Not tainted 5.15.2.1-13 #1 Hardware name: MICROSOFT CORPORATION, BIOS MICROSOFT CORPORATION pstate: 62400009 (nZCv daif +PAN -UAO +TCO -DIT -SSBS BTYPE=--) pc : cppc_get_perf_caps+0xec/0x410 lr : cppc_get_perf_caps+0xe8/0x410 sp : ffff8000155ab730 x29: ffff8000155ab730 x28: ffff0080139d0038 x27: ffff0080139d0078 x26: 0000000000000000 x25: ffff0080139d0058 x24: 00000000ffffffff x23: ffff0080139d0298 x22: ffff0080139d0278 x21: 0000000000000000 x20: ffff00802b251910 x19: ffff0080139d0000 x18: ffffffffffffffff x17: 0000000000000000 x16: ffffdc7e111bad04 x15: ffff00802b251008 x14: ffffffffffffffff x13: ffff013f1fd63300 x12: 0000000000000006 x11: ffffdc7e128f4420 x10: 0000000000000000 x9 : ffffdc7e111badec x8 : ffff00802b251980 x7 : 0000000000000000 x6 : ffff0080139d0028 x5 : 0000000000000000 x4 : ffff0080139d0018 x3 : 00000000ffffffff x2 : 0000000000000008 x1 : ffff8000155ab7a0 x0 : 0000000000000000 Kernel panic - not syncing: Asynchronous SError Interrupt CPU: 26 PID: 1510 Comm: systemd-udevd Not tainted 5.15.2.1-13 #1 Hardware name: MICROSOFT CORPORATION, BIOS MICROSOFT CORPORATION Call trace: dump_backtrace+0x0/0x1e0 show_stack+0x24/0x30 dump_stack_lvl+0x8c/0xb8 dump_stack+0x18/0x34 panic+0x16c/0x384 add_taint+0x0/0xc0 arm64_serror_panic+0x7c/0x90 arm64_is_fatal_ras_serror+0x34/0xa4 do_serror+0x50/0x6c el1h_64_error_handler+0x40/0x74 el1h_64_error+0x7c/0x80 cppc_get_perf_caps+0xec/0x410 cppc_cpufreq_cpu_init+0x74/0x400 [cppc_cpufreq] cpufreq_online+0x2dc/0xa30 cpufreq_add_dev+0xc0/0xd4 subsys_interface_register+0x134/0x14c cpufreq_register_driver+0x1b0/0x354 cppc_cpufreq_init+0x1a8/0x1000 [cppc_cpufreq] do_one_initcall+0x50/0x250 do_init_module+0x60/0x27c load_module+0x2300/0x2570 __do_sys_finit_module+0xa8/0x114 __arm64_sys_finit_module+0x2c/0x3c invoke_syscall+0x78/0x100 el0_svc_common.constprop.0+0x180/0x1a0 do_el0_svc+0x84/0xa0 el0_svc+0x2c/0xc0 el0t_64_sync_handler+0xa4/0x12c el0t_64_sync+0x1a4/0x1a8  Instead, use access_width to determine the size and use the offset and width to shift and mask the bits to read/write out. Make sure to add a check for system memory since pcc redefines the access_width to subspace id.  If access_width is not set, then fall back to using bit_width.  [ rjw: Subject and changelog edits, comment adjustments ]",
      "cve": "CVE-2024-35995",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35995",
          "value": "CVE-2024-35995",
          "url": "https://scout.docker.com/v/CVE-2024-35995?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35995?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "efd4c8499295c842d58f7702cf95d19bb9bfcf84b33f164ed7972b1b96d067df",
      "category": "container_scanning",
      "message": "CVE-2024-35998 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb3: fix lock ordering potential deadlock in cifs_sync_mid_result  Coverity spotted that the cifs_sync_mid_result function could deadlock  \"Thread deadlock (ORDER_REVERSAL) lock_order: Calling spin_lock acquires lock TCP_Server_Info.srv_lock while holding lock TCP_Server_Info.mid_lock\"  Addresses-Coverity: 1590401 (\"Thread deadlock (ORDER_REVERSAL)\")",
      "cve": "CVE-2024-35998",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35998",
          "value": "CVE-2024-35998",
          "url": "https://scout.docker.com/v/CVE-2024-35998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b369362b43f29f2672fa46c97467e03662a9de8f954239a3738145df07ae0431",
      "category": "container_scanning",
      "message": "CVE-2024-36000 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/hugetlb: fix missing hugetlb_lock for resv uncharge  There is a recent report on UFFDIO_COPY over hugetlb:  https://lore.kernel.org/all/000000000000ee06de0616177560@google.com/  350:\tlockdep_assert_held(&hugetlb_lock);  Should be an issue in hugetlb but triggered in an userfault context, where it goes into the unlikely path where two threads modifying the resv map together.  Mike has a fix in that path for resv uncharge but it looks like the locking criteria was overlooked: hugetlb_cgroup_uncharge_folio_rsvd() will update the cgroup pointer, so it requires to be called with the lock held.",
      "cve": "CVE-2024-36000",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36000",
          "value": "CVE-2024-36000",
          "url": "https://scout.docker.com/v/CVE-2024-36000?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36000?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "402fa258d8fbe27973542abce63754530a24162c848ba1cd8e1540e5bc05c84d",
      "category": "container_scanning",
      "message": "CVE-2024-36003 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: fix LAG and VF lock dependency in ice_reset_vf()  9f74a3dfcf83 (\"ice: Fix VF Reset paths when interface in a failed over aggregate\"), the ice driver has acquired the LAG mutex in ice_reset_vf(). The commit placed this lock acquisition just prior to the acquisition of the VF configuration lock.  If ice_reset_vf() acquires the configuration lock via the ICE_VF_RESET_LOCK flag, this could deadlock with ice_vc_cfg_qs_msg() because it always acquires the locks in the order of the VF configuration lock and then the LAG mutex.  Lockdep reports this violation almost immediately on creating and then removing 2 VF:  ====================================================== WARNING: possible circular locking dependency detected 6.8.0-rc6 #54 Tainted: G        W  O ------------------------------------------------------ kworker/60:3/6771 is trying to acquire lock: ff40d43e099380a0 (&vf->cfg_lock){+.+.}-{3:3}, at: ice_reset_vf+0x22f/0x4d0 [ice]  but task is already holding lock: ff40d43ea1961210 (&pf->lag_mutex){+.+.}-{3:3}, at: ice_reset_vf+0xb7/0x4d0 [ice]  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #1 (&pf->lag_mutex){+.+.}-{3:3}: __lock_acquire+0x4f8/0xb40 lock_acquire+0xd4/0x2d0 __mutex_lock+0x9b/0xbf0 ice_vc_cfg_qs_msg+0x45/0x690 [ice] ice_vc_process_vf_msg+0x4f5/0x870 [ice] __ice_clean_ctrlq+0x2b5/0x600 [ice] ice_service_task+0x2c9/0x480 [ice] process_one_work+0x1e9/0x4d0 worker_thread+0x1e1/0x3d0 kthread+0x104/0x140 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1b/0x30  -> #0 (&vf->cfg_lock){+.+.}-{3:3}: check_prev_add+0xe2/0xc50 validate_chain+0x558/0x800 __lock_acquire+0x4f8/0xb40 lock_acquire+0xd4/0x2d0 __mutex_lock+0x9b/0xbf0 ice_reset_vf+0x22f/0x4d0 [ice] ice_process_vflr_event+0x98/0xd0 [ice] ice_service_task+0x1cc/0x480 [ice] process_one_work+0x1e9/0x4d0 worker_thread+0x1e1/0x3d0 kthread+0x104/0x140 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1b/0x30  other info that might help us debug this: Possible unsafe locking scenario: CPU0                    CPU1 ----                    ---- lock(&pf->lag_mutex); lock(&vf->cfg_lock); lock(&pf->lag_mutex); lock(&vf->cfg_lock);  *** DEADLOCK *** 4 locks held by kworker/60:3/6771: #0: ff40d43e05428b38 ((wq_completion)ice){+.+.}-{0:0}, at: process_one_work+0x176/0x4d0 #1: ff50d06e05197e58 ((work_completion)(&pf->serv_task)){+.+.}-{0:0}, at: process_one_work+0x176/0x4d0 #2: ff40d43ea1960e50 (&pf->vfs.table_lock){+.+.}-{3:3}, at: ice_process_vflr_event+0x48/0xd0 [ice] #3: ff40d43ea1961210 (&pf->lag_mutex){+.+.}-{3:3}, at: ice_reset_vf+0xb7/0x4d0 [ice]  stack backtrace: CPU: 60 PID: 6771 Comm: kworker/60:3 Tainted: G        W  O       6.8.0-rc6 #54 Hardware name: Workqueue: ice ice_service_task [ice] Call Trace: <TASK> dump_stack_lvl+0x4a/0x80 check_noncircular+0x12d/0x150 check_prev_add+0xe2/0xc50 ? save_trace+0x59/0x230 ? add_chain_cache+0x109/0x450 validate_chain+0x558/0x800 __lock_acquire+0x4f8/0xb40 ? lockdep_hardirqs_on+0x7d/0x100 lock_acquire+0xd4/0x2d0 ? ice_reset_vf+0x22f/0x4d0 [ice] ? lock_is_held_type+0xc7/0x120 __mutex_lock+0x9b/0xbf0 ? ice_reset_vf+0x22f/0x4d0 [ice] ? ice_reset_vf+0x22f/0x4d0 [ice] ? rcu_is_watching+0x11/0x50 ? ice_reset_vf+0x22f/0x4d0 [ice] ice_reset_vf+0x22f/0x4d0 [ice] ? process_one_work+0x176/0x4d0 ice_process_vflr_event+0x98/0xd0 [ice] ice_service_task+0x1cc/0x480 [ice] process_one_work+0x1e9/0x4d0 worker_thread+0x1e1/0x3d0 ? __pfx_worker_thread+0x10/0x10 kthread+0x104/0x140 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK>  To avoid deadlock, we must acquire the LAG ---truncated---",
      "cve": "CVE-2024-36003",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36003",
          "value": "CVE-2024-36003",
          "url": "https://scout.docker.com/v/CVE-2024-36003?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36003?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7f2d262760c892e23c3758a5421ee1ba00523c1dc887dbae29c42d9d3db1f3de",
      "category": "container_scanning",
      "message": "CVE-2024-36009 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: Fix netdev refcount issue  The dev_tracker is added to ax25_cb in ax25_bind(). When the ax25 device is detaching, the dev_tracker of ax25_cb should be deallocated in ax25_kill_by_device() instead of the dev_tracker of ax25_dev. The log reported by ref_tracker is shown below:  [   80.884935] ref_tracker: reference already released. [   80.885150] ref_tracker: allocated in: [   80.885349]  ax25_dev_device_up+0x105/0x540 [   80.885730]  ax25_device_event+0xa4/0x420 [   80.885730]  notifier_call_chain+0xc9/0x1e0 [   80.885730]  __dev_notify_flags+0x138/0x280 [   80.885730]  dev_change_flags+0xd7/0x180 [   80.885730]  dev_ifsioc+0x6a9/0xa30 [   80.885730]  dev_ioctl+0x4d8/0xd90 [   80.885730]  sock_do_ioctl+0x1c2/0x2d0 [   80.885730]  sock_ioctl+0x38b/0x4f0 [   80.885730]  __se_sys_ioctl+0xad/0xf0 [   80.885730]  do_syscall_64+0xc4/0x1b0 [   80.885730]  entry_SYSCALL_64_after_hwframe+0x67/0x6f [   80.885730] ref_tracker: freed in: [   80.885730]  ax25_device_event+0x272/0x420 [   80.885730]  notifier_call_chain+0xc9/0x1e0 [   80.885730]  dev_close_many+0x272/0x370 [   80.885730]  unregister_netdevice_many_notify+0x3b5/0x1180 [   80.885730]  unregister_netdev+0xcf/0x120 [   80.885730]  sixpack_close+0x11f/0x1b0 [   80.885730]  tty_ldisc_kill+0xcb/0x190 [   80.885730]  tty_ldisc_hangup+0x338/0x3d0 [   80.885730]  __tty_hangup+0x504/0x740 [   80.885730]  tty_release+0x46e/0xd80 [   80.885730]  __fput+0x37f/0x770 [   80.885730]  __x64_sys_close+0x7b/0xb0 [   80.885730]  do_syscall_64+0xc4/0x1b0 [   80.885730]  entry_SYSCALL_64_after_hwframe+0x67/0x6f [   80.893739] ------------[ cut here ]------------ [   80.894030] WARNING: CPU: 2 PID: 140 at lib/ref_tracker.c:255 ref_tracker_free+0x47b/0x6b0 [   80.894297] Modules linked in: [   80.894929] CPU: 2 PID: 140 Comm: ax25_conn_rel_6 Not tainted 6.9.0-rc4-g8cd26fd90c1a #11 [   80.895190] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qem4 [   80.895514] RIP: 0010:ref_tracker_free+0x47b/0x6b0 [   80.895808] Code: 83 c5 18 4c 89 eb 48 c1 eb 03 8a 04 13 84 c0 0f 85 df 01 00 00 41 83 7d 00 00 75 4b 4c 89 ff 9 [   80.896171] RSP: 0018:ffff888009edf8c0 EFLAGS: 00000286 [   80.896339] RAX: 1ffff1100141ac00 RBX: 1ffff1100149463b RCX: dffffc0000000000 [   80.896502] RDX: 0000000000000001 RSI: 0000000000000246 RDI: ffff88800a0d6518 [   80.896925] RBP: ffff888009edf9b0 R08: ffff88806d3288d3 R09: 1ffff1100da6511a [   80.897212] R10: dffffc0000000000 R11: ffffed100da6511b R12: ffff88800a4a31d4 [   80.897859] R13: ffff88800a4a31d8 R14: dffffc0000000000 R15: ffff88800a0d6518 [   80.898279] FS:  00007fd88b7fe700(0000) GS:ffff88806d300000(0000) knlGS:0000000000000000 [   80.899436] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [   80.900181] CR2: 00007fd88c001d48 CR3: 000000000993e000 CR4: 00000000000006f0 ... [   80.935774] ref_tracker: sp%d@000000000bb9df3d has 1/1 users at [   80.935774]      ax25_bind+0x424/0x4e0 [   80.935774]      __sys_bind+0x1d9/0x270 [   80.935774]      __x64_sys_bind+0x75/0x80 [   80.935774]      do_syscall_64+0xc4/0x1b0 [   80.935774]      entry_SYSCALL_64_after_hwframe+0x67/0x6f  Change ax25_dev->dev_tracker to the dev_tracker of ax25_cb in order to mitigate the bug.",
      "cve": "CVE-2024-36009",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36009",
          "value": "CVE-2024-36009",
          "url": "https://scout.docker.com/v/CVE-2024-36009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "173ea753f60a37549c9713693b4f1f06bdadb72d7b0dc426995253c07129d78c",
      "category": "container_scanning",
      "message": "CVE-2024-36021 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hns3: fix kernel crash when devlink reload during pf initialization  The devlink reload process will access the hardware resources, but the register operation is done before the hardware is initialized. So, processing the devlink reload during initialization may lead to kernel crash. This patch fixes this by taking devl_lock during initialization.",
      "cve": "CVE-2024-36021",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36021",
          "value": "CVE-2024-36021",
          "url": "https://scout.docker.com/v/CVE-2024-36021?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36021?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6dba5e1c8558926afa83fe511599c9b4e00c6d72cf1f1144b0d156423e25b5e2",
      "category": "container_scanning",
      "message": "CVE-2024-36026 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: fixes a random hang in S4 for SMU v13.0.4/11  While doing multiple S4 stress tests, GC/RLC/PMFW get into an invalid state resulting into hard hangs.  Adding a GFX reset as workaround just before sending the MP1_UNLOAD message avoids this failure.",
      "cve": "CVE-2024-36026",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36026",
          "value": "CVE-2024-36026",
          "url": "https://scout.docker.com/v/CVE-2024-36026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36026?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c269075280090a199469a1900b2c5381813d8fb8bc9018d46fdfea7e351a08fe",
      "category": "container_scanning",
      "message": "CVE-2024-36244 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/sched: taprio: extend minimum interval restriction to entire cycle too  It is possible for syzbot to side-step the restriction imposed by the blamed commit in the Fixes: tag, because the taprio UAPI permits a cycle-time different from (and potentially shorter than) the sum of entry intervals.  We need one more restriction, which is that the cycle time itself must be larger than N * ETH_ZLEN bit times, where N is the number of schedule entries. This restriction needs to apply regardless of whether the cycle time came from the user or was the implicit, auto-calculated value, so we move the existing \"cycle == 0\" check outside the \"if \"(!new->cycle_time)\" branch. This way covers both conditions and scenarios.  Add a selftest which illustrates the issue triggered by syzbot.",
      "cve": "CVE-2024-36244",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36244",
          "value": "CVE-2024-36244",
          "url": "https://scout.docker.com/v/CVE-2024-36244?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36244?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "998188146ba63006c1a63d8fab0c7e0e28b54d5733847fd0ac71e6a5331bf081",
      "category": "container_scanning",
      "message": "CVE-2024-36478 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  null_blk: fix null-ptr-dereference while configuring 'power' and 'submit_queues'  Writing 'power' and 'submit_queues' concurrently will trigger kernel panic:  Test script:  modprobe null_blk nr_devices=0 mkdir -p /sys/kernel/config/nullb/nullb0 while true; do echo 1 > submit_queues; echo 4 > submit_queues; done & while true; do echo 1 > power; echo 0 > power; done  Test result:  BUG: kernel NULL pointer dereference, address: 0000000000000148 Oops: 0000 [#1] PREEMPT SMP RIP: 0010:__lock_acquire+0x41d/0x28f0 Call Trace: <TASK> lock_acquire+0x121/0x450 down_write+0x5f/0x1d0 simple_recursive_removal+0x12f/0x5c0 blk_mq_debugfs_unregister_hctxs+0x7c/0x100 blk_mq_update_nr_hw_queues+0x4a3/0x720 nullb_update_nr_hw_queues+0x71/0xf0 [null_blk] nullb_device_submit_queues_store+0x79/0xf0 [null_blk] configfs_write_iter+0x119/0x1e0 vfs_write+0x326/0x730 ksys_write+0x74/0x150  This is because del_gendisk() can concurrent with blk_mq_update_nr_hw_queues():  nullb_device_power_store\tnullb_apply_submit_queues null_del_dev del_gendisk nullb_update_nr_hw_queues if (!dev->nullb) // still set while gendisk is deleted return 0 blk_mq_update_nr_hw_queues dev->nullb = NULL  Fix this problem by resuing the global mutex to protect nullb_device_power_store() and nullb_update_nr_hw_queues() from configfs.",
      "cve": "CVE-2024-36478",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36478",
          "value": "CVE-2024-36478",
          "url": "https://scout.docker.com/v/CVE-2024-36478?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36478?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "508ba595954eac8b086882a32a69df9c91f2abf4f84e90033820689626361112",
      "category": "container_scanning",
      "message": "CVE-2024-36479 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fpga: bridge: add owner module and take its refcount  The current implementation of the fpga bridge assumes that the low-level module registers a driver for the parent device and uses its owner pointer to take the module's refcount. This approach is problematic since it can lead to a null pointer dereference while attempting to get the bridge if the parent device does not have a driver.  To address this problem, add a module owner pointer to the fpga_bridge struct and use it to take the module's refcount. Modify the function for registering a bridge to take an additional owner module parameter and rename it to avoid conflicts. Use the old function name for a helper macro that automatically sets the module that registers the bridge as the owner. This ensures compatibility with existing low-level control modules and reduces the chances of registering a bridge without setting the owner.  Also, update the documentation to keep it consistent with the new interface for registering an fpga bridge.  Other changes: opportunistically move put_device() from __fpga_bridge_get() to fpga_bridge_get() and of_fpga_bridge_get() to improve code clarity since the bridge device is taken in these functions.",
      "cve": "CVE-2024-36479",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36479",
          "value": "CVE-2024-36479",
          "url": "https://scout.docker.com/v/CVE-2024-36479?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36479?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ee75c046c62891a51a4e26ddce6da1cea1b9886db296eb73511ea19410faeb39",
      "category": "container_scanning",
      "message": "CVE-2024-36900 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hns3: fix kernel crash when devlink reload during initialization  The devlink reload process will access the hardware resources, but the register operation is done before the hardware is initialized. So, processing the devlink reload during initialization may lead to kernel crash.  This patch fixes this by registering the devlink after hardware initialization.",
      "cve": "CVE-2024-36900",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36900",
          "value": "CVE-2024-36900",
          "url": "https://scout.docker.com/v/CVE-2024-36900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e69118f86ca4fb838010ad88e0604f6c72d671de3ff9890a459378f7ef8356e8",
      "category": "container_scanning",
      "message": "CVE-2024-36903 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipv6: Fix potential uninit-value access in __ip6_make_skb()  As it was done in commit fc1092f51567 (\"ipv4: Fix uninit-value access in __ip_make_skb()\") for IPv4, check FLOWI_FLAG_KNOWN_NH on fl6->flowi6_flags instead of testing HDRINCL on the socket to avoid a race condition which causes uninit-value access.",
      "cve": "CVE-2024-36903",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36903",
          "value": "CVE-2024-36903",
          "url": "https://scout.docker.com/v/CVE-2024-36903?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36903?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "76da34dc71c47d816cbf3c35f7ec8fd06555ec6ec4f8a718c12c66592173fb66",
      "category": "container_scanning",
      "message": "CVE-2024-36909 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Drivers: hv: vmbus: Don't free ring buffers that couldn't be re-encrypted  In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues.  The VMBus ring buffer code could free decrypted/shared pages if set_memory_decrypted() fails. Check the decrypted field in the struct vmbus_gpadl for the ring buffers to decide whether to free the memory.",
      "cve": "CVE-2024-36909",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36909",
          "value": "CVE-2024-36909",
          "url": "https://scout.docker.com/v/CVE-2024-36909?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36909?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "682927d3276d1cd3c6ff89850b9b426d71d411f89338cb183517104c7ad218dd",
      "category": "container_scanning",
      "message": "CVE-2024-36911 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hv_netvsc: Don't free decrypted memory  In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues.  The netvsc driver could free decrypted/shared pages if set_memory_decrypted() fails. Check the decrypted field in the gpadl to decide whether to free the memory.",
      "cve": "CVE-2024-36911",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36911",
          "value": "CVE-2024-36911",
          "url": "https://scout.docker.com/v/CVE-2024-36911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0158d79d7ec80bd817140ee6f940e3d574a6286fad3e595ea93f23fca00d945a",
      "category": "container_scanning",
      "message": "CVE-2024-36917 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: fix overflow in blk_ioctl_discard()  There is no check for overflow of 'start + len' in blk_ioctl_discard(). Hung task occurs if submit an discard ioctl with the following param: start = 0x80000000000ff000, len = 0x8000000000fff000; Add the overflow validation now.",
      "cve": "CVE-2024-36917",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36917",
          "value": "CVE-2024-36917",
          "url": "https://scout.docker.com/v/CVE-2024-36917?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36917?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3046e522e37d0bc2a017fc8b448dc23d4e1df94a39293936c11cf75b366d93d7",
      "category": "container_scanning",
      "message": "CVE-2024-36918 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Check bloom filter map value size  This patch adds a missing check to bloom filter creating, rejecting values above KMALLOC_MAX_SIZE. This brings the bloom map in line with many other map types.  The lack of this protection can cause kernel crashes for value sizes that overflow int's. Such a crash was caught by syzkaller. The next patch adds more guard-rails at a lower level.",
      "cve": "CVE-2024-36918",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36918",
          "value": "CVE-2024-36918",
          "url": "https://scout.docker.com/v/CVE-2024-36918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5dc9759dac59b8c771648296e6ad7ab82d4c20426d85065df130cd8bd77e9f7d",
      "category": "container_scanning",
      "message": "CVE-2024-36920 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Avoid memcpy field-spanning write WARNING  When the \"storcli2 show\" command is executed for eHBA-9600, mpi3mr driver prints this WARNING message:  memcpy: detected field-spanning write (size 128) of single field \"bsg_reply_buf->reply_buf\" at drivers/scsi/mpi3mr/mpi3mr_app.c:1658 (size 1) WARNING: CPU: 0 PID: 12760 at drivers/scsi/mpi3mr/mpi3mr_app.c:1658 mpi3mr_bsg_request+0x6b12/0x7f10 [mpi3mr]  The cause of the WARN is 128 bytes memcpy to the 1 byte size array \"__u8 replay_buf[1]\" in the struct mpi3mr_bsg_in_reply_buf. The array is intended to be a flexible length array, so the WARN is a false positive.  To suppress the WARN, remove the constant number '1' from the array declaration and clarify that it has flexible length. Also, adjust the memory allocation size to match the change.",
      "cve": "CVE-2024-36920",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36920",
          "value": "CVE-2024-36920",
          "url": "https://scout.docker.com/v/CVE-2024-36920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6ba61863e5bd707f8acefc34dc5baea0cb86b9489623db43eaa139c06f5ace55",
      "category": "container_scanning",
      "message": "CVE-2024-36922 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: read txq->read_ptr under lock  If we read txq->read_ptr without lock, we can read the same value twice, then obtain the lock, and reclaim from there to two different places, but crucially reclaim the same entry twice, resulting in the WARN_ONCE() a little later. Fix that by reading txq->read_ptr under lock.",
      "cve": "CVE-2024-36922",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36922",
          "value": "CVE-2024-36922",
          "url": "https://scout.docker.com/v/CVE-2024-36922?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36922?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "77bb46b6423310e03f7338d2dd9f43cf05380785b1880c4f01722c2cf4e3f6cc",
      "category": "container_scanning",
      "message": "CVE-2024-36923 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/9p: fix uninitialized values during inode evict  If an iget fails due to not being able to retrieve information from the server then the inode structure is only partially initialized.  When the inode gets evicted, references to uninitialized structures (like fscache cookies) were being made.  This patch checks for a bad_inode before doing anything other than clearing the inode from the cache.  Since the inode is bad, it shouldn't have any state associated with it that needs to be written back (and there really isn't a way to complete those anyways).",
      "cve": "CVE-2024-36923",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36923",
          "value": "CVE-2024-36923",
          "url": "https://scout.docker.com/v/CVE-2024-36923?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36923?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f85b6e4f2a4e74630ee42691446bb2af7a4974dbc0fc44a54917dbd6c9482e58",
      "category": "container_scanning",
      "message": "CVE-2024-36924 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Release hbalock before calling lpfc_worker_wake_up()  lpfc_worker_wake_up() calls the lpfc_work_done() routine, which takes the hbalock.  Thus, lpfc_worker_wake_up() should not be called while holding the hbalock to avoid potential deadlock.",
      "cve": "CVE-2024-36924",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36924",
          "value": "CVE-2024-36924",
          "url": "https://scout.docker.com/v/CVE-2024-36924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6e008651ced064afe2f680d8da8e973c06b53713679846bec9ab71f71e349580",
      "category": "container_scanning",
      "message": "CVE-2024-36948 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/xe_migrate: Cast to output precision before multiplying operands  Addressing potential overflow in result of  multiplication of two lower precision (u32) operands before widening it to higher precision (u64).  -v2 Fix commit message and description. (Rodrigo)  (cherry picked from commit 34820967ae7b45411f8f4f737c2d63b0c608e0d7)",
      "cve": "CVE-2024-36948",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36948",
          "value": "CVE-2024-36948",
          "url": "https://scout.docker.com/v/CVE-2024-36948?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36948?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "240d7bba261ef4cc24deefded5a21bc9d715221cdc1f8639fc212b09c568cccd",
      "category": "container_scanning",
      "message": "CVE-2024-36951 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: range check cp bad op exception interrupts  Due to a CP interrupt bug, bad packet garbage exception codes are raised. Do a range check so that the debugger and runtime do not receive garbage codes. Update the user api to guard exception code type checking as well.",
      "cve": "CVE-2024-36951",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36951",
          "value": "CVE-2024-36951",
          "url": "https://scout.docker.com/v/CVE-2024-36951?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36951?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "779f0d415c612661f0e6d142487bb3c1b0de0108626e8321528f9bbfc3e24eba",
      "category": "container_scanning",
      "message": "CVE-2024-36966 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: reliably distinguish block based and fscache mode  When erofs_kill_sb() is called in block dev based mode, s_bdev may not have been initialised yet, and if CONFIG_EROFS_FS_ONDEMAND is enabled, it will be mistaken for fscache mode, and then attempt to free an anon_dev that has never been allocated, triggering the following warning:  ============================================ ida_free called for id=0 which is not allocated. WARNING: CPU: 14 PID: 926 at lib/idr.c:525 ida_free+0x134/0x140 Modules linked in: CPU: 14 PID: 926 Comm: mount Not tainted 6.9.0-rc3-dirty #630 RIP: 0010:ida_free+0x134/0x140 Call Trace: <TASK> erofs_kill_sb+0x81/0x90 deactivate_locked_super+0x35/0x80 get_tree_bdev+0x136/0x1e0 vfs_get_tree+0x2c/0xf0 do_new_mount+0x190/0x2f0 [...] ============================================  Now when erofs_kill_sb() is called, erofs_sb_info must have been initialised, so use sbi->fsid to distinguish between the two modes.",
      "cve": "CVE-2024-36966",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36966",
          "value": "CVE-2024-36966",
          "url": "https://scout.docker.com/v/CVE-2024-36966?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36966?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1bec824328abaf3186a6162e98aa91b6224e99df903d3a5b845e9cf6ab88b031",
      "category": "container_scanning",
      "message": "CVE-2024-37021 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fpga: manager: add owner module and take its refcount  The current implementation of the fpga manager assumes that the low-level module registers a driver for the parent device and uses its owner pointer to take the module's refcount. This approach is problematic since it can lead to a null pointer dereference while attempting to get the manager if the parent device does not have a driver.  To address this problem, add a module owner pointer to the fpga_manager struct and use it to take the module's refcount. Modify the functions for registering the manager to take an additional owner module parameter and rename them to avoid conflicts. Use the old function names for helper macros that automatically set the module that registers the manager as the owner. This ensures compatibility with existing low-level control modules and reduces the chances of registering a manager without setting the owner.  Also, update the documentation to keep it consistent with the new interface for registering an fpga manager.  Other changes: opportunistically move put_device() from __fpga_mgr_get() to fpga_mgr_get() and of_fpga_mgr_get() to improve code clarity since the manager device is taken in these functions.",
      "cve": "CVE-2024-37021",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-37021",
          "value": "CVE-2024-37021",
          "url": "https://scout.docker.com/v/CVE-2024-37021?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-37021?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db5a97b48f4944d68694845339aaead56577577939128f0aafa2509792e83d52",
      "category": "container_scanning",
      "message": "CVE-2024-38543 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  lib/test_hmm.c: handle src_pfns and dst_pfns allocation failure  The kcalloc() in dmirror_device_evict_chunk() will return null if the physical memory has run out.  As a result, if src_pfns or dst_pfns is dereferenced, the null pointer dereference bug will happen.  Moreover, the device is going away.  If the kcalloc() fails, the pages mapping a chunk could not be evicted.  So add a __GFP_NOFAIL flag in kcalloc().  Finally, as there is no need to have physically contiguous memory, Switch kcalloc() to kvcalloc() in order to avoid failing allocations.",
      "cve": "CVE-2024-38543",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38543",
          "value": "CVE-2024-38543",
          "url": "https://scout.docker.com/v/CVE-2024-38543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38543?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "662b4d5eae87c3862fb727d32c6a55504b47b401e8041237c20cd680173f7938",
      "category": "container_scanning",
      "message": "CVE-2024-38554 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: Fix reference count leak issue of net_device  There is a reference count leak issue of the object \"net_device\" in ax25_dev_device_down(). When the ax25 device is shutting down, the ax25_dev_device_down() drops the reference count of net_device one or zero times depending on if we goto unlock_put or not, which will cause memory leak.  In order to solve the above issue, decrease the reference count of net_device after dev->ax25_ptr is set to null.",
      "cve": "CVE-2024-38554",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38554",
          "value": "CVE-2024-38554",
          "url": "https://scout.docker.com/v/CVE-2024-38554?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38554?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c1cc39caf4306cadf6611beff1de77651856d31c0819f35fcedbfb960a482144",
      "category": "container_scanning",
      "message": "CVE-2024-38557 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Reload only IB representors upon lag disable/enable  On lag disable, the bond IB device along with all of its representors are destroyed, and then the slaves' representors get reloaded.  In case the slave IB representor load fails, the eswitch error flow unloads all representors, including ethernet representors, where the netdevs get detached and removed from lag bond. Such flow is inaccurate as the lag driver is not responsible for loading/unloading ethernet representors. Furthermore, the flow described above begins by holding lag lock to prevent bond changes during disable flow. However, when reaching the ethernet representors detachment from lag, the lag lock is required again, triggering the following deadlock:  Call trace: __switch_to+0xf4/0x148 __schedule+0x2c8/0x7d0 schedule+0x50/0xe0 schedule_preempt_disabled+0x18/0x28 __mutex_lock.isra.13+0x2b8/0x570 __mutex_lock_slowpath+0x1c/0x28 mutex_lock+0x4c/0x68 mlx5_lag_remove_netdev+0x3c/0x1a0 [mlx5_core] mlx5e_uplink_rep_disable+0x70/0xa0 [mlx5_core] mlx5e_detach_netdev+0x6c/0xb0 [mlx5_core] mlx5e_netdev_change_profile+0x44/0x138 [mlx5_core] mlx5e_netdev_attach_nic_profile+0x28/0x38 [mlx5_core] mlx5e_vport_rep_unload+0x184/0x1b8 [mlx5_core] mlx5_esw_offloads_rep_load+0xd8/0xe0 [mlx5_core] mlx5_eswitch_reload_reps+0x74/0xd0 [mlx5_core] mlx5_disable_lag+0x130/0x138 [mlx5_core] mlx5_lag_disable_change+0x6c/0x70 [mlx5_core] // hold ldev->lock mlx5_devlink_eswitch_mode_set+0xc0/0x410 [mlx5_core] devlink_nl_cmd_eswitch_set_doit+0xdc/0x180 genl_family_rcv_msg_doit.isra.17+0xe8/0x138 genl_rcv_msg+0xe4/0x220 netlink_rcv_skb+0x44/0x108 genl_rcv+0x40/0x58 netlink_unicast+0x198/0x268 netlink_sendmsg+0x1d4/0x418 sock_sendmsg+0x54/0x60 __sys_sendto+0xf4/0x120 __arm64_sys_sendto+0x30/0x40 el0_svc_common+0x8c/0x120 do_el0_svc+0x30/0xa0 el0_svc+0x20/0x30 el0_sync_handler+0x90/0xb8 el0_sync+0x160/0x180  Thus, upon lag enable/disable, load and unload only the IB representors of the slaves preventing the deadlock mentioned above.  While at it, refactor the mlx5_esw_offloads_rep_load() function to have a static helper method for its internal logic, in symmetry with the representor unload design.",
      "cve": "CVE-2024-38557",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38557",
          "value": "CVE-2024-38557",
          "url": "https://scout.docker.com/v/CVE-2024-38557?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38557?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5c5eacaffb1fe144e83c8145e7c4c4dcf56dd190c5294804ab9301fbf5a3eb54",
      "category": "container_scanning",
      "message": "CVE-2024-38564 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Add BPF_PROG_TYPE_CGROUP_SKB attach type enforcement in BPF_LINK_CREATE  bpf_prog_attach uses attach_type_to_prog_type to enforce proper attach type for BPF_PROG_TYPE_CGROUP_SKB. link_create uses bpf_prog_get and relies on bpf_prog_attach_check_attach_type to properly verify prog_type <> attach_type association.  Add missing attach_type enforcement for the link_create case. Otherwise, it's currently possible to attach cgroup_skb prog types to other cgroup hooks.",
      "cve": "CVE-2024-38564",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38564",
          "value": "CVE-2024-38564",
          "url": "https://scout.docker.com/v/CVE-2024-38564?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38564?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "714164b445b63b58ba2a2b7be32d7d8e1351d68a32cd7bf6907f4b5abe741fc5",
      "category": "container_scanning",
      "message": "CVE-2024-38608 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Fix netif state handling  mlx5e_suspend cleans resources only if netif_device_present() returns true. However, mlx5e_resume changes the state of netif, via mlx5e_nic_enable, only if reg_state == NETREG_REGISTERED. In the below case, the above leads to NULL-ptr Oops[1] and memory leaks:  mlx5e_probe _mlx5e_resume mlx5e_attach_netdev mlx5e_nic_enable  <-- netdev not reg, not calling netif_device_attach() register_netdev <-- failed for some reason. ERROR_FLOW: _mlx5e_suspend <-- netif_device_present return false, resources aren't freed :(  Hence, clean resources in this case as well.  [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0010 [#1] SMP CPU: 2 PID: 9345 Comm: test-ovs-ct-gen Not tainted 6.5.0_for_upstream_min_debug_2023_09_05_16_01 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:0x0 Code: Unable to access opcode bytes at0xffffffffffffffd6. RSP: 0018:ffff888178aaf758 EFLAGS: 00010246 Call Trace: <TASK> ? __die+0x20/0x60 ? page_fault_oops+0x14c/0x3c0 ? exc_page_fault+0x75/0x140 ? asm_exc_page_fault+0x22/0x30 notifier_call_chain+0x35/0xb0 blocking_notifier_call_chain+0x3d/0x60 mlx5_blocking_notifier_call_chain+0x22/0x30 [mlx5_core] mlx5_core_uplink_netdev_event_replay+0x3e/0x60 [mlx5_core] mlx5_mdev_netdev_track+0x53/0x60 [mlx5_ib] mlx5_ib_roce_init+0xc3/0x340 [mlx5_ib] __mlx5_ib_add+0x34/0xd0 [mlx5_ib] mlx5r_probe+0xe1/0x210 [mlx5_ib] ? auxiliary_match_id+0x6a/0x90 auxiliary_bus_probe+0x38/0x80 ? driver_sysfs_add+0x51/0x80 really_probe+0xc9/0x3e0 ? driver_probe_device+0x90/0x90 __driver_probe_device+0x80/0x160 driver_probe_device+0x1e/0x90 __device_attach_driver+0x7d/0x100 bus_for_each_drv+0x80/0xd0 __device_attach+0xbc/0x1f0 bus_probe_device+0x86/0xa0 device_add+0x637/0x840 __auxiliary_device_add+0x3b/0xa0 add_adev+0xc9/0x140 [mlx5_core] mlx5_rescan_drivers_locked+0x22a/0x310 [mlx5_core] mlx5_register_device+0x53/0xa0 [mlx5_core] mlx5_init_one_devl_locked+0x5c4/0x9c0 [mlx5_core] mlx5_init_one+0x3b/0x60 [mlx5_core] probe_one+0x44c/0x730 [mlx5_core] local_pci_probe+0x3e/0x90 pci_device_probe+0xbf/0x210 ? kernfs_create_link+0x5d/0xa0 ? sysfs_do_create_link_sd+0x60/0xc0 really_probe+0xc9/0x3e0 ? driver_probe_device+0x90/0x90 __driver_probe_device+0x80/0x160 driver_probe_device+0x1e/0x90 __device_attach_driver+0x7d/0x100 bus_for_each_drv+0x80/0xd0 __device_attach+0xbc/0x1f0 pci_bus_add_device+0x54/0x80 pci_iov_add_virtfn+0x2e6/0x320 sriov_enable+0x208/0x420 mlx5_core_sriov_configure+0x9e/0x200 [mlx5_core] sriov_numvfs_store+0xae/0x1a0 kernfs_fop_write_iter+0x10c/0x1a0 vfs_write+0x291/0x3c0 ksys_write+0x5f/0xe0 do_syscall_64+0x3d/0x90 entry_SYSCALL_64_after_hwframe+0x46/0xb0 CR2: 0000000000000000 ---[ end trace 0000000000000000  ]---",
      "cve": "CVE-2024-38608",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38608",
          "value": "CVE-2024-38608",
          "url": "https://scout.docker.com/v/CVE-2024-38608?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38608?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3131148daf1dc5fb9834a817096bca69b6f0939ff88c28ec2b5ad1adc6ac5596",
      "category": "container_scanning",
      "message": "CVE-2024-38625 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/ntfs3: Check 'folio' pointer for NULL  It can be NULL if bmap is called.",
      "cve": "CVE-2024-38625",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38625",
          "value": "CVE-2024-38625",
          "url": "https://scout.docker.com/v/CVE-2024-38625?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38625?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6551f040f71b4950c2fedc010799f4b4d6e484576f927fcb9ca90ac70e50645a",
      "category": "container_scanning",
      "message": "CVE-2024-39282 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: wwan: t7xx: Fix FSM command timeout issue  When driver processes the internal state change command, it use an asynchronous thread to process the command operation. If the main thread detects that the task has timed out, the asynchronous thread will panic when executing the completion notification because the main thread completion object has been released.  BUG: unable to handle page fault for address: fffffffffffffff8 PGD 1f283a067 P4D 1f283a067 PUD 1f283c067 PMD 0 Oops: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:complete_all+0x3e/0xa0 [...] Call Trace: <TASK> ? __die_body+0x68/0xb0 ? page_fault_oops+0x379/0x3e0 ? exc_page_fault+0x69/0xa0 ? asm_exc_page_fault+0x22/0x30 ? complete_all+0x3e/0xa0 fsm_main_thread+0xa3/0x9c0 [mtk_t7xx (HASH:1400 5)] ? __pfx_autoremove_wake_function+0x10/0x10 kthread+0xd8/0x110 ? __pfx_fsm_main_thread+0x10/0x10 [mtk_t7xx (HASH:1400 5)] ? __pfx_kthread+0x10/0x10 ret_from_fork+0x38/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK> [...] CR2: fffffffffffffff8 ---[ end trace 0000000000000000 ]---  Use the reference counter to ensure safe release as Sergey suggests: https://lore.kernel.org/all/da90f64c-260a-4329-87bf-1f9ff20a5951@gmail.com/",
      "cve": "CVE-2024-39282",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-39282",
          "value": "CVE-2024-39282",
          "url": "https://scout.docker.com/v/CVE-2024-39282?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-39282?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "505b8a781dda34f693330ee52074a80c3c822f92a760c1671e191435265bab46",
      "category": "container_scanning",
      "message": "CVE-2024-39298 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/memory-failure: fix handling of dissolved but not taken off from buddy pages  When I did memory failure tests recently, below panic occurs:  page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x8cee00 flags: 0x6fffe0000000000(node=1|zone=2|lastcpupid=0x7fff) raw: 06fffe0000000000 dead000000000100 dead000000000122 0000000000000000 raw: 0000000000000000 0000000000000009 00000000ffffffff 0000000000000000 page dumped because: VM_BUG_ON_PAGE(!PageBuddy(page)) ------------[ cut here ]------------ kernel BUG at include/linux/page-flags.h:1009! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI RIP: 0010:__del_page_from_free_list+0x151/0x180 RSP: 0018:ffffa49c90437998 EFLAGS: 00000046 RAX: 0000000000000035 RBX: 0000000000000009 RCX: ffff8dd8dfd1c9c8 RDX: 0000000000000000 RSI: 0000000000000027 RDI: ffff8dd8dfd1c9c0 RBP: ffffd901233b8000 R08: ffffffffab5511f8 R09: 0000000000008c69 R10: 0000000000003c15 R11: ffffffffab5511f8 R12: ffff8dd8fffc0c80 R13: 0000000000000001 R14: ffff8dd8fffc0c80 R15: 0000000000000009 FS:  00007ff916304740(0000) GS:ffff8dd8dfd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000055eae50124c8 CR3: 00000008479e0000 CR4: 00000000000006f0 Call Trace: <TASK> __rmqueue_pcplist+0x23b/0x520 get_page_from_freelist+0x26b/0xe40 __alloc_pages_noprof+0x113/0x1120 __folio_alloc_noprof+0x11/0xb0 alloc_buddy_hugetlb_folio.isra.0+0x5a/0x130 __alloc_fresh_hugetlb_folio+0xe7/0x140 alloc_pool_huge_folio+0x68/0x100 set_max_huge_pages+0x13d/0x340 hugetlb_sysctl_handler_common+0xe8/0x110 proc_sys_call_handler+0x194/0x280 vfs_write+0x387/0x550 ksys_write+0x64/0xe0 do_syscall_64+0xc2/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7ff916114887 RSP: 002b:00007ffec8a2fd78 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 000055eae500e350 RCX: 00007ff916114887 RDX: 0000000000000004 RSI: 000055eae500e390 RDI: 0000000000000003 RBP: 000055eae50104c0 R08: 0000000000000000 R09: 000055eae50104c0 R10: 0000000000000077 R11: 0000000000000246 R12: 0000000000000004 R13: 0000000000000004 R14: 00007ff916216b80 R15: 00007ff916216a00 </TASK> Modules linked in: mce_inject hwpoison_inject ---[ end trace 0000000000000000 ]---  And before the panic, there had an warning about bad page state:  BUG: Bad page state in process page-types  pfn:8cee00 page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x8cee00 flags: 0x6fffe0000000000(node=1|zone=2|lastcpupid=0x7fff) page_type: 0xffffff7f(buddy) raw: 06fffe0000000000 ffffd901241c0008 ffffd901240f8008 0000000000000000 raw: 0000000000000000 0000000000000009 00000000ffffff7f 0000000000000000 page dumped because: nonzero mapcount Modules linked in: mce_inject hwpoison_inject CPU: 8 PID: 154211 Comm: page-types Not tainted 6.9.0-rc4-00499-g5544ec3178e2-dirty #22 Call Trace: <TASK> dump_stack_lvl+0x83/0xa0 bad_page+0x63/0xf0 free_unref_page+0x36e/0x5c0 unpoison_memory+0x50b/0x630 simple_attr_write_xsigned.constprop.0.isra.0+0xb3/0x110 debugfs_attr_write+0x42/0x60 full_proxy_write+0x5b/0x80 vfs_write+0xcd/0x550 ksys_write+0x64/0xe0 do_syscall_64+0xc2/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f189a514887 RSP: 002b:00007ffdcd899718 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f189a514887 RDX: 0000000000000009 RSI: 00007ffdcd899730 RDI: 0000000000000003 RBP: 00007ffdcd8997a0 R08: 0000000000000000 R09: 00007ffdcd8994b2 R10: 0000000000000000 R11: 0000000000000246 R12: 00007ffdcda199a8 R13: 0000000000404af1 R14: 000000000040ad78 R15: 00007f189a7a5040 </TASK>  The root cause should be the below race:  memory_failure try_memory_failure_hugetlb me_huge_page __page_handle_poison dissolve_free_hugetlb_folio drain_all_pages -- Buddy page can be isolated e.g. for compaction. take_page_off_buddy -- Failed as page is not in the ---truncated---",
      "cve": "CVE-2024-39298",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-39298",
          "value": "CVE-2024-39298",
          "url": "https://scout.docker.com/v/CVE-2024-39298?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-39298?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7402c5ace6d9415618d891a4afa1742499de12ec185de3187d50dc10cb133836",
      "category": "container_scanning",
      "message": "CVE-2024-40966 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  tty: add the option to have a tty reject a new ldisc  ... and use it to limit the virtual terminals to just N_TTY.  They are kind of special, and in particular, the \"con_write()\" routine violates the \"writes cannot sleep\" rule that some ldiscs rely on.  This avoids the  BUG: sleeping function called from invalid context at kernel/printk/printk.c:2659  when N_GSM has been attached to a virtual console, and gsmld_write() calls con_write() while holding a spinlock, and con_write() then tries to get the console lock.",
      "cve": "CVE-2024-40966",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40966",
          "value": "CVE-2024-40966",
          "url": "https://scout.docker.com/v/CVE-2024-40966?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40966?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "352658499108bf20b7a2eeac8c6230e8b1bebd9111023a71a911971aba82f852",
      "category": "container_scanning",
      "message": "CVE-2024-40972 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: do not create EA inode under buffer lock  ext4_xattr_set_entry() creates new EA inodes while holding buffer lock on the external xattr block. This is problematic as it nests all the allocation locking (which acquires locks on other buffers) under the buffer lock. This can even deadlock when the filesystem is corrupted and e.g. quota file is setup to contain xattr block as data block. Move the allocation of EA inode out of ext4_xattr_set_entry() into the callers.",
      "cve": "CVE-2024-40972",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40972",
          "value": "CVE-2024-40972",
          "url": "https://scout.docker.com/v/CVE-2024-40972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f832d9550e6a8a8feed8384391ccf4f6bf767822267107aca29641bf9e5fcc72",
      "category": "container_scanning",
      "message": "CVE-2024-40975 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  platform/x86: x86-android-tablets: Unregister devices in reverse order  Not all subsystems support a device getting removed while there are still consumers of the device with a reference to the device.  One example of this is the regulator subsystem. If a regulator gets unregistered while there are still drivers holding a reference a WARN() at drivers/regulator/core.c:5829 triggers, e.g.:  WARNING: CPU: 1 PID: 1587 at drivers/regulator/core.c:5829 regulator_unregister Hardware name: Intel Corp. VALLEYVIEW C0 PLATFORM/BYT-T FFD8, BIOS BLADE_21.X64.0005.R00.1504101516 FFD8_X64_R_2015_04_10_1516 04/10/2015 RIP: 0010:regulator_unregister Call Trace: <TASK> regulator_unregister devres_release_group i2c_device_remove device_release_driver_internal bus_remove_device device_del device_unregister x86_android_tablet_remove  On the Lenovo Yoga Tablet 2 series the bq24190 charger chip also provides a 5V boost converter output for powering USB devices connected to the micro USB port, the bq24190-charger driver exports this as a Vbus regulator.  On the 830 (8\") and 1050 (\"10\") models this regulator is controlled by a platform_device and x86_android_tablet_remove() removes platform_device-s before i2c_clients so the consumer gets removed first.  But on the 1380 (13\") model there is a lc824206xa micro-USB switch connected over I2C and the extcon driver for that controls the regulator. The bq24190 i2c-client *must* be registered first, because that creates the regulator with the lc824206xa listed as its consumer. If the regulator has not been registered yet the lc824206xa driver will end up getting a dummy regulator.  Since in this case both the regulator provider and consumer are I2C devices, the only way to ensure that the consumer is unregistered first is to unregister the I2C devices in reverse order of in which they were created.  For consistency and to avoid similar problems in the future change x86_android_tablet_remove() to unregister all device types in reverse order.",
      "cve": "CVE-2024-40975",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40975",
          "value": "CVE-2024-40975",
          "url": "https://scout.docker.com/v/CVE-2024-40975?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40975?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "64205a5a6503026b66ace556e89ee480dcef03b23e0c95a44cd1f66f01ea91a2",
      "category": "container_scanning",
      "message": "CVE-2024-40977 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7921s: fix potential hung tasks during chip recovery  During chip recovery (e.g. chip reset), there is a possible situation that kernel worker reset_work is holding the lock and waiting for kernel thread stat_worker to be parked, while stat_worker is waiting for the release of the same lock. It causes a deadlock resulting in the dumping of hung tasks messages and possible rebooting of the device.  This patch prevents the execution of stat_worker during the chip recovery.",
      "cve": "CVE-2024-40977",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40977",
          "value": "CVE-2024-40977",
          "url": "https://scout.docker.com/v/CVE-2024-40977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40977?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cd9758314bbdc7a5114b01e1a0a519fefceafda4d51a7373ba4c1e950ee595fd",
      "category": "container_scanning",
      "message": "CVE-2024-40979 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix kernel crash during resume  Currently during resume, QMI target memory is not properly handled, resulting in kernel crash in case DMA remap is not supported:  BUG: Bad page state in process kworker/u16:54  pfn:36e80 page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x36e80 page dumped because: nonzero _refcount Call Trace: bad_page free_page_is_bad_report __free_pages_ok __free_pages dma_direct_free dma_free_attrs ath12k_qmi_free_target_mem_chunk ath12k_qmi_msg_mem_request_cb  The reason is: Once ath12k module is loaded, firmware sends memory request to host. In case DMA remap not supported, ath12k refuses the first request due to failure in allocating with large segment size:  ath12k_pci 0000:04:00.0: qmi firmware request memory request ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 7077888 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 8454144 ath12k_pci 0000:04:00.0: qmi dma allocation failed (7077888 B type 1), will try later with small size ath12k_pci 0000:04:00.0: qmi delays mem_request 2 ath12k_pci 0000:04:00.0: qmi firmware request memory request  Later firmware comes back with more but small segments and allocation succeeds:  ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 262144 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 524288 ath12k_pci 0000:04:00.0: qmi mem seg type 4 size 65536 ath12k_pci 0000:04:00.0: qmi mem seg type 1 size 524288  Now ath12k is working. If suspend is triggered, firmware will be reloaded during resume. As same as before, firmware requests two large segments at first. In ath12k_qmi_msg_mem_request_cb() segment count and size are assigned:  ab->qmi.mem_seg_count == 2 ab->qmi.target_mem[0].size == 7077888 ab->qmi.target_mem[1].size == 8454144  Then allocation failed like before and ath12k_qmi_free_target_mem_chunk() is called to free all allocated segments. Note the first segment is skipped because its v.addr is cleared due to allocation failure:  chunk->v.addr = dma_alloc_coherent()  Also note that this leaks that segment because it has not been freed.  While freeing the second segment, a size of 8454144 is passed to dma_free_coherent(). However remember that this segment is allocated at the first time firmware is loaded, before suspend. So its real size is 524288, much smaller than 8454144. As a result kernel found we are freeing some memory which is in use and thus cras ---truncated---",
      "cve": "CVE-2024-40979",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40979",
          "value": "CVE-2024-40979",
          "url": "https://scout.docker.com/v/CVE-2024-40979?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40979?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b9793ff6d8372fd7c6102078425012acfeefb674b04cef696240b1b03e4eb74e",
      "category": "container_scanning",
      "message": "CVE-2024-40998 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: fix uninitialized ratelimit_state->lock access in __ext4_fill_super()  In the following concurrency we will access the uninitialized rs->lock:  ext4_fill_super ext4_register_sysfs // sysfs registered msg_ratelimit_interval_ms // Other processes modify rs->interval to // non-zero via msg_ratelimit_interval_ms ext4_orphan_cleanup ext4_msg(sb, KERN_INFO, \"Errors on filesystem, \" __ext4_msg ___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state) if (!rs->interval)  // do nothing if interval is 0 return 1; raw_spin_trylock_irqsave(&rs->lock, flags) raw_spin_trylock(lock) _raw_spin_trylock __raw_spin_trylock spin_acquire(&lock->dep_map, 0, 1, _RET_IP_) lock_acquire __lock_acquire register_lock_class assign_lock_key dump_stack(); ratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10); raw_spin_lock_init(&rs->lock); // init rs->lock here  and get the following dump_stack:  ========================================================= INFO: trying to register non-static key. The code is fine but needs lockdep annotation, or maybe you didn't initialize this object before use? turning off the locking correctness validator. CPU: 12 PID: 753 Comm: mount Tainted: G E 6.7.0-rc6-next-20231222 #504 [...] Call Trace: dump_stack_lvl+0xc5/0x170 dump_stack+0x18/0x30 register_lock_class+0x740/0x7c0 __lock_acquire+0x69/0x13a0 lock_acquire+0x120/0x450 _raw_spin_trylock+0x98/0xd0 ___ratelimit+0xf6/0x220 __ext4_msg+0x7f/0x160 [ext4] ext4_orphan_cleanup+0x665/0x740 [ext4] __ext4_fill_super+0x21ea/0x2b10 [ext4] ext4_fill_super+0x14d/0x360 [ext4] [...] =========================================================  Normally interval is 0 until s_msg_ratelimit_state is initialized, so ___ratelimit() does nothing. But registering sysfs precedes initializing rs->lock, so it is possible to change rs->interval to a non-zero value via the msg_ratelimit_interval_ms interface of sysfs while rs->lock is uninitialized, and then a call to ext4_msg triggers the problem by accessing an uninitialized rs->lock. Therefore register sysfs after all initializations are complete to avoid such problems.",
      "cve": "CVE-2024-40998",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40998",
          "value": "CVE-2024-40998",
          "url": "https://scout.docker.com/v/CVE-2024-40998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9b1496117f708376aff0f3a6b328d062bc0a287f88c2a5099a2c10c68d452d1",
      "category": "container_scanning",
      "message": "CVE-2024-40999 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ena: Add validation for completion descriptors consistency  Validate that `first` flag is set only for the first descriptor in multi-buffer packets. In case of an invalid descriptor, a reset will occur. A new reset reason for RX data corruption has been added.",
      "cve": "CVE-2024-40999",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40999",
          "value": "CVE-2024-40999",
          "url": "https://scout.docker.com/v/CVE-2024-40999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "467b50aa02ff0386ee126d08bf6f7d003b1c56bf5dc2b8030ce0c2ab9581f2a0",
      "category": "container_scanning",
      "message": "CVE-2024-41001 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring/sqpoll: work around a potential audit memory leak  kmemleak complains that there's a memory leak related to connect handling:  unreferenced object 0xffff0001093bdf00 (size 128): comm \"iou-sqp-455\", pid 457, jiffies 4294894164 hex dump (first 32 bytes): 02 00 fa ea 7f 00 00 01 00 00 00 00 00 00 00 00  ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ backtrace (crc 2e481b1a): [<00000000c0a26af4>] kmemleak_alloc+0x30/0x38 [<000000009c30bb45>] kmalloc_trace+0x228/0x358 [<000000009da9d39f>] __audit_sockaddr+0xd0/0x138 [<0000000089a93e34>] move_addr_to_kernel+0x1a0/0x1f8 [<000000000b4e80e6>] io_connect_prep+0x1ec/0x2d4 [<00000000abfbcd99>] io_submit_sqes+0x588/0x1e48 [<00000000e7c25e07>] io_sq_thread+0x8a4/0x10e4 [<00000000d999b491>] ret_from_fork+0x10/0x20  which can can happen if:  1) The command type does something on the prep side that triggers an audit call. 2) The thread hasn't done any operations before this that triggered an audit call inside ->issue(), where we have audit_uring_entry() and audit_uring_exit().  Work around this by issuing a blanket NOP operation before the SQPOLL does anything.",
      "cve": "CVE-2024-41001",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41001",
          "value": "CVE-2024-41001",
          "url": "https://scout.docker.com/v/CVE-2024-41001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41001?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5689cb69bf1d95e79bb475eb410dff642c369f14b79e6ba28e1ce3a11094b5f0",
      "category": "container_scanning",
      "message": "CVE-2024-41008 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: change vm->task_info handling  This patch changes the handling and lifecycle of vm->task_info object. The major changes are: - vm->task_info is a dynamically allocated ptr now, and its uasge is reference counted. - introducing two new helper funcs for task_info lifecycle management - amdgpu_vm_get_task_info: reference counts up task_info before returning this info - amdgpu_vm_put_task_info: reference counts down task_info - last put to task_info() frees task_info from the vm.  This patch also does logistical changes required for existing usage of vm->task_info.  V2: Do not block all the prints when task_info not found (Felix)  V3: Fixed review comments from Felix - Fix wrong indentation - No debug message for -ENOMEM - Add NULL check for task_info - Do not duplicate the debug messages (ti vs no ti) - Get first reference of task_info in vm_init(), put last in vm_fini()  V4: Fixed review comments from Felix - fix double reference increment in create_task_info - change amdgpu_vm_get_task_info_pasid - additional changes in amdgpu_gem.c while porting",
      "cve": "CVE-2024-41008",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41008",
          "value": "CVE-2024-41008",
          "url": "https://scout.docker.com/v/CVE-2024-41008?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41008?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a8f61f4c3106473e783e7daa8c3d6a350f043005140f206cd556539e122202b9",
      "category": "container_scanning",
      "message": "CVE-2024-41023 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  sched/deadline: Fix task_struct reference leak  During the execution of the following stress test with linux-rt:  stress-ng --cyclic 30 --timeout 30 --minimize --quiet  kmemleak frequently reported a memory leak concerning the task_struct:  unreferenced object 0xffff8881305b8000 (size 16136): comm \"stress-ng\", pid 614, jiffies 4294883961 (age 286.412s) object hex dump (first 32 bytes): 02 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .@.............. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ debug hex dump (first 16 bytes): 53 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00  S............... backtrace: [<00000000046b6790>] dup_task_struct+0x30/0x540 [<00000000c5ca0f0b>] copy_process+0x3d9/0x50e0 [<00000000ced59777>] kernel_clone+0xb0/0x770 [<00000000a50befdc>] __do_sys_clone+0xb6/0xf0 [<000000001dbf2008>] do_syscall_64+0x5d/0xf0 [<00000000552900ff>] entry_SYSCALL_64_after_hwframe+0x6e/0x76  The issue occurs in start_dl_timer(), which increments the task_struct reference count and sets a timer. The timer callback, dl_task_timer, is supposed to decrement the reference count upon expiration. However, if enqueue_task_dl() is called before the timer expires and cancels it, the reference count is not decremented, leading to the leak.  This patch fixes the reference leak by ensuring the task_struct reference count is properly decremented when the timer is canceled.",
      "cve": "CVE-2024-41023",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41023",
          "value": "CVE-2024-41023",
          "url": "https://scout.docker.com/v/CVE-2024-41023?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41023?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d90c4420264c396758a21206a410be565d017e9c1917be363cd47de1c8612125",
      "category": "container_scanning",
      "message": "CVE-2024-41030 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: discard write access to the directory open  may_open() does not allow a directory to be opened with the write access. However, some writing flags set by client result in adding write access on server, making ksmbd incompatible with FUSE file system. Simply, let's discard the write access when opening a directory.  list_add corruption. next is NULL. ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:26! pc : __list_add_valid+0x88/0xbc lr : __list_add_valid+0x88/0xbc Call trace: __list_add_valid+0x88/0xbc fuse_finish_open+0x11c/0x170 fuse_open_common+0x284/0x5e8 fuse_dir_open+0x14/0x24 do_dentry_open+0x2a4/0x4e0 dentry_open+0x50/0x80 smb2_open+0xbe4/0x15a4 handle_ksmbd_work+0x478/0x5ec process_one_work+0x1b4/0x448 worker_thread+0x25c/0x430 kthread+0x104/0x1d4 ret_from_fork+0x10/0x20",
      "cve": "CVE-2024-41030",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41030",
          "value": "CVE-2024-41030",
          "url": "https://scout.docker.com/v/CVE-2024-41030?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41030?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ca464a23872e1d1405266ff85157c9466a0762e044c63aa4dc21f4a252a6f894",
      "category": "container_scanning",
      "message": "CVE-2024-41031 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/filemap: skip to create PMD-sized page cache if needed  On ARM64, HPAGE_PMD_ORDER is 13 when the base page size is 64KB.  The PMD-sized page cache can't be supported by xarray as the following error messages indicate.  ------------[ cut here ]------------ WARNING: CPU: 35 PID: 7484 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128 Modules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib  \\ nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct    \\ nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4    \\ ip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm      \\ fuse xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64      \\ sha1_ce virtio_net net_failover virtio_console virtio_blk failover \\ dimlib virtio_mmio CPU: 35 PID: 7484 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #9 Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024 pstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--) pc : xas_split_alloc+0xf8/0x128 lr : split_huge_page_to_list_to_order+0x1c4/0x720 sp : ffff800087a4f6c0 x29: ffff800087a4f6c0 x28: ffff800087a4f720 x27: 000000001fffffff x26: 0000000000000c40 x25: 000000000000000d x24: ffff00010625b858 x23: ffff800087a4f720 x22: ffffffdfc0780000 x21: 0000000000000000 x20: 0000000000000000 x19: ffffffdfc0780000 x18: 000000001ff40000 x17: 00000000ffffffff x16: 0000018000000000 x15: 51ec004000000000 x14: 0000e00000000000 x13: 0000000000002000 x12: 0000000000000020 x11: 51ec000000000000 x10: 51ece1c0ffff8000 x9 : ffffbeb961a44d28 x8 : 0000000000000003 x7 : ffffffdfc0456420 x6 : ffff0000e1aa6eb8 x5 : 20bf08b4fe778fca x4 : ffffffdfc0456420 x3 : 0000000000000c40 x2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000 Call trace: xas_split_alloc+0xf8/0x128 split_huge_page_to_list_to_order+0x1c4/0x720 truncate_inode_partial_folio+0xdc/0x160 truncate_inode_pages_range+0x1b4/0x4a8 truncate_pagecache_range+0x84/0xa0 xfs_flush_unmap_range+0x70/0x90 [xfs] xfs_file_fallocate+0xfc/0x4d8 [xfs] vfs_fallocate+0x124/0x2e8 ksys_fallocate+0x4c/0xa0 __arm64_sys_fallocate+0x24/0x38 invoke_syscall.constprop.0+0x7c/0xd8 do_el0_svc+0xb4/0xd0 el0_svc+0x44/0x1d8 el0t_64_sync_handler+0x134/0x150 el0t_64_sync+0x17c/0x180  Fix it by skipping to allocate PMD-sized page cache when its size is larger than MAX_PAGECACHE_ORDER.  For this specific case, we will fall to regular path where the readahead window is determined by BDI's sysfs file (read_ahead_kb).",
      "cve": "CVE-2024-41031",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41031",
          "value": "CVE-2024-41031",
          "url": "https://scout.docker.com/v/CVE-2024-41031?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41031?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "58e5d19f4f0beca9934ee6d0e31fba61d6b00ce71fc04d034d858ae8397e8b67",
      "category": "container_scanning",
      "message": "CVE-2024-41036 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ks8851: Fix deadlock with the SPI chip variant  When SMP is enabled and spinlocks are actually functional then there is a deadlock with the 'statelock' spinlock between ks8851_start_xmit_spi and ks8851_irq:  watchdog: BUG: soft lockup - CPU#0 stuck for 27s! call trace: queued_spin_lock_slowpath+0x100/0x284 do_raw_spin_lock+0x34/0x44 ks8851_start_xmit_spi+0x30/0xb8 ks8851_start_xmit+0x14/0x20 netdev_start_xmit+0x40/0x6c dev_hard_start_xmit+0x6c/0xbc sch_direct_xmit+0xa4/0x22c __qdisc_run+0x138/0x3fc qdisc_run+0x24/0x3c net_tx_action+0xf8/0x130 handle_softirqs+0x1ac/0x1f0 __do_softirq+0x14/0x20 ____do_softirq+0x10/0x1c call_on_irq_stack+0x3c/0x58 do_softirq_own_stack+0x1c/0x28 __irq_exit_rcu+0x54/0x9c irq_exit_rcu+0x10/0x1c el1_interrupt+0x38/0x50 el1h_64_irq_handler+0x18/0x24 el1h_64_irq+0x64/0x68 __netif_schedule+0x6c/0x80 netif_tx_wake_queue+0x38/0x48 ks8851_irq+0xb8/0x2c8 irq_thread_fn+0x2c/0x74 irq_thread+0x10c/0x1b0 kthread+0xc8/0xd8 ret_from_fork+0x10/0x20  This issue has not been identified earlier because tests were done on a device with SMP disabled and so spinlocks were actually NOPs.  Now use spin_(un)lock_bh for TX queue related locking to avoid execution of softirq work synchronously that would lead to a deadlock.",
      "cve": "CVE-2024-41036",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41036",
          "value": "CVE-2024-41036",
          "url": "https://scout.docker.com/v/CVE-2024-41036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41036?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e01d38611f656fd51fd98f2cee15d3d858e00eec58fe8281c970540b85a779f7",
      "category": "container_scanning",
      "message": "CVE-2024-41062 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bluetooth/l2cap: sync sock recv cb and release  The problem occurs between the system call to close the sock and hci_rx_work, where the former releases the sock and the latter accesses it without lock protection.  CPU0                       CPU1 ----                       ---- sock_close                 hci_rx_work l2cap_sock_release         hci_acldata_packet l2cap_sock_kill            l2cap_recv_frame sk_free                    l2cap_conless_channel l2cap_sock_recv_cb  If hci_rx_work processes the data that needs to be received before the sock is closed, then everything is normal; Otherwise, the work thread may access the released sock when receiving data.  Add a chan mutex in the rx callback of the sock to achieve synchronization between the sock release and recv cb.  Sock is dead, so set chan data to NULL, avoid others use invalid sock pointer.",
      "cve": "CVE-2024-41062",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41062",
          "value": "CVE-2024-41062",
          "url": "https://scout.docker.com/v/CVE-2024-41062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41062?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "35fe45dab684b6ac364f197bfdc7df86b1d0bd15fef8844be237bf85248c5a7f",
      "category": "container_scanning",
      "message": "CVE-2024-41067 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: scrub: handle RST lookup error correctly  [BUG] When running btrfs/060 with forced RST feature, it would crash the following ASSERT() inside scrub_read_endio():  ASSERT(sector_nr < stripe->nr_sectors);  Before that, we would have tree dump from btrfs_get_raid_extent_offset(), as we failed to find the RST entry for the range.  [CAUSE] Inside scrub_submit_extent_sector_read() every time we allocated a new bbio we immediately called btrfs_map_block() to make sure there was some RST range covering the scrub target.  But if btrfs_map_block() fails, we immediately call endio for the bbio, while the bbio is newly allocated, it's completely empty.  Then inside scrub_read_endio(), we go through the bvecs to find the sector number (as bi_sector is no longer reliable if the bio is submitted to lower layers).  And since the bio is empty, such bvecs iteration would not find any sector matching the sector, and return sector_nr == stripe->nr_sectors, triggering the ASSERT().  [FIX] Instead of calling btrfs_map_block() after allocating a new bbio, call btrfs_map_block() first.  Since our only objective of calling btrfs_map_block() is only to update stripe_len, there is really no need to do that after btrfs_alloc_bio().  This new timing would avoid the problem of handling empty bbio completely, and in fact fixes a possible race window for the old code, where if the submission thread is the only owner of the pending_io, the scrub would never finish (since we didn't decrease the pending_io counter).  Although the root cause of RST lookup failure still needs to be addressed.",
      "cve": "CVE-2024-41067",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41067",
          "value": "CVE-2024-41067",
          "url": "https://scout.docker.com/v/CVE-2024-41067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e4bcb60facb36c44105ef9bc69c1803bfea1bb91b965226c4b16f6bc3a2126fa",
      "category": "container_scanning",
      "message": "CVE-2024-41075 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: add consistency check for copen/cread  This prevents malicious processes from completing random copen/cread requests and crashing the system. Added checks are listed below:  * Generic, copen can only complete open requests, and cread can only complete read requests. * For copen, ondemand_id must not be 0, because this indicates that the request has not been read by the daemon. * For cread, the object corresponding to fd and req should be the same.",
      "cve": "CVE-2024-41075",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41075",
          "value": "CVE-2024-41075",
          "url": "https://scout.docker.com/v/CVE-2024-41075?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41075?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "36339fbaa03b87c8cbb96831600b62e830cad2ed9cf8ec642802b124b8916ada",
      "category": "container_scanning",
      "message": "CVE-2024-41079 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvmet: always initialize cqe.result  The spec doesn't mandate that the first two double words (aka results) for the command queue entry need to be set to 0 when they are not used (not specified). Though, the target implemention returns 0 for TCP and FC but not for RDMA.  Let's make RDMA behave the same and thus explicitly initializing the result field. This prevents leaking any data from the stack.",
      "cve": "CVE-2024-41079",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41079",
          "value": "CVE-2024-41079",
          "url": "https://scout.docker.com/v/CVE-2024-41079?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41079?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e7a4d88e00e5b865d88a028433497e48e5238f2bdb4c42b22908266ce717b385",
      "category": "container_scanning",
      "message": "CVE-2024-41082 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-fabrics: use reserved tag for reg read/write command  In some scenarios, if too many commands are issued by nvme command in the same time by user tasks, this may exhaust all tags of admin_q. If a reset (nvme reset or IO timeout) occurs before these commands finish, reconnect routine may fail to update nvme regs due to insufficient tags, which will cause kernel hang forever. In order to workaround this issue, maybe we can let reg_read32()/reg_read64()/reg_write32() use reserved tags. This maybe safe for nvmf:  1. For the disable ctrl path,  we will not issue connect command 2. For the enable ctrl / fw activate path, since connect and reg_xx() are called serially.  So the reserved tags may still be enough while reg_xx() use reserved tags.",
      "cve": "CVE-2024-41082",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41082",
          "value": "CVE-2024-41082",
          "url": "https://scout.docker.com/v/CVE-2024-41082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41082?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc531395ce4ed34e738cdc8d05ee7c3336581c6bbd0cdfc54c995bfa2cbc07ee",
      "category": "container_scanning",
      "message": "CVE-2024-41088 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  can: mcp251xfd: fix infinite loop when xmit fails  When the mcp251xfd_start_xmit() function fails, the driver stops processing messages, and the interrupt routine does not return, running indefinitely even after killing the running application.  Error messages: [  441.298819] mcp251xfd spi2.0 can0: ERROR in mcp251xfd_start_xmit: -16 [  441.306498] mcp251xfd spi2.0 can0: Transmit Event FIFO buffer not empty. (seq=0x000017c7, tef_tail=0x000017cf, tef_head=0x000017d0, tx_head=0x000017d3). ... and repeat forever.  The issue can be triggered when multiple devices share the same SPI interface. And there is concurrent access to the bus.  The problem occurs because tx_ring->head increments even if mcp251xfd_start_xmit() fails. Consequently, the driver skips one TX package while still expecting a response in mcp251xfd_handle_tefif_one().  Resolve the issue by starting a workqueue to write the tx obj synchronously if err = -EBUSY. In case of another error, decrement tx_ring->head, remove skb from the echo stack, and drop the message.  [mkl: use more imperative wording in patch description]",
      "cve": "CVE-2024-41088",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41088",
          "value": "CVE-2024-41088",
          "url": "https://scout.docker.com/v/CVE-2024-41088?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41088?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e852e3e36f48b29291c108cb3ed5511857b6cb0cb8ddb2378806479f431912db",
      "category": "container_scanning",
      "message": "CVE-2024-42067 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Take return from set_memory_rox() into account with bpf_jit_binary_lock_ro()  set_memory_rox() can fail, leaving memory unprotected.  Check return and bail out when bpf_jit_binary_lock_ro() returns an error.",
      "cve": "CVE-2024-42067",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42067",
          "value": "CVE-2024-42067",
          "url": "https://scout.docker.com/v/CVE-2024-42067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42067?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ed6c45f0aee9925a9c38d90fb39a3c63429500e012f40911086e73f1d95b89fa",
      "category": "container_scanning",
      "message": "CVE-2024-42091 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe: Check pat.ops before dumping PAT settings  We may leave pat.ops unset when running on brand new platform or when running as a VF.  While the former is unlikely, the latter is valid (future) use case and will cause NPD when someone will try to dump PAT settings by debugfs.  It's better to check pointer to pat.ops instead of specific .dump hook, as we have this hook always defined for every .ops variant.",
      "cve": "CVE-2024-42091",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42091",
          "value": "CVE-2024-42091",
          "url": "https://scout.docker.com/v/CVE-2024-42091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "623c610af6cb05abac5ea9a6399d19905f49c5fdc1440802e7b2b90ad8de20cf",
      "category": "container_scanning",
      "message": "CVE-2024-42110 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: ntb_netdev: Move ntb_netdev_rx_handler() to call netif_rx() from __netif_rx()  The following is emitted when using idxd (DSA) dmanegine as the data mover for ntb_transport that ntb_netdev uses.  [74412.546922] BUG: using smp_processor_id() in preemptible [00000000] code: irq/52-idxd-por/14526 [74412.556784] caller is netif_rx_internal+0x42/0x130 [74412.562282] CPU: 6 PID: 14526 Comm: irq/52-idxd-por Not tainted 6.9.5 #5 [74412.569870] Hardware name: Intel Corporation ArcherCity/ArcherCity, BIOS EGSDCRB1.E9I.1752.P05.2402080856 02/08/2024 [74412.581699] Call Trace: [74412.584514]  <TASK> [74412.586933]  dump_stack_lvl+0x55/0x70 [74412.591129]  check_preemption_disabled+0xc8/0xf0 [74412.596374]  netif_rx_internal+0x42/0x130 [74412.600957]  __netif_rx+0x20/0xd0 [74412.604743]  ntb_netdev_rx_handler+0x66/0x150 [ntb_netdev] [74412.610985]  ntb_complete_rxc+0xed/0x140 [ntb_transport] [74412.617010]  ntb_rx_copy_callback+0x53/0x80 [ntb_transport] [74412.623332]  idxd_dma_complete_txd+0xe3/0x160 [idxd] [74412.628963]  idxd_wq_thread+0x1a6/0x2b0 [idxd] [74412.634046]  irq_thread_fn+0x21/0x60 [74412.638134]  ? irq_thread+0xa8/0x290 [74412.642218]  irq_thread+0x1a0/0x290 [74412.646212]  ? __pfx_irq_thread_fn+0x10/0x10 [74412.651071]  ? __pfx_irq_thread_dtor+0x10/0x10 [74412.656117]  ? __pfx_irq_thread+0x10/0x10 [74412.660686]  kthread+0x100/0x130 [74412.664384]  ? __pfx_kthread+0x10/0x10 [74412.668639]  ret_from_fork+0x31/0x50 [74412.672716]  ? __pfx_kthread+0x10/0x10 [74412.676978]  ret_from_fork_asm+0x1a/0x30 [74412.681457]  </TASK>  The cause is due to the idxd driver interrupt completion handler uses threaded interrupt and the threaded handler is not hard or soft interrupt context. However __netif_rx() can only be called from interrupt context. Change the call to netif_rx() in order to allow completion via normal context for dmaengine drivers that utilize threaded irq handling.  While the following commit changed from netif_rx() to __netif_rx(), baebdf48c360 (\"net: dev: Makes sure netif_rx() can be invoked in any context.\"), the change should've been a noop instead. However, the code precedes this fix should've been using netif_rx_ni() or netif_rx_any_context().",
      "cve": "CVE-2024-42110",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42110",
          "value": "CVE-2024-42110",
          "url": "https://scout.docker.com/v/CVE-2024-42110?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42110?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "178c70373f2025b68be523010d2b42d7c7466407006b8197c0b7177cb1880043",
      "category": "container_scanning",
      "message": "CVE-2024-42122 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL pointer check for kzalloc  [Why & How] Check return pointer of kzalloc before using it.",
      "cve": "CVE-2024-42122",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42122",
          "value": "CVE-2024-42122",
          "url": "https://scout.docker.com/v/CVE-2024-42122?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42122?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "668d8df762ed2b25f7d1a992245c54fe11f1ca3d5df848d7c100d7802687b7ad",
      "category": "container_scanning",
      "message": "CVE-2024-42125 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: fw: scan offload prohibit all 6 GHz channel if no 6 GHz sband  We have some policy via BIOS to block uses of 6 GHz. In this case, 6 GHz sband will be NULL even if it is WiFi 7 chip. So, add NULL handling here to avoid crash.",
      "cve": "CVE-2024-42125",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42125",
          "value": "CVE-2024-42125",
          "url": "https://scout.docker.com/v/CVE-2024-42125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42125?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1122ef3c3a2fb285f7c781a908f6053758f6396f5f2ba159577d8dfdace876b3",
      "category": "container_scanning",
      "message": "CVE-2024-42128 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  leds: an30259a: Use devm_mutex_init() for mutex initialization  In this driver LEDs are registered using devm_led_classdev_register() so they are automatically unregistered after module's remove() is done. led_classdev_unregister() calls module's led_set_brightness() to turn off the LEDs and that callback uses mutex which was destroyed already in module's remove() so use devm API instead.",
      "cve": "CVE-2024-42128",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42128",
          "value": "CVE-2024-42128",
          "url": "https://scout.docker.com/v/CVE-2024-42128?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42128?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9442fb4d5bd437f093d28a4a75a4310deb0def99429d21841438a9ab9ea44ea",
      "category": "container_scanning",
      "message": "CVE-2024-42129 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  leds: mlxreg: Use devm_mutex_init() for mutex initialization  In this driver LEDs are registered using devm_led_classdev_register() so they are automatically unregistered after module's remove() is done. led_classdev_unregister() calls module's led_set_brightness() to turn off the LEDs and that callback uses mutex which was destroyed already in module's remove() so use devm API instead.",
      "cve": "CVE-2024-42129",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42129",
          "value": "CVE-2024-42129",
          "url": "https://scout.docker.com/v/CVE-2024-42129?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42129?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "979efdcde9629f46175bcd4c8dba03bb833627999baee0480996d7e390e2d7ef",
      "category": "container_scanning",
      "message": "CVE-2024-42135 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  vhost_task: Handle SIGKILL by flushing work and exiting  Instead of lingering until the device is closed, this has us handle SIGKILL by:  1. marking the worker as killed so we no longer try to use it with new virtqueues and new flush operations. 2. setting the virtqueue to worker mapping so no new works are queued. 3. running all the exiting works.",
      "cve": "CVE-2024-42135",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42135",
          "value": "CVE-2024-42135",
          "url": "https://scout.docker.com/v/CVE-2024-42135?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42135?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc28b39e877a52d85dd977a6f8154f2955c24234a62adbca400ecdd7c080f146",
      "category": "container_scanning",
      "message": "CVE-2024-42139 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: Fix improper extts handling  Extts events are disabled and enabled by the application ts2phc. However, in case where the driver is removed when the application is running, a specific extts event remains enabled and can cause a kernel crash. As a side effect, when the driver is reloaded and application is started again, remaining extts event for the channel from a previous run will keep firing and the message \"extts on unexpected channel\" might be printed to the user.  To avoid that, extts events shall be disabled when PTP is released.",
      "cve": "CVE-2024-42139",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42139",
          "value": "CVE-2024-42139",
          "url": "https://scout.docker.com/v/CVE-2024-42139?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42139?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ea53ba432ed574ae0dc8a4056e672f83c5281b374d5c1de8b80b8194a310cab3",
      "category": "container_scanning",
      "message": "CVE-2024-42239 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fail bpf_timer_cancel when callback is being cancelled  Given a schedule:  timer1 cb\t\t\ttimer2 cb  bpf_timer_cancel(timer2);\tbpf_timer_cancel(timer1);  Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup.  Add an atomic_t count named 'cancelling' in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another.  Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors.  Background on prior attempts:  Earlier versions of this patch used a bool 'cancelling' bit and used the following pattern under timer->lock to publish cancellation status.  lock(t->lock); t->cancelling = true; mb(); if (cur->cancelling) return -EDEADLK; unlock(t->lock); hrtimer_cancel(t->timer); t->cancelling = false;  The store outside the critical section could overwrite a parallel requests t->cancelling assignment to true, to ensure the parallely executing callback observes its cancellation status.  It would be necessary to clear this cancelling bit once hrtimer_cancel is done, but lack of serialization introduced races. Another option was explored where bpf_timer_start would clear the bit when (re)starting the timer under timer->lock. This would ensure serialized access to the cancelling bit, but may allow it to be cleared before in-flight hrtimer_cancel has finished executing, such that lockups can occur again.  Thus, we choose an atomic counter to keep track of all outstanding cancellation requests and use it to prevent lockups in case callbacks attempt to cancel each other while executing in parallel.",
      "cve": "CVE-2024-42239",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42239",
          "value": "CVE-2024-42239",
          "url": "https://scout.docker.com/v/CVE-2024-42239?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42239?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "810455b50b78e1bd2a2d0ed92b0ef7c88a3e25fb844939e5b1e89d18d318f90a",
      "category": "container_scanning",
      "message": "CVE-2024-42273 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: assign CURSEG_ALL_DATA_ATGC if blkaddr is valid  mkdir /mnt/test/comp f2fs_io setflags compression /mnt/test/comp dd if=/dev/zero of=/mnt/test/comp/testfile bs=16k count=1 truncate --size 13 /mnt/test/comp/testfile  In the above scenario, we can get a BUG_ON. kernel BUG at fs/f2fs/segment.c:3589! Call Trace: do_write_page+0x78/0x390 [f2fs] f2fs_outplace_write_data+0x62/0xb0 [f2fs] f2fs_do_write_data_page+0x275/0x740 [f2fs] f2fs_write_single_data_page+0x1dc/0x8f0 [f2fs] f2fs_write_multi_pages+0x1e5/0xae0 [f2fs] f2fs_write_cache_pages+0xab1/0xc60 [f2fs] f2fs_write_data_pages+0x2d8/0x330 [f2fs] do_writepages+0xcf/0x270 __writeback_single_inode+0x44/0x350 writeback_sb_inodes+0x242/0x530 __writeback_inodes_wb+0x54/0xf0 wb_writeback+0x192/0x310 wb_workfn+0x30d/0x400  The reason is we gave CURSEG_ALL_DATA_ATGC to COMPR_ADDR where the page was set the gcing flag by set_cluster_dirty().",
      "cve": "CVE-2024-42273",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42273",
          "value": "CVE-2024-42273",
          "url": "https://scout.docker.com/v/CVE-2024-42273?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42273?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "07b2c81d191c9248db0af9c88d58d9a8fae445ccae5659b0bcd00e0e5d8b36e4",
      "category": "container_scanning",
      "message": "CVE-2024-42319 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mailbox: mtk-cmdq: Move devm_mbox_controller_register() after devm_pm_runtime_enable()  When mtk-cmdq unbinds, a WARN_ON message with condition pm_runtime_get_sync() < 0 occurs.  According to the call tracei below: cmdq_mbox_shutdown mbox_free_channel mbox_controller_unregister __devm_mbox_controller_unregister ...  The root cause can be deduced to be calling pm_runtime_get_sync() after calling pm_runtime_disable() as observed below: 1. CMDQ driver uses devm_mbox_controller_register() in cmdq_probe() to bind the cmdq device to the mbox_controller, so devm_mbox_controller_unregister() will automatically unregister the device bound to the mailbox controller when the device-managed resource is removed. That means devm_mbox_controller_unregister() and cmdq_mbox_shoutdown() will be called after cmdq_remove(). 2. CMDQ driver also uses devm_pm_runtime_enable() in cmdq_probe() after devm_mbox_controller_register(), so that devm_pm_runtime_disable() will be called after cmdq_remove(), but before devm_mbox_controller_unregister().  To fix this problem, cmdq_probe() needs to move devm_mbox_controller_register() after devm_pm_runtime_enable() to make devm_pm_runtime_disable() be called after devm_mbox_controller_unregister().",
      "cve": "CVE-2024-42319",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42319",
          "value": "CVE-2024-42319",
          "url": "https://scout.docker.com/v/CVE-2024-42319?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42319?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b6bf989352cddff71ccfb1e8c2378c547170c97e7bc288756c6a4fea6843062f",
      "category": "container_scanning",
      "message": "CVE-2024-42320 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/dasd: fix error checks in dasd_copy_pair_store()  dasd_add_busid() can return an error via ERR_PTR() if an allocation fails. However, two callsites in dasd_copy_pair_store() do not check the result, potentially resulting in a NULL pointer dereference. Fix this by checking the result with IS_ERR() and returning the error up the stack.",
      "cve": "CVE-2024-42320",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42320",
          "value": "CVE-2024-42320",
          "url": "https://scout.docker.com/v/CVE-2024-42320?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42320?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dfefaa20deb5c92986b21b608d4307486d2b3893b5a3cba711da74023475c922",
      "category": "container_scanning",
      "message": "CVE-2024-42321 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: flow_dissector: use DEBUG_NET_WARN_ON_ONCE  The following splat is easy to reproduce upstream as well as in -stable kernels. Florian Westphal provided the following commit:  d1dab4f71d37 (\"net: add and use __skb_get_hash_symmetric_net\")  but this complementary fix has been also suggested by Willem de Bruijn and it can be easily backported to -stable kernel which consists in using DEBUG_NET_WARN_ON_ONCE instead to silence the following splat given __skb_get_hash() is used by the nftables tracing infrastructure to to identify packets in traces.  [69133.561393] ------------[ cut here ]------------ [69133.561404] WARNING: CPU: 0 PID: 43576 at net/core/flow_dissector.c:1104 __skb_flow_dissect+0x134f/ [...] [69133.561944] CPU: 0 PID: 43576 Comm: socat Not tainted 6.10.0-rc7+ #379 [69133.561959] RIP: 0010:__skb_flow_dissect+0x134f/0x2ad0 [69133.561970] Code: 83 f9 04 0f 84 b3 00 00 00 45 85 c9 0f 84 aa 00 00 00 41 83 f9 02 0f 84 81 fc ff ff 44 0f b7 b4 24 80 00 00 00 e9 8b f9 ff ff <0f> 0b e9 20 f3 ff ff 41 f6 c6 20 0f 84 e4 ef ff ff 48 8d 7b 12 e8 [69133.561979] RSP: 0018:ffffc90000006fc0 EFLAGS: 00010246 [69133.561988] RAX: 0000000000000000 RBX: ffffffff82f33e20 RCX: ffffffff81ab7e19 [69133.561994] RDX: dffffc0000000000 RSI: ffffc90000007388 RDI: ffff888103a1b418 [69133.562001] RBP: ffffc90000007310 R08: 0000000000000000 R09: 0000000000000000 [69133.562007] R10: ffffc90000007388 R11: ffffffff810cface R12: ffff888103a1b400 [69133.562013] R13: 0000000000000000 R14: ffffffff82f33e2a R15: ffffffff82f33e28 [69133.562020] FS:  00007f40f7131740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000 [69133.562027] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [69133.562033] CR2: 00007f40f7346ee0 CR3: 000000015d200001 CR4: 00000000001706f0 [69133.562040] Call Trace: [69133.562044]  <IRQ> [69133.562049]  ? __warn+0x9f/0x1a0 [ 1211.841384]  ? __skb_flow_dissect+0x107e/0x2860 [...] [ 1211.841496]  ? bpf_flow_dissect+0x160/0x160 [ 1211.841753]  __skb_get_hash+0x97/0x280 [ 1211.841765]  ? __skb_get_hash_symmetric+0x230/0x230 [ 1211.841776]  ? mod_find+0xbf/0xe0 [ 1211.841786]  ? get_stack_info_noinstr+0x12/0xe0 [ 1211.841798]  ? bpf_ksym_find+0x56/0xe0 [ 1211.841807]  ? __rcu_read_unlock+0x2a/0x70 [ 1211.841819]  nft_trace_init+0x1b9/0x1c0 [nf_tables] [ 1211.841895]  ? nft_trace_notify+0x830/0x830 [nf_tables] [ 1211.841964]  ? get_stack_info+0x2b/0x80 [ 1211.841975]  ? nft_do_chain_arp+0x80/0x80 [nf_tables] [ 1211.842044]  nft_do_chain+0x79c/0x850 [nf_tables]",
      "cve": "CVE-2024-42321",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42321",
          "value": "CVE-2024-42321",
          "url": "https://scout.docker.com/v/CVE-2024-42321?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42321?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "885f34426845aa00122d272f473ffc7241fa216c62a90904882558c680f069b3",
      "category": "container_scanning",
      "message": "CVE-2024-43823 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: keystone: Fix NULL pointer dereference in case of DT error in ks_pcie_setup_rc_app_regs()  If IORESOURCE_MEM is not provided in Device Tree due to any error, resource_list_first_type() will return NULL and pci_parse_request_of_pci_ranges() will just emit a warning.  This will cause a NULL pointer dereference. Fix this bug by adding NULL return check.  Found by Linux Verification Center (linuxtesting.org) with SVACE.",
      "cve": "CVE-2024-43823",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43823",
          "value": "CVE-2024-43823",
          "url": "https://scout.docker.com/v/CVE-2024-43823?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43823?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "abe048cb67210a06b2f8efe3975f8132ed2fea5915112f6083e92025af3a399d",
      "category": "container_scanning",
      "message": "CVE-2024-43824 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: endpoint: pci-epf-test: Make use of cached 'epc_features' in pci_epf_test_core_init()  Instead of getting the epc_features from pci_epc_get_features() API, use the cached pci_epf_test::epc_features value to avoid the NULL check. Since the NULL check is already performed in pci_epf_test_bind(), having one more check in pci_epf_test_core_init() is redundant and it is not possible to hit the NULL pointer dereference.  Also with commit a01e7214bef9 (\"PCI: endpoint: Remove \"core_init_notifier\" flag\"), 'epc_features' got dereferenced without the NULL check, leading to the following false positive Smatch warning:  drivers/pci/endpoint/functions/pci-epf-test.c:784 pci_epf_test_core_init() error: we previously assumed 'epc_features' could be null (see line 747)  Thus, remove the redundant NULL check and also use the epc_features:: {msix_capable/msi_capable} flags directly to avoid local variables.  [kwilczynski: commit log]",
      "cve": "CVE-2024-43824",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43824",
          "value": "CVE-2024-43824",
          "url": "https://scout.docker.com/v/CVE-2024-43824?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43824?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4686b1badf20d9d4c99d64ceaef2536a0f1d2aedf939f46c0ce794e2bc3ab2ed",
      "category": "container_scanning",
      "message": "CVE-2024-43831 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: Handle invalid decoder vsi  Handle an invalid decoder vsi in vpu_dec_init to ensure the decoder vsi is valid for future use.",
      "cve": "CVE-2024-43831",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43831",
          "value": "CVE-2024-43831",
          "url": "https://scout.docker.com/v/CVE-2024-43831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43831?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f28e6429b169022780c030dd106b5be9f609f405a18b965a263144b500d485d6",
      "category": "container_scanning",
      "message": "CVE-2024-43832 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/uv: Don't call folio_wait_writeback() without a folio reference  folio_wait_writeback() requires that no spinlocks are held and that a folio reference is held, as documented. After we dropped the PTL, the folio could get freed concurrently. So grab a temporary reference.",
      "cve": "CVE-2024-43832",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43832",
          "value": "CVE-2024-43832",
          "url": "https://scout.docker.com/v/CVE-2024-43832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43832?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "96832e46621487ff6a370b71e7afbb55acfa4c5c29e63aa43c428dad381580c4",
      "category": "container_scanning",
      "message": "CVE-2024-43844 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: wow: fix GTK offload H2C skbuff issue  We mistakenly put skb too large and that may exceed skb->end. Therefore, we fix it.  skbuff: skb_over_panic: text:ffffffffc09e9a9d len:416 put:204 head:ffff8fba04eca780 data:ffff8fba04eca7e0 tail:0x200 end:0x140 dev:<NULL> ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:192! invalid opcode: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 4747 Comm: kworker/u4:44 Tainted: G           O 6.6.30-02659-gc18865c4dfbd #1 86547039b47e46935493f615ee31d0b2d711d35e Hardware name: HP Meep/Meep, BIOS Google_Meep.11297.262.0 03/18/2021 Workqueue: events_unbound async_run_entry_fn RIP: 0010:skb_panic+0x5d/0x60 Code: c6 63 8b 8f bb 4c 0f 45 f6 48 c7 c7 4d 89 8b bb 48 89 ce 44 89 d1 41 56 53 41 53 ff b0 c8 00 00 00 e8 27 5f 23 00 48 83 c4 20 <0f> 0b 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 RSP: 0018:ffffaa700144bad0 EFLAGS: 00010282 RAX: 0000000000000089 RBX: 0000000000000140 RCX: 14432c5aad26c900 RDX: 0000000000000000 RSI: 00000000ffffdfff RDI: 0000000000000001 RBP: ffffaa700144bae0 R08: 0000000000000000 R09: ffffaa700144b920 R10: 00000000ffffdfff R11: ffffffffbc28fbc0 R12: ffff8fba4e57a010 R13: 0000000000000000 R14: ffffffffbb8f8b63 R15: 0000000000000000 FS:  0000000000000000(0000) GS:ffff8fba7bd00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007999c4ad1000 CR3: 000000015503a000 CR4: 0000000000350ee0 Call Trace: <TASK> ? __die_body+0x1f/0x70 ? die+0x3d/0x60 ? do_trap+0xa4/0x110 ? skb_panic+0x5d/0x60 ? do_error_trap+0x6d/0x90 ? skb_panic+0x5d/0x60 ? handle_invalid_op+0x30/0x40 ? skb_panic+0x5d/0x60 ? exc_invalid_op+0x3c/0x50 ? asm_exc_invalid_op+0x16/0x20 ? skb_panic+0x5d/0x60 skb_put+0x49/0x50 rtw89_fw_h2c_wow_gtk_ofld+0xbd/0x220 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5] rtw89_wow_resume+0x31f/0x540 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5] rtw89_ops_resume+0x2b/0xa0 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5] ieee80211_reconfig+0x84/0x13e0 [mac80211 818a894e3b77da6298269c59ed7cdff065a4ed52] ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d] ? dev_printk_emit+0x51/0x70 ? _dev_info+0x6e/0x90 ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d] wiphy_resume+0x89/0x180 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d] ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d] dpm_run_callback+0x3c/0x140 device_resume+0x1f9/0x3c0 ? __pfx_dpm_watchdog_handler+0x10/0x10 async_resume+0x1d/0x30 async_run_entry_fn+0x29/0xd0 process_scheduled_works+0x1d8/0x3d0 worker_thread+0x1fc/0x2f0 kthread+0xed/0x110 ? __pfx_worker_thread+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x38/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK> Modules linked in: ccm 8021q r8153_ecm cdc_ether usbnet r8152 mii dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc uinput rfcomm cmac algif_hash rtw89_8922ae(O) algif_skcipher rtw89_8922a(O) af_alg rtw89_pci(O) rtw89_core(O) btusb(O) snd_soc_sst_bxt_da7219_max98357a btbcm(O) snd_soc_hdac_hdmi btintel(O) snd_soc_intel_hda_dsp_common snd_sof_probes btrtl(O) btmtk(O) snd_hda_codec_hdmi snd_soc_dmic uvcvideo videobuf2_vmalloc uvc videobuf2_memops videobuf2_v4l2 videobuf2_common snd_sof_pci_intel_apl snd_sof_intel_hda_common snd_soc_hdac_hda snd_sof_intel_hda soundwire_intel soundwire_generic_allocation snd_sof_intel_hda_mlink soundwire_cadence snd_sof_pci snd_sof_xtensa_dsp mac80211 snd_soc_acpi_intel_match snd_soc_acpi snd_sof snd_sof_utils soundwire_bus snd_soc_max98357a snd_soc_avs snd_soc_hda_codec snd_hda_ext_core snd_intel_dspcfg snd_intel_sdw_acpi snd_soc_da7219 snd_hda_codec snd_hwdep snd_hda_core veth ip6table_nat xt_MASQUERADE xt_cgroup fuse bluetooth ecdh_generic cfg80211 ecc gsmi: Log Shutdown ---truncated---",
      "cve": "CVE-2024-43844",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43844",
          "value": "CVE-2024-43844",
          "url": "https://scout.docker.com/v/CVE-2024-43844?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43844?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "948eb12f492da1346fd009e77db329c24a625c58c658a315d9102925b9d4f0cf",
      "category": "container_scanning",
      "message": "CVE-2024-43872 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/hns: Fix soft lockup under heavy CEQE load  CEQEs are handled in interrupt handler currently. This may cause the CPU core staying in interrupt context too long and lead to soft lockup under heavy load.  Handle CEQEs in BH workqueue and set an upper limit for the number of CEQE handled by a single call of work handler.",
      "cve": "CVE-2024-43872",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43872",
          "value": "CVE-2024-43872",
          "url": "https://scout.docker.com/v/CVE-2024-43872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "123bd195348b80542a5b69d957d8bae3c5b8739a448895f6e38d22f3148ebf66",
      "category": "container_scanning",
      "message": "CVE-2024-43899 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix null pointer deref in dcn20_resource.c  Fixes a hang thats triggered when MPV is run on a DCN401 dGPU:  mpv --hwdec=vaapi --vo=gpu --hwdec-codecs=all  and then enabling fullscreen playback (double click on the video)  The following calltrace will be seen:  [  181.843989] BUG: kernel NULL pointer dereference, address: 0000000000000000 [  181.843997] #PF: supervisor instruction fetch in kernel mode [  181.844003] #PF: error_code(0x0010) - not-present page [  181.844009] PGD 0 P4D 0 [  181.844020] Oops: 0010 [#1] PREEMPT SMP NOPTI [  181.844028] CPU: 6 PID: 1892 Comm: gnome-shell Tainted: G        W  OE 6.5.0-41-generic #41~22.04.2-Ubuntu [  181.844038] Hardware name: System manufacturer System Product Name/CROSSHAIR VI HERO, BIOS 6302 10/23/2018 [  181.844044] RIP: 0010:0x0 [  181.844079] Code: Unable to access opcode bytes at 0xffffffffffffffd6. [  181.844084] RSP: 0018:ffffb593c2b8f7b0 EFLAGS: 00010246 [  181.844093] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004 [  181.844099] RDX: ffffb593c2b8f804 RSI: ffffb593c2b8f7e0 RDI: ffff9e3c8e758400 [  181.844105] RBP: ffffb593c2b8f7b8 R08: ffffb593c2b8f9c8 R09: ffffb593c2b8f96c [  181.844110] R10: 0000000000000000 R11: 0000000000000000 R12: ffffb593c2b8f9c8 [  181.844115] R13: 0000000000000001 R14: ffff9e3c88000000 R15: 0000000000000005 [  181.844121] FS:  00007c6e323bb5c0(0000) GS:ffff9e3f85f80000(0000) knlGS:0000000000000000 [  181.844128] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  181.844134] CR2: ffffffffffffffd6 CR3: 0000000140fbe000 CR4: 00000000003506e0 [  181.844141] Call Trace: [  181.844146]  <TASK> [  181.844153]  ? show_regs+0x6d/0x80 [  181.844167]  ? __die+0x24/0x80 [  181.844179]  ? page_fault_oops+0x99/0x1b0 [  181.844192]  ? do_user_addr_fault+0x31d/0x6b0 [  181.844204]  ? exc_page_fault+0x83/0x1b0 [  181.844216]  ? asm_exc_page_fault+0x27/0x30 [  181.844237]  dcn20_get_dcc_compression_cap+0x23/0x30 [amdgpu] [  181.845115]  amdgpu_dm_plane_validate_dcc.constprop.0+0xe5/0x180 [amdgpu] [  181.845985]  amdgpu_dm_plane_fill_plane_buffer_attributes+0x300/0x580 [amdgpu] [  181.846848]  fill_dc_plane_info_and_addr+0x258/0x350 [amdgpu] [  181.847734]  fill_dc_plane_attributes+0x162/0x350 [amdgpu] [  181.848748]  dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu] [  181.849791]  ? dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu] [  181.850840]  amdgpu_dm_atomic_check+0xdfe/0x1760 [amdgpu]",
      "cve": "CVE-2024-43899",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43899",
          "value": "CVE-2024-43899",
          "url": "https://scout.docker.com/v/CVE-2024-43899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "19f75bdbc4102565c982a96833b9c2e3bc85df82f02ea3e5b4b6f7a428cc7ebb",
      "category": "container_scanning",
      "message": "CVE-2024-43911 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: fix NULL dereference at band check in starting tx ba session  In MLD connection, link_data/link_conf are dynamically allocated. They don't point to vif->bss_conf. So, there will be no chanreq assigned to vif->bss_conf and then the chan will be NULL. Tweak the code to check ht_supported/vht_supported/has_he/has_eht on sta deflink.  Crash log (with rtw89 version under MLO development): [ 9890.526087] BUG: kernel NULL pointer dereference, address: 0000000000000000 [ 9890.526102] #PF: supervisor read access in kernel mode [ 9890.526105] #PF: error_code(0x0000) - not-present page [ 9890.526109] PGD 0 P4D 0 [ 9890.526114] Oops: 0000 [#1] PREEMPT SMP PTI [ 9890.526119] CPU: 2 PID: 6367 Comm: kworker/u16:2 Kdump: loaded Tainted: G           OE      6.9.0 #1 [ 9890.526123] Hardware name: LENOVO 2356AD1/2356AD1, BIOS G7ETB3WW (2.73 ) 11/28/2018 [ 9890.526126] Workqueue: phy2 rtw89_core_ba_work [rtw89_core] [ 9890.526203] RIP: 0010:ieee80211_start_tx_ba_session (net/mac80211/agg-tx.c:618 (discriminator 1)) mac80211 [ 9890.526279] Code: f7 e8 d5 93 3e ea 48 83 c4 28 89 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 49 8b 84 24 e0 f1 ff ff 48 8b 80 90 1b 00 00 <83> 38 03 0f 84 37 fe ff ff bb ea ff ff ff eb cc 49 8b 84 24 10 f3 All code ======== 0:\tf7 e8                \timul   %eax 2:\td5                   \t(bad) 3:\t93                   \txchg   %eax,%ebx 4:\t3e ea                \tds (bad) 6:\t48 83 c4 28          \tadd    $0x28,%rsp a:\t89 d8                \tmov    %ebx,%eax c:\t5b                   \tpop    %rbx d:\t41 5c                \tpop    %r12 f:\t41 5d                \tpop    %r13 11:\t41 5e                \tpop    %r14 13:\t41 5f                \tpop    %r15 15:\t5d                   \tpop    %rbp 16:\tc3                   \tretq 17:\tcc                   \tint3 18:\tcc                   \tint3 19:\tcc                   \tint3 1a:\tcc                   \tint3 1b:\t49 8b 84 24 e0 f1 ff \tmov    -0xe20(%r12),%rax 22:\tff 23:\t48 8b 80 90 1b 00 00 \tmov    0x1b90(%rax),%rax 2a:*\t83 38 03             \tcmpl   $0x3,(%rax)\t\t<-- trapping instruction 2d:\t0f 84 37 fe ff ff    \tje     0xfffffffffffffe6a 33:\tbb ea ff ff ff       \tmov    $0xffffffea,%ebx 38:\teb cc                \tjmp    0x6 3a:\t49                   \trex.WB 3b:\t8b                   \t.byte 0x8b 3c:\t84 24 10             \ttest   %ah,(%rax,%rdx,1) 3f:\tf3                   \trepz  Code starting with the faulting instruction =========================================== 0:\t83 38 03             \tcmpl   $0x3,(%rax) 3:\t0f 84 37 fe ff ff    \tje     0xfffffffffffffe40 9:\tbb ea ff ff ff       \tmov    $0xffffffea,%ebx e:\teb cc                \tjmp    0xffffffffffffffdc 10:\t49                   \trex.WB 11:\t8b                   \t.byte 0x8b 12:\t84 24 10             \ttest   %ah,(%rax,%rdx,1) 15:\tf3                   \trepz [ 9890.526285] RSP: 0018:ffffb8db09013d68 EFLAGS: 00010246 [ 9890.526291] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9308e0d656c8 [ 9890.526295] RDX: 0000000000000000 RSI: ffffffffab99460b RDI: ffffffffab9a7685 [ 9890.526300] RBP: ffffb8db09013db8 R08: 0000000000000000 R09: 0000000000000873 [ 9890.526304] R10: ffff9308e0d64800 R11: 0000000000000002 R12: ffff9308e5ff6e70 [ 9890.526308] R13: ffff930952500e20 R14: ffff9309192a8c00 R15: 0000000000000000 [ 9890.526313] FS:  0000000000000000(0000) GS:ffff930b4e700000(0000) knlGS:0000000000000000 [ 9890.526316] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 9890.526318] CR2: 0000000000000000 CR3: 0000000391c58005 CR4: 00000000001706f0 [ 9890.526321] Call Trace: [ 9890.526324]  <TASK> [ 9890.526327] ? show_regs (arch/x86/kernel/dumpstack.c:479) [ 9890.526335] ? __die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434) [ 9890.526340] ? page_fault_oops (arch/x86/mm/fault.c:713) [ 9890.526347] ? search_module_extables (kernel/module/main.c:3256 (discriminator ---truncated---",
      "cve": "CVE-2024-43911",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43911",
          "value": "CVE-2024-43911",
          "url": "https://scout.docker.com/v/CVE-2024-43911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dc73b5309359549aba6140d9298044fcec97477a40e60d755dda398fa92f9267",
      "category": "container_scanning",
      "message": "CVE-2024-43912 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: nl80211: disallow setting special AP channel widths  Setting the AP channel width is meant for use with the normal 20/40/... MHz channel width progression, and switching around in S1G or narrow channels isn't supported. Disallow that.",
      "cve": "CVE-2024-43912",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43912",
          "value": "CVE-2024-43912",
          "url": "https://scout.docker.com/v/CVE-2024-43912?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43912?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1ef5c1ff68b1996d1eefd1e932d786e1767ac0d7a83647e6a1dc6a02912f20a",
      "category": "container_scanning",
      "message": "CVE-2024-44950 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  serial: sc16is7xx: fix invalid FIFO access with special register set  When enabling access to the special register set, Receiver time-out and RHR interrupts can happen. In this case, the IRQ handler will try to read from the FIFO thru the RHR register at address 0x00, but address 0x00 is mapped to DLL register, resulting in erroneous FIFO reading.  Call graph example: sc16is7xx_startup(): entry sc16is7xx_ms_proc(): entry sc16is7xx_set_termios(): entry sc16is7xx_set_baud(): DLH/DLL = $009C --> access special register set sc16is7xx_port_irq() entry            --> IIR is 0x0C sc16is7xx_handle_rx() entry sc16is7xx_fifo_read(): --> unable to access FIFO (RHR) because it is mapped to DLL (LCR=LCR_CONF_MODE_A) sc16is7xx_set_baud(): exit --> Restore access to general register set  Fix the problem by claiming the efr_lock mutex when accessing the Special register set.",
      "cve": "CVE-2024-44950",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44950",
          "value": "CVE-2024-44950",
          "url": "https://scout.docker.com/v/CVE-2024-44950?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44950?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e8a5aab244631c8fd0cb147b85ab424247150ee9f0eabae4bbf0353e962ec4b6",
      "category": "container_scanning",
      "message": "CVE-2024-44961 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Forward soft recovery errors to userspace  As we discussed before[1], soft recovery should be forwarded to userspace, or we can get into a really bad state where apps will keep submitting hanging command buffers cascading us to a hard reset.  1: https://lore.kernel.org/all/bf23d5ed-9a6b-43e7-84ee-8cbfd0d60f18@froggi.es/ (cherry picked from commit 434967aadbbbe3ad9103cc29e9a327de20fdba01)",
      "cve": "CVE-2024-44961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44961",
          "value": "CVE-2024-44961",
          "url": "https://scout.docker.com/v/CVE-2024-44961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "307f8796a12245a918241432e2d299fae231f137ed82dddd16bb63851e8509d8",
      "category": "container_scanning",
      "message": "CVE-2024-44962 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: btnxpuart: Shutdown timer and prevent rearming when driver unloading  When unload the btnxpuart driver, its associated timer will be deleted. If the timer happens to be modified at this moment, it leads to the kernel call this timer even after the driver unloaded, resulting in kernel panic. Use timer_shutdown_sync() instead of del_timer_sync() to prevent rearming.  panic log: Internal error: Oops: 0000000086000007 [#1] PREEMPT SMP Modules linked in: algif_hash algif_skcipher af_alg moal(O) mlan(O) crct10dif_ce polyval_ce polyval_generic   snd_soc_imx_card snd_soc_fsl_asoc_card snd_soc_imx_audmux mxc_jpeg_encdec v4l2_jpeg snd_soc_wm8962 snd_soc_fsl_micfil   snd_soc_fsl_sai flexcan snd_soc_fsl_utils ap130x rpmsg_ctrl imx_pcm_dma can_dev rpmsg_char pwm_fan fuse [last unloaded:   btnxpuart] CPU: 5 PID: 723 Comm: memtester Tainted: G           O 6.6.23-lts-next-06207-g4aef2658ac28 #1 Hardware name: NXP i.MX95 19X19 board (DT) pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : 0xffff80007a2cf464 lr : call_timer_fn.isra.0+0x24/0x80 ... Call trace: 0xffff80007a2cf464 __run_timers+0x234/0x280 run_timer_softirq+0x20/0x40 __do_softirq+0x100/0x26c ____do_softirq+0x10/0x1c call_on_irq_stack+0x24/0x4c do_softirq_own_stack+0x1c/0x2c irq_exit_rcu+0xc0/0xdc el0_interrupt+0x54/0xd8 __el0_irq_handler_common+0x18/0x24 el0t_64_irq_handler+0x10/0x1c el0t_64_irq+0x190/0x194 Code: ???????? ???????? ???????? ???????? (????????) ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops: Fatal exception in interrupt SMP: stopping secondary CPUs Kernel Offset: disabled CPU features: 0x0,c0000000,40028143,1000721b Memory Limit: none ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---",
      "cve": "CVE-2024-44962",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44962",
          "value": "CVE-2024-44962",
          "url": "https://scout.docker.com/v/CVE-2024-44962?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44962?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "27cc64c62cc3eead045e69d98a1abda3e59d241e7df8397b0b417f8c49b0762c",
      "category": "container_scanning",
      "message": "CVE-2024-44963 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: do not BUG_ON() when freeing tree block after error  When freeing a tree block, at btrfs_free_tree_block(), if we fail to create a delayed reference we don't deal with the error and just do a BUG_ON(). The error most likely to happen is -ENOMEM, and we have a comment mentioning that only -ENOMEM can happen, but that is not true, because in case qgroups are enabled any error returned from btrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returned from btrfs_search_slot() for example) can be propagated back to btrfs_free_tree_block().  So stop doing a BUG_ON() and return the error to the callers and make them abort the transaction to prevent leaking space. Syzbot was triggering this, likely due to memory allocation failure injection.",
      "cve": "CVE-2024-44963",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44963",
          "value": "CVE-2024-44963",
          "url": "https://scout.docker.com/v/CVE-2024-44963?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44963?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "18c9ea61c0aa1ccb167796f246db30c4033a3ac794fa6fee46740c5a64b91dcb",
      "category": "container_scanning",
      "message": "CVE-2024-44970 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: SHAMPO, Fix invalid WQ linked list unlink  When all the strides in a WQE have been consumed, the WQE is unlinked from the WQ linked list (mlx5_wq_ll_pop()). For SHAMPO, it is possible to receive CQEs with 0 consumed strides for the same WQE even after the WQE is fully consumed and unlinked. This triggers an additional unlink for the same wqe which corrupts the linked list.  Fix this scenario by accepting 0 sized consumed strides without unlinking the WQE again.",
      "cve": "CVE-2024-44970",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44970",
          "value": "CVE-2024-44970",
          "url": "https://scout.docker.com/v/CVE-2024-44970?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44970?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "436fb9331e8e46603c220e538ad49cafd65bce9c83eb8b9eb3378bc48ec3ec4e",
      "category": "container_scanning",
      "message": "CVE-2024-44972 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: do not clear page dirty inside extent_write_locked_range()  [BUG] For subpage + zoned case, the following workload can lead to rsv data leak at unmount time:  # mkfs.btrfs -f -s 4k $dev # mount $dev $mnt # fsstress -w -n 8 -d $mnt -s 1709539240 0/0: fiemap - no filename 0/1: copyrange read - no filename 0/2: write - no filename 0/3: rename - no source filename 0/4: creat f0 x:0 0 0 0/4: creat add id=0,parent=-1 0/5: writev f0[259 1 0 0 0 0] [778052,113,965] 0 0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [1294220,2291618343991484791,0x10000] -1 0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25, fallback to stat() 0/7: dwrite f0[259 1 0 0 224 887097] [696320,102400] 0 # umount $mnt  The dmesg includes the following rsv leak detection warning (all call trace skipped):  ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6 ------------[ cut here ]------------ WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): space_info DATA has 268218368 free, is not full BTRFS info (device sda): space_info total=268435456, used=204800, pinned=0, reserved=0, may_use=12288, readonly=0 zone_unusable=0 BTRFS info (device sda): global_block_rsv: size 0 reserved 0 BTRFS info (device sda): trans_block_rsv: size 0 reserved 0 BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0 ------------[ cut here ]------------ WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): space_info METADATA has 267796480 free, is not full BTRFS info (device sda): space_info total=268435456, used=131072, pinned=0, reserved=0, may_use=262144, readonly=0 zone_unusable=245760 BTRFS info (device sda): global_block_rsv: size 0 reserved 0 BTRFS info (device sda): trans_block_rsv: size 0 reserved 0 BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0  Above $dev is a tcmu-runner emulated zoned HDD, which has a max zone append size of 64K, and the system has 64K page size.  [CAUSE] I have added several trace_printk() to show the events (header skipped):  > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688 > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288 > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536 > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864  The above lines show our buffered write has dirtied 3 pages of inode 259 of root 5:  704K             768K              832K              896K I           |////I/////////////////I///////////|     I 756K                               868K  |///| is the dirtied range using subpage bitmaps. and 'I' is the page boundary.  Meanwhile all three pages (704K, 768K, 832K) have their PageDirty flag set.  > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400  Then direct IO writ ---truncated---",
      "cve": "CVE-2024-44972",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-44972",
          "value": "CVE-2024-44972",
          "url": "https://scout.docker.com/v/CVE-2024-44972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-44972?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "722bb3d7fe19ab3fa5b402aa7fdea434db7ba5b0cd9a77e944b54dd5bfc424d9",
      "category": "container_scanning",
      "message": "CVE-2024-45010 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mptcp: pm: only mark 'subflow' endp as available  Adding the following warning ...  WARN_ON_ONCE(msk->pm.local_addr_used == 0)  ... before decrementing the local_addr_used counter helped to find a bug when running the \"remove single address\" subtest from the mptcp_join.sh selftests.  Removing a 'signal' endpoint will trigger the removal of all subflows linked to this endpoint via mptcp_pm_nl_rm_addr_or_subflow() with rm_type == MPTCP_MIB_RMSUBFLOW. This will decrement the local_addr_used counter, which is wrong in this case because this counter is linked to 'subflow' endpoints, and here it is a 'signal' endpoint that is being removed.  Now, the counter is decremented, only if the ID is being used outside of mptcp_pm_nl_rm_addr_or_subflow(), only for 'subflow' endpoints, and if the ID is not 0 -- local_addr_used is not taking into account these ones. This marking of the ID as being available, and the decrement is done no matter if a subflow using this ID is currently available, because the subflow could have been closed before.",
      "cve": "CVE-2024-45010",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-45010",
          "value": "CVE-2024-45010",
          "url": "https://scout.docker.com/v/CVE-2024-45010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-45010?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2d8403c40559899bd8e1ed066f81c7da7d8c8d5571eb8258c3071d4e7847dd8e",
      "category": "container_scanning",
      "message": "CVE-2024-45015 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/dpu: move dpu_encoder's connector assignment to atomic_enable()  For cases where the crtc's connectors_changed was set without enable/active getting toggled , there is an atomic_enable() call followed by an atomic_disable() but without an atomic_mode_set().  This results in a NULL ptr access for the dpu_encoder_get_drm_fmt() call in the atomic_enable() as the dpu_encoder's connector was cleared in the atomic_disable() but not re-assigned as there was no atomic_mode_set() call.  Fix the NULL ptr access by moving the assignment for atomic_enable() and also use drm_atomic_get_new_connector_for_encoder() to get the connector from the atomic_state.  Patchwork: https://patchwork.freedesktop.org/patch/606729/",
      "cve": "CVE-2024-45015",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-45015",
          "value": "CVE-2024-45015",
          "url": "https://scout.docker.com/v/CVE-2024-45015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-45015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9eaebb783d111eacfd2607faf0502f1321ecf93bfb4f09425ceab16340ed00b5",
      "category": "container_scanning",
      "message": "CVE-2024-46678 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bonding: change ipsec_lock from spin lock to mutex  In the cited commit, bond->ipsec_lock is added to protect ipsec_list, hence xdo_dev_state_add and xdo_dev_state_delete are called inside this lock. As ipsec_lock is a spin lock and such xfrmdev ops may sleep, \"scheduling while atomic\" will be triggered when changing bond's active slave.  [  101.055189] BUG: scheduling while atomic: bash/902/0x00000200 [  101.055726] Modules linked in: [  101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1 [  101.058760] Hardware name: [  101.059434] Call Trace: [  101.059436]  <TASK> [  101.060873]  dump_stack_lvl+0x51/0x60 [  101.061275]  __schedule_bug+0x4e/0x60 [  101.061682]  __schedule+0x612/0x7c0 [  101.062078]  ? __mod_timer+0x25c/0x370 [  101.062486]  schedule+0x25/0xd0 [  101.062845]  schedule_timeout+0x77/0xf0 [  101.063265]  ? asm_common_interrupt+0x22/0x40 [  101.063724]  ? __bpf_trace_itimer_state+0x10/0x10 [  101.064215]  __wait_for_common+0x87/0x190 [  101.064648]  ? usleep_range_state+0x90/0x90 [  101.065091]  cmd_exec+0x437/0xb20 [mlx5_core] [  101.065569]  mlx5_cmd_do+0x1e/0x40 [mlx5_core] [  101.066051]  mlx5_cmd_exec+0x18/0x30 [mlx5_core] [  101.066552]  mlx5_crypto_create_dek_key+0xea/0x120 [mlx5_core] [  101.067163]  ? bonding_sysfs_store_option+0x4d/0x80 [bonding] [  101.067738]  ? kmalloc_trace+0x4d/0x350 [  101.068156]  mlx5_ipsec_create_sa_ctx+0x33/0x100 [mlx5_core] [  101.068747]  mlx5e_xfrm_add_state+0x47b/0xaa0 [mlx5_core] [  101.069312]  bond_change_active_slave+0x392/0x900 [bonding] [  101.069868]  bond_option_active_slave_set+0x1c2/0x240 [bonding] [  101.070454]  __bond_opt_set+0xa6/0x430 [bonding] [  101.070935]  __bond_opt_set_notify+0x2f/0x90 [bonding] [  101.071453]  bond_opt_tryset_rtnl+0x72/0xb0 [bonding] [  101.071965]  bonding_sysfs_store_option+0x4d/0x80 [bonding] [  101.072567]  kernfs_fop_write_iter+0x10c/0x1a0 [  101.073033]  vfs_write+0x2d8/0x400 [  101.073416]  ? alloc_fd+0x48/0x180 [  101.073798]  ksys_write+0x5f/0xe0 [  101.074175]  do_syscall_64+0x52/0x110 [  101.074576]  entry_SYSCALL_64_after_hwframe+0x4b/0x53  As bond_ipsec_add_sa_all and bond_ipsec_del_sa_all are only called from bond_change_active_slave, which requires holding the RTNL lock. And bond_ipsec_add_sa and bond_ipsec_del_sa are xfrm state xdo_dev_state_add and xdo_dev_state_delete APIs, which are in user context. So ipsec_lock doesn't have to be spin lock, change it to mutex, and thus the above issue can be resolved.",
      "cve": "CVE-2024-46678",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46678",
          "value": "CVE-2024-46678",
          "url": "https://scout.docker.com/v/CVE-2024-46678?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46678?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "04fb8d4ad56bc23d1f36e20d132db3cc38d2b9e324dc05583f2d1de75e4b1e48",
      "category": "container_scanning",
      "message": "CVE-2024-46681 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  pktgen: use cpus_read_lock() in pg_net_init()  I have seen the WARN_ON(smp_processor_id() != cpu) firing in pktgen_thread_worker() during tests.  We must use cpus_read_lock()/cpus_read_unlock() around the for_each_online_cpu(cpu) loop.  While we are at it use WARN_ON_ONCE() to avoid a possible syslog flood.",
      "cve": "CVE-2024-46681",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46681",
          "value": "CVE-2024-46681",
          "url": "https://scout.docker.com/v/CVE-2024-46681?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46681?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "075f5f052e9e949ae764ef28a70debe360a20afb0cc3614b2a86d55c2208ca85",
      "category": "container_scanning",
      "message": "CVE-2024-46705 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe: reset mmio mappings with devm  Set our various mmio mappings to NULL. This should make it easier to catch something rogue trying to mess with mmio after device removal. For example, we might unmap everything and then start hitting some mmio address which has already been unmamped by us and then remapped by something else, causing all kinds of carnage.",
      "cve": "CVE-2024-46705",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46705",
          "value": "CVE-2024-46705",
          "url": "https://scout.docker.com/v/CVE-2024-46705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46705?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e30c8aba3290ebed6790587fbcccd9a03e834a63bce21a9bb1ce25e067070fb3",
      "category": "container_scanning",
      "message": "CVE-2024-46715 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  driver: iio: add missing checks on iio_info's callback access  Some callbacks from iio_info structure are accessed without any check, so if a driver doesn't implement them trying to access the corresponding sysfs entries produce a kernel oops such as:  [ 2203.527791] Unable to handle kernel NULL pointer dereference at virtual address 00000000 when execute [...] [ 2203.783416] Call trace: [ 2203.783429]  iio_read_channel_info_avail from dev_attr_show+0x18/0x48 [ 2203.789807]  dev_attr_show from sysfs_kf_seq_show+0x90/0x120 [ 2203.794181]  sysfs_kf_seq_show from seq_read_iter+0xd0/0x4e4 [ 2203.798555]  seq_read_iter from vfs_read+0x238/0x2a0 [ 2203.802236]  vfs_read from ksys_read+0xa4/0xd4 [ 2203.805385]  ksys_read from ret_fast_syscall+0x0/0x54 [ 2203.809135] Exception stack(0xe0badfa8 to 0xe0badff0) [ 2203.812880] dfa0:                   00000003 b6f10f80 00000003 b6eab000 00020000 00000000 [ 2203.819746] dfc0: 00000003 b6f10f80 7ff00000 00000003 00000003 00000000 00020000 00000000 [ 2203.826619] dfe0: b6e1bc88 bed80958 b6e1bc94 b6e1bcb0 [ 2203.830363] Code: bad PC value [ 2203.832695] ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2024-46715",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46715",
          "value": "CVE-2024-46715",
          "url": "https://scout.docker.com/v/CVE-2024-46715?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46715?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8249d75c6abc32444501e06a9e8da365126990493d7daa7f133bbf13c6f9e29c",
      "category": "container_scanning",
      "message": "CVE-2024-46716 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dmaengine: altera-msgdma: properly free descriptor in msgdma_free_descriptor  Remove list_del call in msgdma_chan_desc_cleanup, this should be the role of msgdma_free_descriptor. In consequence replace list_add_tail with list_move_tail in msgdma_free_descriptor.  This fixes the path: msgdma_free_chan_resources -> msgdma_free_descriptors -> msgdma_free_desc_list -> msgdma_free_descriptor  which does not correctly free the descriptors as first nodes were not removed from the list.",
      "cve": "CVE-2024-46716",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46716",
          "value": "CVE-2024-46716",
          "url": "https://scout.docker.com/v/CVE-2024-46716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46716?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d5debcee2808deee32496c6e926a2f79ced326628b81c4e890b57cbf682d0be5",
      "category": "container_scanning",
      "message": "CVE-2024-46717 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: SHAMPO, Fix incorrect page release  Under the following conditions: 1) No skb created yet 2) header_size == 0 (no SHAMPO header) 3) header_index + 1 % MLX5E_SHAMPO_WQ_HEADER_PER_PAGE == 0 (this is the last page fragment of a SHAMPO header page)  a new skb is formed with a page that is NOT a SHAMPO header page (it is a regular data page). Further down in the same function (mlx5e_handle_rx_cqe_mpwrq_shampo()), a SHAMPO header page from header_index is released. This is wrong and it leads to SHAMPO header pages being released more than once.",
      "cve": "CVE-2024-46717",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46717",
          "value": "CVE-2024-46717",
          "url": "https://scout.docker.com/v/CVE-2024-46717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1af3998652ce4d9beb466abee961e5990e6e9a6af18d763e2f99000f61b20547",
      "category": "container_scanning",
      "message": "CVE-2024-46718 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe: Don't overmap identity VRAM mapping  Overmapping the identity VRAM mapping is triggering hardware bugs on certain platforms. Use 2M pages for the last unaligned (to 1G) VRAM chunk.  v2: - Always use 2M pages for last chunk (Fei Yang) - break loop when 2M pages are used - Add assert for usable_size being 2M aligned v3: - Fix checkpatch",
      "cve": "CVE-2024-46718",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46718",
          "value": "CVE-2024-46718",
          "url": "https://scout.docker.com/v/CVE-2024-46718?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46718?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "acd0810c1f1bb9aa2729cd72fabeb9b9cfff3978e1916401770a2b76b12526a7",
      "category": "container_scanning",
      "message": "CVE-2024-46720 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix dereference after null check  check the pointer hive before use.",
      "cve": "CVE-2024-46720",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46720",
          "value": "CVE-2024-46720",
          "url": "https://scout.docker.com/v/CVE-2024-46720?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46720?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "df6d6f5833785f05f099981b2877c6c46d548fa9d2c3876078de8d14a6dc6019",
      "category": "container_scanning",
      "message": "CVE-2024-46726 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Ensure index calculation will not overflow  [WHY & HOW] Make sure vmid0p72_idx, vnom0p8_idx and vmax0p9_idx calculation will never overflow and exceess array size.  This fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.",
      "cve": "CVE-2024-46726",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46726",
          "value": "CVE-2024-46726",
          "url": "https://scout.docker.com/v/CVE-2024-46726?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46726?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "85cba658c68942f4203f6bf9203d8154bf30e5adf1dc728c5bc4aab97c3e7f5f",
      "category": "container_scanning",
      "message": "CVE-2024-46727 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add otg_master NULL check within resource_log_pipe_topology_update  [Why] Coverity reports NULL_RETURN warning.  [How] Add otg_master NULL check.",
      "cve": "CVE-2024-46727",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46727",
          "value": "CVE-2024-46727",
          "url": "https://scout.docker.com/v/CVE-2024-46727?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46727?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1dbcea96f2682bfec345402929290a32fe00222c8439881a500905e4ec30f320",
      "category": "container_scanning",
      "message": "CVE-2024-46728 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check index for aux_rd_interval before using  aux_rd_interval has size of 7 and should be checked.  This fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.",
      "cve": "CVE-2024-46728",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46728",
          "value": "CVE-2024-46728",
          "url": "https://scout.docker.com/v/CVE-2024-46728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0dad98cbf95e9452608947064c9c8f73fb7ab96ef908ab1d97f5620c7f80f3e5",
      "category": "container_scanning",
      "message": "CVE-2024-46730 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Ensure array index tg_inst won't be -1  [WHY & HOW] tg_inst will be a negative if timing_generator_count equals 0, which should be checked before used.  This fixes 2 OVERRUN issues reported by Coverity.",
      "cve": "CVE-2024-46730",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46730",
          "value": "CVE-2024-46730",
          "url": "https://scout.docker.com/v/CVE-2024-46730?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46730?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c2e9bcecd12a42b0825ca981638d423f5a4382f295a2d10101e049937fd86d22",
      "category": "container_scanning",
      "message": "CVE-2024-46733 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix qgroup reserve leaks in cow_file_range  In the buffered write path, the dirty page owns the qgroup reserve until it creates an ordered_extent.  Therefore, any errors that occur before the ordered_extent is created must free that reservation, or else the space is leaked. The fstest generic/475 exercises various IO error paths, and is able to trigger errors in cow_file_range where we fail to get to allocating the ordered extent. Note that because we *do* clear delalloc, we are likely to remove the inode from the delalloc list, so the inodes/pages to not have invalidate/launder called on them in the commit abort path.  This results in failures at the unmount stage of the test that look like:  BTRFS: error (device dm-8 state EA) in cleanup_transaction:2018: errno=-5 IO failure BTRFS: error (device dm-8 state EA) in btrfs_replace_file_extents:2416: errno=-5 IO failure BTRFS warning (device dm-8 state EA): qgroup 0/5 has unreleased space, type 0 rsv 28672 ------------[ cut here ]------------ WARNING: CPU: 3 PID: 22588 at fs/btrfs/disk-io.c:4333 close_ctree+0x222/0x4d0 [btrfs] Modules linked in: btrfs blake2b_generic libcrc32c xor zstd_compress raid6_pq CPU: 3 PID: 22588 Comm: umount Kdump: loaded Tainted: G W 6.10.0-rc7-gab56fde445b8 #21 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014 RIP: 0010:close_ctree+0x222/0x4d0 [btrfs] RSP: 0018:ffffb4465283be00 EFLAGS: 00010202 RAX: 0000000000000001 RBX: ffffa1a1818e1000 RCX: 0000000000000001 RDX: 0000000000000000 RSI: ffffb4465283bbe0 RDI: ffffa1a19374fcb8 RBP: ffffa1a1818e13c0 R08: 0000000100028b16 R09: 0000000000000000 R10: 0000000000000003 R11: 0000000000000003 R12: ffffa1a18ad7972c R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 FS:  00007f9168312b80(0000) GS:ffffa1a4afcc0000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f91683c9140 CR3: 000000010acaa000 CR4: 00000000000006f0 Call Trace: <TASK> ? close_ctree+0x222/0x4d0 [btrfs] ? __warn.cold+0x8e/0xea ? close_ctree+0x222/0x4d0 [btrfs] ? report_bug+0xff/0x140 ? handle_bug+0x3b/0x70 ? exc_invalid_op+0x17/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? close_ctree+0x222/0x4d0 [btrfs] generic_shutdown_super+0x70/0x160 kill_anon_super+0x11/0x40 btrfs_kill_super+0x11/0x20 [btrfs] deactivate_locked_super+0x2e/0xa0 cleanup_mnt+0xb5/0x150 task_work_run+0x57/0x80 syscall_exit_to_user_mode+0x121/0x130 do_syscall_64+0xab/0x1a0 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f916847a887 ---[ end trace 0000000000000000 ]--- BTRFS error (device dm-8 state EA): qgroup reserved space leaked  Cases 2 and 3 in the out_reserve path both pertain to this type of leak and must free the reserved qgroup data. Because it is already an error path, I opted not to handle the possible errors in btrfs_free_qgroup_data.",
      "cve": "CVE-2024-46733",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46733",
          "value": "CVE-2024-46733",
          "url": "https://scout.docker.com/v/CVE-2024-46733?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46733?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7113fe077626c8895a4bce20e2441686cbb08b8a0c39ef92c0b8286d903075da",
      "category": "container_scanning",
      "message": "CVE-2024-46748 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: Set the max subreq size for cache writes to MAX_RW_COUNT  Set the maximum size of a subrequest that writes to cachefiles to be MAX_RW_COUNT so that we don't overrun the maximum write we can make to the backing filesystem.",
      "cve": "CVE-2024-46748",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46748",
          "value": "CVE-2024-46748",
          "url": "https://scout.docker.com/v/CVE-2024-46748?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46748?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fa45c3a0f708b977a00f6fb99e5c8eef96fe5f505577480bce6cdd6089a3b0bc",
      "category": "container_scanning",
      "message": "CVE-2024-46749 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: btnxpuart: Fix Null pointer dereference in btnxpuart_flush()  This adds a check before freeing the rx->skb in flush and close functions to handle the kernel crash seen while removing driver after FW download fails or before FW download completes.  dmesg log: [   54.634586] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000080 [   54.643398] Mem abort info: [   54.646204]   ESR = 0x0000000096000004 [   54.649964]   EC = 0x25: DABT (current EL), IL = 32 bits [   54.655286]   SET = 0, FnV = 0 [   54.658348]   EA = 0, S1PTW = 0 [   54.661498]   FSC = 0x04: level 0 translation fault [   54.666391] Data abort info: [   54.669273]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [   54.674768]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [   54.674771]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [   54.674775] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000048860000 [   54.674780] [0000000000000080] pgd=0000000000000000, p4d=0000000000000000 [   54.703880] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [   54.710152] Modules linked in: btnxpuart(-) overlay fsl_jr_uio caam_jr caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine authenc libdes crct10dif_ce polyval_ce polyval_generic snd_soc_imx_spdif snd_soc_imx_card snd_soc_ak5558 snd_soc_ak4458 caam secvio error snd_soc_fsl_micfil snd_soc_fsl_spdif snd_soc_fsl_sai snd_soc_fsl_utils imx_pcm_dma gpio_ir_recv rc_core sch_fq_codel fuse [   54.744357] CPU: 3 PID: 72 Comm: kworker/u9:0 Not tainted 6.6.3-otbr-g128004619037 #2 [   54.744364] Hardware name: FSL i.MX8MM EVK board (DT) [   54.744368] Workqueue: hci0 hci_power_on [   54.757244] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [   54.757249] pc : kfree_skb_reason+0x18/0xb0 [   54.772299] lr : btnxpuart_flush+0x40/0x58 [btnxpuart] [   54.782921] sp : ffff8000805ebca0 [   54.782923] x29: ffff8000805ebca0 x28: ffffa5c6cf1869c0 x27: ffffa5c6cf186000 [   54.782931] x26: ffff377b84852400 x25: ffff377b848523c0 x24: ffff377b845e7230 [   54.782938] x23: ffffa5c6ce8dbe08 x22: ffffa5c6ceb65410 x21: 00000000ffffff92 [   54.782945] x20: ffffa5c6ce8dbe98 x19: ffffffffffffffac x18: ffffffffffffffff [   54.807651] x17: 0000000000000000 x16: ffffa5c6ce2824ec x15: ffff8001005eb857 [   54.821917] x14: 0000000000000000 x13: ffffa5c6cf1a02e0 x12: 0000000000000642 [   54.821924] x11: 0000000000000040 x10: ffffa5c6cf19d690 x9 : ffffa5c6cf19d688 [   54.821931] x8 : ffff377b86000028 x7 : 0000000000000000 x6 : 0000000000000000 [   54.821938] x5 : ffff377b86000000 x4 : 0000000000000000 x3 : 0000000000000000 [   54.843331] x2 : 0000000000000000 x1 : 0000000000000002 x0 : ffffffffffffffac [   54.857599] Call trace: [   54.857601]  kfree_skb_reason+0x18/0xb0 [   54.863878]  btnxpuart_flush+0x40/0x58 [btnxpuart] [   54.863888]  hci_dev_open_sync+0x3a8/0xa04 [   54.872773]  hci_power_on+0x54/0x2e4 [   54.881832]  process_one_work+0x138/0x260 [   54.881842]  worker_thread+0x32c/0x438 [   54.881847]  kthread+0x118/0x11c [   54.881853]  ret_from_fork+0x10/0x20 [   54.896406] Code: a9be7bfd 910003fd f9000bf3 aa0003f3 (b940d400) [   54.896410] ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2024-46749",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46749",
          "value": "CVE-2024-46749",
          "url": "https://scout.docker.com/v/CVE-2024-46749?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46749?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "42d832550bd77fe491fa85332fc491d4eb30e24001a14406e1e739f1b5b00290",
      "category": "container_scanning",
      "message": "CVE-2024-46754 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Remove tst_run from lwt_seg6local_prog_ops.  The syzbot reported that the lwt_seg6 related BPF ops can be invoked via bpf_test_run() without without entering input_action_end_bpf() first.  Martin KaFai Lau said that self test for BPF_PROG_TYPE_LWT_SEG6LOCAL probably didn't work since it was introduced in commit 04d4b274e2a (\"ipv6: sr: Add seg6local action End.BPF\"). The reason is that the per-CPU variable seg6_bpf_srh_states::srh is never assigned in the self test case but each BPF function expects it.  Remove test_run for BPF_PROG_TYPE_LWT_SEG6LOCAL.",
      "cve": "CVE-2024-46754",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46754",
          "value": "CVE-2024-46754",
          "url": "https://scout.docker.com/v/CVE-2024-46754?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46754?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c43f83acc764340deff5d869b97d79276cd0b7c8ce7a98afe7379b8779dc03be",
      "category": "container_scanning",
      "message": "CVE-2024-46762 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xen: privcmd: Fix possible access to a freed kirqfd instance  Nothing prevents simultaneous ioctl calls to privcmd_irqfd_assign() and privcmd_irqfd_deassign(). If that happens, it is possible that a kirqfd created and added to the irqfds_list by privcmd_irqfd_assign() may get removed by another thread executing privcmd_irqfd_deassign(), while the former is still using it after dropping the locks.  This can lead to a situation where an already freed kirqfd instance may be accessed and cause kernel oops.  Use SRCU locking to prevent the same, as is done for the KVM implementation for irqfds.",
      "cve": "CVE-2024-46762",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46762",
          "value": "CVE-2024-46762",
          "url": "https://scout.docker.com/v/CVE-2024-46762?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46762?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c41e9e41f86aa148c36d731d7ad59870297feff44225a4278011fd78e30e43df",
      "category": "container_scanning",
      "message": "CVE-2024-46765 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: protect XDP configuration with a mutex  The main threat to data consistency in ice_xdp() is a possible asynchronous PF reset. It can be triggered by a user or by TX timeout handler.  XDP setup and PF reset code access the same resources in the following sections: * ice_vsi_close() in ice_prepare_for_reset() - already rtnl-locked * ice_vsi_rebuild() for the PF VSI - not protected * ice_vsi_open() - already rtnl-locked  With an unfortunate timing, such accesses can result in a crash such as the one below:  [ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 14 [ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 18 [Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 ms [ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx_timeout: VSI_num: 6, Q 14, NTC: 0x0, HW_HEAD: 0x0, NTU: 0x0, INT: 0x4000001 [ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx_timeout recovery level 1, txqueue 14 [ +0.394718] ice 0000:b1:00.0: PTP reset successful [ +0.006184] BUG: kernel NULL pointer dereference, address: 0000000000000098 [ +0.000045] #PF: supervisor read access in kernel mode [ +0.000023] #PF: error_code(0x0000) - not-present page [ +0.000023] PGD 0 P4D 0 [ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTI [ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1 [ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021 [ +0.000036] Workqueue: ice ice_service_task [ice] [ +0.000183] RIP: 0010:ice_clean_tx_ring+0xa/0xd0 [ice] [...] [ +0.000013] Call Trace: [ +0.000016] <TASK> [ +0.000014] ? __die+0x1f/0x70 [ +0.000029] ? page_fault_oops+0x171/0x4f0 [ +0.000029] ? schedule+0x3b/0xd0 [ +0.000027] ? exc_page_fault+0x7b/0x180 [ +0.000022] ? asm_exc_page_fault+0x22/0x30 [ +0.000031] ? ice_clean_tx_ring+0xa/0xd0 [ice] [ +0.000194] ice_free_tx_ring+0xe/0x60 [ice] [ +0.000186] ice_destroy_xdp_rings+0x157/0x310 [ice] [ +0.000151] ice_vsi_decfg+0x53/0xe0 [ice] [ +0.000180] ice_vsi_rebuild+0x239/0x540 [ice] [ +0.000186] ice_vsi_rebuild_by_type+0x76/0x180 [ice] [ +0.000145] ice_rebuild+0x18c/0x840 [ice] [ +0.000145] ? delay_tsc+0x4a/0xc0 [ +0.000022] ? delay_tsc+0x92/0xc0 [ +0.000020] ice_do_reset+0x140/0x180 [ice] [ +0.000886] ice_service_task+0x404/0x1030 [ice] [ +0.000824] process_one_work+0x171/0x340 [ +0.000685] worker_thread+0x277/0x3a0 [ +0.000675] ? preempt_count_add+0x6a/0xa0 [ +0.000677] ? _raw_spin_lock_irqsave+0x23/0x50 [ +0.000679] ? __pfx_worker_thread+0x10/0x10 [ +0.000653] kthread+0xf0/0x120 [ +0.000635] ? __pfx_kthread+0x10/0x10 [ +0.000616] ret_from_fork+0x2d/0x50 [ +0.000612] ? __pfx_kthread+0x10/0x10 [ +0.000604] ret_from_fork_asm+0x1b/0x30 [ +0.000604] </TASK>  The previous way of handling this through returning -EBUSY is not viable, particularly when destroying AF_XDP socket, because the kernel proceeds with removal anyway.  There is plenty of code between those calls and there is no need to create a large critical section that covers all of them, same as there is no need to protect ice_vsi_rebuild() with rtnl_lock().  Add xdp_state_lock mutex to protect ice_vsi_rebuild() and ice_xdp().  Leaving unprotected sections in between would result in two states that have to be considered: 1. when the VSI is closed, but not yet rebuild 2. when VSI is already rebuild, but not yet open  The latter case is actually already handled through !netif_running() case, we just need to adjust flag checking a little. The former one is not as trivial, because between ice_vsi_close() and ice_vsi_rebuild(), a lot of hardware interaction happens, this can make adding/deleting rings exit with an error. Luckily, VSI rebuild is pending and can apply new configuration for us in a managed fashion.  Therefore, add an additional VSI state flag ICE_VSI_REBUILD_PENDING to indicate that ice_x ---truncated---",
      "cve": "CVE-2024-46765",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46765",
          "value": "CVE-2024-46765",
          "url": "https://scout.docker.com/v/CVE-2024-46765?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46765?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "23f3c6e664e08f4ac736d81ac1ffcdba9ff62e7713910a0b3f901fd4f1fdd44f",
      "category": "container_scanning",
      "message": "CVE-2024-46770 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: Add netif_device_attach/detach into PF reset flow  Ethtool callbacks can be executed while reset is in progress and try to access deleted resources, e.g. getting coalesce settings can result in a NULL pointer dereference seen below.  Reproduction steps: Once the driver is fully initialized, trigger reset: # echo 1 > /sys/class/net/<interface>/device/reset when reset is in progress try to get coalesce settings using ethtool: # ethtool -c <interface>  BUG: kernel NULL pointer dereference, address: 0000000000000020 PGD 0 P4D 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI CPU: 11 PID: 19713 Comm: ethtool Tainted: G S                 6.10.0-rc7+ #7 RIP: 0010:ice_get_q_coalesce+0x2e/0xa0 [ice] RSP: 0018:ffffbab1e9bcf6a8 EFLAGS: 00010206 RAX: 000000000000000c RBX: ffff94512305b028 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffff9451c3f2e588 RDI: ffff9451c3f2e588 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: ffff9451c3f2e580 R11: 000000000000001f R12: ffff945121fa9000 R13: ffffbab1e9bcf760 R14: 0000000000000013 R15: ffffffff9e65dd40 FS:  00007faee5fbe740(0000) GS:ffff94546fd80000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000020 CR3: 0000000106c2e005 CR4: 00000000001706f0 Call Trace: <TASK> ice_get_coalesce+0x17/0x30 [ice] coalesce_prepare_data+0x61/0x80 ethnl_default_doit+0xde/0x340 genl_family_rcv_msg_doit+0xf2/0x150 genl_rcv_msg+0x1b3/0x2c0 netlink_rcv_skb+0x5b/0x110 genl_rcv+0x28/0x40 netlink_unicast+0x19c/0x290 netlink_sendmsg+0x222/0x490 __sys_sendto+0x1df/0x1f0 __x64_sys_sendto+0x24/0x30 do_syscall_64+0x82/0x160 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7faee60d8e27  Calling netif_device_detach() before reset makes the net core not call the driver when ethtool command is issued, the attempt to execute an ethtool command during reset will result in the following message:  netlink error: No such device  instead of NULL pointer dereference. Once reset is done and ice_rebuild() is executing, the netif_device_attach() is called to allow for ethtool operations to occur again in a safe manner.",
      "cve": "CVE-2024-46770",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46770",
          "value": "CVE-2024-46770",
          "url": "https://scout.docker.com/v/CVE-2024-46770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46770?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ff42c1ae84895a8221456846db4bcb6e9795e182eb6067f10f8defc99dbe9514",
      "category": "container_scanning",
      "message": "CVE-2024-46775 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Validate function returns  [WHAT & HOW] Function return values must be checked before data can be used in subsequent functions.  This fixes 4 CHECKED_RETURN issues reported by Coverity.",
      "cve": "CVE-2024-46775",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46775",
          "value": "CVE-2024-46775",
          "url": "https://scout.docker.com/v/CVE-2024-46775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8a38daf00ffe342be728e505330f773d8e831281ca757ea9042f042311c5be19",
      "category": "container_scanning",
      "message": "CVE-2024-46778 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check UnboundedRequestEnabled's value  CalculateSwathAndDETConfiguration_params_st's UnboundedRequestEnabled is a pointer (i.e. dml_bool_t *UnboundedRequestEnabled), and thus if (p->UnboundedRequestEnabled) checks its address, not bool value.  This fixes 1 REVERSE_INULL issue reported by Coverity.",
      "cve": "CVE-2024-46778",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46778",
          "value": "CVE-2024-46778",
          "url": "https://scout.docker.com/v/CVE-2024-46778?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46778?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "12c03fcdabccb93539656b981bd1fee0a8cd2a8ac78758a04b8e81f1806da8ce",
      "category": "container_scanning",
      "message": "CVE-2024-46802 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: added NULL check at start of dc_validate_stream  [Why] prevent invalid memory access  [How] check if dc and stream are NULL",
      "cve": "CVE-2024-46802",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46802",
          "value": "CVE-2024-46802",
          "url": "https://scout.docker.com/v/CVE-2024-46802?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46802?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f051a47fa48ba64f4b060726684ea229300c2e75e364d021452f8bb78150445d",
      "category": "container_scanning",
      "message": "CVE-2024-46803 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: Check debug trap enable before write dbg_ev_file  In interrupt context, write dbg_ev_file will be run by work queue. It will cause write dbg_ev_file execution after debug_trap_disable, which will cause NULL pointer access. v2: cancel work \"debug_event_workarea\" before set dbg_ev_file as NULL.",
      "cve": "CVE-2024-46803",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46803",
          "value": "CVE-2024-46803",
          "url": "https://scout.docker.com/v/CVE-2024-46803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46803?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e71c682461bd3d0f382f3674b942c2d5261fda6729278632eebd3f9457f60884",
      "category": "container_scanning",
      "message": "CVE-2024-46806 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix the warning division or modulo by zero  Checks the partition mode and returns an error for an invalid mode.",
      "cve": "CVE-2024-46806",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46806",
          "value": "CVE-2024-46806",
          "url": "https://scout.docker.com/v/CVE-2024-46806?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46806?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fcdab9ac15b0d9f893a2528d29194c50febfbec925aad66cdae5d2751cca8f20",
      "category": "container_scanning",
      "message": "CVE-2024-46808 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add missing NULL pointer check within dpcd_extend_address_range  [Why & How] ASSERT if return NULL from kcalloc.",
      "cve": "CVE-2024-46808",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46808",
          "value": "CVE-2024-46808",
          "url": "https://scout.docker.com/v/CVE-2024-46808?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46808?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "89da8d5a66dcf9a360ddd845496cb4c56a834bfbd46c3369597f7f493aa27af5",
      "category": "container_scanning",
      "message": "CVE-2024-46823 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  kunit/overflow: Fix UB in overflow_allocation_test  The 'device_name' array doesn't exist out of the 'overflow_allocation_test' function scope. However, it is being used as a driver name when calling 'kunit_driver_create' from 'kunit_device_register'. It produces the kernel panic with KASAN enabled.  Since this variable is used in one place only, remove it and pass the device name into kunit_device_register directly as an ascii string.",
      "cve": "CVE-2024-46823",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46823",
          "value": "CVE-2024-46823",
          "url": "https://scout.docker.com/v/CVE-2024-46823?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46823?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f77c776190d8b547b6c8b46860fccb8c6cdcb3c4557f52887b214cb4a75a142",
      "category": "container_scanning",
      "message": "CVE-2024-46827 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix firmware crash due to invalid peer nss  Currently, if the access point receives an association request containing an Extended HE Capabilities Information Element with an invalid MCS-NSS, it triggers a firmware crash.  This issue arises when EHT-PHY capabilities shows support for a bandwidth and MCS-NSS set for that particular bandwidth is filled by zeros and due to this, driver obtains peer_nss as 0 and sending this value to firmware causes crash.  Address this issue by implementing a validation step for the peer_nss value before passing it to the firmware. If the value is greater than zero, proceed with forwarding it to the firmware. However, if the value is invalid, reject the association request to prevent potential firmware crashes.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2024-46827",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46827",
          "value": "CVE-2024-46827",
          "url": "https://scout.docker.com/v/CVE-2024-46827?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46827?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3c5c7d0cb47694c92d9c3a8d86f9ab457f830657926e37ffaa16d38317cacea9",
      "category": "container_scanning",
      "message": "CVE-2024-46834 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ethtool: fail closed if we can't get max channel used in indirection tables  Commit 0d1b7d6c9274 (\"bnxt: fix crashes when reducing ring count with active RSS contexts\") proves that allowing indirection table to contain channels with out of bounds IDs may lead to crashes. Currently the max channel check in the core gets skipped if driver can't fetch the indirection table or when we can't allocate memory.  Both of those conditions should be extremely rare but if they do happen we should try to be safe and fail the channel change.",
      "cve": "CVE-2024-46834",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46834",
          "value": "CVE-2024-46834",
          "url": "https://scout.docker.com/v/CVE-2024-46834?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46834?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "65fcd77a1a4c713bc9d9c9b95d76295aae7dfb4aecd5d7375e3bb9a03bf534e6",
      "category": "container_scanning",
      "message": "CVE-2024-46835 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: Fix smatch static checker warning  adev->gfx.imu.funcs could be NULL",
      "cve": "CVE-2024-46835",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46835",
          "value": "CVE-2024-46835",
          "url": "https://scout.docker.com/v/CVE-2024-46835?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46835?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d5b8ac27886a3401174f7d2fce2ea604adb01c274886916af0954efc4e7f2d4a",
      "category": "container_scanning",
      "message": "CVE-2024-46842 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info  The MBX_TIMEOUT return code is not handled in lpfc_get_sfp_info and the routine unconditionally frees submitted mailbox commands regardless of return status.  The issue is that for MBX_TIMEOUT cases, when firmware returns SFP information at a later time, that same mailbox memory region references previously freed memory in its cmpl routine.  Fix by adding checks for the MBX_TIMEOUT return code.  During mailbox resource cleanup, check the mbox flag to make sure that the wait did not timeout.  If the MBOX_WAKE flag is not set, then do not free the resources because it will be freed when firmware completes the mailbox at a later time in its cmpl routine.  Also, increase the timeout from 30 to 60 seconds to accommodate boot scripts requiring longer timeouts.",
      "cve": "CVE-2024-46842",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46842",
          "value": "CVE-2024-46842",
          "url": "https://scout.docker.com/v/CVE-2024-46842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8001c877425f84fa2c3b6fa3285edbe728a87f95b45957392a373b47b98a31c3",
      "category": "container_scanning",
      "message": "CVE-2024-46843 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Remove SCSI host only if added  If host tries to remove ufshcd driver from a UFS device it would cause a kernel panic if ufshcd_async_scan fails during ufshcd_probe_hba before adding a SCSI host with scsi_add_host and MCQ is enabled since SCSI host has been defered after MCQ configuration introduced by commit 0cab4023ec7b (\"scsi: ufs: core: Defer adding host to SCSI if MCQ is supported\").  To guarantee that SCSI host is removed only if it has been added, set the scsi_host_added flag to true after adding a SCSI host and check whether it is set or not before removing it.",
      "cve": "CVE-2024-46843",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46843",
          "value": "CVE-2024-46843",
          "url": "https://scout.docker.com/v/CVE-2024-46843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "60df3580dcc8e3aba3a37e16427881f257ea5ffd79f9b768642cc38987fb93ac",
      "category": "container_scanning",
      "message": "CVE-2024-46848 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  perf/x86/intel: Limit the period on Haswell  Running the ltp test cve-2015-3290 concurrently reports the following warnings.  perfevents: irq loop stuck! WARNING: CPU: 31 PID: 32438 at arch/x86/events/intel/core.c:3174 intel_pmu_handle_irq+0x285/0x370 Call Trace: <NMI> ? __warn+0xa4/0x220 ? intel_pmu_handle_irq+0x285/0x370 ? __report_bug+0x123/0x130 ? intel_pmu_handle_irq+0x285/0x370 ? __report_bug+0x123/0x130 ? intel_pmu_handle_irq+0x285/0x370 ? report_bug+0x3e/0xa0 ? handle_bug+0x3c/0x70 ? exc_invalid_op+0x18/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? irq_work_claim+0x1e/0x40 ? intel_pmu_handle_irq+0x285/0x370 perf_event_nmi_handler+0x3d/0x60 nmi_handle+0x104/0x330  Thanks to Thomas Gleixner's analysis, the issue is caused by the low initial period (1) of the frequency estimation algorithm, which triggers the defects of the HW, specifically erratum HSW11 and HSW143. (For the details, please refer https://lore.kernel.org/lkml/87plq9l5d2.ffs@tglx/)  The HSW11 requires a period larger than 100 for the INST_RETIRED.ALL event, but the initial period in the freq mode is 1. The erratum is the same as the BDM11, which has been supported in the kernel. A minimum period of 128 is enforced as well on HSW.  HSW143 is regarding that the fixed counter 1 may overcount 32 with the Hyper-Threading is enabled. However, based on the test, the hardware has more issues than it tells. Besides the fixed counter 1, the message 'interrupt took too long' can be observed on any counter which was armed with a period < 32 and two events expired in the same NMI. A minimum period of 32 is enforced for the rest of the events. The recommended workaround code of the HSW143 is not implemented. Because it only addresses the issue for the fixed counter. It brings extra overhead through extra MSR writing. No related overcounting issue has been reported so far.",
      "cve": "CVE-2024-46848",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46848",
          "value": "CVE-2024-46848",
          "url": "https://scout.docker.com/v/CVE-2024-46848?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46848?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0b9acb552ef71a98c67497ad71735c354fbc805b60f5694a4da8d827f28ee870",
      "category": "container_scanning",
      "message": "CVE-2024-46857 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Fix bridge mode operations when there are no VFs  Currently, trying to set the bridge mode attribute when numvfs=0 leads to a crash:  bridge link set dev eth2 hwmode vepa  [  168.967392] BUG: kernel NULL pointer dereference, address: 0000000000000030 [...] [  168.969989] RIP: 0010:mlx5_add_flow_rules+0x1f/0x300 [mlx5_core] [...] [  168.976037] Call Trace: [  168.976188]  <TASK> [  168.978620]  _mlx5_eswitch_set_vepa_locked+0x113/0x230 [mlx5_core] [  168.979074]  mlx5_eswitch_set_vepa+0x7f/0xa0 [mlx5_core] [  168.979471]  rtnl_bridge_setlink+0xe9/0x1f0 [  168.979714]  rtnetlink_rcv_msg+0x159/0x400 [  168.980451]  netlink_rcv_skb+0x54/0x100 [  168.980675]  netlink_unicast+0x241/0x360 [  168.980918]  netlink_sendmsg+0x1f6/0x430 [  168.981162]  ____sys_sendmsg+0x3bb/0x3f0 [  168.982155]  ___sys_sendmsg+0x88/0xd0 [  168.985036]  __sys_sendmsg+0x59/0xa0 [  168.985477]  do_syscall_64+0x79/0x150 [  168.987273]  entry_SYSCALL_64_after_hwframe+0x76/0x7e [  168.987773] RIP: 0033:0x7f8f7950f917  (esw->fdb_table.legacy.vepa_fdb is null)  The bridge mode is only relevant when there are multiple functions per port. Therefore, prevent setting and getting this setting when there are no VFs.  Note that after this change, there are no settings to change on the PF interface using `bridge link` when there are no VFs, so the interface no longer appears in the `bridge link` output.",
      "cve": "CVE-2024-46857",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46857",
          "value": "CVE-2024-46857",
          "url": "https://scout.docker.com/v/CVE-2024-46857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46857?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2f687cbca877c8e952eefa5a8f658b01ab6eb03245b7028d812044d318f78c81",
      "category": "container_scanning",
      "message": "CVE-2024-46860 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7921: fix NULL pointer access in mt7921_ipv6_addr_change  When disabling wifi mt7921_ipv6_addr_change() is called as a notifier. At this point mvif->phy is already NULL so we cannot use it here.",
      "cve": "CVE-2024-46860",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46860",
          "value": "CVE-2024-46860",
          "url": "https://scout.docker.com/v/CVE-2024-46860?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46860?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "32471e62affbf4d3d8681604f0146cc443a05fc1c01cfd4d380588e63d6ecd09",
      "category": "container_scanning",
      "message": "CVE-2024-46861 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usbnet: ipheth: do not stop RX on failing RX callback  RX callbacks can fail for multiple reasons:  * Payload too short * Payload formatted incorrecly (e.g. bad NCM framing) * Lack of memory  None of these should cause the driver to seize up.  Make such failures non-critical and continue processing further incoming URBs.",
      "cve": "CVE-2024-46861",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46861",
          "value": "CVE-2024-46861",
          "url": "https://scout.docker.com/v/CVE-2024-46861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8d958fb707f677f88a44db29f973945c817e0b142b9fceddafa45323c905556d",
      "category": "container_scanning",
      "message": "CVE-2024-47141 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  pinmux: Use sequential access to access desc->pinmux data  When two client of the same gpio call pinctrl_select_state() for the same functionality, we are seeing NULL pointer issue while accessing desc->mux_owner.  Let's say two processes A, B executing in pin_request() for the same pin and process A updates the desc->mux_usecount but not yet updated the desc->mux_owner while process B see the desc->mux_usecount which got updated by A path and further executes strcmp and while accessing desc->mux_owner it crashes with NULL pointer.  Serialize the access to mux related setting with a mutex lock.  cpu0 (process A)\t\t\tcpu1(process B)  pinctrl_select_state() {\t\t  pinctrl_select_state() { pin_request() {\t\t\t\tpin_request() { ... .... } else { desc->mux_usecount++; desc->mux_usecount && strcmp(desc->mux_owner, owner)) {  if (desc->mux_usecount > 1) return 0; desc->mux_owner = owner;  }\t\t\t\t\t\t}",
      "cve": "CVE-2024-47141",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47141",
          "value": "CVE-2024-47141",
          "url": "https://scout.docker.com/v/CVE-2024-47141?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47141?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d46c6a0397038fc0df5221f6150665bb0c7b49c3ef71466b6349ca2495b8880e",
      "category": "container_scanning",
      "message": "CVE-2024-47658 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: stm32/cryp - call finalize with bh disabled  The finalize operation in interrupt mode produce a produces a spinlock recursion warning. The reason is the fact that BH must be disabled during this process.",
      "cve": "CVE-2024-47658",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47658",
          "value": "CVE-2024-47658",
          "url": "https://scout.docker.com/v/CVE-2024-47658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a61d15b8377eae51f51d5272ab93e21f0a224a11e377c9d0647d688ebc2d83aa",
      "category": "container_scanning",
      "message": "CVE-2024-47661 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Avoid overflow from uint32_t to uint8_t  [WHAT & HOW] dmub_rb_cmd's ramping_boundary has size of uint8_t and it is assigned 0xFFFF. Fix it by changing it to uint8_t with value of 0xFF.  This fixes 2 INTEGER_OVERFLOW issues reported by Coverity.",
      "cve": "CVE-2024-47661",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47661",
          "value": "CVE-2024-47661",
          "url": "https://scout.docker.com/v/CVE-2024-47661?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47661?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1cb696d5bc196800e05da0e412350529053d4efb4a30534af2c4e4fac877a454",
      "category": "container_scanning",
      "message": "CVE-2024-47662 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Remove register from DCN35 DMCUB diagnostic collection  [Why] These registers should not be read from driver and triggering the security violation when DMCUB work times out and diagnostics are collected blocks Z8 entry.  [How] Remove the register read from DCN35.",
      "cve": "CVE-2024-47662",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47662",
          "value": "CVE-2024-47662",
          "url": "https://scout.docker.com/v/CVE-2024-47662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47662?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "adb30e7283656e2d0776547b01d30e566f5e390995508fb32fb7510a35874e68",
      "category": "container_scanning",
      "message": "CVE-2024-47664 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  spi: hisi-kunpeng: Add verification for the max_frequency provided by the firmware  If the value of max_speed_hz is 0, it may cause a division by zero error in hisi_calc_effective_speed(). The value of max_speed_hz is provided by firmware. Firmware is generally considered as a trusted domain. However, as division by zero errors can cause system failure, for defense measure, the value of max_speed is validated here. So 0 is regarded as invalid and an error code is returned.",
      "cve": "CVE-2024-47664",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47664",
          "value": "CVE-2024-47664",
          "url": "https://scout.docker.com/v/CVE-2024-47664?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47664?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "319051b87bbac944d7274b3653e5e513c8bd63d6545a14714370827682e27d6f",
      "category": "container_scanning",
      "message": "CVE-2024-47666 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: pm80xx: Set phy->enable_completion only when we wait for it  pm8001_phy_control() populates the enable_completion pointer with a stack address, sends a PHY_LINK_RESET / PHY_HARD_RESET, waits 300 ms, and returns. The problem arises when a phy control response comes late.  After 300 ms the pm8001_phy_control() function returns and the passed enable_completion stack address is no longer valid. Late phy control response invokes complete() on a dangling enable_completion pointer which leads to a kernel crash.",
      "cve": "CVE-2024-47666",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47666",
          "value": "CVE-2024-47666",
          "url": "https://scout.docker.com/v/CVE-2024-47666?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47666?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c8d7f3bf000fdf01b3dab28b7718ef254426648621adde7aa55f8a75e4af6048",
      "category": "container_scanning",
      "message": "CVE-2024-47678 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  icmp: change the order of rate limits  ICMP messages are ratelimited :  After the blamed commits, the two rate limiters are applied in this order:  1) host wide ratelimit (icmp_global_allow())  2) Per destination ratelimit (inetpeer based)  In order to avoid side-channels attacks, we need to apply the per destination check first.  This patch makes the following change :  1) icmp_global_allow() checks if the host wide limit is reached. But credits are not yet consumed. This is deferred to 3)  2) The per destination limit is checked/updated. This might add a new node in inetpeer tree.  3) icmp_global_consume() consumes tokens if prior operations succeeded.  This means that host wide ratelimit is still effective in keeping inetpeer tree small even under DDOS.  As a bonus, I removed icmp_global.lock as the fast path can use a lock-free operation.",
      "cve": "CVE-2024-47678",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47678",
          "value": "CVE-2024-47678",
          "url": "https://scout.docker.com/v/CVE-2024-47678?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47678?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "919fbaa96091b04204c4f080e05bcefe375ec5351953c5a4e275d2cde2be37d0",
      "category": "container_scanning",
      "message": "CVE-2024-47683 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Skip Recompute DSC Params if no Stream on Link  [why] Encounter NULL pointer dereference uner mst + dsc setup.  BUG: kernel NULL pointer dereference, address: 0000000000000008 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2 Hardware name: LENOVO 20NKS01Y00/20NKS01Y00, BIOS R12ET61W(1.31 ) 07/28/2022 RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper] Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8> RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224 RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280 RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850 R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000 R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224 FS:  00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? plist_add+0xbe/0x100 ? exc_page_fault+0x7c/0x180 ? asm_exc_page_fault+0x26/0x30 ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] drm_atomic_check_only+0x5c5/0xa40 drm_mode_atomic_ioctl+0x76e/0xbc0  [how] dsc recompute should be skipped if no mode change detected on the new request. If detected, keep checking whether the stream is already on current state or not.",
      "cve": "CVE-2024-47683",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47683",
          "value": "CVE-2024-47683",
          "url": "https://scout.docker.com/v/CVE-2024-47683?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47683?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bf0a3d9df92f96dc388ced0a0c8597798f9e803649de72de5c3842bc552324f7",
      "category": "container_scanning",
      "message": "CVE-2024-47703 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf, lsm: Add check for BPF LSM return value  A bpf prog returning a positive number attached to file_alloc_security hook makes kernel panic.  This happens because file system can not filter out the positive number returned by the LSM prog using IS_ERR, and misinterprets this positive number as a file pointer.  Given that hook file_alloc_security never returned positive number before the introduction of BPF LSM, and other BPF LSM hooks may encounter similar issues, this patch adds LSM return value check in verifier, to ensure no unexpected value is returned.",
      "cve": "CVE-2024-47703",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47703",
          "value": "CVE-2024-47703",
          "url": "https://scout.docker.com/v/CVE-2024-47703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d164f388829a606cf28e3d20b844a2817298ccca760921e1a3bb1c70ff8e29c1",
      "category": "container_scanning",
      "message": "CVE-2024-47704 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check link_res->hpo_dp_link_enc before using it  [WHAT & HOW] Functions dp_enable_link_phy and dp_disable_link_phy can pass link_res without initializing hpo_dp_link_enc and it is necessary to check for null before dereferencing.  This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "cve": "CVE-2024-47704",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47704",
          "value": "CVE-2024-47704",
          "url": "https://scout.docker.com/v/CVE-2024-47704?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47704?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6452fceee3fbfac45e1aa24d5a5ac71af1b83a3da92f7f8786865ba39bfee887",
      "category": "container_scanning",
      "message": "CVE-2024-47728 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Zero former ARG_PTR_TO_{LONG,INT} args in case of error  For all non-tracing helpers which formerly had ARG_PTR_TO_{LONG,INT} as input arguments, zero the value for the case of an error as otherwise it could leak memory. For tracing, it is not needed given CAP_PERFMON can already read all kernel memory anyway hence bpf_get_func_arg() and bpf_get_func_ret() is skipped in here.  Also, the MTU helpers mtu_len pointer value is being written but also read. Technically, the MEM_UNINIT should not be there in order to always force init. Removing MEM_UNINIT needs more verifier rework though: MEM_UNINIT right now implies two things actually: i) write into memory, ii) memory does not have to be initialized. If we lift MEM_UNINIT, it then becomes: i) read into memory, ii) memory must be initialized. This means that for bpf_*_check_mtu() we're readding the issue we're trying to fix, that is, it would then be able to write back into things like .rodata BPF maps. Follow-up work will rework the MEM_UNINIT semantics such that the intent can be better expressed. For now just clear the *mtu_len on error path which can be lifted later again.",
      "cve": "CVE-2024-47728",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47728",
          "value": "CVE-2024-47728",
          "url": "https://scout.docker.com/v/CVE-2024-47728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47728?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "47105dc4294e303dd60340cfa3b6f002886397cb0c776135198457b478316042",
      "category": "container_scanning",
      "message": "CVE-2024-47736 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: handle overlapped pclusters out of crafted images properly  syzbot reported a task hang issue due to a deadlock case where it is waiting for the folio lock of a cached folio that will be used for cache I/Os.  After looking into the crafted fuzzed image, I found it's formed with several overlapped big pclusters as below:  Ext:   logical offset   |  length :     physical offset    |  length 0:        0..   16384 |   16384 :     151552..    167936 |   16384 1:    16384..   32768 |   16384 :     155648..    172032 |   16384 2:    32768..   49152 |   16384 :  537223168.. 537239552 |   16384 ...  Here, extent 0/1 are physically overlapped although it's entirely _impossible_ for normal filesystem images generated by mkfs.  First, managed folios containing compressed data will be marked as up-to-date and then unlocked immediately (unlike in-place folios) when compressed I/Os are complete.  If physical blocks are not submitted in the incremental order, there should be separate BIOs to avoid dependency issues.  However, the current code mis-arranges z_erofs_fill_bio_vec() and BIO submission which causes unexpected BIO waits.  Second, managed folios will be connected to their own pclusters for efficient inter-queries.  However, this is somewhat hard to implement easily if overlapped big pclusters exist.  Again, these only appear in fuzzed images so let's simply fall back to temporary short-lived pages for correctness.  Additionally, it justifies that referenced managed folios cannot be truncated for now and reverts part of commit 2080ca1ed3e4 (\"erofs: tidy up `struct z_erofs_bvec`\") for simplicity although it shouldn't be any difference.",
      "cve": "CVE-2024-47736",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47736",
          "value": "CVE-2024-47736",
          "url": "https://scout.docker.com/v/CVE-2024-47736?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47736?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bbdff0b44cbb2739b4066f2738a715d817fd2fbac2a18fea998eef00577d20f5",
      "category": "container_scanning",
      "message": "CVE-2024-47794 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Prevent tailcall infinite loop caused by freplace  There is a potential infinite loop issue that can occur when using a combination of tail calls and freplace.  In an upcoming selftest, the attach target for entry_freplace of tailcall_freplace.c is subprog_tc of tc_bpf2bpf.c, while the tail call in entry_freplace leads to entry_tc. This results in an infinite loop:  entry_tc -> subprog_tc -> entry_freplace --tailcall-> entry_tc.  The problem arises because the tail_call_cnt in entry_freplace resets to zero each time entry_freplace is executed, causing the tail call mechanism to never terminate, eventually leading to a kernel panic.  To fix this issue, the solution is twofold:  1. Prevent updating a program extended by an freplace program to a prog_array map. 2. Prevent extending a program that is already part of a prog_array map with an freplace program.  This ensures that:  * If a program or its subprogram has been extended by an freplace program, it can no longer be updated to a prog_array map. * If a program has been added to a prog_array map, neither it nor its subprograms can be extended by an freplace program.  Moreover, an extension program should not be tailcalled. As such, return -EINVAL if the program has a type of BPF_PROG_TYPE_EXT when adding it to a prog_array map.  Additionally, fix a minor code style issue by replacing eight spaces with a tab for proper formatting.",
      "cve": "CVE-2024-47794",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47794",
          "value": "CVE-2024-47794",
          "url": "https://scout.docker.com/v/CVE-2024-47794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cd2bae8130716405d7582f18a8145cee43ab8ba895df0c5cb96b87f893433b2a",
      "category": "container_scanning",
      "message": "CVE-2024-47809 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dlm: fix possible lkb_resource null dereference  This patch fixes a possible null pointer dereference when this function is called from request_lock() as lkb->lkb_resource is not assigned yet, only after validate_lock_args() by calling attach_lkb(). Another issue is that a resource name could be a non printable bytearray and we cannot assume to be ASCII coded.  The log functionality is probably never being hit when DLM is used in normal way and no debug logging is enabled. The null pointer dereference can only occur on a new created lkb that does not have the resource assigned yet, it probably never hits the null pointer dereference but we should be sure that other changes might not change this behaviour and we actually can hit the mentioned null pointer dereference.  In this patch we just drop the printout of the resource name, the lkb id is enough to make a possible connection to a resource name if this exists.",
      "cve": "CVE-2024-47809",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47809",
          "value": "CVE-2024-47809",
          "url": "https://scout.docker.com/v/CVE-2024-47809?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47809?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1927e7e8b338b774a09b8cdf7454ca4af6325707bb269a8b836bf1755da0ffc9",
      "category": "container_scanning",
      "message": "CVE-2024-48873 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: check return value of ieee80211_probereq_get() for RNR  The return value of ieee80211_probereq_get() might be NULL, so check it before using to avoid NULL pointer access.  Addresses-Coverity-ID: 1529805 (\"Dereference null return value\")",
      "cve": "CVE-2024-48873",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-48873",
          "value": "CVE-2024-48873",
          "url": "https://scout.docker.com/v/CVE-2024-48873?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-48873?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "90790f5af408ed28bfc2fcba280d0e9d67bad10e3af4cdd9a2f48a7f3da2c0bb",
      "category": "container_scanning",
      "message": "CVE-2024-48875 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't take dev_replace rwsem on task already holding it  Running fstests btrfs/011 with MKFS_OPTIONS=\"-O rst\" to force the usage of the RAID stripe-tree, we get the following splat from lockdep:  BTRFS info (device sdd): dev_replace from /dev/sdd (devid 1) to /dev/sdb started  ============================================ WARNING: possible recursive locking detected 6.11.0-rc3-btrfs-for-next #599 Not tainted -------------------------------------------- btrfs/2326 is trying to acquire lock: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250  but task is already holding lock: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250  other info that might help us debug this: Possible unsafe locking scenario:  CPU0 ---- lock(&fs_info->dev_replace.rwsem); lock(&fs_info->dev_replace.rwsem);  *** DEADLOCK ***  May be due to missing lock nesting notation  1 lock held by btrfs/2326: #0: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250  stack backtrace: CPU: 1 UID: 0 PID: 2326 Comm: btrfs Not tainted 6.11.0-rc3-btrfs-for-next #599 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 Call Trace: <TASK> dump_stack_lvl+0x5b/0x80 __lock_acquire+0x2798/0x69d0 ? __pfx___lock_acquire+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 lock_acquire+0x19d/0x4a0 ? btrfs_map_block+0x39f/0x2250 ? __pfx_lock_acquire+0x10/0x10 ? find_held_lock+0x2d/0x110 ? lock_is_held_type+0x8f/0x100 down_read+0x8e/0x440 ? btrfs_map_block+0x39f/0x2250 ? __pfx_down_read+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 btrfs_map_block+0x39f/0x2250 ? btrfs_dev_replace_by_ioctl+0xd69/0x1d00 ? btrfs_bio_counter_inc_blocked+0xd9/0x2e0 ? __kasan_slab_alloc+0x6e/0x70 ? __pfx_btrfs_map_block+0x10/0x10 ? __pfx_btrfs_bio_counter_inc_blocked+0x10/0x10 ? kmem_cache_alloc_noprof+0x1f2/0x300 ? mempool_alloc_noprof+0xed/0x2b0 btrfs_submit_chunk+0x28d/0x17e0 ? __pfx_btrfs_submit_chunk+0x10/0x10 ? bvec_alloc+0xd7/0x1b0 ? bio_add_folio+0x171/0x270 ? __pfx_bio_add_folio+0x10/0x10 ? __kasan_check_read+0x20/0x20 btrfs_submit_bio+0x37/0x80 read_extent_buffer_pages+0x3df/0x6c0 btrfs_read_extent_buffer+0x13e/0x5f0 read_tree_block+0x81/0xe0 read_block_for_search+0x4bd/0x7a0 ? __pfx_read_block_for_search+0x10/0x10 btrfs_search_slot+0x78d/0x2720 ? __pfx_btrfs_search_slot+0x10/0x10 ? lock_is_held_type+0x8f/0x100 ? kasan_save_track+0x14/0x30 ? __kasan_slab_alloc+0x6e/0x70 ? kmem_cache_alloc_noprof+0x1f2/0x300 btrfs_get_raid_extent_offset+0x181/0x820 ? __pfx_lock_acquire+0x10/0x10 ? __pfx_btrfs_get_raid_extent_offset+0x10/0x10 ? down_read+0x194/0x440 ? __pfx_down_read+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 btrfs_map_block+0x5b5/0x2250 ? __pfx_btrfs_map_block+0x10/0x10 scrub_submit_initial_read+0x8fe/0x11b0 ? __pfx_scrub_submit_initial_read+0x10/0x10 submit_initial_group_read+0x161/0x3a0 ? lock_release+0x20e/0x710 ? __pfx_submit_initial_group_read+0x10/0x10 ? __pfx_lock_release+0x10/0x10 scrub_simple_mirror.isra.0+0x3eb/0x580 scrub_stripe+0xe4d/0x1440 ? lock_release+0x20e/0x710 ? __pfx_scrub_stripe+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 scrub_chunk+0x257/0x4a0 scrub_enumerate_chunks+0x64c/0xf70 ? __mutex_unlock_slowpath+0x147/0x5f0 ? __pfx_scrub_enumerate_chunks+0x10/0x10 ? bit_wait_timeout+0xb0/0x170 ? __up_read+0x189/0x700 ? scrub_workers_get+0x231/0x300 ? up_write+0x490/0x4f0 btrfs_scrub_dev+0x52e/0xcd0 ? create_pending_snapshots+0x230/0x250 ? __pfx_btrfs_scrub_dev+0x10/0x10 btrfs_dev_replace_by_ioctl+0xd69/0x1d00 ? lock_acquire+0x19d/0x4a0 ? __pfx_btrfs_dev_replace_by_ioctl+0x10/0x10 ? ---truncated---",
      "cve": "CVE-2024-48875",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-48875",
          "value": "CVE-2024-48875",
          "url": "https://scout.docker.com/v/CVE-2024-48875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-48875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "891189915ca6636f942c88f9177fece97af3f95fc6feea42fdde0a7381235632",
      "category": "container_scanning",
      "message": "CVE-2024-49568 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: check v2_ext_offset/eid_cnt/ism_gid_cnt when receiving proposal msg  When receiving proposal msg in server, the fields v2_ext_offset/ eid_cnt/ism_gid_cnt in proposal msg are from the remote client and can not be fully trusted. Especially the field v2_ext_offset, once exceed the max value, there has the chance to access wrong address, and crash may happen.  This patch checks the fields v2_ext_offset/eid_cnt/ism_gid_cnt before using them.",
      "cve": "CVE-2024-49568",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49568",
          "value": "CVE-2024-49568",
          "url": "https://scout.docker.com/v/CVE-2024-49568?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49568?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eded7168c9c41970fcc4ba32d609569f77c1d07be76b86868ce20fdb83c5e53a",
      "category": "container_scanning",
      "message": "CVE-2024-49870 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: fix dentry leak in cachefiles_open_file()  A dentry leak may be caused when a lookup cookie and a cull are concurrent:  P1             |             P2 ----------------------------------------------------------- cachefiles_lookup_cookie cachefiles_look_up_object lookup_one_positive_unlocked // get dentry cachefiles_cull inode->i_flags |= S_KERNEL_FILE; cachefiles_open_file cachefiles_mark_inode_in_use __cachefiles_mark_inode_in_use can_use = false if (!(inode->i_flags & S_KERNEL_FILE)) can_use = true return false return false // Returns an error but doesn't put dentry  After that the following WARNING will be triggered when the backend folder is umounted:  ================================================================== BUG: Dentry 000000008ad87947{i=7a,n=Dx_1_1.img}  still in use (1) [unmount of ext4 sda] WARNING: CPU: 4 PID: 359261 at fs/dcache.c:1767 umount_check+0x5d/0x70 CPU: 4 PID: 359261 Comm: umount Not tainted 6.6.0-dirty #25 RIP: 0010:umount_check+0x5d/0x70 Call Trace: <TASK> d_walk+0xda/0x2b0 do_one_tree+0x20/0x40 shrink_dcache_for_umount+0x2c/0x90 generic_shutdown_super+0x20/0x160 kill_block_super+0x1a/0x40 ext4_kill_sb+0x22/0x40 deactivate_locked_super+0x35/0x80 cleanup_mnt+0x104/0x160 ==================================================================  Whether cachefiles_open_file() returns true or false, the reference count obtained by lookup_positive_unlocked() in cachefiles_look_up_object() should be released.  Therefore release that reference count in cachefiles_look_up_object() to fix the above issue and simplify the code.",
      "cve": "CVE-2024-49870",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49870",
          "value": "CVE-2024-49870",
          "url": "https://scout.docker.com/v/CVE-2024-49870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1c800eed490dc8ae48fcf70e902ed962d36dfaed900c439a12547649700be8b4",
      "category": "container_scanning",
      "message": "CVE-2024-49888 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix a sdiv overflow issue  Zac Ecob reported a problem where a bpf program may cause kernel crash due to the following error: Oops: divide error: 0000 [#1] PREEMPT SMP KASAN PTI  The failure is due to the below signed divide: LLONG_MIN/-1 where LLONG_MIN equals to -9,223,372,036,854,775,808. LLONG_MIN/-1 is supposed to give a positive number 9,223,372,036,854,775,808, but it is impossible since for 64-bit system, the maximum positive number is 9,223,372,036,854,775,807. On x86_64, LLONG_MIN/-1 will cause a kernel exception. On arm64, the result for LLONG_MIN/-1 is LLONG_MIN.  Further investigation found all the following sdiv/smod cases may trigger an exception when bpf program is running on x86_64 platform: - LLONG_MIN/-1 for 64bit operation - INT_MIN/-1 for 32bit operation - LLONG_MIN%-1 for 64bit operation - INT_MIN%-1 for 32bit operation where -1 can be an immediate or in a register.  On arm64, there are no exceptions: - LLONG_MIN/-1 = LLONG_MIN - INT_MIN/-1 = INT_MIN - LLONG_MIN%-1 = 0 - INT_MIN%-1 = 0 where -1 can be an immediate or in a register.  Insn patching is needed to handle the above cases and the patched codes produced results aligned with above arm64 result. The below are pseudo codes to handle sdiv/smod exceptions including both divisor -1 and divisor 0 and the divisor is stored in a register.  sdiv: tmp = rX tmp += 1 /* [-1, 0] -> [0, 1] if tmp >(unsigned) 1 goto L2 if tmp == 0 goto L1 rY = 0 L1: rY = -rY; goto L3 L2: rY /= rX L3:  smod: tmp = rX tmp += 1 /* [-1, 0] -> [0, 1] if tmp >(unsigned) 1 goto L1 if tmp == 1 (is64 ? goto L2 : goto L3) rY = 0; goto L2 L1: rY %= rX L2: goto L4  // only when !is64 L3: wY = wY  // only when !is64 L4:  [1] https://lore.kernel.org/bpf/tPJLTEh7S_DxFEqAI2Ji5MBSoZVg7_G-Py2iaZpAaWtM961fFTWtsnlzwvTbzBzaUzwQAoNATXKUlt0LZOFgnDcIyKCswAnAGdUF3LBrhGQ=@protonmail.com/",
      "cve": "CVE-2024-49888",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49888",
          "value": "CVE-2024-49888",
          "url": "https://scout.docker.com/v/CVE-2024-49888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "95cbb3070f57727622080d9682b2c6cf0f4a35cd441c8ac856f2ca279b79cf06",
      "category": "container_scanning",
      "message": "CVE-2024-49891 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Validate hdwq pointers before dereferencing in reset/errata paths  When the HBA is undergoing a reset or is handling an errata event, NULL ptr dereference crashes may occur in routines such as lpfc_sli_flush_io_rings(), lpfc_dev_loss_tmo_callbk(), or lpfc_abort_handler().  Add NULL ptr checks before dereferencing hdwq pointers that may have been freed due to operations colliding with a reset or errata event handler.",
      "cve": "CVE-2024-49891",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49891",
          "value": "CVE-2024-49891",
          "url": "https://scout.docker.com/v/CVE-2024-49891?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49891?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "12afd0ce16b0701e307c77e8a110b70a22c54fdf55f084783bbfb1bedc263006",
      "category": "container_scanning",
      "message": "CVE-2024-49893 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check stream_status before it is used  [WHAT & HOW] dc_state_get_stream_status can return null, and therefore null must be checked before stream_status is used.  This fixes 1 NULL_RETURNS issue reported by Coverity.",
      "cve": "CVE-2024-49893",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49893",
          "value": "CVE-2024-49893",
          "url": "https://scout.docker.com/v/CVE-2024-49893?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49893?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d9f442a53681d789105871248e9e804174aac83ca3cca3cb2e0ba02fb995e3a3",
      "category": "container_scanning",
      "message": "CVE-2024-49898 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null-initialized variables  [WHAT & HOW] drr_timing and subvp_pipe are initialized to null and they are not always assigned new values. It is necessary to check for null before dereferencing.  This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "cve": "CVE-2024-49898",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49898",
          "value": "CVE-2024-49898",
          "url": "https://scout.docker.com/v/CVE-2024-49898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f8056313166f0538f66ac491927be306988528bee5f7c95caeb9d1b9276f275b",
      "category": "container_scanning",
      "message": "CVE-2024-49899 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Initialize denominators' default to 1  [WHAT & HOW] Variables used as denominators and maybe not assigned to other values, should not be 0. Change their default to 1 so they are never 0.  This fixes 10 DIVIDE_BY_ZERO issues reported by Coverity.",
      "cve": "CVE-2024-49899",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49899",
          "value": "CVE-2024-49899",
          "url": "https://scout.docker.com/v/CVE-2024-49899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3192ffadd59b07c906fded8614e580309035fa65670fdf88e0979f67bceda283",
      "category": "container_scanning",
      "message": "CVE-2024-49901 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/adreno: Assign msm_gpu->pdev earlier to avoid nullptrs  There are some cases, such as the one uncovered by Commit 46d4efcccc68 (\"drm/msm/a6xx: Avoid a nullptr dereference when speedbin setting fails\") where  msm_gpu_cleanup() : platform_set_drvdata(gpu->pdev, NULL);  is called on gpu->pdev == NULL, as the GPU device has not been fully initialized yet.  Turns out that there's more than just the aforementioned path that causes this to happen (e.g. the case when there's speedbin data in the catalog, but opp-supported-hw is missing in DT).  Assigning msm_gpu->pdev earlier seems like the least painful solution to this, therefore do so.  Patchwork: https://patchwork.freedesktop.org/patch/602742/",
      "cve": "CVE-2024-49901",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49901",
          "value": "CVE-2024-49901",
          "url": "https://scout.docker.com/v/CVE-2024-49901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49901?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ffded0c72f133a40d35ef95b1e9c23f6e2ed914b008be48d91a40dd8454f254e",
      "category": "container_scanning",
      "message": "CVE-2024-49904 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: add list empty check to avoid null pointer issue  Add list empty check to avoid null pointer issues in some corner cases. - list_for_each_entry_safe()",
      "cve": "CVE-2024-49904",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49904",
          "value": "CVE-2024-49904",
          "url": "https://scout.docker.com/v/CVE-2024-49904?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49904?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8ef00f944d82ee694f83acd6a556103ea554cfed3df03391f15715d5f89a7261",
      "category": "container_scanning",
      "message": "CVE-2024-49905 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add null check for 'afb' in amdgpu_dm_plane_handle_cursor_update (v2)  This commit adds a null check for the 'afb' variable in the amdgpu_dm_plane_handle_cursor_update function. Previously, 'afb' was assumed to be null, but was used later in the code without a null check. This could potentially lead to a null pointer dereference.  Changes since v1: - Moved the null check for 'afb' to the line where 'afb' is used. (Alex)  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_plane.c:1298 amdgpu_dm_plane_handle_cursor_update() error: we previously assumed 'afb' could be null (see line 1252)",
      "cve": "CVE-2024-49905",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49905",
          "value": "CVE-2024-49905",
          "url": "https://scout.docker.com/v/CVE-2024-49905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49905?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6e2123ed406ae6e804669b467a18645e891456033e4e2f7c9dd35667ddcbe24b",
      "category": "container_scanning",
      "message": "CVE-2024-49906 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null pointer before try to access it  [why & how] Change the order of the pipe_ctx->plane_state check to ensure that plane_state is not null before accessing it.",
      "cve": "CVE-2024-49906",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49906",
          "value": "CVE-2024-49906",
          "url": "https://scout.docker.com/v/CVE-2024-49906?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49906?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b2a543120801bbdcd71c74cb83f6e1cbcbbb529a2ca66640dae13a8039404068",
      "category": "container_scanning",
      "message": "CVE-2024-49908 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add null check for 'afb' in amdgpu_dm_update_cursor (v2)  This commit adds a null check for the 'afb' variable in the amdgpu_dm_update_cursor function. Previously, 'afb' was assumed to be null at line 8388, but was used later in the code without a null check. This could potentially lead to a null pointer dereference.  Changes since v1: - Moved the null check for 'afb' to the line where 'afb' is used. (Alex)  Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:8433 amdgpu_dm_update_cursor() error: we previously assumed 'afb' could be null (see line 8388)",
      "cve": "CVE-2024-49908",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49908",
          "value": "CVE-2024-49908",
          "url": "https://scout.docker.com/v/CVE-2024-49908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2479b73fe5d5512dd9ac160faa11b547286a9d6462391d4451bdaf583289b1f",
      "category": "container_scanning",
      "message": "CVE-2024-49909 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for function pointer in dcn32_set_output_transfer_func  This commit adds a null check for the set_output_gamma function pointer in the dcn32_set_output_transfer_func function. Previously, set_output_gamma was being checked for null, but then it was being dereferenced without any null check. This could lead to a null pointer dereference if set_output_gamma is null.  To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma.",
      "cve": "CVE-2024-49909",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49909",
          "value": "CVE-2024-49909",
          "url": "https://scout.docker.com/v/CVE-2024-49909?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49909?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "08fd76ad27fc346d70960c8d7808f9938c74149ebe3f9bae6071f2c5bd2ba420",
      "category": "container_scanning",
      "message": "CVE-2024-49910 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for function pointer in dcn401_set_output_transfer_func  This commit adds a null check for the set_output_gamma function pointer in the dcn401_set_output_transfer_func function. Previously, set_output_gamma was being checked for null, but then it was being dereferenced without any null check. This could lead to a null pointer dereference if set_output_gamma is null.  To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma.",
      "cve": "CVE-2024-49910",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49910",
          "value": "CVE-2024-49910",
          "url": "https://scout.docker.com/v/CVE-2024-49910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49910?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d4421158403f605fccbc592a80fe6c756b620b13de9a755503ac096a5156ce51",
      "category": "container_scanning",
      "message": "CVE-2024-49911 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for function pointer in dcn20_set_output_transfer_func  This commit adds a null check for the set_output_gamma function pointer in the dcn20_set_output_transfer_func function. Previously, set_output_gamma was being checked for null at line 1030, but then it was being dereferenced without any null check at line 1048. This could potentially lead to a null pointer dereference error if set_output_gamma is null.  To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma at line 1048.",
      "cve": "CVE-2024-49911",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49911",
          "value": "CVE-2024-49911",
          "url": "https://scout.docker.com/v/CVE-2024-49911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49911?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6ef001840a8808c236fa46fca34eb67c9ab3c80a8fdd465f5a706fec742fa55e",
      "category": "container_scanning",
      "message": "CVE-2024-49912 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Handle null 'stream_status' in 'planes_changed_for_existing_stream'  This commit adds a null check for 'stream_status' in the function 'planes_changed_for_existing_stream'. Previously, the code assumed 'stream_status' could be null, but did not handle the case where it was actually null. This could lead to a null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:3784 planes_changed_for_existing_stream() error: we previously assumed 'stream_status' could be null (see line 3774)",
      "cve": "CVE-2024-49912",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49912",
          "value": "CVE-2024-49912",
          "url": "https://scout.docker.com/v/CVE-2024-49912?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49912?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "35abcc2716d3b4a452618bb4fcb9cfbcd1a18ee590d3f36ea8cd00dca8f5100c",
      "category": "container_scanning",
      "message": "CVE-2024-49914 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add null check for pipe_ctx->plane_state in dcn20_program_pipe  This commit addresses a null pointer dereference issue in the `dcn20_program_pipe` function. The issue could occur when `pipe_ctx->plane_state` is null.  The fix adds a check to ensure `pipe_ctx->plane_state` is not null before accessing. This prevents a null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn20/dcn20_hwseq.c:1925 dcn20_program_pipe() error: we previously assumed 'pipe_ctx->plane_state' could be null (see line 1877)",
      "cve": "CVE-2024-49914",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49914",
          "value": "CVE-2024-49914",
          "url": "https://scout.docker.com/v/CVE-2024-49914?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49914?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1b814b2bb9b967490275f2631e4c7c15ded832618adc59c33489443ea1b27625",
      "category": "container_scanning",
      "message": "CVE-2024-49915 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for clk_mgr in dcn32_init_hw  This commit addresses a potential null pointer dereference issue in the `dcn32_init_hw` function. The issue could occur when `dc->clk_mgr` is null.  The fix adds a check to ensure `dc->clk_mgr` is not null before accessing its functions. This prevents a potential null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn32/dcn32_hwseq.c:961 dcn32_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 782)",
      "cve": "CVE-2024-49915",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49915",
          "value": "CVE-2024-49915",
          "url": "https://scout.docker.com/v/CVE-2024-49915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fe3e62e8c32be5a75e4d017553412b3b59f8fa97128d1b881b536870ef011762",
      "category": "container_scanning",
      "message": "CVE-2024-49916 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn401_init_hw  This commit addresses a potential null pointer dereference issue in the `dcn401_init_hw` function. The issue could occur when `dc->clk_mgr` or `dc->clk_mgr->funcs` is null.  The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is not null before accessing its functions. This prevents a potential null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn401/dcn401_hwseq.c:416 dcn401_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 225)",
      "cve": "CVE-2024-49916",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49916",
          "value": "CVE-2024-49916",
          "url": "https://scout.docker.com/v/CVE-2024-49916?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49916?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e6ae1d057234e4a3eedeedd60046cf55cd8e69c99697b7d8602e8201b1cf38d4",
      "category": "container_scanning",
      "message": "CVE-2024-49917 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn30_init_hw  This commit addresses a potential null pointer dereference issue in the `dcn30_init_hw` function. The issue could occur when `dc->clk_mgr` or `dc->clk_mgr->funcs` is null.  The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is not null before accessing its functions. This prevents a potential null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:789 dcn30_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 628)",
      "cve": "CVE-2024-49917",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49917",
          "value": "CVE-2024-49917",
          "url": "https://scout.docker.com/v/CVE-2024-49917?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49917?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9c527bef24a004e1e2e1a499dee7e8b04bfc17d5de009f9728fdd4b1083ccadc",
      "category": "container_scanning",
      "message": "CVE-2024-49918 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add null check for head_pipe in dcn32_acquire_idle_pipe_for_head_pipe_in_layer  This commit addresses a potential null pointer dereference issue in the `dcn32_acquire_idle_pipe_for_head_pipe_in_layer` function. The issue could occur when `head_pipe` is null.  The fix adds a check to ensure `head_pipe` is not null before asserting it. If `head_pipe` is null, the function returns NULL to prevent a potential null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn32/dcn32_resource.c:2690 dcn32_acquire_idle_pipe_for_head_pipe_in_layer() error: we previously assumed 'head_pipe' could be null (see line 2681)",
      "cve": "CVE-2024-49918",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49918",
          "value": "CVE-2024-49918",
          "url": "https://scout.docker.com/v/CVE-2024-49918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "807dfbe28a5fe4c7dd591b2ee4124d8fb0cdcf5e87c9571e379d7054cc9bcea7",
      "category": "container_scanning",
      "message": "CVE-2024-49919 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Add null check for head_pipe in dcn201_acquire_free_pipe_for_layer  This commit addresses a potential null pointer dereference issue in the `dcn201_acquire_free_pipe_for_layer` function. The issue could occur when `head_pipe` is null.  The fix adds a check to ensure `head_pipe` is not null before asserting it. If `head_pipe` is null, the function returns NULL to prevent a potential null pointer dereference.  Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn201/dcn201_resource.c:1016 dcn201_acquire_free_pipe_for_layer() error: we previously assumed 'head_pipe' could be null (see line 1010)",
      "cve": "CVE-2024-49919",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49919",
          "value": "CVE-2024-49919",
          "url": "https://scout.docker.com/v/CVE-2024-49919?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49919?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ea6f2f44643c941dbc3074c870120c150e94d58158b4794bedfeb062c129704e",
      "category": "container_scanning",
      "message": "CVE-2024-49920 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null pointers before multiple uses  [WHAT & HOW] Poniters, such as stream_enc and dc->bw_vbios, are null checked previously in the same function, so Coverity warns \"implies that stream_enc and dc->bw_vbios might be null\". They are used multiple times in the subsequent code and need to be checked.  This fixes 10 FORWARD_NULL issues reported by Coverity.",
      "cve": "CVE-2024-49920",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49920",
          "value": "CVE-2024-49920",
          "url": "https://scout.docker.com/v/CVE-2024-49920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49920?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "edcca7f2a3df1e5ac7fb99c28d039e11b35d82022b5271c56ae10e398cc07574",
      "category": "container_scanning",
      "message": "CVE-2024-49921 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null pointers before used  [WHAT & HOW] Poniters, such as dc->clk_mgr, are null checked previously in the same function, so Coverity warns \"implies that \"dc->clk_mgr\" might be null\". As a result, these pointers need to be checked when used again.  This fixes 10 FORWARD_NULL issues reported by Coverity.",
      "cve": "CVE-2024-49921",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49921",
          "value": "CVE-2024-49921",
          "url": "https://scout.docker.com/v/CVE-2024-49921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f070e7ced802908fff693e1b31d8e4145db1efc0b166b7385d22f6a8357e2d7d",
      "category": "container_scanning",
      "message": "CVE-2024-49922 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null pointers before using them  [WHAT & HOW] These pointers are null checked previously in the same function, indicating they might be null as reported by Coverity. As a result, they need to be checked when used again.  This fixes 3 FORWARD_NULL issue reported by Coverity.",
      "cve": "CVE-2024-49922",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49922",
          "value": "CVE-2024-49922",
          "url": "https://scout.docker.com/v/CVE-2024-49922?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49922?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "edf5ad9bddbc3a83a9eb2a6a41d2e6fea3efd1832a701641b2a2defd4be03415",
      "category": "container_scanning",
      "message": "CVE-2024-49923 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Pass non-null to dcn20_validate_apply_pipe_split_flags  [WHAT & HOW] \"dcn20_validate_apply_pipe_split_flags\" dereferences merge, and thus it cannot be a null pointer. Let's pass a valid pointer to avoid null dereference.  This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "cve": "CVE-2024-49923",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49923",
          "value": "CVE-2024-49923",
          "url": "https://scout.docker.com/v/CVE-2024-49923?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49923?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "12099bdd2a289e6142f2795c6a39e4e540944fc66c6143f490428ca388ba074c",
      "category": "container_scanning",
      "message": "CVE-2024-49926 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcu-tasks: Fix access non-existent percpu rtpcp variable in rcu_tasks_need_gpcb()  For kernels built with CONFIG_FORCE_NR_CPUS=y, the nr_cpu_ids is defined as NR_CPUS instead of the number of possible cpus, this will cause the following system panic:  smpboot: Allowing 4 CPUs, 0 hotplug CPUs ... setup_percpu: NR_CPUS:512 nr_cpumask_bits:512 nr_cpu_ids:512 nr_node_ids:1 ... BUG: unable to handle page fault for address: ffffffff9911c8c8 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 15 Comm: rcu_tasks_trace Tainted: G W 6.6.21 #1 5dc7acf91a5e8e9ac9dcfc35bee0245691283ea6 RIP: 0010:rcu_tasks_need_gpcb+0x25d/0x2c0 RSP: 0018:ffffa371c00a3e60 EFLAGS: 00010082 CR2: ffffffff9911c8c8 CR3: 000000040fa20005 CR4: 00000000001706f0 Call Trace: <TASK> ? __die+0x23/0x80 ? page_fault_oops+0xa4/0x180 ? exc_page_fault+0x152/0x180 ? asm_exc_page_fault+0x26/0x40 ? rcu_tasks_need_gpcb+0x25d/0x2c0 ? __pfx_rcu_tasks_kthread+0x40/0x40 rcu_tasks_one_gp+0x69/0x180 rcu_tasks_kthread+0x94/0xc0 kthread+0xe8/0x140 ? __pfx_kthread+0x40/0x40 ret_from_fork+0x34/0x80 ? __pfx_kthread+0x40/0x40 ret_from_fork_asm+0x1b/0x80 </TASK>  Considering that there may be holes in the CPU numbers, use the maximum possible cpu number, instead of nr_cpu_ids, for configuring enqueue and dequeue limits.  [ neeraj.upadhyay: Fix htmldocs build error reported by Stephen Rothwell ]",
      "cve": "CVE-2024-49926",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49926",
          "value": "CVE-2024-49926",
          "url": "https://scout.docker.com/v/CVE-2024-49926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49926?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0788a7c32d41e0440e4817e1eb0de46bb7c3398e522298c1997a4fc7d6d7784d",
      "category": "container_scanning",
      "message": "CVE-2024-49929 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: avoid NULL pointer dereference  iwl_mvm_tx_skb_sta() and iwl_mvm_tx_mpdu() verify that the mvmvsta pointer is not NULL. It retrieves this pointer using iwl_mvm_sta_from_mac80211, which is dereferencing the ieee80211_sta pointer. If sta is NULL, iwl_mvm_sta_from_mac80211 will dereference a NULL pointer. Fix this by checking the sta pointer before retrieving the mvmsta from it. If sta is not NULL, then mvmsta isn't either.",
      "cve": "CVE-2024-49929",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49929",
          "value": "CVE-2024-49929",
          "url": "https://scout.docker.com/v/CVE-2024-49929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5932de0f7a33000534339128d37016873b620583445bb1cdcea156a606500029",
      "category": "container_scanning",
      "message": "CVE-2024-49932 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: don't readahead the relocation inode on RST  On relocation we're doing readahead on the relocation inode, but if the filesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due to preallocated extents not being mapped in the RST) from the lookup.  But readahead doesn't handle the error and submits invalid reads to the device, causing an assertion in the scatter-gather list code:  BTRFS info (device nvme1n1): balance: start -d -m -s BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0 BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192, 6481969152] devid 2, profile raid0 ------------[ cut here ]------------ kernel BUG at include/linux/scatterlist.h:115! Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567 RIP: 0010:__blk_rq_map_sg+0x339/0x4a0 RSP: 0018:ffffc90001a43820 EFLAGS: 00010202 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802 RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000 RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8 R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000 FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0 Call Trace: <TASK> ? __die_body.cold+0x14/0x25 ? die+0x2e/0x50 ? do_trap+0xca/0x110 ? do_error_trap+0x65/0x80 ? __blk_rq_map_sg+0x339/0x4a0 ? exc_invalid_op+0x50/0x70 ? __blk_rq_map_sg+0x339/0x4a0 ? asm_exc_invalid_op+0x1a/0x20 ? __blk_rq_map_sg+0x339/0x4a0 nvme_prep_rq.part.0+0x9d/0x770 nvme_queue_rq+0x7d/0x1e0 __blk_mq_issue_directly+0x2a/0x90 ? blk_mq_get_budget_and_tag+0x61/0x90 blk_mq_try_issue_list_directly+0x56/0xf0 blk_mq_flush_plug_list.part.0+0x52b/0x5d0 __blk_flush_plug+0xc6/0x110 blk_finish_plug+0x28/0x40 read_pages+0x160/0x1c0 page_cache_ra_unbounded+0x109/0x180 relocate_file_extent_cluster+0x611/0x6a0 ? btrfs_search_slot+0xba4/0xd20 ? balance_dirty_pages_ratelimited_flags+0x26/0xb00 relocate_data_extent.constprop.0+0x134/0x160 relocate_block_group+0x3f2/0x500 btrfs_relocate_block_group+0x250/0x430 btrfs_relocate_chunk+0x3f/0x130 btrfs_balance+0x71b/0xef0 ? kmalloc_trace_noprof+0x13b/0x280 btrfs_ioctl+0x2c2e/0x3030 ? kvfree_call_rcu+0x1e6/0x340 ? list_lru_add_obj+0x66/0x80 ? mntput_no_expire+0x3a/0x220 __x64_sys_ioctl+0x96/0xc0 do_syscall_64+0x54/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fcc04514f9b Code: Unable to access opcode bytes at 0x7fcc04514f71. RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9b RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003 RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001 R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5 R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:__blk_rq_map_sg+0x339/0x4a0 RSP: 0018:ffffc90001a43820 EFLAGS: 00010202 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802 RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000 RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8 R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000 FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0 Kernel p ---truncated---",
      "cve": "CVE-2024-49932",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49932",
          "value": "CVE-2024-49932",
          "url": "https://scout.docker.com/v/CVE-2024-49932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "600a4f38025e206a1abad75aed537ca115bc50b280eb7e35bfe1ab4b4e48dd83",
      "category": "container_scanning",
      "message": "CVE-2024-49939 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: avoid to add interface to list twice when SER  If SER L2 occurs during the WoWLAN resume flow, the add interface flow is triggered by ieee80211_reconfig(). However, due to rtw89_wow_resume() return failure, it will cause the add interface flow to be executed again, resulting in a double add list and causing a kernel panic. Therefore, we have added a check to prevent double adding of the list.  list_add double add: new=ffff99d6992e2010, prev=ffff99d6992e2010, next=ffff99d695302628. ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:37! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 0 PID: 9 Comm: kworker/0:1 Tainted: G        W  O 6.6.30-02659-gc18865c4dfbd #1 770df2933251a0e3c888ba69d1053a817a6376a7 Hardware name: HP Grunt/Grunt, BIOS Google_Grunt.11031.169.0 06/24/2021 Workqueue: events_freezable ieee80211_restart_work [mac80211] RIP: 0010:__list_add_valid_or_report+0x5e/0xb0 Code: c7 74 18 48 39 ce 74 13 b0 01 59 5a 5e 5f 41 58 41 59 41 5a 5d e9 e2 d6 03 00 cc 48 c7 c7 8d 4f 17 83 48 89 c2 e8 02 c0 00 00 <0f> 0b 48 c7 c7 aa 8c 1c 83 e8 f4 bf 00 00 0f 0b 48 c7 c7 c8 bc 12 RSP: 0018:ffffa91b8007bc50 EFLAGS: 00010246 RAX: 0000000000000058 RBX: ffff99d6992e0900 RCX: a014d76c70ef3900 RDX: ffffa91b8007bae8 RSI: 00000000ffffdfff RDI: 0000000000000001 RBP: ffffa91b8007bc88 R08: 0000000000000000 R09: ffffa91b8007bae0 R10: 00000000ffffdfff R11: ffffffff83a79800 R12: ffff99d695302060 R13: ffff99d695300900 R14: ffff99d6992e1be0 R15: ffff99d6992e2010 FS:  0000000000000000(0000) GS:ffff99d6aac00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000078fbdba43480 CR3: 000000010e464000 CR4: 00000000001506f0 Call Trace: <TASK> ? __die_body+0x1f/0x70 ? die+0x3d/0x60 ? do_trap+0xa4/0x110 ? __list_add_valid_or_report+0x5e/0xb0 ? do_error_trap+0x6d/0x90 ? __list_add_valid_or_report+0x5e/0xb0 ? handle_invalid_op+0x30/0x40 ? __list_add_valid_or_report+0x5e/0xb0 ? exc_invalid_op+0x3c/0x50 ? asm_exc_invalid_op+0x16/0x20 ? __list_add_valid_or_report+0x5e/0xb0 rtw89_ops_add_interface+0x309/0x310 [rtw89_core 7c32b1ee6854761c0321027c8a58c5160e41f48f] drv_add_interface+0x5c/0x130 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] ieee80211_reconfig+0x241/0x13d0 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] ? finish_wait+0x3e/0x90 ? synchronize_rcu_expedited+0x174/0x260 ? sync_rcu_exp_done_unlocked+0x50/0x50 ? wake_bit_function+0x40/0x40 ieee80211_restart_work+0xf0/0x140 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] process_scheduled_works+0x1e5/0x480 worker_thread+0xea/0x1e0 kthread+0xdb/0x110 ? move_linked_works+0x90/0x90 ? kthread_associate_blkcg+0xa0/0xa0 ret_from_fork+0x3b/0x50 ? kthread_associate_blkcg+0xa0/0xa0 ret_from_fork_asm+0x11/0x20 </TASK> Modules linked in: dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc rfcomm cmac uinput algif_hash algif_skcipher af_alg btusb btrtl iio_trig_hrtimer industrialio_sw_trigger btmtk industrialio_configfs btbcm btintel uvcvideo videobuf2_vmalloc iio_trig_sysfs videobuf2_memops videobuf2_v4l2 videobuf2_common uvc snd_hda_codec_hdmi veth snd_hda_intel snd_intel_dspcfg acpi_als snd_hda_codec industrialio_triggered_buffer kfifo_buf snd_hwdep industrialio i2c_piix4 snd_hda_core designware_i2s ip6table_nat snd_soc_max98357a xt_MASQUERADE xt_cgroup snd_soc_acp_rt5682_mach fuse rtw89_8922ae(O) rtw89_8922a(O) rtw89_pci(O) rtw89_core(O) 8021q mac80211(O) bluetooth ecdh_generic ecc cfg80211 r8152 mii joydev gsmi: Log Shutdown Reason 0x03 ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2024-49939",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49939",
          "value": "CVE-2024-49939",
          "url": "https://scout.docker.com/v/CVE-2024-49939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8b072c43cd4cfdeecd964a8d759f38eaaac83b75c4f60d3c2b51cbaf3f33dc4c",
      "category": "container_scanning",
      "message": "CVE-2024-49940 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  l2tp: prevent possible tunnel refcount underflow  When a session is created, it sets a backpointer to its tunnel. When the session refcount drops to 0, l2tp_session_free drops the tunnel refcount if session->tunnel is non-NULL. However, session->tunnel is set in l2tp_session_create, before the tunnel refcount is incremented by l2tp_session_register, which leaves a small window where session->tunnel is non-NULL when the tunnel refcount hasn't been bumped.  Moving the assignment to l2tp_session_register is trivial but l2tp_session_create calls l2tp_session_set_header_len which uses session->tunnel to get the tunnel's encap. Add an encap arg to l2tp_session_set_header_len to avoid using session->tunnel.  If l2tpv3 sessions have colliding IDs, it is possible for l2tp_v3_session_get to race with l2tp_session_register and fetch a session which doesn't yet have session->tunnel set. Add a check for this case.",
      "cve": "CVE-2024-49940",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49940",
          "value": "CVE-2024-49940",
          "url": "https://scout.docker.com/v/CVE-2024-49940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49940?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4c2f84015b4b38a6c01b1609a1ec64143d399267c574df78072c5232d503fd36",
      "category": "container_scanning",
      "message": "CVE-2024-49945 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/ncsi: Disable the ncsi work before freeing the associated structure  The work function can run after the ncsi device is freed, resulting in use-after-free bugs or kernel panic.",
      "cve": "CVE-2024-49945",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49945",
          "value": "CVE-2024-49945",
          "url": "https://scout.docker.com/v/CVE-2024-49945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1faf6127e9b142b95b2a0a4fcec881a2817aa951d260be59e879ea6bdd634c7e",
      "category": "container_scanning",
      "message": "CVE-2024-49961 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: i2c: ar0521: Use cansleep version of gpiod_set_value()  If we use GPIO reset from I2C port expander, we must use *_cansleep() variant of GPIO functions. This was not done in ar0521_power_on()/ar0521_power_off() functions. Let's fix that.  ------------[ cut here ]------------ WARNING: CPU: 0 PID: 11 at drivers/gpio/gpiolib.c:3496 gpiod_set_value+0x74/0x7c Modules linked in: CPU: 0 PID: 11 Comm: kworker/u16:0 Not tainted 6.10.0 #53 Hardware name: Diasom DS-RK3568-SOM-EVB (DT) Workqueue: events_unbound deferred_probe_work_func pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : gpiod_set_value+0x74/0x7c lr : ar0521_power_on+0xcc/0x290 sp : ffffff8001d7ab70 x29: ffffff8001d7ab70 x28: ffffff80027dcc90 x27: ffffff8003c82000 x26: ffffff8003ca9250 x25: ffffffc080a39c60 x24: ffffff8003ca9088 x23: ffffff8002402720 x22: ffffff8003ca9080 x21: ffffff8003ca9088 x20: 0000000000000000 x19: ffffff8001eb2a00 x18: ffffff80efeeac80 x17: 756d2d6332692f30 x16: 0000000000000000 x15: 0000000000000000 x14: ffffff8001d91d40 x13: 0000000000000016 x12: ffffffc080e98930 x11: ffffff8001eb2880 x10: 0000000000000890 x9 : ffffff8001d7a9f0 x8 : ffffff8001d92570 x7 : ffffff80efeeac80 x6 : 000000003fc6e780 x5 : ffffff8001d91c80 x4 : 0000000000000002 x3 : 0000000000000000 x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000001 Call trace: gpiod_set_value+0x74/0x7c ar0521_power_on+0xcc/0x290 ...",
      "cve": "CVE-2024-49961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49961",
          "value": "CVE-2024-49961",
          "url": "https://scout.docker.com/v/CVE-2024-49961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "337aed1bd29cc1343f6ecf845989ccebc407b693d0d3eba5171fd3955bcddd25",
      "category": "container_scanning",
      "message": "CVE-2024-49970 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Implement bounds check for stream encoder creation in DCN401  'stream_enc_regs' array is an array of dcn10_stream_enc_registers structures. The array is initialized with four elements, corresponding to the four calls to stream_enc_regs() in the array initializer. This means that valid indices for this array are 0, 1, 2, and 3.  The error message 'stream_enc_regs' 4 <= 5 below, is indicating that there is an attempt to access this array with an index of 5, which is out of bounds. This could lead to undefined behavior  Here, eng_id is used as an index to access the stream_enc_regs array. If eng_id is 5, this would result in an out-of-bounds access on the stream_enc_regs array.  Thus fixing Buffer overflow error in dcn401_stream_encoder_create  Found by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn401/dcn401_resource.c:1209 dcn401_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",
      "cve": "CVE-2024-49970",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49970",
          "value": "CVE-2024-49970",
          "url": "https://scout.docker.com/v/CVE-2024-49970?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49970?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9f2bcbbd0870ca0a609075e0a52912f9fcd57535c563196cc213719c20965d6d",
      "category": "container_scanning",
      "message": "CVE-2024-49978 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gso: fix udp gso fraglist segmentation after pull from frag_list  Detect gso fraglist skbs with corrupted geometry (see below) and pass these to skb_segment instead of skb_segment_list, as the first can segment them correctly.  Valid SKB_GSO_FRAGLIST skbs - consist of two or more segments - the head_skb holds the protocol headers plus first gso_size - one or more frag_list skbs hold exactly one segment - all but the last must be gso_size  Optional datapath hooks such as NAT and BPF (bpf_skb_pull_data) can modify these skbs, breaking these invariants.  In extreme cases they pull all data into skb linear. For UDP, this causes a NULL ptr deref in __udpv4_gso_segment_list_csum at udp_hdr(seg->next)->dest.  Detect invalid geometry due to pull, by checking head_skb size. Don't just drop, as this may blackhole a destination. Convert to be able to pass to regular skb_segment.",
      "cve": "CVE-2024-49978",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49978",
          "value": "CVE-2024-49978",
          "url": "https://scout.docker.com/v/CVE-2024-49978?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49978?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "42b485565c2dd042d49045ff7b1b3fc145ca6a907266244be14dee63fc7d6457",
      "category": "container_scanning",
      "message": "CVE-2024-49987 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpftool: Fix undefined behavior in qsort(NULL, 0, ...)  When netfilter has no entry to display, qsort is called with qsort(NULL, 0, ...). This results in undefined behavior, as UBSan reports:  net.c:827:2: runtime error: null pointer passed as argument 1, which is declared to never be null  Although the C standard does not explicitly state whether calling qsort with a NULL pointer when the size is 0 constitutes undefined behavior, Section 7.1.4 of the C standard (Use of library functions) mentions:  \"Each of the following statements applies unless explicitly stated otherwise in the detailed descriptions that follow: If an argument to a function has an invalid value (such as a value outside the domain of the function, or a pointer outside the address space of the program, or a null pointer, or a pointer to non-modifiable storage when the corresponding parameter is not const-qualified) or a type (after promotion) not expected by a function with variable number of arguments, the behavior is undefined.\"  To avoid this, add an early return when nf_link_info is NULL to prevent calling qsort with a NULL pointer.",
      "cve": "CVE-2024-49987",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49987",
          "value": "CVE-2024-49987",
          "url": "https://scout.docker.com/v/CVE-2024-49987?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49987?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3351ea5a00283550783b3e74a599d1c176c62c24002f0c6ffeef8a9a00f5e6d1",
      "category": "container_scanning",
      "message": "CVE-2024-49988 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: add refcnt to ksmbd_conn struct  When sending an oplock break request, opinfo->conn is used, But freed ->conn can be used on multichannel. This patch add a reference count to the ksmbd_conn struct so that it can be freed when it is no longer used.",
      "cve": "CVE-2024-49988",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49988",
          "value": "CVE-2024-49988",
          "url": "https://scout.docker.com/v/CVE-2024-49988?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49988?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cfc386d32cd57eace76034cd664a1649bf012eb0942716b4325908cff10bde6e",
      "category": "container_scanning",
      "message": "CVE-2024-49990 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/hdcp: Check GSC structure validity  Sometimes xe_gsc is not initialized when checked at HDCP capability check. Add gsc structure check to avoid null pointer error.",
      "cve": "CVE-2024-49990",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49990",
          "value": "CVE-2024-49990",
          "url": "https://scout.docker.com/v/CVE-2024-49990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "81a13405e5b2356621803336868b68ee4c99e00ffe1351cece5ccb37b399ac17",
      "category": "container_scanning",
      "message": "CVE-2024-49994 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: fix integer overflow in BLKSECDISCARD  I independently rediscovered  commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155 block: fix overflow in blk_ioctl_discard()  but for secure erase.  Same problem:  uint64_t r[2] = {512, 18446744073709551104ULL}; ioctl(fd, BLKSECDISCARD, r);  will enter near infinite loop inside blkdev_issue_secure_erase():  a.out: attempt to access beyond end of device loop0: rw=5, sector=3399043073, nr_sectors = 1024 limit=2048 bio_check_eod: 3286214 callbacks suppressed",
      "cve": "CVE-2024-49994",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49994",
          "value": "CVE-2024-49994",
          "url": "https://scout.docker.com/v/CVE-2024-49994?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49994?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2998446ccedc6e51bffcc2ea7ef4afccd9e43eb6cc32a29a4228ac80011ac5c",
      "category": "container_scanning",
      "message": "CVE-2024-50004 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: update DML2 policy EnhancedPrefetchScheduleAccelerationFinal DCN35  [WHY & HOW] Mismatch in DCN35 DML2 cause bw validation failed to acquire unexpected DPP pipe to cause grey screen and system hang. Remove EnhancedPrefetchScheduleAccelerationFinal value override to match HW spec.  (cherry picked from commit 9dad21f910fcea2bdcff4af46159101d7f9cd8ba)",
      "cve": "CVE-2024-50004",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50004",
          "value": "CVE-2024-50004",
          "url": "https://scout.docker.com/v/CVE-2024-50004?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50004?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "661c3a6c93ba41f660dbaebc02ccd283fb884cdea28c3b7e4ac86a253ccc3113",
      "category": "container_scanning",
      "message": "CVE-2024-50009 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpufreq: amd-pstate: add check for cpufreq_cpu_get's return value  cpufreq_cpu_get may return NULL. To avoid NULL-dereference check it and return in case of error.  Found by Linux Verification Center (linuxtesting.org) with SVACE.",
      "cve": "CVE-2024-50009",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50009",
          "value": "CVE-2024-50009",
          "url": "https://scout.docker.com/v/CVE-2024-50009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50009?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0146f0cc22cf3f7aa9a9b5098b6fc3463335828a87bae5155200d282bf05d4f6",
      "category": "container_scanning",
      "message": "CVE-2024-50012 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cpufreq: Avoid a bad reference count on CPU node  In the parse_perf_domain function, if the call to of_parse_phandle_with_args returns an error, then the reference to the CPU device node that was acquired at the start of the function would not be properly decremented.  Address this by declaring the variable with the __free(device_node) cleanup attribute.",
      "cve": "CVE-2024-50012",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50012",
          "value": "CVE-2024-50012",
          "url": "https://scout.docker.com/v/CVE-2024-50012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "91ef2da2878844e3b729e59ee20fe634d5f1110538c9dace2e3764b2d0bbb447",
      "category": "container_scanning",
      "message": "CVE-2024-50014 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: fix access to uninitialised lock in fc replay path  The following kernel trace can be triggered with fstest generic/629 when executed against a filesystem with fast-commit feature enabled:  INFO: trying to register non-static key. The code is fine but needs lockdep annotation, or maybe you didn't initialize this object before use? turning off the locking correctness validator. CPU: 0 PID: 866 Comm: mount Not tainted 6.10.0+ #11 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x66/0x90 register_lock_class+0x759/0x7d0 __lock_acquire+0x85/0x2630 ? __find_get_block+0xb4/0x380 lock_acquire+0xd1/0x2d0 ? __ext4_journal_get_write_access+0xd5/0x160 _raw_spin_lock+0x33/0x40 ? __ext4_journal_get_write_access+0xd5/0x160 __ext4_journal_get_write_access+0xd5/0x160 ext4_reserve_inode_write+0x61/0xb0 __ext4_mark_inode_dirty+0x79/0x270 ? ext4_ext_replay_set_iblocks+0x2f8/0x450 ext4_ext_replay_set_iblocks+0x330/0x450 ext4_fc_replay+0x14c8/0x1540 ? jread+0x88/0x2e0 ? rcu_is_watching+0x11/0x40 do_one_pass+0x447/0xd00 jbd2_journal_recover+0x139/0x1b0 jbd2_journal_load+0x96/0x390 ext4_load_and_init_journal+0x253/0xd40 ext4_fill_super+0x2cc6/0x3180 ...  In the replay path there's an attempt to lock sbi->s_bdev_wb_lock in function ext4_check_bdev_write_error().  Unfortunately, at this point this spinlock has not been initialized yet.  Moving it's initialization to an earlier point in __ext4_fill_super() fixes this splat.",
      "cve": "CVE-2024-50014",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50014",
          "value": "CVE-2024-50014",
          "url": "https://scout.docker.com/v/CVE-2024-50014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "82325106943e1e6877895e441544e72347dee9234a0d6a229d2da8030c832ccb",
      "category": "container_scanning",
      "message": "CVE-2024-50017 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/mm/ident_map: Use gbpages only where full GB page should be mapped.  When ident_pud_init() uses only GB pages to create identity maps, large ranges of addresses not actually requested can be included in the resulting table; a 4K request will map a full GB.  This can include a lot of extra address space past that requested, including areas marked reserved by the BIOS.  That allows processor speculation into reserved regions, that on UV systems can cause system halts.  Only use GB pages when map creation requests include the full GB page of space.  Fall back to using smaller 2M pages when only portions of a GB page are included in the request.  No attempt is made to coalesce mapping requests. If a request requires a map entry at the 2M (pmd) level, subsequent mapping requests within the same 1G region will also be at the pmd level, even if adjacent or overlapping such requests could have been combined to map a full GB page. Existing usage starts with larger regions and then adds smaller regions, so this should not have any great consequence.",
      "cve": "CVE-2024-50017",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50017",
          "value": "CVE-2024-50017",
          "url": "https://scout.docker.com/v/CVE-2024-50017?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50017?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "624d6921795f6bb2ebb4579fe48f6b1b44d46044995edc284deda4db828e8391",
      "category": "container_scanning",
      "message": "CVE-2024-50028 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  thermal: core: Reference count the zone in thermal_zone_get_by_id()  There are places in the thermal netlink code where nothing prevents the thermal zone object from going away while being accessed after it has been returned by thermal_zone_get_by_id().  To address this, make thermal_zone_get_by_id() get a reference on the thermal zone device object to be returned with the help of get_device(), under thermal_list_lock, and adjust all of its callers to this change with the help of the cleanup.h infrastructure.",
      "cve": "CVE-2024-50028",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50028",
          "value": "CVE-2024-50028",
          "url": "https://scout.docker.com/v/CVE-2024-50028?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50028?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a650753892a2ba7145760befa2c73e6ec5c4e28bab5bfa6916a2b367f90400f5",
      "category": "container_scanning",
      "message": "CVE-2024-50034 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: fix lacks of icsk_syn_mss with IPPROTO_SMC  Eric report a panic on IPPROTO_SMC, and give the facts that when INET_PROTOSW_ICSK was set, icsk->icsk_sync_mss must be set too.  Bug: Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Mem abort info: ESR = 0x0000000086000005 EC = 0x21: IABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x05: level 1 translation fault user pgtable: 4k pages, 48-bit VAs, pgdp=00000001195d1000 [0000000000000000] pgd=0800000109c46003, p4d=0800000109c46003, pud=0000000000000000 Internal error: Oops: 0000000086000005 [#1] PREEMPT SMP Modules linked in: CPU: 1 UID: 0 PID: 8037 Comm: syz.3.265 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : 0x0 lr : cipso_v4_sock_setattr+0x2a8/0x3c0 net/ipv4/cipso_ipv4.c:1910 sp : ffff80009b887a90 x29: ffff80009b887aa0 x28: ffff80008db94050 x27: 0000000000000000 x26: 1fffe0001aa6f5b3 x25: dfff800000000000 x24: ffff0000db75da00 x23: 0000000000000000 x22: ffff0000d8b78518 x21: 0000000000000000 x20: ffff0000d537ad80 x19: ffff0000d8b78000 x18: 1fffe000366d79ee x17: ffff8000800614a8 x16: ffff800080569b84 x15: 0000000000000001 x14: 000000008b336894 x13: 00000000cd96feaa x12: 0000000000000003 x11: 0000000000040000 x10: 00000000000020a3 x9 : 1fffe0001b16f0f1 x8 : 0000000000000000 x7 : 0000000000000000 x6 : 000000000000003f x5 : 0000000000000040 x4 : 0000000000000001 x3 : 0000000000000000 x2 : 0000000000000002 x1 : 0000000000000000 x0 : ffff0000d8b78000 Call trace: 0x0 netlbl_sock_setattr+0x2e4/0x338 net/netlabel/netlabel_kapi.c:1000 smack_netlbl_add+0xa4/0x154 security/smack/smack_lsm.c:2593 smack_socket_post_create+0xa8/0x14c security/smack/smack_lsm.c:2973 security_socket_post_create+0x94/0xd4 security/security.c:4425 __sock_create+0x4c8/0x884 net/socket.c:1587 sock_create net/socket.c:1622 [inline] __sys_socket_create net/socket.c:1659 [inline] __sys_socket+0x134/0x340 net/socket.c:1706 __do_sys_socket net/socket.c:1720 [inline] __se_sys_socket net/socket.c:1718 [inline] __arm64_sys_socket+0x7c/0x94 net/socket.c:1718 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598 Code: ???????? ???????? ???????? ???????? (????????) ---[ end trace 0000000000000000 ]---  This patch add a toy implementation that performs a simple return to prevent such panic. This is because MSS can be set in sock_create_kern or smc_setsockopt, similar to how it's done in AF_SMC. However, for AF_SMC, there is currently no way to synchronize MSS within __sys_connect_file. This toy implementation lays the groundwork for us to support such feature for IPPROTO_SMC in the future.",
      "cve": "CVE-2024-50034",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50034",
          "value": "CVE-2024-50034",
          "url": "https://scout.docker.com/v/CVE-2024-50034?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50034?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "007e9132d443b3a875adae65841cf9abac15cdc19273da32d73010d5c8e4e15a",
      "category": "container_scanning",
      "message": "CVE-2024-50048 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbcon: Fix a NULL pointer dereference issue in fbcon_putcs  syzbot has found a NULL pointer dereference bug in fbcon. Here is the simplified C reproducer:  struct param { uint8_t type; struct tiocl_selection ts; };  int main() { struct fb_con2fbmap con2fb; struct param param;  int fd = open(\"/dev/fb1\", 0, 0);  con2fb.console = 0x19; con2fb.framebuffer = 0; ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb);  param.type = 2; param.ts.xs = 0; param.ts.ys = 0; param.ts.xe = 0; param.ts.ye = 0; param.ts.sel_mode = 0;  int fd1 = open(\"/dev/tty1\", O_RDWR, 0); ioctl(fd1, TIOCLINUX, &param);  con2fb.console = 1; con2fb.framebuffer = 0; ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb);  return 0; }  After calling ioctl(fd1, TIOCLINUX, &param), the subsequent ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb) causes the kernel to follow a different execution path:  set_con2fb_map -> con2fb_init_display -> fbcon_set_disp -> redraw_screen -> hide_cursor -> clear_selection -> highlight -> invert_screen -> do_update_region -> fbcon_putcs -> ops->putcs  Since ops->putcs is a NULL pointer, this leads to a kernel panic. To prevent this, we need to call set_blitting_type() within set_con2fb_map() to properly initialize ops->putcs.",
      "cve": "CVE-2024-50048",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50048",
          "value": "CVE-2024-50048",
          "url": "https://scout.docker.com/v/CVE-2024-50048?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50048?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a1f80baeabaef6bf132e13f799902703c16c6fc378db23be008ce29ccbf24c5c",
      "category": "container_scanning",
      "message": "CVE-2024-50056 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: gadget: uvc: Fix ERR_PTR dereference in uvc_v4l2.c  Fix potential dereferencing of ERR_PTR() in find_format_by_pix() and uvc_v4l2_enum_format().  Fix the following smatch errors:  drivers/usb/gadget/function/uvc_v4l2.c:124 find_format_by_pix() error: 'fmtdesc' dereferencing possible ERR_PTR()  drivers/usb/gadget/function/uvc_v4l2.c:392 uvc_v4l2_enum_format() error: 'fmtdesc' dereferencing possible ERR_PTR()  Also, fix similar issue in uvc_v4l2_try_format() for potential dereferencing of ERR_PTR().",
      "cve": "CVE-2024-50056",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50056",
          "value": "CVE-2024-50056",
          "url": "https://scout.docker.com/v/CVE-2024-50056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "878a50beefbd29599e20868c19ccf5dd2875316c9c3bca82182aaedb3ad822ad",
      "category": "container_scanning",
      "message": "CVE-2024-50060 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring: check if we need to reschedule during overflow flush  In terms of normal application usage, this list will always be empty. And if an application does overflow a bit, it'll have a few entries. However, nothing obviously prevents syzbot from running a test case that generates a ton of overflow entries, and then flushing them can take quite a while.  Check for needing to reschedule while flushing, and drop our locks and do so if necessary. There's no state to maintain here as overflows always prune from head-of-list, hence it's fine to drop and reacquire the locks at the end of the loop.",
      "cve": "CVE-2024-50060",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50060",
          "value": "CVE-2024-50060",
          "url": "https://scout.docker.com/v/CVE-2024-50060?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50060?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5922988ec0b105524a3c1ca58c9879c5e735ba34ce374b6eedd57ef90808c704",
      "category": "container_scanning",
      "message": "CVE-2024-50090 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/oa: Fix overflow in oa batch buffer  By default xe_bb_create_job() appends a MI_BATCH_BUFFER_END to batch buffer, this is not a problem if batch buffer is only used once but oa reuses the batch buffer for the same metric and at each call it appends a MI_BATCH_BUFFER_END, printing the warning below and then overflowing.  [  381.072016] ------------[ cut here ]------------ [  381.072019] xe 0000:00:02.0: [drm] Assertion `bb->len * 4 + bb_prefetch(q->gt) <= size` failed! platform: LUNARLAKE subplatform: 1 graphics: Xe2_LPG / Xe2_HPG 20.04 step B0 media: Xe2_LPM / Xe2_HPM 20.00 step B0 tile: 0 VRAM 0 B GT: 0 type 1  So here checking if batch buffer already have MI_BATCH_BUFFER_END if not append it.  v2: - simply fix, suggestion from Ashutosh  (cherry picked from commit 9ba0e0f30ca42a98af3689460063edfb6315718a)",
      "cve": "CVE-2024-50090",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50090",
          "value": "CVE-2024-50090",
          "url": "https://scout.docker.com/v/CVE-2024-50090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50090?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "41d8d03b552ed84beb0575e3dc06718b6de0a4930b759c3ec92b87d3f2c18266",
      "category": "container_scanning",
      "message": "CVE-2024-50091 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dm vdo: don't refer to dedupe_context after releasing it  Clear the dedupe_context pointer in a data_vio whenever ownership of the context is lost, so that vdo can't examine it accidentally.",
      "cve": "CVE-2024-50091",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50091",
          "value": "CVE-2024-50091",
          "url": "https://scout.docker.com/v/CVE-2024-50091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5794eebf8c79f3e154ebbfb3930b2d0b72f20d84f18f2b4ee30cf16702aa9bb",
      "category": "container_scanning",
      "message": "CVE-2024-50098 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Set SDEV_OFFLINE when UFS is shut down  There is a history of deadlock if reboot is performed at the beginning of booting. SDEV_QUIESCE was set for all LU's scsi_devices by UFS shutdown, and at that time the audio driver was waiting on blk_mq_submit_bio() holding a mutex_lock while reading the fw binary. After that, a deadlock issue occurred while audio driver shutdown was waiting for mutex_unlock of blk_mq_submit_bio(). To solve this, set SDEV_OFFLINE for all LUs except WLUN, so that any I/O that comes down after a UFS shutdown will return an error.  [   31.907781]I[0:      swapper/0:    0]        1        130705007 1651079834      11289729804                0 D(   2) 3 ffffff882e208000 * init [device_shutdown] [   31.907793]I[0:      swapper/0:    0] Mutex: 0xffffff8849a2b8b0: owner[0xffffff882e28cb00 kworker/6:0 :49] [   31.907806]I[0:      swapper/0:    0] Call trace: [   31.907810]I[0:      swapper/0:    0]  __switch_to+0x174/0x338 [   31.907819]I[0:      swapper/0:    0]  __schedule+0x5ec/0x9cc [   31.907826]I[0:      swapper/0:    0]  schedule+0x7c/0xe8 [   31.907834]I[0:      swapper/0:    0] schedule_preempt_disabled+0x24/0x40 [   31.907842]I[0:      swapper/0:    0]  __mutex_lock+0x408/0xdac [   31.907849]I[0:      swapper/0:    0]  __mutex_lock_slowpath+0x14/0x24 [   31.907858]I[0:      swapper/0:    0]  mutex_lock+0x40/0xec [   31.907866]I[0:      swapper/0:    0]  device_shutdown+0x108/0x280 [   31.907875]I[0:      swapper/0:    0]  kernel_restart+0x4c/0x11c [   31.907883]I[0:      swapper/0:    0]  __arm64_sys_reboot+0x15c/0x280 [   31.907890]I[0:      swapper/0:    0]  invoke_syscall+0x70/0x158 [   31.907899]I[0:      swapper/0:    0]  el0_svc_common+0xb4/0xf4 [   31.907909]I[0:      swapper/0:    0]  do_el0_svc+0x2c/0xb0 [   31.907918]I[0:      swapper/0:    0]  el0_svc+0x34/0xe0 [   31.907928]I[0:      swapper/0:    0]  el0t_64_sync_handler+0x68/0xb4 [   31.907937]I[0:      swapper/0:    0]  el0t_64_sync+0x1a0/0x1a4  [   31.908774]I[0:      swapper/0:    0]       49                0 11960702      11236868007                0 D(   2) 6 ffffff882e28cb00 * kworker/6:0 [__bio_queue_enter] [   31.908783]I[0:      swapper/0:    0] Call trace: [   31.908788]I[0:      swapper/0:    0]  __switch_to+0x174/0x338 [   31.908796]I[0:      swapper/0:    0]  __schedule+0x5ec/0x9cc [   31.908803]I[0:      swapper/0:    0]  schedule+0x7c/0xe8 [   31.908811]I[0:      swapper/0:    0]  __bio_queue_enter+0xb8/0x178 [   31.908818]I[0:      swapper/0:    0]  blk_mq_submit_bio+0x194/0x67c [   31.908827]I[0:      swapper/0:    0]  __submit_bio+0xb8/0x19c",
      "cve": "CVE-2024-50098",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50098",
          "value": "CVE-2024-50098",
          "url": "https://scout.docker.com/v/CVE-2024-50098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "70337a1b813fa9d399f8c76309ad37e2e11a626c04730887a8acc9e8bf0999d8",
      "category": "container_scanning",
      "message": "CVE-2024-50108 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Disable PSR-SU on Parade 08-01 TCON too  Stuart Hayhurst has found that both at bootup and fullscreen VA-API video is leading to black screens for around 1 second and kernel WARNING [1] traces when calling dmub_psr_enable() with Parade 08-01 TCON.  These symptoms all go away with PSR-SU disabled for this TCON, so disable it for now while DMUB traces [2] from the failure can be analyzed and the failure state properly root caused.  (cherry picked from commit afb634a6823d8d9db23c5fb04f79c5549349628b)",
      "cve": "CVE-2024-50108",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50108",
          "value": "CVE-2024-50108",
          "url": "https://scout.docker.com/v/CVE-2024-50108?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50108?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a4b4f0f56248ead30d113ab1c79fc7063b8a7f2f1b4d7eec27e08eea743af3d",
      "category": "container_scanning",
      "message": "CVE-2024-50111 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  LoongArch: Enable IRQ if do_ale() triggered in irq-enabled context  Unaligned access exception can be triggered in irq-enabled context such as user mode, in this case do_ale() may call get_user() which may cause sleep. Then we will get:  BUG: sleeping function called from invalid context at arch/loongarch/kernel/access-helper.h:7 in_atomic(): 0, irqs_disabled(): 1, non_block: 0, pid: 129, name: modprobe preempt_count: 0, expected: 0 RCU nest depth: 0, expected: 0 CPU: 0 UID: 0 PID: 129 Comm: modprobe Tainted: G        W 6.12.0-rc1+ #1723 Tainted: [W]=WARN Stack : 9000000105e0bd48 0000000000000000 9000000003803944 9000000105e08000 9000000105e0bc70 9000000105e0bc78 0000000000000000 0000000000000000 9000000105e0bc78 0000000000000001 9000000185e0ba07 9000000105e0b890 ffffffffffffffff 9000000105e0bc78 73924b81763be05b 9000000100194500 000000000000020c 000000000000000a 0000000000000000 0000000000000003 00000000000023f0 00000000000e1401 00000000072f8000 0000007ffbb0e260 0000000000000000 0000000000000000 9000000005437650 90000000055d5000 0000000000000000 0000000000000003 0000007ffbb0e1f0 0000000000000000 0000005567b00490 0000000000000000 9000000003803964 0000007ffbb0dfec 00000000000000b0 0000000000000007 0000000000000003 0000000000071c1d ... Call Trace: [<9000000003803964>] show_stack+0x64/0x1a0 [<9000000004c57464>] dump_stack_lvl+0x74/0xb0 [<9000000003861ab4>] __might_resched+0x154/0x1a0 [<900000000380c96c>] emulate_load_store_insn+0x6c/0xf60 [<9000000004c58118>] do_ale+0x78/0x180 [<9000000003801bc8>] handle_ale+0x128/0x1e0  So enable IRQ if unaligned access exception is triggered in irq-enabled context to fix it.",
      "cve": "CVE-2024-50111",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50111",
          "value": "CVE-2024-50111",
          "url": "https://scout.docker.com/v/CVE-2024-50111?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50111?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1c44af0dc9f4be234fde99fd462731740d02e26b5f38cafec70100271566fead",
      "category": "container_scanning",
      "message": "CVE-2024-50138 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Use raw_spinlock_t in ringbuf  The function __bpf_ringbuf_reserve is invoked from a tracepoint, which disables preemption. Using spinlock_t in this context can lead to a \"sleep in atomic\" warning in the RT variant. This issue is illustrated in the example below:  BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 556208, name: test_progs preempt_count: 1, expected: 0 RCU nest depth: 1, expected: 1 INFO: lockdep is turned off. Preemption disabled at: [<ffffd33a5c88ea44>] migrate_enable+0xc0/0x39c CPU: 7 PID: 556208 Comm: test_progs Tainted: G Hardware name: Qualcomm SA8775P Ride (DT) Call trace: dump_backtrace+0xac/0x130 show_stack+0x1c/0x30 dump_stack_lvl+0xac/0xe8 dump_stack+0x18/0x30 __might_resched+0x3bc/0x4fc rt_spin_lock+0x8c/0x1a4 __bpf_ringbuf_reserve+0xc4/0x254 bpf_ringbuf_reserve_dynptr+0x5c/0xdc bpf_prog_ac3d15160d62622a_test_read_write+0x104/0x238 trace_call_bpf+0x238/0x774 perf_call_bpf_enter.isra.0+0x104/0x194 perf_syscall_enter+0x2f8/0x510 trace_sys_enter+0x39c/0x564 syscall_trace_enter+0x220/0x3c0 do_el0_svc+0x138/0x1dc el0_svc+0x54/0x130 el0t_64_sync_handler+0x134/0x150 el0t_64_sync+0x17c/0x180  Switch the spinlock to raw_spinlock_t to avoid this error.",
      "cve": "CVE-2024-50138",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50138",
          "value": "CVE-2024-50138",
          "url": "https://scout.docker.com/v/CVE-2024-50138?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50138?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f621bbd2969f9eaf6eb729ad79142e6c4f77140ed60e62b63d06fba66df3e835",
      "category": "container_scanning",
      "message": "CVE-2024-50146 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Don't call cleanup on profile rollback failure  When profile rollback fails in mlx5e_netdev_change_profile, the netdev profile var is left set to NULL. Avoid a crash when unloading the driver by not calling profile->cleanup in such a case.  This was encountered while testing, with the original trigger that the wq rescuer thread creation got interrupted (presumably due to Ctrl+C-ing modprobe), which gets converted to ENOMEM (-12) by mlx5e_priv_init, the profile rollback also fails for the same reason (signal still active) so the profile is left as NULL, leading to a crash later in _mlx5e_remove.  [  732.473932] mlx5_core 0000:08:00.1: E-Switch: Unload vfs: mode(OFFLOADS), nvfs(2), necvfs(0), active vports(2) [  734.525513] workqueue: Failed to create a rescuer kthread for wq \"mlx5e\": -EINTR [  734.557372] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12 [  734.559187] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: new profile init failed, -12 [  734.560153] workqueue: Failed to create a rescuer kthread for wq \"mlx5e\": -EINTR [  734.589378] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12 [  734.591136] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: failed to rollback to orig profile, -12 [  745.537492] BUG: kernel NULL pointer dereference, address: 0000000000000008 [  745.538222] #PF: supervisor read access in kernel mode <snipped> [  745.551290] Call Trace: [  745.551590]  <TASK> [  745.551866]  ? __die+0x20/0x60 [  745.552218]  ? page_fault_oops+0x150/0x400 [  745.555307]  ? exc_page_fault+0x79/0x240 [  745.555729]  ? asm_exc_page_fault+0x22/0x30 [  745.556166]  ? mlx5e_remove+0x6b/0xb0 [mlx5_core] [  745.556698]  auxiliary_bus_remove+0x18/0x30 [  745.557134]  device_release_driver_internal+0x1df/0x240 [  745.557654]  bus_remove_device+0xd7/0x140 [  745.558075]  device_del+0x15b/0x3c0 [  745.558456]  mlx5_rescan_drivers_locked.part.0+0xb1/0x2f0 [mlx5_core] [  745.559112]  mlx5_unregister_device+0x34/0x50 [mlx5_core] [  745.559686]  mlx5_uninit_one+0x46/0xf0 [mlx5_core] [  745.560203]  remove_one+0x4e/0xd0 [mlx5_core] [  745.560694]  pci_device_remove+0x39/0xa0 [  745.561112]  device_release_driver_internal+0x1df/0x240 [  745.561631]  driver_detach+0x47/0x90 [  745.562022]  bus_remove_driver+0x84/0x100 [  745.562444]  pci_unregister_driver+0x3b/0x90 [  745.562890]  mlx5_cleanup+0xc/0x1b [mlx5_core] [  745.563415]  __x64_sys_delete_module+0x14d/0x2f0 [  745.563886]  ? kmem_cache_free+0x1b0/0x460 [  745.564313]  ? lockdep_hardirqs_on_prepare+0xe2/0x190 [  745.564825]  do_syscall_64+0x6d/0x140 [  745.565223]  entry_SYSCALL_64_after_hwframe+0x4b/0x53 [  745.565725] RIP: 0033:0x7f1579b1288b",
      "cve": "CVE-2024-50146",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50146",
          "value": "CVE-2024-50146",
          "url": "https://scout.docker.com/v/CVE-2024-50146?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50146?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "43078331cc648cd42fbf1295d0bc780ca00e5353701cb0504d5ec42a873a73e2",
      "category": "container_scanning",
      "message": "CVE-2024-50166 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fsl/fman: Fix refcount handling of fman-related devices  In mac_probe() there are multiple calls to of_find_device_by_node(), fman_bind() and fman_port_bind() which takes references to of_dev->dev. Not all references taken by these calls are released later on error path in mac_probe() and in mac_remove() which lead to reference leaks.  Add references release.",
      "cve": "CVE-2024-50166",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50166",
          "value": "CVE-2024-50166",
          "url": "https://scout.docker.com/v/CVE-2024-50166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50166?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "db991315f5fc17f95476151e1bf936cbf48d8b93fa6f0c1ebf11f897f389c89d",
      "category": "container_scanning",
      "message": "CVE-2024-50187 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/vc4: Stop the active perfmon before being destroyed  Upon closing the file descriptor, the active performance monitor is not stopped. Although all perfmons are destroyed in `vc4_perfmon_close_file()`, the active performance monitor's pointer (`vc4->active_perfmon`) is still retained.  If we open a new file descriptor and submit a few jobs with performance monitors, the driver will attempt to stop the active performance monitor using the stale pointer in `vc4->active_perfmon`. However, this pointer is no longer valid because the previous process has already terminated, and all performance monitors associated with it have been destroyed and freed.  To fix this, when the active performance monitor belongs to a given process, explicitly stop it before destroying and freeing it.",
      "cve": "CVE-2024-50187",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50187",
          "value": "CVE-2024-50187",
          "url": "https://scout.docker.com/v/CVE-2024-50187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3f14e93395ebf05201e8775f12042069dc79244975af811ccf2f3f7aba3f3954",
      "category": "container_scanning",
      "message": "CVE-2024-50271 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  signal: restore the override_rlimit logic  Prior to commit d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of ucounts\") UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals.  However now it's enforced unconditionally, even if override_rlimit is set.  This behavior change caused production issues.  For example, if the limit is reached and a process receives a SIGSEGV signal, sigqueue_alloc fails to allocate the necessary resources for the signal delivery, preventing the signal from being delivered with siginfo. This prevents the process from correctly identifying the fault address and handling the error.  From the user-space perspective, applications are unaware that the limit has been reached and that the siginfo is effectively 'corrupted'.  This can lead to unpredictable behavior and crashes, as we observed with java applications.  Fix this by passing override_rlimit into inc_rlimit_get_ucounts() and skip the comparison to max there if override_rlimit is set.  This effectively restores the old behavior.",
      "cve": "CVE-2024-50271",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50271",
          "value": "CVE-2024-50271",
          "url": "https://scout.docker.com/v/CVE-2024-50271?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50271?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "693c0b1503cb1a5cc59e2985ed865c6ddfb2c40f31938140d048cb39f26ad951",
      "category": "container_scanning",
      "message": "CVE-2024-50284 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: Fix the missing xa_store error check  xa_store() can fail, it return xa_err(-EINVAL) if the entry cannot be stored in an XArray, or xa_err(-ENOMEM) if memory allocation failed, so check error for xa_store() to fix it.",
      "cve": "CVE-2024-50284",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50284",
          "value": "CVE-2024-50284",
          "url": "https://scout.docker.com/v/CVE-2024-50284?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50284?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9d1516f4645d707aaebc994265f27eed716f3f2364867179e6bcca0326c363c",
      "category": "container_scanning",
      "message": "CVE-2024-50285 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: check outstanding simultaneous SMB operations  If Client send simultaneous SMB operations to ksmbd, It exhausts too much memory through the \"ksmbd_work_cache. It will cause OOM issue. ksmbd has a credit mechanism but it can't handle this problem. This patch add the check if it exceeds max credits to prevent this problem by assuming that one smb request consumes at least one credit.",
      "cve": "CVE-2024-50285",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50285",
          "value": "CVE-2024-50285",
          "url": "https://scout.docker.com/v/CVE-2024-50285?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50285?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b6ef07ceac9c352e81c94b638e217d818abea14be02186ee5f5e94044d13c192",
      "category": "container_scanning",
      "message": "CVE-2024-50289 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: av7110: fix a spectre vulnerability  As warned by smatch: drivers/staging/media/av7110/av7110_ca.c:270 dvb_ca_ioctl() warn: potential spectre issue 'av7110->ci_slot' [w] (local cap)  There is a spectre-related vulnerability at the code. Fix it.",
      "cve": "CVE-2024-50289",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50289",
          "value": "CVE-2024-50289",
          "url": "https://scout.docker.com/v/CVE-2024-50289?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50289?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "63763e4ba7adf8637ea93c78c1af4bb1e1718a48549a7d5e1c24901e7b45c018",
      "category": "container_scanning",
      "message": "CVE-2024-50298 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: enetc: allocate vf_state during PF probes  In the previous implementation, vf_state is allocated memory only when VF is enabled. However, net_device_ops::ndo_set_vf_mac() may be called before VF is enabled to configure the MAC address of VF. If this is the case, enetc_pf_set_vf_mac() will access vf_state, resulting in access to a null pointer. The simplified error log is as follows.  root@ls1028ardb:~# ip link set eno0 vf 1 mac 00:0c:e7:66:77:89 [  173.543315] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004 [  173.637254] pc : enetc_pf_set_vf_mac+0x3c/0x80 Message from sy [  173.641973] lr : do_setlink+0x4a8/0xec8 [  173.732292] Call trace: [  173.734740]  enetc_pf_set_vf_mac+0x3c/0x80 [  173.738847]  __rtnl_newlink+0x530/0x89c [  173.742692]  rtnl_newlink+0x50/0x7c [  173.746189]  rtnetlink_rcv_msg+0x128/0x390 [  173.750298]  netlink_rcv_skb+0x60/0x130 [  173.754145]  rtnetlink_rcv+0x18/0x24 [  173.757731]  netlink_unicast+0x318/0x380 [  173.761665]  netlink_sendmsg+0x17c/0x3c8",
      "cve": "CVE-2024-50298",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50298",
          "value": "CVE-2024-50298",
          "url": "https://scout.docker.com/v/CVE-2024-50298?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50298?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2f5e939fd3b891527b17b73c7c73104caf3e26e4b4c3344811114f07d6f389e0",
      "category": "container_scanning",
      "message": "CVE-2024-52559 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/gem: prevent integer overflow in msm_ioctl_gem_submit()  The \"submit->cmd[i].size\" and \"submit->cmd[i].offset\" variables are u32 values that come from the user via the submit_lookup_cmds() function. This addition could lead to an integer wrapping bug so use size_add() to prevent that.  Patchwork: https://patchwork.freedesktop.org/patch/624696/",
      "cve": "CVE-2024-52559",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-52559",
          "value": "CVE-2024-52559",
          "url": "https://scout.docker.com/v/CVE-2024-52559?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-52559?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e32539a8db94ed4ea86c8d8592b04bfbc9f39eae4f263697be6f0aed32b51e91",
      "category": "container_scanning",
      "message": "CVE-2024-52560 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/ntfs3: Mark inode as bad as soon as error detected in mi_enum_attr()  Extended the `mi_enum_attr()` function interface with an additional parameter, `struct ntfs_inode *ni`, to allow marking the inode as bad as soon as an error is detected.",
      "cve": "CVE-2024-52560",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-52560",
          "value": "CVE-2024-52560",
          "url": "https://scout.docker.com/v/CVE-2024-52560?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-52560?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5e5004fcf38c8fdf3c88a38714f54394ac12e157bb75a4d80b4941f0a9b50f54",
      "category": "container_scanning",
      "message": "CVE-2024-53050 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/i915/hdcp: Add encoder check in hdcp2_get_capability  Add encoder check in intel_hdcp2_get_capability to avoid null pointer error.",
      "cve": "CVE-2024-53050",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53050",
          "value": "CVE-2024-53050",
          "url": "https://scout.docker.com/v/CVE-2024-53050?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53050?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7825c7e9c445697810101e382def64e4def64c2536324cc2970592f3bc5fa701",
      "category": "container_scanning",
      "message": "CVE-2024-53056 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/mediatek: Fix potential NULL dereference in mtk_crtc_destroy()  In mtk_crtc_create(), if the call to mbox_request_channel() fails then we set the \"mtk_crtc->cmdq_client.chan\" pointer to NULL.  In that situation, we do not call cmdq_pkt_create().  During the cleanup, we need to check if the \"mtk_crtc->cmdq_client.chan\" is NULL first before calling cmdq_pkt_destroy().  Calling cmdq_pkt_destroy() is unnecessary if we didn't call cmdq_pkt_create() and it will result in a NULL pointer dereference.",
      "cve": "CVE-2024-53056",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53056",
          "value": "CVE-2024-53056",
          "url": "https://scout.docker.com/v/CVE-2024-53056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53056?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7fda080b886e24921ea1a8bd6c2d66bc853c5570bf3f908d108d5b381210f11d",
      "category": "container_scanning",
      "message": "CVE-2024-53079 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/thp: fix deferred split unqueue naming and locking  Recent changes are putting more pressure on THP deferred split queues: under load revealing long-standing races, causing list_del corruptions, \"Bad page state\"s and worse (I keep BUGs in both of those, so usually don't get to see how badly they end up without).  The relevant recent changes being 6.8's mTHP, 6.10's mTHP swapout, and 6.12's mTHP swapin, improved swap allocation, and underused THP splitting.  Before fixing locking: rename misleading folio_undo_large_rmappable(), which does not undo large_rmappable, to folio_unqueue_deferred_split(), which is what it does.  But that and its out-of-line __callee are mm internals of very limited usability: add comment and WARN_ON_ONCEs to check usage; and return a bool to say if a deferred split was unqueued, which can then be used in WARN_ON_ONCEs around safety checks (sparing callers the arcane conditionals in __folio_unqueue_deferred_split()).  Just omit the folio_unqueue_deferred_split() from free_unref_folios(), all of whose callers now call it beforehand (and if any forget then bad_page() will tell) - except for its caller put_pages_list(), which itself no longer has any callers (and will be deleted separately).  Swapout: mem_cgroup_swapout() has been resetting folio->memcg_data 0 without checking and unqueueing a THP folio from deferred split list; which is unfortunate, since the split_queue_lock depends on the memcg (when memcg is enabled); so swapout has been unqueueing such THPs later, when freeing the folio, using the pgdat's lock instead: potentially corrupting the memcg's list.  __remove_mapping() has frozen refcount to 0 here, so no problem with calling folio_unqueue_deferred_split() before resetting memcg_data.  That goes back to 5.4 commit 87eaceb3faa5 (\"mm: thp: make deferred split shrinker memcg aware\"): which included a check on swapcache before adding to deferred queue, but no check on deferred queue before adding THP to swapcache.  That worked fine with the usual sequence of events in reclaim (though there were a couple of rare ways in which a THP on deferred queue could have been swapped out), but 6.12 commit dafff3f4c850 (\"mm: split underused THPs\") avoids splitting underused THPs in reclaim, which makes swapcache THPs on deferred queue commonplace.  Keep the check on swapcache before adding to deferred queue?  Yes: it is no longer essential, but preserves the existing behaviour, and is likely to be a worthwhile optimization (vmstat showed much more traffic on the queue under swapping load if the check was removed); update its comment.  Memcg-v1 move (deprecated): mem_cgroup_move_account() has been changing folio->memcg_data without checking and unqueueing a THP folio from the deferred list, sometimes corrupting \"from\" memcg's list, like swapout. Refcount is non-zero here, so folio_unqueue_deferred_split() can only be used in a WARN_ON_ONCE to validate the fix, which must be done earlier: mem_cgroup_move_charge_pte_range() first try to split the THP (splitting of course unqueues), or skip it if that fails.  Not ideal, but moving charge has been requested, and khugepaged should repair the THP later: nobody wants new custom unqueueing code just for this deprecated case.  The 87eaceb3faa5 commit did have the code to move from one deferred list to another (but was not conscious of its unsafety while refcount non-0); but that was removed by 5.6 commit fac0516b5534 (\"mm: thp: don't need care deferred split queue in memcg charge move path\"), which argued that the existence of a PMD mapping guarantees that the THP cannot be on a deferred list.  As above, false in rare cases, and now commonly false.  Backport to 6.11 should be straightforward.  Earlier backports must take care that other _deferred_list fixes and dependencies are included.  There is not a strong case for backports, but they can fix cornercases.",
      "cve": "CVE-2024-53079",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53079",
          "value": "CVE-2024-53079",
          "url": "https://scout.docker.com/v/CVE-2024-53079?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53079?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "853cdbb2f7d88fe9dd3f19ff5a9a3071989cd0fe8a30b7ad92c3cbd597f41318",
      "category": "container_scanning",
      "message": "CVE-2024-53091 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Add sk_is_inet and IS_ICSK check in tls_sw_has_ctx_tx/rx  As the introduction of the support for vsock and unix sockets in sockmap, tls_sw_has_ctx_tx/rx cannot presume the socket passed in must be IS_ICSK. vsock and af_unix sockets have vsock_sock and unix_sock instead of inet_connection_sock. For these sockets, tls_get_ctx may return an invalid pointer and cause page fault in function tls_sw_ctx_rx.  BUG: unable to handle page fault for address: 0000000000040030 Workqueue: vsock-loopback vsock_loopback_work RIP: 0010:sk_psock_strp_data_ready+0x23/0x60 Call Trace: ? __die+0x81/0xc3 ? no_context+0x194/0x350 ? do_page_fault+0x30/0x110 ? async_page_fault+0x3e/0x50 ? sk_psock_strp_data_ready+0x23/0x60 virtio_transport_recv_pkt+0x750/0x800 ? update_load_avg+0x7e/0x620 vsock_loopback_work+0xd0/0x100 process_one_work+0x1a7/0x360 worker_thread+0x30/0x390 ? create_worker+0x1a0/0x1a0 kthread+0x112/0x130 ? __kthread_cancel_work+0x40/0x40 ret_from_fork+0x1f/0x40  v2: - Add IS_ICSK check v3: - Update the commits in Fixes",
      "cve": "CVE-2024-53091",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53091",
          "value": "CVE-2024-53091",
          "url": "https://scout.docker.com/v/CVE-2024-53091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53091?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "da074e85943a241ee07df99193c02385e5803d6e585f8213b24e51651b19cf23",
      "category": "container_scanning",
      "message": "CVE-2024-53114 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/CPU/AMD: Clear virtualized VMLOAD/VMSAVE on Zen4 client  A number of Zen4 client SoCs advertise the ability to use virtualized VMLOAD/VMSAVE, but using these instructions is reported to be a cause of a random host reboot.  These instructions aren't intended to be advertised on Zen4 client so clear the capability.",
      "cve": "CVE-2024-53114",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53114",
          "value": "CVE-2024-53114",
          "url": "https://scout.docker.com/v/CVE-2024-53114?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53114?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bfc28cd7038db54dc2cb983a7a9cde65f59ce298a9ff4ec688019a7322e357ad",
      "category": "container_scanning",
      "message": "CVE-2024-53175 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipc: fix memleak if msg_init_ns failed in create_ipc_ns  Percpu memory allocation may failed during create_ipc_ns however this fail is not handled properly since ipc sysctls and mq sysctls is not released properly. Fix this by release these two resource when failure.  Here is the kmemleak stack when percpu failed:  unreferenced object 0xffff88819de2a600 (size 512): comm \"shmem_2nstest\", pid 120711, jiffies 4300542254 hex dump (first 32 bytes): 60 aa 9d 84 ff ff ff ff fc 18 48 b2 84 88 ff ff  `.........H..... 04 00 00 00 a4 01 00 00 20 e4 56 81 ff ff ff ff  ........ .V..... backtrace (crc be7cba35): [<ffffffff81b43f83>] __kmalloc_node_track_caller_noprof+0x333/0x420 [<ffffffff81a52e56>] kmemdup_noprof+0x26/0x50 [<ffffffff821b2f37>] setup_mq_sysctls+0x57/0x1d0 [<ffffffff821b29cc>] copy_ipcs+0x29c/0x3b0 [<ffffffff815d6a10>] create_new_namespaces+0x1d0/0x920 [<ffffffff815d7449>] copy_namespaces+0x2e9/0x3e0 [<ffffffff815458f3>] copy_process+0x29f3/0x7ff0 [<ffffffff8154b080>] kernel_clone+0xc0/0x650 [<ffffffff8154b6b1>] __do_sys_clone+0xa1/0xe0 [<ffffffff843df8ff>] do_syscall_64+0xbf/0x1c0 [<ffffffff846000b0>] entry_SYSCALL_64_after_hwframe+0x4b/0x53",
      "cve": "CVE-2024-53175",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53175",
          "value": "CVE-2024-53175",
          "url": "https://scout.docker.com/v/CVE-2024-53175?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53175?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "474aea7e9d99301578251db0cec22fcb32c2b8abc4639ebdcb33550e7539da2f",
      "category": "container_scanning",
      "message": "CVE-2024-53187 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring: check for overflows in io_pin_pages  WARNING: CPU: 0 PID: 5834 at io_uring/memmap.c:144 io_pin_pages+0x149/0x180 io_uring/memmap.c:144 CPU: 0 UID: 0 PID: 5834 Comm: syz-executor825 Not tainted 6.12.0-next-20241118-syzkaller #0 Call Trace: <TASK> __io_uaddr_map+0xfb/0x2d0 io_uring/memmap.c:183 io_rings_map io_uring/io_uring.c:2611 [inline] io_allocate_scq_urings+0x1c0/0x650 io_uring/io_uring.c:3470 io_uring_create+0x5b5/0xc00 io_uring/io_uring.c:3692 io_uring_setup io_uring/io_uring.c:3781 [inline] ... </TASK>  io_pin_pages()'s uaddr parameter came directly from the user and can be garbage. Don't just add size to it as it can overflow.",
      "cve": "CVE-2024-53187",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53187",
          "value": "CVE-2024-53187",
          "url": "https://scout.docker.com/v/CVE-2024-53187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53187?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0d836eb43e7b9010503b4c17eed17d853ab9235d0e36fb298423294f8c9886ef",
      "category": "container_scanning",
      "message": "CVE-2024-53190 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtlwifi: Drastically reduce the attempts to read efuse in case of failures  Syzkaller reported a hung task with uevent_show() on stack trace. That specific issue was addressed by another commit [0], but even with that fix applied (for example, running v6.12-rc5) we face another type of hung task that comes from the same reproducer [1]. By investigating that, we could narrow it to the following path:  (a) Syzkaller emulates a Realtek USB WiFi adapter using raw-gadget and dummy_hcd infrastructure.  (b) During the probe of rtl8192cu, the driver ends-up performing an efuse read procedure (which is related to EEPROM load IIUC), and here lies the issue: the function read_efuse() calls read_efuse_byte() many times, as loop iterations depending on the efuse size (in our example, 512 in total).  This procedure for reading efuse bytes relies in a loop that performs an I/O read up to *10k* times in case of failures. We measured the time of the loop inside read_efuse_byte() alone, and in this reproducer (which involves the dummy_hcd emulation layer), it takes 15 seconds each. As a consequence, we have the driver stuck in its probe routine for big time, exposing a stack trace like below if we attempt to reboot the system, for example:  task:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000 Workqueue: usb_hub_wq hub_event Call Trace: __schedule+0xe22/0xeb6 schedule_timeout+0xe7/0x132 __wait_for_common+0xb5/0x12e usb_start_wait_urb+0xc5/0x1ef ? usb_alloc_urb+0x95/0xa4 usb_control_msg+0xff/0x184 _usbctrl_vendorreq_sync+0xa0/0x161 _usb_read_sync+0xb3/0xc5 read_efuse_byte+0x13c/0x146 read_efuse+0x351/0x5f0 efuse_read_all_map+0x42/0x52 rtl_efuse_shadow_map_update+0x60/0xef rtl_get_hwinfo+0x5d/0x1c2 rtl92cu_read_eeprom_info+0x10a/0x8d5 ? rtl92c_read_chip_version+0x14f/0x17e rtl_usb_probe+0x323/0x851 usb_probe_interface+0x278/0x34b really_probe+0x202/0x4a4 __driver_probe_device+0x166/0x1b2 driver_probe_device+0x2f/0xd8 [...]  We propose hereby to drastically reduce the attempts of doing the I/O reads in case of failures, restricted to USB devices (given that they're inherently slower than PCIe ones). By retrying up to 10 times (instead of 10000), we got reponsiveness in the reproducer, while seems reasonable to believe that there's no sane USB device implementation in the field requiring this amount of retries at every I/O read in order to properly work. Based on that assumption, it'd be good to have it backported to stable but maybe not since driver implementation (the 10k number comes from day 0), perhaps up to 6.x series makes sense.  [0] Commit 15fffc6a5624 (\"driver core: Fix uevent_show() vs driver detach race\")  [1] A note about that: this syzkaller report presents multiple reproducers that differs by the type of emulated USB device. For this specific case, check the entry from 2024/08/08 06:23 in the list of crashes; the C repro is available at https://syzkaller.appspot.com/text?tag=ReproC&x=1521fc83980000.",
      "cve": "CVE-2024-53190",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53190",
          "value": "CVE-2024-53190",
          "url": "https://scout.docker.com/v/CVE-2024-53190?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53190?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d8db80983e2758ccd21709ff9307eb44c07fc71c1d3a1c91ffdde06ba986b20",
      "category": "container_scanning",
      "message": "CVE-2024-53195 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Get rid of userspace_irqchip_in_use  Improper use of userspace_irqchip_in_use led to syzbot hitting the following WARN_ON() in kvm_timer_update_irq():  WARNING: CPU: 0 PID: 3281 at arch/arm64/kvm/arch_timer.c:459 kvm_timer_update_irq+0x21c/0x394 Call trace: kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c:459 kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c:968 kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c:264 kvm_vcpu_set_target arch/arm64/kvm/arm.c:1553 [inline] kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c:1573 [inline] kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c:1695 kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c:4658 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c:893 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c:132 do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c:151 el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c:712 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598  The following sequence led to the scenario: - Userspace creates a VM and a vCPU. - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 during KVM_ARM_VCPU_INIT. - Without any other setup, such as vGIC or vPMU, userspace issues KVM_RUN on the vCPU. Since the vPMU is requested, but not setup, kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change(). As a result, KVM_RUN returns after enabling the timer, but before incrementing 'userspace_irqchip_in_use': kvm_arch_vcpu_run_pid_change() ret = kvm_arm_pmu_v3_enable() if (!vcpu->arch.pmu.created) return -EINVAL; if (ret) return ret; [...] if (!irqchip_in_kernel(kvm)) static_branch_inc(&userspace_irqchip_in_use); - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again. Since the timer is already enabled, control moves through the following flow, ultimately hitting the WARN_ON(): kvm_timer_vcpu_reset() if (timer->enabled) kvm_timer_update_irq() if (!userspace_irqchip()) ret = kvm_vgic_inject_irq() ret = vgic_lazy_init() if (unlikely(!vgic_initialized(kvm))) if (kvm->arch.vgic.vgic_model != KVM_DEV_TYPE_ARM_VGIC_V2) return -EBUSY; WARN_ON(ret);  Theoretically, since userspace_irqchip_in_use's functionality can be simply replaced by '!irqchip_in_kernel()', get rid of the static key to avoid the mismanagement, which also helps with the syzbot issue.",
      "cve": "CVE-2024-53195",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53195",
          "value": "CVE-2024-53195",
          "url": "https://scout.docker.com/v/CVE-2024-53195?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53195?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "30e19357ddedb1c49d7e31cbe20d1aaa60ae636701e5cb6b4b05a2b9e6028ac4",
      "category": "container_scanning",
      "message": "CVE-2024-53196 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Don't retire aborted MMIO instruction  Returning an abort to the guest for an unsupported MMIO access is a documented feature of the KVM UAPI. Nevertheless, it's clear that this plumbing has seen limited testing, since userspace can trivially cause a WARN in the MMIO return:  WARNING: CPU: 0 PID: 30558 at arch/arm64/include/asm/kvm_emulate.h:536 kvm_handle_mmio_return+0x46c/0x5c4 arch/arm64/include/asm/kvm_emulate.h:536 Call trace: kvm_handle_mmio_return+0x46c/0x5c4 arch/arm64/include/asm/kvm_emulate.h:536 kvm_arch_vcpu_ioctl_run+0x98/0x15b4 arch/arm64/kvm/arm.c:1133 kvm_vcpu_ioctl+0x75c/0xa78 virt/kvm/kvm_main.c:4487 __do_sys_ioctl fs/ioctl.c:51 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __arm64_sys_ioctl+0x14c/0x1c8 fs/ioctl.c:893 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x1e0/0x23c arch/arm64/kernel/syscall.c:132 do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151 el0_svc+0x38/0x68 arch/arm64/kernel/entry-common.c:712 el0t_64_sync_handler+0x90/0xfc arch/arm64/kernel/entry-common.c:730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598  The splat is complaining that KVM is advancing PC while an exception is pending, i.e. that KVM is retiring the MMIO instruction despite a pending synchronous external abort. Womp womp.  Fix the glaring UAPI bug by skipping over all the MMIO emulation in case there is a pending synchronous exception. Note that while userspace is capable of pending an asynchronous exception (SError, IRQ, or FIQ), it is still safe to retire the MMIO instruction in this case as (1) they are by definition asynchronous, and (2) KVM relies on hardware support for pending/delivering these exceptions instead of the software state machine for advancing PC.",
      "cve": "CVE-2024-53196",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53196",
          "value": "CVE-2024-53196",
          "url": "https://scout.docker.com/v/CVE-2024-53196?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53196?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "53aa6108e7dcf58891bad6809bd99491bd6b60789b966be1788b46e54e4d770c",
      "category": "container_scanning",
      "message": "CVE-2024-53210 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  s390/iucv: MSG_PEEK causes memory leak in iucv_sock_destruct()  Passing MSG_PEEK flag to skb_recv_datagram() increments skb refcount (skb->users) and iucv_sock_recvmsg() does not decrement skb refcount at exit. This results in skb memory leak in skb_queue_purge() and WARN_ON in iucv_sock_destruct() during socket close. To fix this decrease skb refcount by one if MSG_PEEK is set in order to prevent memory leak and WARN_ON.  WARNING: CPU: 2 PID: 6292 at net/iucv/af_iucv.c:286 iucv_sock_destruct+0x144/0x1a0 [af_iucv] CPU: 2 PID: 6292 Comm: afiucv_test_msg Kdump: loaded Tainted: G        W 6.10.0-rc7 #1 Hardware name: IBM 3931 A01 704 (z/VM 7.3.0) Call Trace: [<001587c682c4aa98>] iucv_sock_destruct+0x148/0x1a0 [af_iucv] [<001587c682c4a9d0>] iucv_sock_destruct+0x80/0x1a0 [af_iucv] [<001587c704117a32>] __sk_destruct+0x52/0x550 [<001587c704104a54>] __sock_release+0xa4/0x230 [<001587c704104c0c>] sock_close+0x2c/0x40 [<001587c702c5f5a8>] __fput+0x2e8/0x970 [<001587c7024148c4>] task_work_run+0x1c4/0x2c0 [<001587c7023b0716>] do_exit+0x996/0x1050 [<001587c7023b13aa>] do_group_exit+0x13a/0x360 [<001587c7023b1626>] __s390x_sys_exit_group+0x56/0x60 [<001587c7022bccca>] do_syscall+0x27a/0x380 [<001587c7049a6a0c>] __do_syscall+0x9c/0x160 [<001587c7049ce8a8>] system_call+0x70/0x98 Last Breaking-Event-Address: [<001587c682c4a9d4>] iucv_sock_destruct+0x84/0x1a0 [af_iucv]",
      "cve": "CVE-2024-53210",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53210",
          "value": "CVE-2024-53210",
          "url": "https://scout.docker.com/v/CVE-2024-53210?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53210?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bf132908e02c616e5557ffceb8a4958485a3c5dfdcf19512b40f2a4587a77336",
      "category": "container_scanning",
      "message": "CVE-2024-53219 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  virtiofs: use pages instead of pointer for kernel direct IO  When trying to insert a 10MB kernel module kept in a virtio-fs with cache disabled, the following warning was reported:  ------------[ cut here ]------------ WARNING: CPU: 1 PID: 404 at mm/page_alloc.c:4551 ...... Modules linked in: CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ...... RIP: 0010:__alloc_pages+0x2bf/0x380 ...... Call Trace: <TASK> ? __warn+0x8e/0x150 ? __alloc_pages+0x2bf/0x380 __kmalloc_large_node+0x86/0x160 __kmalloc+0x33c/0x480 virtio_fs_enqueue_req+0x240/0x6d0 virtio_fs_wake_pending_and_unlock+0x7f/0x190 queue_request_and_unlock+0x55/0x60 fuse_simple_request+0x152/0x2b0 fuse_direct_io+0x5d2/0x8c0 fuse_file_read_iter+0x121/0x160 __kernel_read+0x151/0x2d0 kernel_read+0x45/0x50 kernel_read_file+0x1a9/0x2a0 init_module_from_file+0x6a/0xe0 idempotent_init_module+0x175/0x230 __x64_sys_finit_module+0x5d/0xb0 x64_sys_call+0x1c3/0x9e0 do_syscall_64+0x3d/0xc0 entry_SYSCALL_64_after_hwframe+0x4b/0x53 ...... </TASK> ---[ end trace 0000000000000000 ]---  The warning is triggered as follows:  1) syscall finit_module() handles the module insertion and it invokes kernel_read_file() to read the content of the module first.  2) kernel_read_file() allocates a 10MB buffer by using vmalloc() and passes it to kernel_read(). kernel_read() constructs a kvec iter by using iov_iter_kvec() and passes it to fuse_file_read_iter().  3) virtio-fs disables the cache, so fuse_file_read_iter() invokes fuse_direct_io(). As for now, the maximal read size for kvec iter is only limited by fc->max_read. For virtio-fs, max_read is UINT_MAX, so fuse_direct_io() doesn't split the 10MB buffer. It saves the address and the size of the 10MB-sized buffer in out_args[0] of a fuse request and passes the fuse request to virtio_fs_wake_pending_and_unlock().  4) virtio_fs_wake_pending_and_unlock() uses virtio_fs_enqueue_req() to queue the request. Because virtiofs need DMA-able address, so virtio_fs_enqueue_req() uses kmalloc() to allocate a bounce buffer for all fuse args, copies these args into the bounce buffer and passed the physical address of the bounce buffer to virtiofsd. The total length of these fuse args for the passed fuse request is about 10MB, so copy_args_to_argbuf() invokes kmalloc() with a 10MB size parameter and it triggers the warning in __alloc_pages():  if (WARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER, gfp)) return NULL;  5) virtio_fs_enqueue_req() will retry the memory allocation in a kworker, but it won't help, because kmalloc() will always return NULL due to the abnormal size and finit_module() will hang forever.  A feasible solution is to limit the value of max_read for virtio-fs, so the length passed to kmalloc() will be limited. However it will affect the maximal read size for normal read. And for virtio-fs write initiated from kernel, it has the similar problem but now there is no way to limit fc->max_write in kernel.  So instead of limiting both the values of max_read and max_write in kernel, introducing use_pages_for_kvec_io in fuse_conn and setting it as true in virtiofs. When use_pages_for_kvec_io is enabled, fuse will use pages instead of pointer to pass the KVEC_IO data.  After switching to pages for KVEC_IO data, these pages will be used for DMA through virtio-fs. If these pages are backed by vmalloc(), {flush|invalidate}_kernel_vmap_range() are necessary to flush or invalidate the cache before the DMA operation. So add two new fields in fuse_args_pages to record the base address of vmalloc area and the condition indicating whether invalidation is needed. Perform the flush in fuse_get_user_pages() for write operations and the invalidation in fuse_release_user_pages() for read operations.  It may seem necessary to introduce another fie ---truncated---",
      "cve": "CVE-2024-53219",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53219",
          "value": "CVE-2024-53219",
          "url": "https://scout.docker.com/v/CVE-2024-53219?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53219?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d0e03ba89c908fca677343fb693bce8ab55988a6159c477b3e145cc66c091bf5",
      "category": "container_scanning",
      "message": "CVE-2024-53220 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to account dirty data in __get_secs_required()  It will trigger system panic w/ testcase in [1]:  ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2752! RIP: 0010:new_curseg+0xc81/0x2110 Call Trace: f2fs_allocate_data_block+0x1c91/0x4540 do_write_page+0x163/0xdf0 f2fs_outplace_write_data+0x1aa/0x340 f2fs_do_write_data_page+0x797/0x2280 f2fs_write_single_data_page+0x16cd/0x2190 f2fs_write_cache_pages+0x994/0x1c80 f2fs_write_data_pages+0x9cc/0xea0 do_writepages+0x194/0x7a0 filemap_fdatawrite_wbc+0x12b/0x1a0 __filemap_fdatawrite_range+0xbb/0xf0 file_write_and_wait_range+0xa1/0x110 f2fs_do_sync_file+0x26f/0x1c50 f2fs_sync_file+0x12b/0x1d0 vfs_fsync_range+0xfa/0x230 do_fsync+0x3d/0x80 __x64_sys_fsync+0x37/0x50 x64_sys_call+0x1e88/0x20d0 do_syscall_64+0x4b/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e  The root cause is if checkpoint_disabling and lfs_mode are both on, it will trigger OPU for all overwritten data, it may cost more free segment than expected, so f2fs must account those data correctly to calculate cosumed free segments later, and return ENOSPC earlier to avoid run out of free segment during block allocation.  [1] https://lore.kernel.org/fstests/20241015025106.3203676-1-chao@kernel.org/",
      "cve": "CVE-2024-53220",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53220",
          "value": "CVE-2024-53220",
          "url": "https://scout.docker.com/v/CVE-2024-53220?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53220?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2387fb2354d9c3987e5a7071fb02f13626882b617631dc036ee24f185d5eb17b",
      "category": "container_scanning",
      "message": "CVE-2024-53221 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix null-ptr-deref in f2fs_submit_page_bio()  There's issue as follows when concurrently installing the f2fs.ko module and mounting the f2fs file system: KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] RIP: 0010:__bio_alloc+0x2fb/0x6c0 [f2fs] Call Trace: <TASK> f2fs_submit_page_bio+0x126/0x8b0 [f2fs] __get_meta_page+0x1d4/0x920 [f2fs] get_checkpoint_version.constprop.0+0x2b/0x3c0 [f2fs] validate_checkpoint+0xac/0x290 [f2fs] f2fs_get_valid_checkpoint+0x207/0x950 [f2fs] f2fs_fill_super+0x1007/0x39b0 [f2fs] mount_bdev+0x183/0x250 legacy_get_tree+0xf4/0x1e0 vfs_get_tree+0x88/0x340 do_new_mount+0x283/0x5e0 path_mount+0x2b2/0x15b0 __x64_sys_mount+0x1fe/0x270 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Above issue happens as the biset of the f2fs file system is not initialized before register \"f2fs_fs_type\". To address above issue just register \"f2fs_fs_type\" at the last in init_f2fs_fs(). Ensure that all f2fs file system resources are initialized.",
      "cve": "CVE-2024-53221",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53221",
          "value": "CVE-2024-53221",
          "url": "https://scout.docker.com/v/CVE-2024-53221?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53221?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a35a9fb26292e6be88ebf4d1e5049c9fded4f6981b171847617f3b617a493a14",
      "category": "container_scanning",
      "message": "CVE-2024-53224 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/mlx5: Move events notifier registration to be after device registration  Move pkey change work initialization and cleanup from device resources stage to notifier stage, since this is the stage which handles this work events.  Fix a race between the device deregistration and pkey change work by moving MLX5_IB_STAGE_DEVICE_NOTIFIER to be after MLX5_IB_STAGE_IB_REG in order to ensure that the notifier is deregistered before the device during cleanup. Which ensures there are no works that are being executed after the device has already unregistered which can cause the panic below.  BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 630071 Comm: kworker/1:2 Kdump: loaded Tainted: G W OE --------- --- 5.14.0-162.6.1.el9_1.x86_64 #1 Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS 090008 02/27/2023 Workqueue: events pkey_change_handler [mlx5_ib] RIP: 0010:setup_qp+0x38/0x1f0 [mlx5_ib] Code: ee 41 54 45 31 e4 55 89 f5 53 48 89 fb 48 83 ec 20 8b 77 08 65 48 8b 04 25 28 00 00 00 48 89 44 24 18 48 8b 07 48 8d 4c 24 16 <4c> 8b 38 49 8b 87 80 0b 00 00 4c 89 ff 48 8b 80 08 05 00 00 8b 40 RSP: 0018:ffffbcc54068be20 EFLAGS: 00010282 RAX: 0000000000000000 RBX: ffff954054494128 RCX: ffffbcc54068be36 RDX: ffff954004934000 RSI: 0000000000000001 RDI: ffff954054494128 RBP: 0000000000000023 R08: ffff954001be2c20 R09: 0000000000000001 R10: ffff954001be2c20 R11: ffff9540260133c0 R12: 0000000000000000 R13: 0000000000000023 R14: 0000000000000000 R15: ffff9540ffcb0905 FS: 0000000000000000(0000) GS:ffff9540ffc80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 000000010625c001 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: mlx5_ib_gsi_pkey_change+0x20/0x40 [mlx5_ib] process_one_work+0x1e8/0x3c0 worker_thread+0x50/0x3b0 ? rescuer_thread+0x380/0x380 kthread+0x149/0x170 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 Modules linked in: rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) mlx5_fwctl(OE) fwctl(OE) ib_uverbs(OE) mlx5_core(OE) mlxdevm(OE) ib_core(OE) mlx_compat(OE) psample mlxfw(OE) tls knem(OE) netconsole nfsv3 nfs_acl nfs lockd grace fscache netfs qrtr rfkill sunrpc intel_rapl_msr intel_rapl_common rapl hv_balloon hv_utils i2c_piix4 pcspkr joydev fuse ext4 mbcache jbd2 sr_mod sd_mod cdrom t10_pi sg ata_generic pci_hyperv pci_hyperv_intf hyperv_drm drm_shmem_helper drm_kms_helper hv_storvsc syscopyarea hv_netvsc sysfillrect sysimgblt hid_hyperv fb_sys_fops scsi_transport_fc hyperv_keyboard drm ata_piix crct10dif_pclmul crc32_pclmul crc32c_intel libata ghash_clmulni_intel hv_vmbus serio_raw [last unloaded: ib_core] CR2: 0000000000000000 ---[ end trace f6f8be4eae12f7bc ]---",
      "cve": "CVE-2024-53224",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53224",
          "value": "CVE-2024-53224",
          "url": "https://scout.docker.com/v/CVE-2024-53224?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53224?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b5baa792d996f24056210b6716d299ba94f062efac438de686e01a884ada545a",
      "category": "container_scanning",
      "message": "CVE-2024-53234 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  erofs: handle NONHEAD !delta[1] lclusters gracefully  syzbot reported a WARNING in iomap_iter_done: iomap_fiemap+0x73b/0x9b0 fs/iomap/fiemap.c:80 ioctl_fiemap fs/ioctl.c:220 [inline]  Generally, NONHEAD lclusters won't have delta[1]==0, except for crafted images and filesystems created by pre-1.0 mkfs versions.  Previously, it would immediately bail out if delta[1]==0, which led to inadequate decompressed lengths (thus FIEMAP is impacted).  Treat it as delta[1]=1 to work around these legacy mkfs versions.  `lclusterbits > 14` is illegal for compact indexes, error out too.",
      "cve": "CVE-2024-53234",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53234",
          "value": "CVE-2024-53234",
          "url": "https://scout.docker.com/v/CVE-2024-53234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f1ecefb2b37e3a9415fec6159a6043a2ad0641c3fa56c94b03588c5f3a1d64c9",
      "category": "container_scanning",
      "message": "CVE-2024-53687 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: Fix IPIs usage in kfence_protect_page()  flush_tlb_kernel_range() may use IPIs to flush the TLBs of all the cores, which triggers the following warning when the irqs are disabled:  [    3.455330] WARNING: CPU: 1 PID: 0 at kernel/smp.c:815 smp_call_function_many_cond+0x452/0x520 [    3.456647] Modules linked in: [    3.457218] CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.12.0-rc7-00010-g91d3de7240b8 #1 [    3.457416] Hardware name: QEMU QEMU Virtual Machine, BIOS [    3.457633] epc : smp_call_function_many_cond+0x452/0x520 [    3.457736]  ra : on_each_cpu_cond_mask+0x1e/0x30 [    3.457786] epc : ffffffff800b669a ra : ffffffff800b67c2 sp : ff2000000000bb50 [    3.457824]  gp : ffffffff815212b8 tp : ff6000008014f080 t0 : 000000000000003f [    3.457859]  t1 : ffffffff815221e0 t2 : 000000000000000f s0 : ff2000000000bc10 [    3.457920]  s1 : 0000000000000040 a0 : ffffffff815221e0 a1 : 0000000000000001 [    3.457953]  a2 : 0000000000010000 a3 : 0000000000000003 a4 : 0000000000000000 [    3.458006]  a5 : 0000000000000000 a6 : ffffffffffffffff a7 : 0000000000000000 [    3.458042]  s2 : ffffffff815223be s3 : 00fffffffffff000 s4 : ff600001ffe38fc0 [    3.458076]  s5 : ff600001ff950d00 s6 : 0000000200000120 s7 : 0000000000000001 [    3.458109]  s8 : 0000000000000001 s9 : ff60000080841ef0 s10: 0000000000000001 [    3.458141]  s11: ffffffff81524812 t3 : 0000000000000001 t4 : ff60000080092bc0 [    3.458172]  t5 : 0000000000000000 t6 : ff200000000236d0 [    3.458203] status: 0000000200000100 badaddr: ffffffff800b669a cause: 0000000000000003 [    3.458373] [<ffffffff800b669a>] smp_call_function_many_cond+0x452/0x520 [    3.458593] [<ffffffff800b67c2>] on_each_cpu_cond_mask+0x1e/0x30 [    3.458625] [<ffffffff8000e4ca>] __flush_tlb_range+0x118/0x1ca [    3.458656] [<ffffffff8000e6b2>] flush_tlb_kernel_range+0x1e/0x26 [    3.458683] [<ffffffff801ea56a>] kfence_protect+0xc0/0xce [    3.458717] [<ffffffff801e9456>] kfence_guarded_free+0xc6/0x1c0 [    3.458742] [<ffffffff801e9d6c>] __kfence_free+0x62/0xc6 [    3.458764] [<ffffffff801c57d8>] kfree+0x106/0x32c [    3.458786] [<ffffffff80588cf2>] detach_buf_split+0x188/0x1a8 [    3.458816] [<ffffffff8058708c>] virtqueue_get_buf_ctx+0xb6/0x1f6 [    3.458839] [<ffffffff805871da>] virtqueue_get_buf+0xe/0x16 [    3.458880] [<ffffffff80613d6a>] virtblk_done+0x5c/0xe2 [    3.458908] [<ffffffff8058766e>] vring_interrupt+0x6a/0x74 [    3.458930] [<ffffffff800747d8>] __handle_irq_event_percpu+0x7c/0xe2 [    3.458956] [<ffffffff800748f0>] handle_irq_event+0x3c/0x86 [    3.458978] [<ffffffff800786cc>] handle_simple_irq+0x9e/0xbe [    3.459004] [<ffffffff80073934>] generic_handle_domain_irq+0x1c/0x2a [    3.459027] [<ffffffff804bf87c>] imsic_handle_irq+0xba/0x120 [    3.459056] [<ffffffff80073934>] generic_handle_domain_irq+0x1c/0x2a [    3.459080] [<ffffffff804bdb76>] riscv_intc_aia_irq+0x24/0x34 [    3.459103] [<ffffffff809d0452>] handle_riscv_irq+0x2e/0x4c [    3.459133] [<ffffffff809d923e>] call_on_irq_stack+0x32/0x40  So only flush the local TLB and let the lazy kfence page fault handling deal with the faults which could happen when a core has an old protected pte version cached in its TLB. That leads to potential inaccuracies which can be tolerated when using kfence.",
      "cve": "CVE-2024-53687",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53687",
          "value": "CVE-2024-53687",
          "url": "https://scout.docker.com/v/CVE-2024-53687?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53687?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8e9ce6a8c7715f2edd6b2313aedee1f3fb761a93da802996faa2297596107c77",
      "category": "container_scanning",
      "message": "CVE-2024-54683 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  netfilter: IDLETIMER: Fix for possible ABBA deadlock  Deletion of the last rule referencing a given idletimer may happen at the same time as a read of its file in sysfs:  | ====================================================== | WARNING: possible circular locking dependency detected | 6.12.0-rc7-01692-g5e9a28f41134-dirty #594 Not tainted | ------------------------------------------------------ | iptables/3303 is trying to acquire lock: | ffff8881057e04b8 (kn->active#48){++++}-{0:0}, at: __kernfs_remove+0x20 | | but task is already holding lock: | ffffffffa0249068 (list_mutex){+.+.}-{3:3}, at: idletimer_tg_destroy_v] | | which lock already depends on the new lock.  A simple reproducer is:  | #!/bin/bash | | while true; do |         iptables -A INPUT -i foo -j IDLETIMER --timeout 10 --label \"testme\" |         iptables -D INPUT -i foo -j IDLETIMER --timeout 10 --label \"testme\" | done & | while true; do |         cat /sys/class/xt_idletimer/timers/testme >/dev/null | done  Avoid this by freeing list_mutex right after deleting the element from the list, then continuing with the teardown.",
      "cve": "CVE-2024-54683",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-54683",
          "value": "CVE-2024-54683",
          "url": "https://scout.docker.com/v/CVE-2024-54683?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-54683?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2ce548bed47f3feb7ed87180d1d3462ad6457464f04bcf75442634dc400843a0",
      "category": "container_scanning",
      "message": "CVE-2024-56368 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ring-buffer: Fix overflow in __rb_map_vma  An overflow occurred when performing the following calculation:  nr_pages = ((nr_subbufs + 1) << subbuf_order) - pgoff;  Add a check before the calculation to avoid this problem.  syzbot reported this as a slab-out-of-bounds in __rb_map_vma:  BUG: KASAN: slab-out-of-bounds in __rb_map_vma+0x9ab/0xae0 kernel/trace/ring_buffer.c:7058 Read of size 8 at addr ffff8880767dd2b8 by task syz-executor187/5836  CPU: 0 UID: 0 PID: 5836 Comm: syz-executor187 Not tainted 6.13.0-rc2-syzkaller-00159-gf932fb9b4074 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/25/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0xc3/0x620 mm/kasan/report.c:489 kasan_report+0xd9/0x110 mm/kasan/report.c:602 __rb_map_vma+0x9ab/0xae0 kernel/trace/ring_buffer.c:7058 ring_buffer_map+0x56e/0x9b0 kernel/trace/ring_buffer.c:7138 tracing_buffers_mmap+0xa6/0x120 kernel/trace/trace.c:8482 call_mmap include/linux/fs.h:2183 [inline] mmap_file mm/internal.h:124 [inline] __mmap_new_file_vma mm/vma.c:2291 [inline] __mmap_new_vma mm/vma.c:2355 [inline] __mmap_region+0x1786/0x2670 mm/vma.c:2456 mmap_region+0x127/0x320 mm/mmap.c:1348 do_mmap+0xc00/0xfc0 mm/mmap.c:496 vm_mmap_pgoff+0x1ba/0x360 mm/util.c:580 ksys_mmap_pgoff+0x32c/0x5c0 mm/mmap.c:542 __do_sys_mmap arch/x86/kernel/sys_x86_64.c:89 [inline] __se_sys_mmap arch/x86/kernel/sys_x86_64.c:82 [inline] __x64_sys_mmap+0x125/0x190 arch/x86/kernel/sys_x86_64.c:82 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  The reproducer for this bug is:  ------------------------8<------------------------- #include <fcntl.h> #include <stdlib.h> #include <unistd.h> #include <asm/types.h> #include <sys/mman.h>  int main(int argc, char **argv) { int page_size = getpagesize(); int fd; void *meta;  system(\"echo 1 > /sys/kernel/tracing/buffer_size_kb\"); fd = open(\"/sys/kernel/tracing/per_cpu/cpu0/trace_pipe_raw\", O_RDONLY);  meta = mmap(NULL, page_size, PROT_READ, MAP_SHARED, fd, page_size * 5); } ------------------------>8-------------------------",
      "cve": "CVE-2024-56368",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56368",
          "value": "CVE-2024-56368",
          "url": "https://scout.docker.com/v/CVE-2024-56368?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56368?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "135cd4bb63598701a6b0469879e19360ea2a33709ccba11a0e3c39b6d8a83c7a",
      "category": "container_scanning",
      "message": "CVE-2024-56544 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  udmabuf: change folios array from kmalloc to kvmalloc  When PAGE_SIZE 4096, MAX_PAGE_ORDER 10, 64bit machine, page_alloc only support 4MB. If above this, trigger this warn and return NULL.  udmabuf can change size limit, if change it to 3072(3GB), and then alloc 3GB udmabuf, will fail create.  [ 4080.876581] ------------[ cut here ]------------ [ 4080.876843] WARNING: CPU: 3 PID: 2015 at mm/page_alloc.c:4556 __alloc_pages+0x2c8/0x350 [ 4080.878839] RIP: 0010:__alloc_pages+0x2c8/0x350 [ 4080.879470] Call Trace: [ 4080.879473]  <TASK> [ 4080.879473]  ? __alloc_pages+0x2c8/0x350 [ 4080.879475]  ? __warn.cold+0x8e/0xe8 [ 4080.880647]  ? __alloc_pages+0x2c8/0x350 [ 4080.880909]  ? report_bug+0xff/0x140 [ 4080.881175]  ? handle_bug+0x3c/0x80 [ 4080.881556]  ? exc_invalid_op+0x17/0x70 [ 4080.881559]  ? asm_exc_invalid_op+0x1a/0x20 [ 4080.882077]  ? udmabuf_create+0x131/0x400  Because MAX_PAGE_ORDER, kmalloc can max alloc 4096 * (1 << 10), 4MB memory, each array entry is pointer(8byte), so can save 524288 pages(2GB).  Further more, costly order(order 3) may not be guaranteed that it can be applied for, due to fragmentation.  This patch change udmabuf array use kvmalloc_array, this can fallback alloc into vmalloc, which can guarantee allocation for any size and does not affect the performance of kmalloc allocations.",
      "cve": "CVE-2024-56544",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56544",
          "value": "CVE-2024-56544",
          "url": "https://scout.docker.com/v/CVE-2024-56544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56544?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cbafed4feb9ade17e0af73819be1e9b308f4d3d65a2f73f510bf9b021d35f890",
      "category": "container_scanning",
      "message": "CVE-2024-56565 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to drop all discards after creating snapshot on lvm device  Piergiorgio reported a bug in bugzilla as below:  ------------[ cut here ]------------ WARNING: CPU: 2 PID: 969 at fs/f2fs/segment.c:1330 RIP: 0010:__submit_discard_cmd+0x27d/0x400 [f2fs] Call Trace: __issue_discard_cmd+0x1ca/0x350 [f2fs] issue_discard_thread+0x191/0x480 [f2fs] kthread+0xcf/0x100 ret_from_fork+0x31/0x50 ret_from_fork_asm+0x1a/0x30  w/ below testcase, it can reproduce this bug quickly: - pvcreate /dev/vdb - vgcreate myvg1 /dev/vdb - lvcreate -L 1024m -n mylv1 myvg1 - mount /dev/myvg1/mylv1 /mnt/f2fs - dd if=/dev/zero of=/mnt/f2fs/file bs=1M count=20 - sync - rm /mnt/f2fs/file - sync - lvcreate -L 1024m -s -n mylv1-snapshot /dev/myvg1/mylv1 - umount /mnt/f2fs  The root cause is: it will update discard_max_bytes of mounted lvm device to zero after creating snapshot on this lvm device, then, __submit_discard_cmd() will pass parameter @nr_sects w/ zero value to __blkdev_issue_discard(), it returns a NULL bio pointer, result in panic.  This patch changes as below for fixing: 1. Let's drop all remained discards in f2fs_unfreeze() if snapshot of lvm device is created. 2. Checking discard_max_bytes before submitting discard during __submit_discard_cmd().",
      "cve": "CVE-2024-56565",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56565",
          "value": "CVE-2024-56565",
          "url": "https://scout.docker.com/v/CVE-2024-56565?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56565?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fe45c1be1f6fd21805295a20c2bafc30ca78c392d7a28a54cdd46676ff262041",
      "category": "container_scanning",
      "message": "CVE-2024-56566 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/slub: Avoid list corruption when removing a slab from the full list  Boot with slub_debug=UFPZ.  If allocated object failed in alloc_consistency_checks, all objects of the slab will be marked as used, and then the slab will be removed from the partial list.  When an object belonging to the slab got freed later, the remove_full() function is called. Because the slab is neither on the partial list nor on the full list, it eventually lead to a list corruption (actually a list poison being detected).  So we need to mark and isolate the slab page with metadata corruption, do not put it back in circulation.  Because the debug caches avoid all the fastpaths, reusing the frozen bit to mark slab page with metadata corruption seems to be fine.  [ 4277.385669] list_del corruption, ffffea00044b3e50->next is LIST_POISON1 (dead000000000100) [ 4277.387023] ------------[ cut here ]------------ [ 4277.387880] kernel BUG at lib/list_debug.c:56! [ 4277.388680] invalid opcode: 0000 [#1] PREEMPT SMP PTI [ 4277.389562] CPU: 5 PID: 90 Comm: kworker/5:1 Kdump: loaded Tainted: G OE      6.6.1-1 #1 [ 4277.392113] Workqueue: xfs-inodegc/vda1 xfs_inodegc_worker [xfs] [ 4277.393551] RIP: 0010:__list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.394518] Code: 48 91 82 e8 37 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 28 49 91 82 e8 26 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 58 49 91 [ 4277.397292] RSP: 0018:ffffc90000333b38 EFLAGS: 00010082 [ 4277.398202] RAX: 000000000000004e RBX: ffffea00044b3e50 RCX: 0000000000000000 [ 4277.399340] RDX: 0000000000000002 RSI: ffffffff828f8715 RDI: 00000000ffffffff [ 4277.400545] RBP: ffffea00044b3e40 R08: 0000000000000000 R09: ffffc900003339f0 [ 4277.401710] R10: 0000000000000003 R11: ffffffff82d44088 R12: ffff888112cf9910 [ 4277.402887] R13: 0000000000000001 R14: 0000000000000001 R15: ffff8881000424c0 [ 4277.404049] FS:  0000000000000000(0000) GS:ffff88842fd40000(0000) knlGS:0000000000000000 [ 4277.405357] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 4277.406389] CR2: 00007f2ad0b24000 CR3: 0000000102a3a006 CR4: 00000000007706e0 [ 4277.407589] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 4277.408780] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 4277.410000] PKRU: 55555554 [ 4277.410645] Call Trace: [ 4277.411234]  <TASK> [ 4277.411777]  ? die+0x32/0x80 [ 4277.412439]  ? do_trap+0xd6/0x100 [ 4277.413150]  ? __list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.414158]  ? do_error_trap+0x6a/0x90 [ 4277.414948]  ? __list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.415915]  ? exc_invalid_op+0x4c/0x60 [ 4277.416710]  ? __list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.417675]  ? asm_exc_invalid_op+0x16/0x20 [ 4277.418482]  ? __list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.419466]  ? __list_del_entry_valid_or_report+0x7b/0xc0 [ 4277.420410]  free_to_partial_list+0x515/0x5e0 [ 4277.421242]  ? xfs_iext_remove+0x41a/0xa10 [xfs] [ 4277.422298]  xfs_iext_remove+0x41a/0xa10 [xfs] [ 4277.423316]  ? xfs_inodegc_worker+0xb4/0x1a0 [xfs] [ 4277.424383]  xfs_bmap_del_extent_delay+0x4fe/0x7d0 [xfs] [ 4277.425490]  __xfs_bunmapi+0x50d/0x840 [xfs] [ 4277.426445]  xfs_itruncate_extents_flags+0x13a/0x490 [xfs] [ 4277.427553]  xfs_inactive_truncate+0xa3/0x120 [xfs] [ 4277.428567]  xfs_inactive+0x22d/0x290 [xfs] [ 4277.429500]  xfs_inodegc_worker+0xb4/0x1a0 [xfs] [ 4277.430479]  process_one_work+0x171/0x340 [ 4277.431227]  worker_thread+0x277/0x390 [ 4277.431962]  ? __pfx_worker_thread+0x10/0x10 [ 4277.432752]  kthread+0xf0/0x120 [ 4277.433382]  ? __pfx_kthread+0x10/0x10 [ 4277.434134]  ret_from_fork+0x2d/0x50 [ 4277.434837]  ? __pfx_kthread+0x10/0x10 [ 4277.435566]  ret_from_fork_asm+0x1b/0x30 [ 4277.436280]  </TASK>",
      "cve": "CVE-2024-56566",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56566",
          "value": "CVE-2024-56566",
          "url": "https://scout.docker.com/v/CVE-2024-56566?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56566?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "121b856ca4438c1550a76370e3d701ccf4105d3b67640fdd1d74efe8c663538d",
      "category": "container_scanning",
      "message": "CVE-2024-56583 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  sched/deadline: Fix warning in migrate_enable for boosted tasks  When running the following command:  while true; do stress-ng --cyclic 30 --timeout 30s --minimize --quiet done  a warning is eventually triggered:  WARNING: CPU: 43 PID: 2848 at kernel/sched/deadline.c:794 setup_new_dl_entity+0x13e/0x180 ... Call Trace: <TASK> ? show_trace_log_lvl+0x1c4/0x2df ? enqueue_dl_entity+0x631/0x6e0 ? setup_new_dl_entity+0x13e/0x180 ? __warn+0x7e/0xd0 ? report_bug+0x11a/0x1a0 ? handle_bug+0x3c/0x70 ? exc_invalid_op+0x14/0x70 ? asm_exc_invalid_op+0x16/0x20 enqueue_dl_entity+0x631/0x6e0 enqueue_task_dl+0x7d/0x120 __do_set_cpus_allowed+0xe3/0x280 __set_cpus_allowed_ptr_locked+0x140/0x1d0 __set_cpus_allowed_ptr+0x54/0xa0 migrate_enable+0x7e/0x150 rt_spin_unlock+0x1c/0x90 group_send_sig_info+0xf7/0x1a0 ? kill_pid_info+0x1f/0x1d0 kill_pid_info+0x78/0x1d0 kill_proc_info+0x5b/0x110 __x64_sys_kill+0x93/0xc0 do_syscall_64+0x5c/0xf0 entry_SYSCALL_64_after_hwframe+0x6e/0x76 RIP: 0033:0x7f0dab31f92b  This warning occurs because set_cpus_allowed dequeues and enqueues tasks with the ENQUEUE_RESTORE flag set. If the task is boosted, the warning is triggered. A boosted task already had its parameters set by rt_mutex_setprio, and a new call to setup_new_dl_entity is unnecessary, hence the WARN_ON call.  Check if we are requeueing a boosted task and avoid calling setup_new_dl_entity if that's the case.",
      "cve": "CVE-2024-56583",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56583",
          "value": "CVE-2024-56583",
          "url": "https://scout.docker.com/v/CVE-2024-56583?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56583?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "126079382ea64340bd31f61dc5f34cce7524f6c4fe0a7f3745ff86ef3bcec6e3",
      "category": "container_scanning",
      "message": "CVE-2024-56584 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring/tctx: work around xa_store() allocation error issue  syzbot triggered the following WARN_ON:  WARNING: CPU: 0 PID: 16 at io_uring/tctx.c:51 __io_uring_free+0xfa/0x140 io_uring/tctx.c:51  which is the  WARN_ON_ONCE(!xa_empty(&tctx->xa));  sanity check in __io_uring_free() when a io_uring_task is going through its final put. The syzbot test case includes injecting memory allocation failures, and it very much looks like xa_store() can fail one of its memory allocations and end up with ->head being non-NULL even though no entries exist in the xarray.  Until this issue gets sorted out, work around it by attempting to iterate entries in our xarray, and WARN_ON_ONCE() if one is found.",
      "cve": "CVE-2024-56584",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56584",
          "value": "CVE-2024-56584",
          "url": "https://scout.docker.com/v/CVE-2024-56584?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56584?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "55dd30e8012095e612bb0bd81dd46dcba514e2e128c990dbdb1b300d197ca0db",
      "category": "container_scanning",
      "message": "CVE-2024-56588 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: hisi_sas: Create all dump files during debugfs initialization  For the current debugfs of hisi_sas, after user triggers dump, the driver allocate memory space to save the register information and create debugfs files to display the saved information. In this process, the debugfs files created after each dump.  Therefore, when the dump is triggered while the driver is unbind, the following hang occurs:  [67840.853907] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0 [67840.862947] Mem abort info: [67840.865855]   ESR = 0x0000000096000004 [67840.869713]   EC = 0x25: DABT (current EL), IL = 32 bits [67840.875125]   SET = 0, FnV = 0 [67840.878291]   EA = 0, S1PTW = 0 [67840.881545]   FSC = 0x04: level 0 translation fault [67840.886528] Data abort info: [67840.889524]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [67840.895117]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [67840.900284]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [67840.905709] user pgtable: 4k pages, 48-bit VAs, pgdp=0000002803a1f000 [67840.912263] [00000000000000a0] pgd=0000000000000000, p4d=0000000000000000 [67840.919177] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [67840.996435] pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [67841.003628] pc : down_write+0x30/0x98 [67841.007546] lr : start_creating.part.0+0x60/0x198 [67841.012495] sp : ffff8000b979ba20 [67841.016046] x29: ffff8000b979ba20 x28: 0000000000000010 x27: 0000000000024b40 [67841.023412] x26: 0000000000000012 x25: ffff20202b355ae8 x24: ffff20202b35a8c8 [67841.030779] x23: ffffa36877928208 x22: ffffa368b4972240 x21: ffff8000b979bb18 [67841.038147] x20: ffff00281dc1e3c0 x19: fffffffffffffffe x18: 0000000000000020 [67841.045515] x17: 0000000000000000 x16: ffffa368b128a530 x15: ffffffffffffffff [67841.052888] x14: ffff8000b979bc18 x13: ffffffffffffffff x12: ffff8000b979bb18 [67841.060263] x11: 0000000000000000 x10: 0000000000000000 x9 : ffffa368b1289b18 [67841.067640] x8 : 0000000000000012 x7 : 0000000000000000 x6 : 00000000000003a9 [67841.075014] x5 : 0000000000000000 x4 : ffff002818c5cb00 x3 : 0000000000000001 [67841.082388] x2 : 0000000000000000 x1 : ffff002818c5cb00 x0 : 00000000000000a0 [67841.089759] Call trace: [67841.092456]  down_write+0x30/0x98 [67841.096017]  start_creating.part.0+0x60/0x198 [67841.100613]  debugfs_create_dir+0x48/0x1f8 [67841.104950]  debugfs_create_files_v3_hw+0x88/0x348 [hisi_sas_v3_hw] [67841.111447]  debugfs_snapshot_regs_v3_hw+0x708/0x798 [hisi_sas_v3_hw] [67841.118111]  debugfs_trigger_dump_v3_hw_write+0x9c/0x120 [hisi_sas_v3_hw] [67841.125115]  full_proxy_write+0x68/0xc8 [67841.129175]  vfs_write+0xd8/0x3f0 [67841.132708]  ksys_write+0x70/0x108 [67841.136317]  __arm64_sys_write+0x24/0x38 [67841.140440]  invoke_syscall+0x50/0x128 [67841.144385]  el0_svc_common.constprop.0+0xc8/0xf0 [67841.149273]  do_el0_svc+0x24/0x38 [67841.152773]  el0_svc+0x38/0xd8 [67841.156009]  el0t_64_sync_handler+0xc0/0xc8 [67841.160361]  el0t_64_sync+0x1a4/0x1a8 [67841.164189] Code: b9000882 d2800002 d2800023 f9800011 (c85ffc05) [67841.170443] ---[ end trace 0000000000000000 ]---  To fix this issue, create all directories and files during debugfs initialization. In this way, the driver only needs to allocate memory space to save information each time the user triggers dumping.",
      "cve": "CVE-2024-56588",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56588",
          "value": "CVE-2024-56588",
          "url": "https://scout.docker.com/v/CVE-2024-56588?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56588?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d49c36646dfcc7e28deb41449dcb4f9d5cebff4e7f2b64740be4b4e7cce1ffe8",
      "category": "container_scanning",
      "message": "CVE-2024-56591 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_conn: Use disable_delayed_work_sync  This makes use of disable_delayed_work_sync instead cancel_delayed_work_sync as it not only cancel the ongoing work but also disables new submit which is disarable since the object holding the work is about to be freed.",
      "cve": "CVE-2024-56591",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56591",
          "value": "CVE-2024-56591",
          "url": "https://scout.docker.com/v/CVE-2024-56591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56591?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6919ebace897b528d546a79c15e80e043ba9a0ac05f23207ac458a32c186b1ab",
      "category": "container_scanning",
      "message": "CVE-2024-56592 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Call free_htab_elem() after htab_unlock_bucket()  For htab of maps, when the map is removed from the htab, it may hold the last reference of the map. bpf_map_fd_put_ptr() will invoke bpf_map_free_id() to free the id of the removed map element. However, bpf_map_fd_put_ptr() is invoked while holding a bucket lock (raw_spin_lock_t), and bpf_map_free_id() attempts to acquire map_idr_lock (spinlock_t), triggering the following lockdep warning:  ============================= [ BUG: Invalid wait context ] 6.11.0-rc4+ #49 Not tainted ----------------------------- test_maps/4881 is trying to lock: ffffffff84884578 (map_idr_lock){+...}-{3:3}, at: bpf_map_free_id.part.0+0x21/0x70 other info that might help us debug this: context-{5:5} 2 locks held by test_maps/4881: #0: ffffffff846caf60 (rcu_read_lock){....}-{1:3}, at: bpf_fd_htab_map_update_elem+0xf9/0x270 #1: ffff888149ced148 (&htab->lockdep_key#2){....}-{2:2}, at: htab_map_update_elem+0x178/0xa80 stack backtrace: CPU: 0 UID: 0 PID: 4881 Comm: test_maps Not tainted 6.11.0-rc4+ #49 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), ... Call Trace: <TASK> dump_stack_lvl+0x6e/0xb0 dump_stack+0x10/0x20 __lock_acquire+0x73e/0x36c0 lock_acquire+0x182/0x450 _raw_spin_lock_irqsave+0x43/0x70 bpf_map_free_id.part.0+0x21/0x70 bpf_map_put+0xcf/0x110 bpf_map_fd_put_ptr+0x9a/0xb0 free_htab_elem+0x69/0xe0 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 htab_map_update_elem+0x50f/0xa80 bpf_fd_htab_map_update_elem+0x131/0x270 bpf_map_update_value+0x266/0x380 __sys_bpf+0x21bb/0x36b0 __x64_sys_bpf+0x45/0x60 x64_sys_call+0x1b2a/0x20d0 do_syscall_64+0x5d/0x100 entry_SYSCALL_64_after_hwframe+0x76/0x7e  One way to fix the lockdep warning is using raw_spinlock_t for map_idr_lock as well. However, bpf_map_alloc_id() invokes idr_alloc_cyclic() after acquiring map_idr_lock, it will trigger a similar lockdep warning because the slab's lock (s->cpu_slab->lock) is still a spinlock.  Instead of changing map_idr_lock's type, fix the issue by invoking htab_put_fd_value() after htab_unlock_bucket(). However, only deferring the invocation of htab_put_fd_value() is not enough, because the old map pointers in htab of maps can not be saved during batched deletion. Therefore, also defer the invocation of free_htab_elem(), so these to-be-freed elements could be linked together similar to lru map.  There are four callers for ->map_fd_put_ptr:  (1) alloc_htab_elem() (through htab_put_fd_value()) It invokes ->map_fd_put_ptr() under a raw_spinlock_t. The invocation of htab_put_fd_value() can not simply move after htab_unlock_bucket(), because the old element has already been stashed in htab->extra_elems. It may be reused immediately after htab_unlock_bucket() and the invocation of htab_put_fd_value() after htab_unlock_bucket() may release the newly-added element incorrectly. Therefore, saving the map pointer of the old element for htab of maps before unlocking the bucket and releasing the map_ptr after unlock. Beside the map pointer in the old element, should do the same thing for the special fields in the old element as well.  (2) free_htab_elem() (through htab_put_fd_value()) Its caller includes __htab_map_lookup_and_delete_elem(), htab_map_delete_elem() and __htab_map_lookup_and_delete_batch().  For htab_map_delete_elem(), simply invoke free_htab_elem() after htab_unlock_bucket(). For __htab_map_lookup_and_delete_batch(), just like lru map, linking the to-be-freed element into node_to_free list and invoking free_htab_elem() for these element after unlock. It is safe to reuse batch_flink as the link for node_to_free, because these elements have been removed from the hash llist.  Because htab of maps doesn't support lookup_and_delete operation, __htab_map_lookup_and_delete_elem() doesn't have the problem, so kept it as ---truncated---",
      "cve": "CVE-2024-56592",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56592",
          "value": "CVE-2024-56592",
          "url": "https://scout.docker.com/v/CVE-2024-56592?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56592?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7c5d4f0161930795b24feb799600767de2c2c71653c795c932a3c8b9a65a938d",
      "category": "container_scanning",
      "message": "CVE-2024-56607 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix atomic calls in ath12k_mac_op_set_bitrate_mask()  When I try to manually set bitrates:  iw wlan0 set bitrates legacy-2.4 1  I get sleeping from invalid context error, see below. Fix that by switching to use recently introduced ieee80211_iterate_stations_mtx().  Do note that WCN6855 firmware is still crashing, I'm not sure if that firmware even supports bitrate WMI commands and should we consider disabling ath12k_mac_op_set_bitrate_mask() for WCN6855? But that's for another patch.  BUG: sleeping function called from invalid context at drivers/net/wireless/ath/ath12k/wmi.c:420 in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 2236, name: iw preempt_count: 0, expected: 0 RCU nest depth: 1, expected: 0 3 locks held by iw/2236: #0: ffffffffabc6f1d8 (cb_lock){++++}-{3:3}, at: genl_rcv+0x14/0x40 #1: ffff888138410810 (&rdev->wiphy.mtx){+.+.}-{3:3}, at: nl80211_pre_doit+0x54d/0x800 [cfg80211] #2: ffffffffab2cfaa0 (rcu_read_lock){....}-{1:2}, at: ieee80211_iterate_stations_atomic+0x2f/0x200 [mac80211] CPU: 3 UID: 0 PID: 2236 Comm: iw Not tainted 6.11.0-rc7-wt-ath+ #1772 Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021 Call Trace: <TASK> dump_stack_lvl+0xa4/0xe0 dump_stack+0x10/0x20 __might_resched+0x363/0x5a0 ? __alloc_skb+0x165/0x340 __might_sleep+0xad/0x160 ath12k_wmi_cmd_send+0xb1/0x3d0 [ath12k] ? ath12k_wmi_init_wcn7850+0xa40/0xa40 [ath12k] ? __netdev_alloc_skb+0x45/0x7b0 ? __asan_memset+0x39/0x40 ? ath12k_wmi_alloc_skb+0xf0/0x150 [ath12k] ? reacquire_held_locks+0x4d0/0x4d0 ath12k_wmi_set_peer_param+0x340/0x5b0 [ath12k] ath12k_mac_disable_peer_fixed_rate+0xa3/0x110 [ath12k] ? ath12k_mac_vdev_stop+0x4f0/0x4f0 [ath12k] ieee80211_iterate_stations_atomic+0xd4/0x200 [mac80211] ath12k_mac_op_set_bitrate_mask+0x5d2/0x1080 [ath12k] ? ath12k_mac_vif_chan+0x320/0x320 [ath12k] drv_set_bitrate_mask+0x267/0x470 [mac80211] ieee80211_set_bitrate_mask+0x4cc/0x8a0 [mac80211] ? __this_cpu_preempt_check+0x13/0x20 nl80211_set_tx_bitrate_mask+0x2bc/0x530 [cfg80211] ? nl80211_parse_tx_bitrate_mask+0x2320/0x2320 [cfg80211] ? trace_contention_end+0xef/0x140 ? rtnl_unlock+0x9/0x10 ? nl80211_pre_doit+0x557/0x800 [cfg80211] genl_family_rcv_msg_doit+0x1f0/0x2e0 ? genl_family_rcv_msg_attrs_parse.isra.0+0x250/0x250 ? ns_capable+0x57/0xd0 genl_family_rcv_msg+0x34c/0x600 ? genl_family_rcv_msg_dumpit+0x310/0x310 ? __lock_acquire+0xc62/0x1de0 ? he_set_mcs_mask.isra.0+0x8d0/0x8d0 [cfg80211] ? nl80211_parse_tx_bitrate_mask+0x2320/0x2320 [cfg80211] ? cfg80211_external_auth_request+0x690/0x690 [cfg80211] genl_rcv_msg+0xa0/0x130 netlink_rcv_skb+0x14c/0x400 ? genl_family_rcv_msg+0x600/0x600 ? netlink_ack+0xd70/0xd70 ? rwsem_optimistic_spin+0x4f0/0x4f0 ? genl_rcv+0x14/0x40 ? down_read_killable+0x580/0x580 ? netlink_deliver_tap+0x13e/0x350 ? __this_cpu_preempt_check+0x13/0x20 genl_rcv+0x23/0x40 netlink_unicast+0x45e/0x790 ? netlink_attachskb+0x7f0/0x7f0 netlink_sendmsg+0x7eb/0xdb0 ? netlink_unicast+0x790/0x790 ? __this_cpu_preempt_check+0x13/0x20 ? selinux_socket_sendmsg+0x31/0x40 ? netlink_unicast+0x790/0x790 __sock_sendmsg+0xc9/0x160 ____sys_sendmsg+0x620/0x990 ? kernel_sendmsg+0x30/0x30 ? __copy_msghdr+0x410/0x410 ? __kasan_check_read+0x11/0x20 ? mark_lock+0xe6/0x1470 ___sys_sendmsg+0xe9/0x170 ? copy_msghdr_from_user+0x120/0x120 ? __lock_acquire+0xc62/0x1de0 ? do_fault_around+0x2c6/0x4e0 ? do_user_addr_fault+0x8c1/0xde0 ? reacquire_held_locks+0x220/0x4d0 ? do_user_addr_fault+0x8c1/0xde0 ? __kasan_check_read+0x11/0x20 ? __fdget+0x4e/0x1d0 ? sockfd_lookup_light+0x1a/0x170 __sys_sendmsg+0xd2/0x180 ? __sys_sendmsg_sock+0x20/0x20 ? reacquire_held_locks+0x4d0/0x4d0 ? debug_smp_processor_id+0x17/0x20 __x64_sys_sendmsg+0x72/0xb0 ? lockdep_hardirqs_on+0x7d/0x100 x64_sys_call+0x894/0x9f0 do_syscall_64+0x64/0x130 entry_SYSCALL_64_after_ ---truncated---",
      "cve": "CVE-2024-56607",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56607",
          "value": "CVE-2024-56607",
          "url": "https://scout.docker.com/v/CVE-2024-56607?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56607?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7f71aa67f7efd502e6547a81b6575a5566000826fb2d26470b3e3ab2a61a7fb9",
      "category": "container_scanning",
      "message": "CVE-2024-56611 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/mempolicy: fix migrate_to_node() assuming there is at least one VMA in a MM  We currently assume that there is at least one VMA in a MM, which isn't true.  So we might end up having find_vma() return NULL, to then de-reference NULL.  So properly handle find_vma() returning NULL.  This fixes the report:  Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 UID: 0 PID: 6021 Comm: syz-executor284 Not tainted 6.12.0-rc7-syzkaller-00187-gf868cd251776 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024 RIP: 0010:migrate_to_node mm/mempolicy.c:1090 [inline] RIP: 0010:do_migrate_pages+0x403/0x6f0 mm/mempolicy.c:1194 Code: ... RSP: 0018:ffffc9000375fd08 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffc9000375fd78 RCX: 0000000000000000 RDX: ffff88807e171300 RSI: dffffc0000000000 RDI: ffff88803390c044 RBP: ffff88807e171428 R08: 0000000000000014 R09: fffffbfff2039ef1 R10: ffffffff901cf78f R11: 0000000000000000 R12: 0000000000000003 R13: ffffc9000375fe90 R14: ffffc9000375fe98 R15: ffffc9000375fdf8 FS:  00005555919e1380(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005555919e1ca8 CR3: 000000007f12a000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> kernel_migrate_pages+0x5b2/0x750 mm/mempolicy.c:1709 __do_sys_migrate_pages mm/mempolicy.c:1727 [inline] __se_sys_migrate_pages mm/mempolicy.c:1723 [inline] __x64_sys_migrate_pages+0x96/0x100 mm/mempolicy.c:1723 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f  [akpm@linux-foundation.org: add unlikely()]",
      "cve": "CVE-2024-56611",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56611",
          "value": "CVE-2024-56611",
          "url": "https://scout.docker.com/v/CVE-2024-56611?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56611?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "54b11664b164a01119f89093fea414ee4e95d0b7d9e85a62966c1057a0861758",
      "category": "container_scanning",
      "message": "CVE-2024-56639 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hsr: must allocate more bytes for RedBox support  Blamed commit forgot to change hsr_init_skb() to allocate larger skb for RedBox case.  Indeed, send_hsr_supervision_frame() will add two additional components (struct hsr_sup_tlv and struct hsr_sup_payload)  syzbot reported the following crash: skbuff: skb_over_panic: text:ffffffff8afd4b0a len:34 put:6 head:ffff88802ad29e00 data:ffff88802ad29f22 tail:0x144 end:0x140 dev:gretap0 ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:206 ! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 2 UID: 0 PID: 7611 Comm: syz-executor Not tainted 6.12.0-syzkaller #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:skb_panic+0x157/0x1d0 net/core/skbuff.c:206 Code: b6 04 01 84 c0 74 04 3c 03 7e 21 8b 4b 70 41 56 45 89 e8 48 c7 c7 a0 7d 9b 8c 41 57 56 48 89 ee 52 4c 89 e2 e8 9a 76 79 f8 90 <0f> 0b 4c 89 4c 24 10 48 89 54 24 08 48 89 34 24 e8 94 76 fb f8 4c RSP: 0018:ffffc90000858ab8 EFLAGS: 00010282 RAX: 0000000000000087 RBX: ffff8880598c08c0 RCX: ffffffff816d3e69 RDX: 0000000000000000 RSI: ffffffff816de786 RDI: 0000000000000005 RBP: ffffffff8c9b91c0 R08: 0000000000000005 R09: 0000000000000000 R10: 0000000000000302 R11: ffffffff961cc1d0 R12: ffffffff8afd4b0a R13: 0000000000000006 R14: ffff88804b938130 R15: 0000000000000140 FS:  000055558a3d6500(0000) GS:ffff88806a800000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f1295974ff8 CR3: 000000002ab6e000 CR4: 0000000000352ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> skb_over_panic net/core/skbuff.c:211 [inline] skb_put+0x174/0x1b0 net/core/skbuff.c:2617 send_hsr_supervision_frame+0x6fa/0x9e0 net/hsr/hsr_device.c:342 hsr_proxy_announce+0x1a3/0x4a0 net/hsr/hsr_device.c:436 call_timer_fn+0x1a0/0x610 kernel/time/timer.c:1794 expire_timers kernel/time/timer.c:1845 [inline] __run_timers+0x6e8/0x930 kernel/time/timer.c:2419 __run_timer_base kernel/time/timer.c:2430 [inline] __run_timer_base kernel/time/timer.c:2423 [inline] run_timer_base+0x111/0x190 kernel/time/timer.c:2439 run_timer_softirq+0x1a/0x40 kernel/time/timer.c:2449 handle_softirqs+0x213/0x8f0 kernel/softirq.c:554 __do_softirq kernel/softirq.c:588 [inline] invoke_softirq kernel/softirq.c:428 [inline] __irq_exit_rcu kernel/softirq.c:637 [inline] irq_exit_rcu+0xbb/0x120 kernel/softirq.c:649 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline] sysvec_apic_timer_interrupt+0xa4/0xc0 arch/x86/kernel/apic/apic.c:1049 </IRQ>",
      "cve": "CVE-2024-56639",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56639",
          "value": "CVE-2024-56639",
          "url": "https://scout.docker.com/v/CVE-2024-56639?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56639?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8f3d6a32e067fe577eafbb46dff713583330bd8fac037fcd34ac909f491d1a31",
      "category": "container_scanning",
      "message": "CVE-2024-56641 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: initialize close_work early to avoid warning  We encountered a warning that close_work was canceled before initialization.  WARNING: CPU: 7 PID: 111103 at kernel/workqueue.c:3047 __flush_work+0x19e/0x1b0 Workqueue: events smc_lgr_terminate_work [smc] RIP: 0010:__flush_work+0x19e/0x1b0 Call Trace: ? __wake_up_common+0x7a/0x190 ? work_busy+0x80/0x80 __cancel_work_timer+0xe3/0x160 smc_close_cancel_work+0x1a/0x70 [smc] smc_close_active_abort+0x207/0x360 [smc] __smc_lgr_terminate.part.38+0xc8/0x180 [smc] process_one_work+0x19e/0x340 worker_thread+0x30/0x370 ? process_one_work+0x340/0x340 kthread+0x117/0x130 ? __kthread_cancel_work+0x50/0x50 ret_from_fork+0x22/0x30  This is because when smc_close_cancel_work is triggered, e.g. the RDMA driver is rmmod and the LGR is terminated, the conn->close_work is flushed before initialization, resulting in WARN_ON(!work->func).  __smc_lgr_terminate             | smc_connect_{rdma|ism} ------------------------------------------------------------- | smc_conn_create | \\- smc_lgr_register_conn for conn in lgr->conns_all      | \\- smc_conn_kill                | \\- smc_close_active_abort    | \\- smc_close_cancel_work  | \\- cancel_work_sync    | \\- __flush_work     | (close_work)   | | smc_close_init | \\- INIT_WORK(&close_work)  So fix this by initializing close_work before establishing the connection.",
      "cve": "CVE-2024-56641",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56641",
          "value": "CVE-2024-56641",
          "url": "https://scout.docker.com/v/CVE-2024-56641?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56641?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b081288d5d557ad314af252e76ef91adc3589b97b8b2c6e52cdc635205af016e",
      "category": "container_scanning",
      "message": "CVE-2024-56647 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: Fix icmp host relookup triggering ip_rt_bug  arp link failure may trigger ip_rt_bug while xfrm enabled, call trace is:  WARNING: CPU: 0 PID: 0 at net/ipv4/route.c:1241 ip_rt_bug+0x14/0x20 Modules linked in: CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc6-00077-g2e1b3cc9d7f7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:ip_rt_bug+0x14/0x20 Call Trace: <IRQ> ip_send_skb+0x14/0x40 __icmp_send+0x42d/0x6a0 ipv4_link_failure+0xe2/0x1d0 arp_error_report+0x3c/0x50 neigh_invalidate+0x8d/0x100 neigh_timer_handler+0x2e1/0x330 call_timer_fn+0x21/0x120 __run_timer_base.part.0+0x1c9/0x270 run_timer_softirq+0x4c/0x80 handle_softirqs+0xac/0x280 irq_exit_rcu+0x62/0x80 sysvec_apic_timer_interrupt+0x77/0x90  The script below reproduces this scenario: ip xfrm policy add src 0.0.0.0/0 dst 0.0.0.0/0 \\ dir out priority 0 ptype main flag localok icmp ip l a veth1 type veth ip a a 192.168.141.111/24 dev veth0 ip l s veth0 up ping 192.168.141.155 -c 1  icmp_route_lookup() create input routes for locally generated packets while xfrm relookup ICMP traffic.Then it will set input route (dst->out = ip_rt_bug) to skb for DESTUNREACH.  For ICMP err triggered by locally generated packets, dst->dev of output route is loopback. Generally, xfrm relookup verification is not required on loopback interfaces (net.ipv4.conf.lo.disable_xfrm = 1).  Skip icmp relookup for locally generated packets to fix it.",
      "cve": "CVE-2024-56647",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56647",
          "value": "CVE-2024-56647",
          "url": "https://scout.docker.com/v/CVE-2024-56647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56647?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d5ac54079550df820db5aab6948d64a505b64f5f30305e9635c3b7e39f058be1",
      "category": "container_scanning",
      "message": "CVE-2024-56657 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: control: Avoid WARN() for symlink errors  Using WARN() for showing the error of symlink creations don't give more information than telling that something goes wrong, since the usual code path is a lregister callback from each control element creation.  More badly, the use of WARN() rather confuses fuzzer as if it were serious issues.  This patch downgrades the warning messages to use the normal dev_err() instead of WARN().  For making it clearer, add the function name to the prefix, too.",
      "cve": "CVE-2024-56657",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56657",
          "value": "CVE-2024-56657",
          "url": "https://scout.docker.com/v/CVE-2024-56657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56657?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ae783c32081bdfb3b4d19bd3fdd2b205efd8253450f683702edb058558d57f26",
      "category": "container_scanning",
      "message": "CVE-2024-56660 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: DR, prevent potential error pointer dereference  The dr_domain_add_vport_cap() function generally returns NULL on error but sometimes we want it to return ERR_PTR(-EBUSY) so the caller can retry.  The problem here is that \"ret\" can be either -EBUSY or -ENOMEM and if it's and -ENOMEM then the error pointer is propogated back and eventually dereferenced in dr_ste_v0_build_src_gvmi_qpn_tag().",
      "cve": "CVE-2024-56660",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56660",
          "value": "CVE-2024-56660",
          "url": "https://scout.docker.com/v/CVE-2024-56660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56660?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1bf8143cda4065443d9cecab4914f508e6686e69c223db5f683a4b39edd8c579",
      "category": "container_scanning",
      "message": "CVE-2024-56665 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf,perf: Fix invalid prog_array access in perf_event_detach_bpf_prog  Syzbot reported [1] crash that happens for following tracing scenario:  - create tracepoint perf event with attr.inherit=1, attach it to the process and set bpf program to it - attached process forks -> chid creates inherited event  the new child event shares the parent's bpf program and tp_event (hence prog_array) which is global for tracepoint  - exit both process and its child -> release both events - first perf_event_detach_bpf_prog call will release tp_event->prog_array and second perf_event_detach_bpf_prog will crash, because tp_event->prog_array is NULL  The fix makes sure the perf_event_detach_bpf_prog checks prog_array is valid before it tries to remove the bpf program from it.  [1] https://lore.kernel.org/bpf/Z1MR6dCIKajNS6nU@krava/T/#m91dbf0688221ec7a7fc95e896a7ef9ff93b0b8ad",
      "cve": "CVE-2024-56665",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56665",
          "value": "CVE-2024-56665",
          "url": "https://scout.docker.com/v/CVE-2024-56665?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56665?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3e807a3ed16e690243d20d505ece3a53a0a11c1367c3071bbf006548b746051d",
      "category": "container_scanning",
      "message": "CVE-2024-56671 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gpio: graniterapids: Fix vGPIO driver crash  Move setting irq_chip.name from probe() function to the initialization of \"irq_chip\" struct in order to fix vGPIO driver crash during bootup.  Crash was caused by unauthorized modification of irq_chip.name field where irq_chip struct was initialized as const.  This behavior is a consequence of suboptimal implementation of gpio_irq_chip_set_chip(), which should be changed to avoid casting away const qualifier.  Crash log: BUG: unable to handle page fault for address: ffffffffc0ba81c0 /#PF: supervisor write access in kernel mode /#PF: error_code(0x0003) - permissions violation CPU: 33 UID: 0 PID: 1075 Comm: systemd-udevd Not tainted 6.12.0-rc6-00077-g2e1b3cc9d7f7 #1 Hardware name: Intel Corporation Kaseyville RP/Kaseyville RP, BIOS KVLDCRB1.PGS.0026.D73.2410081258 10/08/2024 RIP: 0010:gnr_gpio_probe+0x171/0x220 [gpio_graniterapids]",
      "cve": "CVE-2024-56671",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56671",
          "value": "CVE-2024-56671",
          "url": "https://scout.docker.com/v/CVE-2024-56671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56671?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "66ce3286042615c4baffd95c083e0d463cbf33c0162dda99765835ba09f11b90",
      "category": "container_scanning",
      "message": "CVE-2024-56674 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  virtio_net: correct netdev_tx_reset_queue() invocation point  When virtnet_close is followed by virtnet_open, some TX completions can possibly remain unconsumed, until they are finally processed during the first NAPI poll after the netdev_tx_reset_queue(), resulting in a crash [1]. Commit b96ed2c97c79 (\"virtio_net: move netdev_tx_reset_queue() call before RX napi enable\") was not sufficient to eliminate all BQL crash cases for virtio-net.  This issue can be reproduced with the latest net-next master by running: `while :; do ip l set DEV down; ip l set DEV up; done` under heavy network TX load from inside the machine.  netdev_tx_reset_queue() can actually be dropped from virtnet_open path; the device is not stopped in any case. For BQL core part, it's just like traffic nearly ceases to exist for some period. For stall detector added to BQL, even if virtnet_close could somehow lead to some TX completions delayed for long, followed by virtnet_open, we can just take it as stall as mentioned in commit 6025b9135f7a (\"net: dqs: add NIC stall detector based on BQL\"). Note also that users can still reset stall_max via sysfs.  So, drop netdev_tx_reset_queue() from virtnet_enable_queue_pair(). This eliminates the BQL crashes. As a result, netdev_tx_reset_queue() is now explicitly required in freeze/restore path. This patch adds it to immediately after free_unused_bufs(), following the rule of thumb: netdev_tx_reset_queue() should follow any SKB freeing not followed by netdev_tx_completed_queue(). This seems the most consistent and streamlined approach, and now netdev_tx_reset_queue() runs whenever free_unused_bufs() is done.  [1]: ------------[ cut here ]------------ kernel BUG at lib/dynamic_queue_limits.c:99! Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 7 UID: 0 PID: 1598 Comm: ip Tainted: G    N 6.12.0net-next_main+ #2 Tainted: [N]=TEST Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), \\ BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:dql_completed+0x26b/0x290 Code: b7 c2 49 89 e9 44 89 da 89 c6 4c 89 d7 e8 ed 17 47 00 58 65 ff 0d 4d 27 90 7e 0f 85 fd fe ff ff e8 ea 53 8d ff e9 f3 fe ff ff <0f> 0b 01 d2 44 89 d1 29 d1 ba 00 00 00 00 0f 48 ca e9 28 ff ff ff RSP: 0018:ffffc900002b0d08 EFLAGS: 00010297 RAX: 0000000000000000 RBX: ffff888102398c80 RCX: 0000000080190009 RDX: 0000000000000000 RSI: 000000000000006a RDI: 0000000000000000 RBP: ffff888102398c00 R08: 0000000000000000 R09: 0000000000000000 R10: 00000000000000ca R11: 0000000000015681 R12: 0000000000000001 R13: ffffc900002b0d68 R14: ffff88811115e000 R15: ffff8881107aca40 FS:  00007f41ded69500(0000) GS:ffff888667dc0000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000556ccc2dc1a0 CR3: 0000000104fd8003 CR4: 0000000000772ef0 PKRU: 55555554 Call Trace: <IRQ> ? die+0x32/0x80 ? do_trap+0xd9/0x100 ? dql_completed+0x26b/0x290 ? dql_completed+0x26b/0x290 ? do_error_trap+0x6d/0xb0 ? dql_completed+0x26b/0x290 ? exc_invalid_op+0x4c/0x60 ? dql_completed+0x26b/0x290 ? asm_exc_invalid_op+0x16/0x20 ? dql_completed+0x26b/0x290 __free_old_xmit+0xff/0x170 [virtio_net] free_old_xmit+0x54/0xc0 [virtio_net] virtnet_poll+0xf4/0xe30 [virtio_net] ? __update_load_avg_cfs_rq+0x264/0x2d0 ? update_curr+0x35/0x260 ? reweight_entity+0x1be/0x260 __napi_poll.constprop.0+0x28/0x1c0 net_rx_action+0x329/0x420 ? enqueue_hrtimer+0x35/0x90 ? trace_hardirqs_on+0x1d/0x80 ? kvm_sched_clock_read+0xd/0x20 ? sched_clock+0xc/0x30 ? kvm_sched_clock_read+0xd/0x20 ? sched_clock+0xc/0x30 ? sched_clock_cpu+0xd/0x1a0 handle_softirqs+0x138/0x3e0 do_softirq.part.0+0x89/0xc0 </IRQ> <TASK> __local_bh_enable_ip+0xa7/0xb0 virtnet_open+0xc8/0x310 [virtio_net] __dev_open+0xfa/0x1b0 __dev_change_flags+0x1de/0x250 dev_change_flags+0x22/0x60 do_setlink.isra.0+0x2df/0x10b0 ? rtnetlink_rcv_msg+0x34f/0x3f0 ? netlink_rcv_skb+0x54/0x100 ? netlink_unicas ---truncated---",
      "cve": "CVE-2024-56674",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56674",
          "value": "CVE-2024-56674",
          "url": "https://scout.docker.com/v/CVE-2024-56674?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56674?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9d0821d73d78d839477e4c4d4a2d514a6c11d206629f28a0a656b52104313068",
      "category": "container_scanning",
      "message": "CVE-2024-56677 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/fadump: Move fadump_cma_init to setup_arch() after initmem_init()  During early init CMA_MIN_ALIGNMENT_BYTES can be PAGE_SIZE, since pageblock_order is still zero and it gets initialized later during initmem_init() e.g. setup_arch() -> initmem_init() -> sparse_init() -> set_pageblock_order()  One such use case where this causes issue is - early_setup() -> early_init_devtree() -> fadump_reserve_mem() -> fadump_cma_init()  This causes CMA memory alignment check to be bypassed in cma_init_reserved_mem(). Then later cma_activate_area() can hit a VM_BUG_ON_PAGE(pfn & ((1 << order) - 1)) if the reserved memory area was not pageblock_order aligned.  Fix it by moving the fadump_cma_init() after initmem_init(), where other such cma reservations also gets called.  <stack trace> ============== page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10010 flags: 0x13ffff800000000(node=1|zone=0|lastcpupid=0x7ffff) CMA raw: 013ffff800000000 5deadbeef0000100 5deadbeef0000122 0000000000000000 raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000 page dumped because: VM_BUG_ON_PAGE(pfn & ((1 << order) - 1)) ------------[ cut here ]------------ kernel BUG at mm/page_alloc.c:778!  Call Trace: __free_one_page+0x57c/0x7b0 (unreliable) free_pcppages_bulk+0x1a8/0x2c8 free_unref_page_commit+0x3d4/0x4e4 free_unref_page+0x458/0x6d0 init_cma_reserved_pageblock+0x114/0x198 cma_init_reserved_areas+0x270/0x3e0 do_one_initcall+0x80/0x2f8 kernel_init_freeable+0x33c/0x530 kernel_init+0x34/0x26c ret_from_kernel_user_thread+0x14/0x1c",
      "cve": "CVE-2024-56677",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56677",
          "value": "CVE-2024-56677",
          "url": "https://scout.docker.com/v/CVE-2024-56677?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56677?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "995a13b7855332763ab0a9216a5f1692d95e5f87e92c868549582ffd8a856718",
      "category": "container_scanning",
      "message": "CVE-2024-56692 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to do sanity check on node blkaddr in truncate_node()  syzbot reports a f2fs bug as below:  ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2534! RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534 Call Trace: truncate_node+0x1ae/0x8c0 fs/f2fs/node.c:909 f2fs_remove_inode_page+0x5c2/0x870 fs/f2fs/node.c:1288 f2fs_evict_inode+0x879/0x15c0 fs/f2fs/inode.c:856 evict+0x4e8/0x9b0 fs/inode.c:723 f2fs_handle_failed_inode+0x271/0x2e0 fs/f2fs/inode.c:986 f2fs_create+0x357/0x530 fs/f2fs/namei.c:394 lookup_open fs/namei.c:3595 [inline] open_last_lookups fs/namei.c:3694 [inline] path_openat+0x1c03/0x3590 fs/namei.c:3930 do_filp_open+0x235/0x490 fs/namei.c:3960 do_sys_openat2+0x13e/0x1d0 fs/open.c:1415 do_sys_open fs/open.c:1430 [inline] __do_sys_openat fs/open.c:1446 [inline] __se_sys_openat fs/open.c:1441 [inline] __x64_sys_openat+0x247/0x2a0 fs/open.c:1441 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534  The root cause is: on a fuzzed image, blkaddr in nat entry may be corrupted, then it will cause system panic when using it in f2fs_invalidate_blocks(), to avoid this, let's add sanity check on nat blkaddr in truncate_node().",
      "cve": "CVE-2024-56692",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56692",
          "value": "CVE-2024-56692",
          "url": "https://scout.docker.com/v/CVE-2024-56692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56692?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "01f88762c7aa10c03351e9c5a9969334e3347056fa430077ff16598bbd55ac7e",
      "category": "container_scanning",
      "message": "CVE-2024-56703 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipv6: Fix soft lockups in fib6_select_path under high next hop churn  Soft lockups have been observed on a cluster of Linux-based edge routers located in a highly dynamic environment. Using the `bird` service, these routers continuously update BGP-advertised routes due to frequently changing nexthop destinations, while also managing significant IPv6 traffic. The lockups occur during the traversal of the multipath circular linked-list in the `fib6_select_path` function, particularly while iterating through the siblings in the list. The issue typically arises when the nodes of the linked list are unexpectedly deleted concurrently on a different coreindicated by their 'next' and 'previous' elements pointing back to the node itself and their reference count dropping to zero. This results in an infinite loop, leading to a soft lockup that triggers a system panic via the watchdog timer.  Apply RCU primitives in the problematic code sections to resolve the issue. Where necessary, update the references to fib6_siblings to annotate or use the RCU APIs.  Include a test script that reproduces the issue. The script periodically updates the routing table while generating a heavy load of outgoing IPv6 traffic through multiple iperf3 clients. It consistently induces infinite soft lockups within a couple of minutes.  Kernel log:  0 [ffffbd13003e8d30] machine_kexec at ffffffff8ceaf3eb 1 [ffffbd13003e8d90] __crash_kexec at ffffffff8d0120e3 2 [ffffbd13003e8e58] panic at ffffffff8cef65d4 3 [ffffbd13003e8ed8] watchdog_timer_fn at ffffffff8d05cb03 4 [ffffbd13003e8f08] __hrtimer_run_queues at ffffffff8cfec62f 5 [ffffbd13003e8f70] hrtimer_interrupt at ffffffff8cfed756 6 [ffffbd13003e8fd0] __sysvec_apic_timer_interrupt at ffffffff8cea01af 7 [ffffbd13003e8ff0] sysvec_apic_timer_interrupt at ffffffff8df1b83d -- <IRQ stack> -- 8 [ffffbd13003d3708] asm_sysvec_apic_timer_interrupt at ffffffff8e000ecb [exception RIP: fib6_select_path+299] RIP: ffffffff8ddafe7b  RSP: ffffbd13003d37b8  RFLAGS: 00000287 RAX: ffff975850b43600  RBX: ffff975850b40200  RCX: 0000000000000000 RDX: 000000003fffffff  RSI: 0000000051d383e4  RDI: ffff975850b43618 RBP: ffffbd13003d3800   R8: 0000000000000000   R9: ffff975850b40200 R10: 0000000000000000  R11: 0000000000000000  R12: ffffbd13003d3830 R13: ffff975850b436a8  R14: ffff975850b43600  R15: 0000000000000007 ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018 9 [ffffbd13003d3808] ip6_pol_route at ffffffff8ddb030c 10 [ffffbd13003d3888] ip6_pol_route_input at ffffffff8ddb068c 11 [ffffbd13003d3898] fib6_rule_lookup at ffffffff8ddf02b5 12 [ffffbd13003d3928] ip6_route_input at ffffffff8ddb0f47 13 [ffffbd13003d3a18] ip6_rcv_finish_core.constprop.0 at ffffffff8dd950d0 14 [ffffbd13003d3a30] ip6_list_rcv_finish.constprop.0 at ffffffff8dd96274 15 [ffffbd13003d3a98] ip6_sublist_rcv at ffffffff8dd96474 16 [ffffbd13003d3af8] ipv6_list_rcv at ffffffff8dd96615 17 [ffffbd13003d3b60] __netif_receive_skb_list_core at ffffffff8dc16fec 18 [ffffbd13003d3be0] netif_receive_skb_list_internal at ffffffff8dc176b3 19 [ffffbd13003d3c50] napi_gro_receive at ffffffff8dc565b9 20 [ffffbd13003d3c80] ice_receive_skb at ffffffffc087e4f5 [ice] 21 [ffffbd13003d3c90] ice_clean_rx_irq at ffffffffc0881b80 [ice] 22 [ffffbd13003d3d20] ice_napi_poll at ffffffffc088232f [ice] 23 [ffffbd13003d3d80] __napi_poll at ffffffff8dc18000 24 [ffffbd13003d3db8] net_rx_action at ffffffff8dc18581 25 [ffffbd13003d3e40] __do_softirq at ffffffff8df352e9 26 [ffffbd13003d3eb0] run_ksoftirqd at ffffffff8ceffe47 27 [ffffbd13003d3ec0] smpboot_thread_fn at ffffffff8cf36a30 28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f 29 [ffffbd13003d3f28] ret_from_fork at ffffffff8ce5fa64 30 [ffffbd13003d3f50] ret_from_fork_asm at ffffffff8ce03cbb",
      "cve": "CVE-2024-56703",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56703",
          "value": "CVE-2024-56703",
          "url": "https://scout.docker.com/v/CVE-2024-56703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56703?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f0156ec0751750838c6efed788b4dbadc50414f078df76d61c70b00a8a039c38",
      "category": "container_scanning",
      "message": "CVE-2024-56707 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_dmac_flt.c  Add error pointer checks after calling otx2_mbox_get_rsp().",
      "cve": "CVE-2024-56707",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56707",
          "value": "CVE-2024-56707",
          "url": "https://scout.docker.com/v/CVE-2024-56707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56707?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "65de67c97afaafd4d51ec7d451d0283afe1e6b988e72b5313feaafa98921e749",
      "category": "container_scanning",
      "message": "CVE-2024-56709 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring: check if iowq is killed before queuing  task work can be executed after the task has gone through io_uring termination, whether it's the final task_work run or the fallback path. In this case, task work will find ->io_wq being already killed and null'ed, which is a problem if it then tries to forward the request to io_queue_iowq(). Make io_queue_iowq() fail requests in this case.  Note that it also checks PF_KTHREAD, because the user can first close a DEFER_TASKRUN ring and shortly after kill the task, in which case ->iowq check would race.",
      "cve": "CVE-2024-56709",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56709",
          "value": "CVE-2024-56709",
          "url": "https://scout.docker.com/v/CVE-2024-56709?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56709?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "99aae09ad4006b0af78da702271192f79dad44a41bce010e5603032c89fba6f7",
      "category": "container_scanning",
      "message": "CVE-2024-56712 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  udmabuf: fix memory leak on last export_udmabuf() error path  In export_udmabuf(), if dma_buf_fd() fails because the FD table is full, a dma_buf owning the udmabuf has already been created; but the error handling in udmabuf_create() will tear down the udmabuf without doing anything about the containing dma_buf.  This leaves a dma_buf in memory that contains a dangling pointer; though that doesn't seem to lead to anything bad except a memory leak.  Fix it by moving the dma_buf_fd() call out of export_udmabuf() so that we can give it different error handling.  Note that the shape of this code changed a lot in commit 5e72b2b41a21 (\"udmabuf: convert udmabuf driver to use folios\"); but the memory leak seems to have existed since the introduction of udmabuf.",
      "cve": "CVE-2024-56712",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56712",
          "value": "CVE-2024-56712",
          "url": "https://scout.docker.com/v/CVE-2024-56712?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56712?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6e386a735c6989126516fa86d44f8ee8abb32a01a65538abdb5ac7eae7bfd2ef",
      "category": "container_scanning",
      "message": "CVE-2024-56717 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: mscc: ocelot: fix incorrect IFH SRC_PORT field in ocelot_ifh_set_basic()  Packets injected by the CPU should have a SRC_PORT field equal to the CPU port module index in the Analyzer block (ocelot->num_phys_ports).  The blamed commit copied the ocelot_ifh_set_basic() call incorrectly from ocelot_xmit_common() in net/dsa/tag_ocelot.c. Instead of calling with \"x\", it calls with BIT_ULL(x), but the field is not a port mask, but rather a single port index.  [ side note: this is the technical debt of code duplication :( ]  The error used to be silent and doesn't appear to have other user-visible manifestations, but with new changes in the packing library, it now fails loudly as follows:  ------------[ cut here ]------------ Cannot store 0x40 inside bits 46-43 - will truncate sja1105 spi2.0: xmit timed out WARNING: CPU: 1 PID: 102 at lib/packing.c:98 __pack+0x90/0x198 sja1105 spi2.0: timed out polling for tstamp CPU: 1 UID: 0 PID: 102 Comm: felix_xmit Tainted: G        W        N 6.13.0-rc1-00372-gf706b85d972d-dirty #2605 Call trace: __pack+0x90/0x198 (P) __pack+0x90/0x198 (L) packing+0x78/0x98 ocelot_ifh_set_basic+0x260/0x368 ocelot_port_inject_frame+0xa8/0x250 felix_port_deferred_xmit+0x14c/0x258 kthread_worker_fn+0x134/0x350 kthread+0x114/0x138  The code path pertains to the ocelot switchdev driver and to the felix secondary DSA tag protocol, ocelot-8021q. Here seen with ocelot-8021q.  The messenger (packing) is not really to blame, so fix the original commit instead.",
      "cve": "CVE-2024-56717",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56717",
          "value": "CVE-2024-56717",
          "url": "https://scout.docker.com/v/CVE-2024-56717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56717?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2056e01415611f7aec4df5a16c4051ba3c63968065fae12914e8b36c6931e694",
      "category": "container_scanning",
      "message": "CVE-2024-56718 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/smc: protect link down work from execute after lgr freed  link down work may be scheduled before lgr freed but execute after lgr freed, which may result in crash. So it is need to hold a reference before shedule link down work, and put the reference after work executed or canceled.  The relevant crash call stack as follows: list_del corruption. prev->next should be ffffb638c9c0fe20, but was 0000000000000000 ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:51! invalid opcode: 0000 [#1] SMP NOPTI CPU: 6 PID: 978112 Comm: kworker/6:119 Kdump: loaded Tainted: G #1 Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 2221b89 04/01/2014 Workqueue: events smc_link_down_work [smc] RIP: 0010:__list_del_entry_valid.cold+0x31/0x47 RSP: 0018:ffffb638c9c0fdd8 EFLAGS: 00010086 RAX: 0000000000000054 RBX: ffff942fb75e5128 RCX: 0000000000000000 RDX: ffff943520930aa0 RSI: ffff94352091fc80 RDI: ffff94352091fc80 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb638c9c0fc38 R10: ffffb638c9c0fc30 R11: ffffffffa015eb28 R12: 0000000000000002 R13: ffffb638c9c0fe20 R14: 0000000000000001 R15: ffff942f9cd051c0 FS:  0000000000000000(0000) GS:ffff943520900000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f4f25214000 CR3: 000000025fbae004 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: rwsem_down_write_slowpath+0x17e/0x470 smc_link_down_work+0x3c/0x60 [smc] process_one_work+0x1ac/0x350 worker_thread+0x49/0x2f0 ? rescuer_thread+0x360/0x360 kthread+0x118/0x140 ? __kthread_bind_mask+0x60/0x60 ret_from_fork+0x1f/0x30",
      "cve": "CVE-2024-56718",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56718",
          "value": "CVE-2024-56718",
          "url": "https://scout.docker.com/v/CVE-2024-56718?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56718?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3ccd9037bbacf0f297be867311c2d7b90b874a06475885ad37e225202cd370cb",
      "category": "container_scanning",
      "message": "CVE-2024-56719 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: stmmac: fix TSO DMA API usage causing oops  Commit 66600fac7a98 (\"net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data\") moved the assignment of tx_skbuff_dma[]'s members to be later in stmmac_tso_xmit().  The buf (dma cookie) and len stored in this structure are passed to dma_unmap_single() by stmmac_tx_clean(). The DMA API requires that the dma cookie passed to dma_unmap_single() is the same as the value returned from dma_map_single(). However, by moving the assignment later, this is not the case when priv->dma_cap.addr64 > 32 as \"des\" is offset by proto_hdr_len.  This causes problems such as:  dwc-eth-dwmac 2490000.ethernet eth0: Tx DMA map failed  and with DMA_API_DEBUG enabled:  DMA-API: dwc-eth-dwmac 2490000.ethernet: device driver tries to +free DMA memory it has not allocated [device address=0x000000ffffcf65c0] [size=66 bytes]  Fix this by maintaining \"des\" as the original DMA cookie, and use tso_des to pass the offset DMA cookie to stmmac_tso_allocator().  Full details of the crashes can be found at: https://lore.kernel.org/all/d8112193-0386-4e14-b516-37c2d838171a@nvidia.com/ https://lore.kernel.org/all/klkzp5yn5kq5efgtrow6wbvnc46bcqfxs65nz3qy77ujr5turc@bwwhelz2l4dw/",
      "cve": "CVE-2024-56719",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56719",
          "value": "CVE-2024-56719",
          "url": "https://scout.docker.com/v/CVE-2024-56719?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56719?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6833f19a389f223aff7a12701cad9819bc8a4bdeb4f0f7342d6ba339d655cc8",
      "category": "container_scanning",
      "message": "CVE-2024-56722 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  RDMA/hns: Fix cpu stuck caused by printings during reset  During reset, cmd to destroy resources such as qp, cq, and mr may fail, and error logs will be printed. When a large number of resources are destroyed, there will be lots of printings, and it may lead to a cpu stuck.  Delete some unnecessary printings and replace other printing functions in these paths with the ratelimited version.",
      "cve": "CVE-2024-56722",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56722",
          "value": "CVE-2024-56722",
          "url": "https://scout.docker.com/v/CVE-2024-56722?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56722?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "649259a1a7f81d02433dec1bace074a536099599e36a1a4d8cfeca8b54fd61e5",
      "category": "container_scanning",
      "message": "CVE-2024-56727 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_flows.c  Adding error pointer check after calling otx2_mbox_get_rsp().",
      "cve": "CVE-2024-56727",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56727",
          "value": "CVE-2024-56727",
          "url": "https://scout.docker.com/v/CVE-2024-56727?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56727?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3bb47697e9675fcf2d3b686363fa351b4a7857e0059e598945f6da76def016a3",
      "category": "container_scanning",
      "message": "CVE-2024-56744 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to avoid potential deadlock in f2fs_record_stop_reason()  syzbot reports deadlock issue of f2fs as below:  ====================================================== WARNING: possible circular locking dependency detected 6.12.0-rc3-syzkaller-00087-gc964ced77262 #0 Not tainted ------------------------------------------------------ kswapd0/79 is trying to acquire lock: ffff888011824088 (&sbi->sb_lock){++++}-{3:3}, at: f2fs_down_write fs/f2fs/f2fs.h:2199 [inline] ffff888011824088 (&sbi->sb_lock){++++}-{3:3}, at: f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c:4068  but task is already holding lock: ffff88804bd92610 (sb_internal#2){.+.+}-{0:0}, at: f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c:842  which lock already depends on the new lock.  the existing dependency chain (in reverse order) is:  -> #2 (sb_internal#2){.+.+}-{0:0}: lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825 percpu_down_read include/linux/percpu-rwsem.h:51 [inline] __sb_start_write include/linux/fs.h:1716 [inline] sb_start_intwrite+0x4d/0x1c0 include/linux/fs.h:1899 f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c:842 evict+0x4e8/0x9b0 fs/inode.c:725 f2fs_evict_inode+0x1a4/0x15c0 fs/f2fs/inode.c:807 evict+0x4e8/0x9b0 fs/inode.c:725 dispose_list fs/inode.c:774 [inline] prune_icache_sb+0x239/0x2f0 fs/inode.c:963 super_cache_scan+0x38c/0x4b0 fs/super.c:223 do_shrink_slab+0x701/0x1160 mm/shrinker.c:435 shrink_slab+0x1093/0x14d0 mm/shrinker.c:662 shrink_one+0x43b/0x850 mm/vmscan.c:4818 shrink_many mm/vmscan.c:4879 [inline] lru_gen_shrink_node mm/vmscan.c:4957 [inline] shrink_node+0x3799/0x3de0 mm/vmscan.c:5937 kswapd_shrink_node mm/vmscan.c:6765 [inline] balance_pgdat mm/vmscan.c:6957 [inline] kswapd+0x1ca3/0x3700 mm/vmscan.c:7226 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  -> #1 (fs_reclaim){+.+.}-{0:0}: lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825 __fs_reclaim_acquire mm/page_alloc.c:3834 [inline] fs_reclaim_acquire+0x88/0x130 mm/page_alloc.c:3848 might_alloc include/linux/sched/mm.h:318 [inline] prepare_alloc_pages+0x147/0x5b0 mm/page_alloc.c:4493 __alloc_pages_noprof+0x16f/0x710 mm/page_alloc.c:4722 alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c:2265 alloc_pages_noprof mm/mempolicy.c:2345 [inline] folio_alloc_noprof+0x128/0x180 mm/mempolicy.c:2352 filemap_alloc_folio_noprof+0xdf/0x500 mm/filemap.c:1010 do_read_cache_folio+0x2eb/0x850 mm/filemap.c:3787 read_mapping_folio include/linux/pagemap.h:1011 [inline] f2fs_commit_super+0x3c0/0x7d0 fs/f2fs/super.c:4032 f2fs_record_stop_reason+0x13b/0x1d0 fs/f2fs/super.c:4079 f2fs_handle_critical_error+0x2ac/0x5c0 fs/f2fs/super.c:4174 f2fs_write_inode+0x35f/0x4d0 fs/f2fs/inode.c:785 write_inode fs/fs-writeback.c:1503 [inline] __writeback_single_inode+0x711/0x10d0 fs/fs-writeback.c:1723 writeback_single_inode+0x1f3/0x660 fs/fs-writeback.c:1779 sync_inode_metadata+0xc4/0x120 fs/fs-writeback.c:2849 f2fs_release_file+0xa8/0x100 fs/f2fs/file.c:1941 __fput+0x23f/0x880 fs/file_table.c:431 task_work_run+0x24f/0x310 kernel/task_work.c:228 resume_user_mode_work include/linux/resume_user_mode.h:50 [inline] exit_to_user_mode_loop kernel/entry/common.c:114 [inline] exit_to_user_mode_prepare include/linux/entry-common.h:328 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline] syscall_exit_to_user_mode+0x168/0x370 kernel/entry/common.c:218 do_syscall_64+0x100/0x230 arch/x86/entry/common.c:89 entry_SYSCALL_64_after_hwframe+0x77/0x7f  ---truncated---",
      "cve": "CVE-2024-56744",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56744",
          "value": "CVE-2024-56744",
          "url": "https://scout.docker.com/v/CVE-2024-56744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3d650d9718b2ce63917960f8f9a7c3c439e30c6d1125d100d0d64ff7c593fb54",
      "category": "container_scanning",
      "message": "CVE-2024-56757 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: btusb: mediatek: add intf release flow when usb disconnect  MediaTek claim an special usb intr interface for ISO data transmission. The interface need to be released before unregistering hci device when usb disconnect. Removing BT usb dongle without properly releasing the interface may cause Kernel panic while unregister hci device.",
      "cve": "CVE-2024-56757",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56757",
          "value": "CVE-2024-56757",
          "url": "https://scout.docker.com/v/CVE-2024-56757?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56757?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "58b329e0484e151e70fe758da9b8740ff87964e8824a4e7d86b511843dbc83f7",
      "category": "container_scanning",
      "message": "CVE-2024-56782 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ACPI: x86: Add adev NULL check to acpi_quirk_skip_serdev_enumeration()  acpi_dev_hid_match() does not check for adev == NULL, dereferencing it unconditional.  Add a check for adev being NULL before calling acpi_dev_hid_match().  At the moment acpi_quirk_skip_serdev_enumeration() is never called with a controller_parent without an ACPI companion, but better safe than sorry.",
      "cve": "CVE-2024-56782",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56782",
          "value": "CVE-2024-56782",
          "url": "https://scout.docker.com/v/CVE-2024-56782?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56782?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "50c0bba5edf4f5c40e3466dfdc8d948887d3c64a41c95ba149ff33634404f5b0",
      "category": "container_scanning",
      "message": "CVE-2024-57804 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Fix corrupt config pages PHY state is switched in sysfs  The driver, through the SAS transport, exposes a sysfs interface to enable/disable PHYs in a controller/expander setup.  When multiple PHYs are disabled and enabled in rapid succession, the persistent and current config pages related to SAS IO unit/SAS Expander pages could get corrupted.  Use separate memory for each config request.",
      "cve": "CVE-2024-57804",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57804",
          "value": "CVE-2024-57804",
          "url": "https://scout.docker.com/v/CVE-2024-57804?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57804?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ffb67121f69be5f7030762c6ff122df4667b7e991e417e8911bb28ec816c6d59",
      "category": "container_scanning",
      "message": "CVE-2024-57809 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  PCI: imx6: Fix suspend/resume support on i.MX6QDL  The suspend/resume functionality is currently broken on the i.MX6QDL platform, as documented in the NXP errata (ERR005723):  https://www.nxp.com/docs/en/errata/IMX6DQCE.pdf  This patch addresses the issue by sharing most of the suspend/resume sequences used by other i.MX devices, while avoiding modifications to critical registers that disrupt the PCIe functionality. It targets the same problem as the following downstream commit:   https://github.com/nxp-imx/linux-imx/commit/4e92355e1f79d225ea842511fcfd42b343b32995  Unlike the downstream commit, this patch also resets the connected PCIe device if possible. Without this reset, certain drivers, such as ath10k or iwlwifi, will crash on resume. The device reset is also done by the driver on other i.MX platforms, making this patch consistent with existing practices.  Upon resuming, the kernel will hang and display an error. Here's an example of the error encountered with the ath10k driver:  ath10k_pci 0000:01:00.0: Unable to change power state from D3hot to D0, device inaccessible Unhandled fault: imprecise external abort (0x1406) at 0x0106f944  Without this patch, suspend/resume will fail on i.MX6QDL devices if a PCIe device is connected.  [kwilczynski: commit log, added tag for stable releases]",
      "cve": "CVE-2024-57809",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57809",
          "value": "CVE-2024-57809",
          "url": "https://scout.docker.com/v/CVE-2024-57809?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57809?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3a5df360ec9de0041475b6f83b3aa130e2eb1844314d5aef254c79ee942210a3",
      "category": "container_scanning",
      "message": "CVE-2024-57843 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  virtio-net: fix overflow inside virtnet_rq_alloc  When the frag just got a page, then may lead to regression on VM. Specially if the sysctl net.core.high_order_alloc_disable value is 1, then the frag always get a page when do refill.  Which could see reliable crashes or scp failure (scp a file 100M in size to VM).  The issue is that the virtnet_rq_dma takes up 16 bytes at the beginning of a new frag. When the frag size is larger than PAGE_SIZE, everything is fine. However, if the frag is only one page and the total size of the buffer and virtnet_rq_dma is larger than one page, an overflow may occur.  The commit f9dac92ba908 (\"virtio_ring: enable premapped mode whatever use_dma_api\") introduced this problem. And we reverted some commits to fix this in last linux version. Now we try to enable it and fix this bug directly.  Here, when the frag size is not enough, we reduce the buffer len to fix this problem.",
      "cve": "CVE-2024-57843",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57843",
          "value": "CVE-2024-57843",
          "url": "https://scout.docker.com/v/CVE-2024-57843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57843?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "cfea18b3de9314921aa68ec1c35336646f15e67d6d19088182f4c441c798a292",
      "category": "container_scanning",
      "message": "CVE-2024-57852 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  firmware: qcom: scm: smc: Handle missing SCM device  Commit ca61d6836e6f (\"firmware: qcom: scm: fix a NULL-pointer dereference\") makes it explicit that qcom_scm_get_tzmem_pool() can return NULL, therefore its users should handle this.",
      "cve": "CVE-2024-57852",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57852",
          "value": "CVE-2024-57852",
          "url": "https://scout.docker.com/v/CVE-2024-57852?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57852?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "28e6c0d8a029aad08123d3ff5d44f1e551893ee52e0eaf421e42c44b37d7e804",
      "category": "container_scanning",
      "message": "CVE-2024-57872 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: pltfrm: Dellocate HBA during ufshcd_pltfrm_remove()  This will ensure that the scsi host is cleaned up properly using scsi_host_dev_release(). Otherwise, it may lead to memory leaks.",
      "cve": "CVE-2024-57872",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57872",
          "value": "CVE-2024-57872",
          "url": "https://scout.docker.com/v/CVE-2024-57872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57872?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "61a7e0ddac9f37d3e57388363e9a1c1dec3dcf661a851da487a9f07b8177324d",
      "category": "container_scanning",
      "message": "CVE-2024-57875 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: RCU protect disk->conv_zones_bitmap  Ensure that a disk revalidation changing the conventional zones bitmap of a disk does not cause invalid memory references when using the disk_zone_is_conv() helper by RCU protecting the disk->conv_zones_bitmap pointer.  disk_zone_is_conv() is modified to operate under the RCU read lock and the function disk_set_conv_zones_bitmap() is added to update a disk conv_zones_bitmap pointer using rcu_replace_pointer() with the disk zone_wplugs_lock spinlock held.  disk_free_zone_resources() is modified to call disk_update_zone_resources() with a NULL bitmap pointer to free the disk conv_zones_bitmap. disk_set_conv_zones_bitmap() is also used in disk_update_zone_resources() to set the new (revalidated) bitmap and free the old one.",
      "cve": "CVE-2024-57875",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57875",
          "value": "CVE-2024-57875",
          "url": "https://scout.docker.com/v/CVE-2024-57875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57875?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e2d37546ee71b54dfe00f9ab13c65a5fcbcfd6d1bca6dcc4ee3b2cfc530e895",
      "category": "container_scanning",
      "message": "CVE-2024-57888 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  workqueue: Do not warn when cancelling WQ_MEM_RECLAIM work from !WQ_MEM_RECLAIM worker  After commit 746ae46c1113 (\"drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM\") amdgpu started seeing the following warning:  [ ] workqueue: WQ_MEM_RECLAIM sdma0:drm_sched_run_job_work [gpu_sched] is flushing !WQ_MEM_RECLAIM events:amdgpu_device_delay_enable_gfx_off [amdgpu] ... [ ] Workqueue: sdma0 drm_sched_run_job_work [gpu_sched] ... [ ] Call Trace: [ ]  <TASK> ... [ ]  ? check_flush_dependency+0xf5/0x110 ... [ ]  cancel_delayed_work_sync+0x6e/0x80 [ ]  amdgpu_gfx_off_ctrl+0xab/0x140 [amdgpu] [ ]  amdgpu_ring_alloc+0x40/0x50 [amdgpu] [ ]  amdgpu_ib_schedule+0xf4/0x810 [amdgpu] [ ]  ? drm_sched_run_job_work+0x22c/0x430 [gpu_sched] [ ]  amdgpu_job_run+0xaa/0x1f0 [amdgpu] [ ]  drm_sched_run_job_work+0x257/0x430 [gpu_sched] [ ]  process_one_work+0x217/0x720 ... [ ]  </TASK>  The intent of the verifcation done in check_flush_depedency is to ensure forward progress during memory reclaim, by flagging cases when either a memory reclaim process, or a memory reclaim work item is flushed from a context not marked as memory reclaim safe.  This is correct when flushing, but when called from the cancel(_delayed)_work_sync() paths it is a false positive because work is either already running, or will not be running at all. Therefore cancelling it is safe and we can relax the warning criteria by letting the helper know of the calling context.  References: 746ae46c1113 (\"drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM\")",
      "cve": "CVE-2024-57888",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57888",
          "value": "CVE-2024-57888",
          "url": "https://scout.docker.com/v/CVE-2024-57888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57888?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "882c15394e105768d2bf24a20493a00d1c9008398367b60448eff29e1964844f",
      "category": "container_scanning",
      "message": "CVE-2024-57895 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: set ATTR_CTIME flags when setting mtime  David reported that the new warning from setattr_copy_mgtime is coming like the following.  [  113.215316] ------------[ cut here ]------------ [  113.215974] WARNING: CPU: 1 PID: 31 at fs/attr.c:300 setattr_copy+0x1ee/0x200 [  113.219192] CPU: 1 UID: 0 PID: 31 Comm: kworker/1:1 Not tainted 6.13.0-rc1+ #234 [  113.220127] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 [  113.221530] Workqueue: ksmbd-io handle_ksmbd_work [ksmbd] [  113.222220] RIP: 0010:setattr_copy+0x1ee/0x200 [  113.222833] Code: 24 28 49 8b 44 24 30 48 89 53 58 89 43 6c 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 48 89 df e8 77 d6 ff ff e9 cd fe ff ff <0f> 0b e9 be fe ff ff 66 0 [  113.225110] RSP: 0018:ffffaf218010fb68 EFLAGS: 00010202 [  113.225765] RAX: 0000000000000120 RBX: ffffa446815f8568 RCX: 0000000000000003 [  113.226667] RDX: ffffaf218010fd38 RSI: ffffa446815f8568 RDI: ffffffff94eb03a0 [  113.227531] RBP: ffffaf218010fb90 R08: 0000001a251e217d R09: 00000000675259fa [  113.228426] R10: 0000000002ba8a6d R11: ffffa4468196c7a8 R12: ffffaf218010fd38 [  113.229304] R13: 0000000000000120 R14: ffffffff94eb03a0 R15: 0000000000000000 [  113.230210] FS:  0000000000000000(0000) GS:ffffa44739d00000(0000) knlGS:0000000000000000 [  113.231215] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  113.232055] CR2: 00007efe0053d27e CR3: 000000000331a000 CR4: 00000000000006b0 [  113.232926] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [  113.233812] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [  113.234797] Call Trace: [  113.235116]  <TASK> [  113.235393]  ? __warn+0x73/0xd0 [  113.235802]  ? setattr_copy+0x1ee/0x200 [  113.236299]  ? report_bug+0xf3/0x1e0 [  113.236757]  ? handle_bug+0x4d/0x90 [  113.237202]  ? exc_invalid_op+0x13/0x60 [  113.237689]  ? asm_exc_invalid_op+0x16/0x20 [  113.238185]  ? setattr_copy+0x1ee/0x200 [  113.238692]  btrfs_setattr+0x80/0x820 [btrfs] [  113.239285]  ? get_stack_info_noinstr+0x12/0xf0 [  113.239857]  ? __module_address+0x22/0xa0 [  113.240368]  ? handle_ksmbd_work+0x6e/0x460 [ksmbd] [  113.240993]  ? __module_text_address+0x9/0x50 [  113.241545]  ? __module_address+0x22/0xa0 [  113.242033]  ? unwind_next_frame+0x10e/0x920 [  113.242600]  ? __pfx_stack_trace_consume_entry+0x10/0x10 [  113.243268]  notify_change+0x2c2/0x4e0 [  113.243746]  ? stack_depot_save_flags+0x27/0x730 [  113.244339]  ? set_file_basic_info+0x130/0x2b0 [ksmbd] [  113.244993]  set_file_basic_info+0x130/0x2b0 [ksmbd] [  113.245613]  ? process_scheduled_works+0xbe/0x310 [  113.246181]  ? worker_thread+0x100/0x240 [  113.246696]  ? kthread+0xc8/0x100 [  113.247126]  ? ret_from_fork+0x2b/0x40 [  113.247606]  ? ret_from_fork_asm+0x1a/0x30 [  113.248132]  smb2_set_info+0x63f/0xa70 [ksmbd]  ksmbd is trying to set the atime and mtime via notify_change without also setting the ctime. so This patch add ATTR_CTIME flags when setting mtime to avoid a warning.",
      "cve": "CVE-2024-57895",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57895",
          "value": "CVE-2024-57895",
          "url": "https://scout.docker.com/v/CVE-2024-57895?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57895?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "81851c3e2966f0c5a2b05c5be175dcd6b70b2e0ed9d0bb674e26c94984179953",
      "category": "container_scanning",
      "message": "CVE-2024-57924 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs: relax assertions on failure to encode file handles  Encoding file handles is usually performed by a filesystem >encode_fh() method that may fail for various reasons.  The legacy users of exportfs_encode_fh(), namely, nfsd and name_to_handle_at(2) syscall are ready to cope with the possibility of failure to encode a file handle.  There are a few other users of exportfs_encode_{fh,fid}() that currently have a WARN_ON() assertion when ->encode_fh() fails. Relax those assertions because they are wrong.  The second linked bug report states commit 16aac5ad1fa9 (\"ovl: support encoding non-decodable file handles\") in v6.6 as the regressing commit, but this is not accurate.  The aforementioned commit only increases the chances of the assertion and allows triggering the assertion with the reproducer using overlayfs, inotify and drop_caches.  Triggering this assertion was always possible with other filesystems and other reasons of ->encode_fh() failures and more particularly, it was also possible with the exact same reproducer using overlayfs that is mounted with options index=on,nfs_export=on also on kernels < v6.6. Therefore, I am not listing the aforementioned commit as a Fixes commit.  Backport hint: this patch will have a trivial conflict applying to v6.6.y, and other trivial conflicts applying to stable kernels < v6.6.",
      "cve": "CVE-2024-57924",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57924",
          "value": "CVE-2024-57924",
          "url": "https://scout.docker.com/v/CVE-2024-57924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57924?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "42d0fb75d5c1aecce096d3c4b1d517a291af9f995e945f4b58a6d52e9d8731d6",
      "category": "container_scanning",
      "message": "CVE-2024-57950 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Initialize denominator defaults to 1  [WHAT & HOW] Variables, used as denominators and maybe not assigned to other values, should be initialized to non-zero to avoid DIVIDE_BY_ZERO, as reported by Coverity.  (cherry picked from commit e2c4c6c10542ccfe4a0830bb6c9fd5b177b7bbb7)",
      "cve": "CVE-2024-57950",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57950",
          "value": "CVE-2024-57950",
          "url": "https://scout.docker.com/v/CVE-2024-57950?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57950?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d12187448d551b1b0a07802de920ad58891de4764d310760e571771316a29a60",
      "category": "container_scanning",
      "message": "CVE-2024-57952 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"libfs: fix infinite directory reads for offset dir\"  The current directory offset allocator (based on mtree_alloc_cyclic) stores the next offset value to return in octx->next_offset. This mechanism typically returns values that increase monotonically over time. Eventually, though, the newly allocated offset value wraps back to a low number (say, 2) which is smaller than other already- allocated offset values.  Yu Kuai <yukuai3@huawei.com> reports that, after commit 64a7ce76fb90 (\"libfs: fix infinite directory reads for offset dir\"), if a directory's offset allocator wraps, existing entries are no longer visible via readdir/getdents because offset_readdir() stops listing entries once an entry's offset is larger than octx->next_offset. These entries vanish persistently -- they can be looked up, but will never again appear in readdir(3) output.  The reason for this is that the commit treats directory offsets as monotonically increasing integer values rather than opaque cookies, and introduces this comparison:  if (dentry2offset(dentry) >= last_index) {  On 64-bit platforms, the directory offset value upper bound is 2^63 - 1. Directory offsets will monotonically increase for millions of years without wrapping.  On 32-bit platforms, however, LONG_MAX is 2^31 - 1. The allocator can wrap after only a few weeks (at worst).  Revert commit 64a7ce76fb90 (\"libfs: fix infinite directory reads for offset dir\") to prepare for a fix that can work properly on 32-bit systems and might apply to recent LTS kernels where shmem employs the simple_offset mechanism.",
      "cve": "CVE-2024-57952",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57952",
          "value": "CVE-2024-57952",
          "url": "https://scout.docker.com/v/CVE-2024-57952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57952?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a7d44fb9ccaf5e50ed6b0453f759d054adacec436da14a6586f5c7e5a57310f8",
      "category": "container_scanning",
      "message": "CVE-2024-57975 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: do proper folio cleanup when run_delalloc_nocow() failed  [BUG] With CONFIG_DEBUG_VM set, test case generic/476 has some chance to crash with the following VM_BUG_ON_FOLIO():  BTRFS error (device dm-3): cow_file_range failed, start 1146880 end 1253375 len 106496 ret -28 BTRFS error (device dm-3): run_delalloc_nocow failed, start 1146880 end 1253375 len 106496 ret -28 page: refcount:4 mapcount:0 mapping:00000000592787cc index:0x12 pfn:0x10664 aops:btrfs_aops [btrfs] ino:101 dentry name(?):\"f1774\" flags: 0x2fffff80004028(uptodate|lru|private|node=0|zone=2|lastcpupid=0xfffff) page dumped because: VM_BUG_ON_FOLIO(!folio_test_locked(folio)) ------------[ cut here ]------------ kernel BUG at mm/page-writeback.c:2992! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP CPU: 2 UID: 0 PID: 3943513 Comm: kworker/u24:15 Tainted: G           OE 6.12.0-rc7-custom+ #87 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs] pc : folio_clear_dirty_for_io+0x128/0x258 lr : folio_clear_dirty_for_io+0x128/0x258 Call trace: folio_clear_dirty_for_io+0x128/0x258 btrfs_folio_clamp_clear_dirty+0x80/0xd0 [btrfs] __process_folios_contig+0x154/0x268 [btrfs] extent_clear_unlock_delalloc+0x5c/0x80 [btrfs] run_delalloc_nocow+0x5f8/0x760 [btrfs] btrfs_run_delalloc_range+0xa8/0x220 [btrfs] writepage_delalloc+0x230/0x4c8 [btrfs] extent_writepage+0xb8/0x358 [btrfs] extent_write_cache_pages+0x21c/0x4e8 [btrfs] btrfs_writepages+0x94/0x150 [btrfs] do_writepages+0x74/0x190 filemap_fdatawrite_wbc+0x88/0xc8 start_delalloc_inodes+0x178/0x3a8 [btrfs] btrfs_start_delalloc_roots+0x174/0x280 [btrfs] shrink_delalloc+0x114/0x280 [btrfs] flush_space+0x250/0x2f8 [btrfs] btrfs_async_reclaim_data_space+0x180/0x228 [btrfs] process_one_work+0x164/0x408 worker_thread+0x25c/0x388 kthread+0x100/0x118 ret_from_fork+0x10/0x20 Code: 910a8021 a90363f7 a9046bf9 94012379 (d4210000) ---[ end trace 0000000000000000 ]---  [CAUSE] The first two lines of extra debug messages show the problem is caused by the error handling of run_delalloc_nocow().  E.g. we have the following dirtied range (4K blocksize 4K page size):  0                 16K                  32K |//////////////////////////////////////| |  Pre-allocated  |  And the range [0, 16K) has a preallocated extent.  - Enter run_delalloc_nocow() for range [0, 16K) Which found range [0, 16K) is preallocated, can do the proper NOCOW write.  - Enter fallback_to_fow() for range [16K, 32K) Since the range [16K, 32K) is not backed by preallocated extent, we have to go COW.  - cow_file_range() failed for range [16K, 32K) So cow_file_range() will do the clean up by clearing folio dirty, unlock the folios.  Now the folios in range [16K, 32K) is unlocked.  - Enter extent_clear_unlock_delalloc() from run_delalloc_nocow() Which is called with PAGE_START_WRITEBACK to start page writeback. But folios can only be marked writeback when it's properly locked, thus this triggered the VM_BUG_ON_FOLIO().  Furthermore there is another hidden but common bug that run_delalloc_nocow() is not clearing the folio dirty flags in its error handling path. This is the common bug shared between run_delalloc_nocow() and cow_file_range().  [FIX] - Clear folio dirty for range [@start, @cur_offset) Introduce a helper, cleanup_dirty_folios(), which will find and lock the folio in the range, clear the dirty flag and start/end the writeback, with the extra handling for the @locked_folio.  - Introduce a helper to clear folio dirty, start and end writeback  - Introduce a helper to record the last failed COW range end This is to trace which range we should skip, to avoid double unlocking.  - Skip the failed COW range for the e ---truncated---",
      "cve": "CVE-2024-57975",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57975",
          "value": "CVE-2024-57975",
          "url": "https://scout.docker.com/v/CVE-2024-57975?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57975?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6c7faf03a23e3d4002dc5326f8337e6a3112071cea31b940f73608335dff0df",
      "category": "container_scanning",
      "message": "CVE-2024-57976 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: do proper folio cleanup when cow_file_range() failed  [BUG] When testing with COW fixup marked as BUG_ON() (this is involved with the new pin_user_pages*() change, which should not result new out-of-band dirty pages), I hit a crash triggered by the BUG_ON() from hitting COW fixup path.  This BUG_ON() happens just after a failed btrfs_run_delalloc_range():  BTRFS error (device dm-2): failed to run delalloc range, root 348 ino 405 folio 65536 submit_bitmap 6-15 start 90112 len 106496: -28 ------------[ cut here ]------------ kernel BUG at fs/btrfs/extent_io.c:1444! Internal error: Oops - BUG: 00000000f2000800 [#1] SMP CPU: 0 UID: 0 PID: 434621 Comm: kworker/u24:8 Tainted: G           OE 6.12.0-rc7-custom+ #86 Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs] pc : extent_writepage_io+0x2d4/0x308 [btrfs] lr : extent_writepage_io+0x2d4/0x308 [btrfs] Call trace: extent_writepage_io+0x2d4/0x308 [btrfs] extent_writepage+0x218/0x330 [btrfs] extent_write_cache_pages+0x1d4/0x4b0 [btrfs] btrfs_writepages+0x94/0x150 [btrfs] do_writepages+0x74/0x190 filemap_fdatawrite_wbc+0x88/0xc8 start_delalloc_inodes+0x180/0x3b0 [btrfs] btrfs_start_delalloc_roots+0x174/0x280 [btrfs] shrink_delalloc+0x114/0x280 [btrfs] flush_space+0x250/0x2f8 [btrfs] btrfs_async_reclaim_data_space+0x180/0x228 [btrfs] process_one_work+0x164/0x408 worker_thread+0x25c/0x388 kthread+0x100/0x118 ret_from_fork+0x10/0x20 Code: aa1403e1 9402f3ef aa1403e0 9402f36f (d4210000) ---[ end trace 0000000000000000 ]---  [CAUSE] That failure is mostly from cow_file_range(), where we can hit -ENOSPC.  Although the -ENOSPC is already a bug related to our space reservation code, let's just focus on the error handling.  For example, we have the following dirty range [0, 64K) of an inode, with 4K sector size and 4K page size:  0        16K        32K       48K       64K |///////////////////////////////////////| |#######################################|  Where |///| means page are still dirty, and |###| means the extent io tree has EXTENT_DELALLOC flag.  - Enter extent_writepage() for page 0  - Enter btrfs_run_delalloc_range() for range [0, 64K)  - Enter cow_file_range() for range [0, 64K)  - Function btrfs_reserve_extent() only reserved one 16K extent So we created extent map and ordered extent for range [0, 16K)  0        16K        32K       48K       64K |////////|//////////////////////////////| |<- OE ->|##############################|  And range [0, 16K) has its delalloc flag cleared. But since we haven't yet submit any bio, involved 4 pages are still dirty.  - Function btrfs_reserve_extent() returns with -ENOSPC Now we have to run error cleanup, which will clear all EXTENT_DELALLOC* flags and clear the dirty flags for the remaining ranges:  0        16K        32K       48K       64K |////////|                              | |        |                              |  Note that range [0, 16K) still has its pages dirty.  - Some time later, writeback is triggered again for the range [0, 16K) since the page range still has dirty flags.  - btrfs_run_delalloc_range() will do nothing because there is no EXTENT_DELALLOC flag.  - extent_writepage_io() finds page 0 has no ordered flag Which falls into the COW fixup path, triggering the BUG_ON().  Unfortunately this error handling bug dates back to the introduction of btrfs.  Thankfully with the abuse of COW fixup, at least it won't crash the kernel.  [FIX] Instead of immediately unlocking the extent and folios, we keep the extent and folios locked until either erroring out or the whole delalloc range finished.  When the whole delalloc range finished without error, we just unlock the whole range with PAGE_SET_ORDERED (and PAGE_UNLOCK for !keep_locked cases) ---truncated---",
      "cve": "CVE-2024-57976",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57976",
          "value": "CVE-2024-57976",
          "url": "https://scout.docker.com/v/CVE-2024-57976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57976?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a9da37cf2738ca83b63129555ee4fd0453d763327adab8e738d4c52e86d87f27",
      "category": "container_scanning",
      "message": "CVE-2024-57993 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  HID: hid-thrustmaster: Fix warning in thrustmaster_probe by adding endpoint check  syzbot has found a type mismatch between a USB pipe and the transfer endpoint, which is triggered by the hid-thrustmaster driver[1]. There is a number of similar, already fixed issues [2]. In this case as in others, implementing check for endpoint type fixes the issue.  [1] https://syzkaller.appspot.com/bug?extid=040e8b3db6a96908d470 [2] https://syzkaller.appspot.com/bug?extid=348331f63b034f89b622",
      "cve": "CVE-2024-57993",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57993",
          "value": "CVE-2024-57993",
          "url": "https://scout.docker.com/v/CVE-2024-57993?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57993?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f889d7e4a71babd29da093a81bd446e4dfa174dea65950379571d69eafc8c43",
      "category": "container_scanning",
      "message": "CVE-2024-57999 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/pseries/iommu: IOMMU incorrectly marks MMIO range in DDW  Power Hypervisor can possibily allocate MMIO window intersecting with Dynamic DMA Window (DDW) range, which is over 32-bit addressing.  These MMIO pages needs to be marked as reserved so that IOMMU doesn't map DMA buffers in this range.  The current code is not marking these pages correctly which is resulting in LPAR to OOPS while booting. The stack is at below  BUG: Unable to handle kernel data access on read at 0xc00800005cd40000 Faulting instruction address: 0xc00000000005cdac Oops: Kernel access of bad area, sig: 11 [#1] LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries Modules linked in: af_packet rfkill ibmveth(X) lpfc(+) nvmet_fc nvmet nvme_keyring crct10dif_vpmsum nvme_fc nvme_fabrics nvme_core be2net(+) nvme_auth rtc_generic nfsd auth_rpcgss nfs_acl lockd grace sunrpc fuse configfs ip_tables x_tables xfs libcrc32c dm_service_time ibmvfc(X) scsi_transport_fc vmx_crypto gf128mul crc32c_vpmsum dm_mirror dm_region_hash dm_log dm_multipath dm_mod sd_mod scsi_dh_emc scsi_dh_rdac scsi_dh_alua t10_pi crc64_rocksoft_generic crc64_rocksoft sg crc64 scsi_mod Supported: Yes, External CPU: 8 PID: 241 Comm: kworker/8:1 Kdump: loaded Not tainted 6.4.0-150600.23.14-default #1 SLE15-SP6 b44ee71c81261b9e4bab5e0cde1f2ed891d5359b Hardware name: IBM,9080-M9S POWER9 (raw) 0x4e2103 0xf000005 of:IBM,FW950.B0 (VH950_149) hv:phyp pSeries Workqueue: events work_for_cpu_fn NIP:  c00000000005cdac LR: c00000000005e830 CTR: 0000000000000000 REGS: c00001400c9ff770 TRAP: 0300   Not tainted (6.4.0-150600.23.14-default) MSR:  800000000280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 24228448 XER: 00000001 CFAR: c00000000005cdd4 DAR: c00800005cd40000 DSISR: 40000000 IRQMASK: 0 GPR00: c00000000005e830 c00001400c9ffa10 c000000001987d00 c00001400c4fe800 GPR04: 0000080000000000 0000000000000001 0000000004000000 0000000000800000 GPR08: 0000000004000000 0000000000000001 c00800005cd40000 ffffffffffffffff GPR12: 0000000084228882 c00000000a4c4f00 0000000000000010 0000080000000000 GPR16: c00001400c4fe800 0000000004000000 0800000000000000 c00000006088b800 GPR20: c00001401a7be980 c00001400eff3800 c000000002a2da68 000000000000002b GPR24: c0000000026793a8 c000000002679368 000000000000002a c0000000026793c8 GPR28: 000008007effffff 0000080000000000 0000000000800000 c00001400c4fe800 NIP [c00000000005cdac] iommu_table_reserve_pages+0xac/0x100 LR [c00000000005e830] iommu_init_table+0x80/0x1e0 Call Trace: [c00001400c9ffa10] [c00000000005e810] iommu_init_table+0x60/0x1e0 (unreliable) [c00001400c9ffa90] [c00000000010356c] iommu_bypass_supported_pSeriesLP+0x9cc/0xe40 [c00001400c9ffc30] [c00000000005c300] dma_iommu_dma_supported+0xf0/0x230 [c00001400c9ffcb0] [c00000000024b0c4] dma_supported+0x44/0x90 [c00001400c9ffcd0] [c00000000024b14c] dma_set_mask+0x3c/0x80 [c00001400c9ffd00] [c0080000555b715c] be_probe+0xc4/0xb90 [be2net] [c00001400c9ffdc0] [c000000000986f3c] local_pci_probe+0x6c/0x110 [c00001400c9ffe40] [c000000000188f28] work_for_cpu_fn+0x38/0x60 [c00001400c9ffe70] [c00000000018e454] process_one_work+0x314/0x620 [c00001400c9fff10] [c00000000018f280] worker_thread+0x2b0/0x620 [c00001400c9fff90] [c00000000019bb18] kthread+0x148/0x150 [c00001400c9fffe0] [c00000000000ded8] start_kernel_thread+0x14/0x18  There are 2 issues in the code  1. The index is \"int\" while the address is \"unsigned long\". This results in negative value when setting the bitmap.  2. The DMA offset is page shifted but the MMIO range is used as-is (64-bit address). MMIO address needs to be page shifted as well.",
      "cve": "CVE-2024-57999",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57999",
          "value": "CVE-2024-57999",
          "url": "https://scout.docker.com/v/CVE-2024-57999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57999?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "773cb2cc6f8c9a96493fec08bf4c6a5e19c7d8834baf0edfa2dae80cd65daa30",
      "category": "container_scanning",
      "message": "CVE-2024-58011 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  platform/x86: int3472: Check for adev == NULL  Not all devices have an ACPI companion fwnode, so adev might be NULL. This can e.g. (theoretically) happen when a user manually binds one of the int3472 drivers to another i2c/platform device through sysfs.  Add a check for adev not being set and return -ENODEV in that case to avoid a possible NULL pointer deref in skl_int3472_get_acpi_buffer().",
      "cve": "CVE-2024-58011",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58011",
          "value": "CVE-2024-58011",
          "url": "https://scout.docker.com/v/CVE-2024-58011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58011?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c352da91447c7b78c312d84c6e8897cd143ccfb2b4c8b212162c24f778c433f1",
      "category": "container_scanning",
      "message": "CVE-2024-58012 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: Intel: hda-dai: Ensure DAI widget is valid during params  Each cpu DAI should associate with a widget. However, the topology might not create the right number of DAI widgets for aggregated amps. And it will cause NULL pointer deference. Check that the DAI widget associated with the CPU DAI is valid to prevent NULL pointer deference due to missing DAI widgets in topologies with aggregated amps.",
      "cve": "CVE-2024-58012",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58012",
          "value": "CVE-2024-58012",
          "url": "https://scout.docker.com/v/CVE-2024-58012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b999e2506d6a2abcdab45186d8eecf516aed9fb1b5a0d48e38e93f7af7e3a1e8",
      "category": "container_scanning",
      "message": "CVE-2024-58018 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvkm: correctly calculate the available space of the GSP cmdq buffer  r535_gsp_cmdq_push() waits for the available page in the GSP cmdq buffer when handling a large RPC request. When it sees at least one available page in the cmdq, it quits the waiting with the amount of free buffer pages in the queue.  Unfortunately, it always takes the [write pointer, buf_size) as available buffer pages before rolling back and wrongly calculates the size of the data should be copied. Thus, it can overwrite the RPC request that GSP is currently reading, which causes GSP hang due to corrupted RPC request:  [  549.209389] ------------[ cut here ]------------ [  549.214010] WARNING: CPU: 8 PID: 6314 at drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c:116 r535_gsp_msgq_wait+0xd0/0x190 [nvkm] [  549.225678] Modules linked in: nvkm(E+) gsp_log(E) snd_seq_dummy(E) snd_hrtimer(E) snd_seq(E) snd_timer(E) snd_seq_device(E) snd(E) soundcore(E) rfkill(E) qrtr(E) vfat(E) fat(E) ipmi_ssif(E) amd_atl(E) intel_rapl_msr(E) intel_rapl_common(E) mlx5_ib(E) amd64_edac(E) edac_mce_amd(E) kvm_amd(E) ib_uverbs(E) kvm(E) ib_core(E) acpi_ipmi(E) ipmi_si(E) mxm_wmi(E) ipmi_devintf(E) rapl(E) i2c_piix4(E) wmi_bmof(E) joydev(E) ptdma(E) acpi_cpufreq(E) k10temp(E) pcspkr(E) ipmi_msghandler(E) xfs(E) libcrc32c(E) ast(E) i2c_algo_bit(E) crct10dif_pclmul(E) drm_shmem_helper(E) nvme_tcp(E) crc32_pclmul(E) ahci(E) drm_kms_helper(E) libahci(E) nvme_fabrics(E) crc32c_intel(E) nvme(E) cdc_ether(E) mlx5_core(E) nvme_core(E) usbnet(E) drm(E) libata(E) ccp(E) ghash_clmulni_intel(E) mii(E) t10_pi(E) mlxfw(E) sp5100_tco(E) psample(E) pci_hyperv_intf(E) wmi(E) dm_multipath(E) sunrpc(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E) be2iscsi(E) bnx2i(E) cnic(E) uio(E) cxgb4i(E) cxgb4(E) tls(E) libcxgbi(E) libcxgb(E) qla4xxx(E) [  549.225752]  iscsi_boot_sysfs(E) iscsi_tcp(E) libiscsi_tcp(E) libiscsi(E) scsi_transport_iscsi(E) fuse(E) [last unloaded: gsp_log(E)] [  549.326293] CPU: 8 PID: 6314 Comm: insmod Tainted: G            E 6.9.0-rc6+ #1 [  549.334039] Hardware name: ASRockRack 1U1G-MILAN/N/ROMED8-NL, BIOS L3.12E 09/06/2022 [  549.341781] RIP: 0010:r535_gsp_msgq_wait+0xd0/0x190 [nvkm] [  549.347343] Code: 08 00 00 89 da c1 e2 0c 48 8d ac 11 00 10 00 00 48 8b 0c 24 48 85 c9 74 1f c1 e0 0c 4c 8d 6d 30 83 e8 30 89 01 e9 68 ff ff ff <0f> 0b 49 c7 c5 92 ff ff ff e9 5a ff ff ff ba ff ff ff ff be c0 0c [  549.366090] RSP: 0018:ffffacbccaaeb7d0 EFLAGS: 00010246 [  549.371315] RAX: 0000000000000000 RBX: 0000000000000012 RCX: 0000000000923e28 [  549.378451] RDX: 0000000000000000 RSI: 0000000055555554 RDI: ffffacbccaaeb730 [  549.385590] RBP: 0000000000000001 R08: ffff8bd14d235f70 R09: ffff8bd14d235f70 [  549.392721] R10: 0000000000000002 R11: ffff8bd14d233864 R12: 0000000000000020 [  549.399854] R13: ffffacbccaaeb818 R14: 0000000000000020 R15: ffff8bb298c67000 [  549.406988] FS:  00007f5179244740(0000) GS:ffff8bd14d200000(0000) knlGS:0000000000000000 [  549.415076] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [  549.420829] CR2: 00007fa844000010 CR3: 00000001567dc005 CR4: 0000000000770ef0 [  549.427963] PKRU: 55555554 [  549.430672] Call Trace: [  549.433126]  <TASK> [  549.435233]  ? __warn+0x7f/0x130 [  549.438473]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm] [  549.443426]  ? report_bug+0x18a/0x1a0 [  549.447098]  ? handle_bug+0x3c/0x70 [  549.450589]  ? exc_invalid_op+0x14/0x70 [  549.454430]  ? asm_exc_invalid_op+0x16/0x20 [  549.458619]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm] [  549.463565]  r535_gsp_msg_recv+0x46/0x230 [nvkm] [  549.468257]  r535_gsp_rpc_push+0x106/0x160 [nvkm] [  549.473033]  r535_gsp_rpc_rm_ctrl_push+0x40/0x130 [nvkm] [  549.478422]  nvidia_grid_init_vgpu_types+0xbc/0xe0 [nvkm] [  549.483899]  nvidia_grid_init+0xb1/0xd0 [nvkm] [  549.488420]  ? srso_alias_return_thunk+0x5/0xfbef5 [  549.493213]  nvkm_device_pci_probe+0x305/0x420 [nvkm] [  549.498338]  local_pci_probe+0x46/ ---truncated---",
      "cve": "CVE-2024-58018",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58018",
          "value": "CVE-2024-58018",
          "url": "https://scout.docker.com/v/CVE-2024-58018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58018?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d243ba5d0e66fbc48fb2681a48170890ace08e55add37759dd0752d3174954d4",
      "category": "container_scanning",
      "message": "CVE-2024-58053 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rxrpc: Fix handling of received connection abort  Fix the handling of a connection abort that we've received.  Though the abort is at the connection level, it needs propagating to the calls on that connection.  Whilst the propagation bit is performed, the calls aren't then woken up to go and process their termination, and as no further input is forthcoming, they just hang.  Also add some tracing for the logging of connection aborts.",
      "cve": "CVE-2024-58053",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58053",
          "value": "CVE-2024-58053",
          "url": "https://scout.docker.com/v/CVE-2024-58053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58053?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ed42c7001254ccc678595e1bba526e20b17ed2eac1310270b2876e2d7d409ca9",
      "category": "container_scanning",
      "message": "CVE-2024-58089 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix double accounting race when btrfs_run_delalloc_range() failed  [BUG] When running btrfs with block size (4K) smaller than page size (64K, aarch64), there is a very high chance to crash the kernel at generic/750, with the following messages: (before the call traces, there are 3 extra debug messages added)  BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimental BTRFS info (device dm-3): checking UUID tree hrtimer: interrupt took 5451385 ns BTRFS error (device dm-3): cow_file_range failed, root=4957 inode=257 start=1605632 len=69632: -28 BTRFS error (device dm-3): run_delalloc_nocow failed, root=4957 inode=257 start=1605632 len=69632: -28 BTRFS error (device dm-3): failed to run delalloc range, root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28 ------------[ cut here ]------------ WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs] CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G           OE 6.13.0-rc1-custom+ #89 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs] pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs] lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] Call trace: can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P) can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L) btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs] extent_writepage+0x10c/0x3b8 [btrfs] extent_write_cache_pages+0x21c/0x4e8 [btrfs] btrfs_writepages+0x94/0x160 [btrfs] do_writepages+0x74/0x190 filemap_fdatawrite_wbc+0x74/0xa0 start_delalloc_inodes+0x17c/0x3b0 [btrfs] btrfs_start_delalloc_roots+0x17c/0x288 [btrfs] shrink_delalloc+0x11c/0x280 [btrfs] flush_space+0x288/0x328 [btrfs] btrfs_async_reclaim_data_space+0x180/0x228 [btrfs] process_one_work+0x228/0x680 worker_thread+0x1bc/0x360 kthread+0x100/0x118 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0 BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008 BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0 CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G        W  OE 6.13.0-rc1-custom+ #89 Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue:  btrfs_work_helper [btrfs] (btrfs-endio-write) pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : process_one_work+0x110/0x680 lr : worker_thread+0x1bc/0x360 Call trace: process_one_work+0x110/0x680 (P) worker_thread+0x1bc/0x360 (L) worker_thread+0x1bc/0x360 kthread+0x100/0x118 ret_from_fork+0x10/0x20 Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661) ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops: Fatal exception SMP: stopping secondary CPUs SMP: failed to stop secondary CPUs 2-3 Dumping ftrace buffer: (ftrace buffer empty) Kernel Offset: 0x275bb9540000 from 0xffff800080000000 PHYS_OFFSET: 0xffff8fbba0000000 CPU features: 0x100,00000070,00801250,8201720b  [CAUSE] The above warning is triggered immediately after the delalloc range failure, this happens in the following sequence:  - Range [1568K, 1636K) is dirty  1536K  1568K     1600K    1636K  1664K |      |/////////|////////|      |  Where 1536K, 1600K and 1664K are page boundaries (64K page size)  - Enter extent_writepage() for page 1536K  - Enter run_delalloc_nocow() with locke ---truncated---",
      "cve": "CVE-2024-58089",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58089",
          "value": "CVE-2024-58089",
          "url": "https://scout.docker.com/v/CVE-2024-58089?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58089?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a149065db180733cab2f5601cbbaa18280a3ecf4932ef5f2f4e9d17b8ee82a58",
      "category": "container_scanning",
      "message": "CVE-2024-58097 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath11k: fix RCU stall while reaping monitor destination ring  While processing the monitor destination ring, MSDUs are reaped from the link descriptor based on the corresponding buf_id.  However, sometimes the driver cannot obtain a valid buffer corresponding to the buf_id received from the hardware. This causes an infinite loop in the destination processing, resulting in a kernel crash.  kernel log: ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed  Fix this by skipping the problematic buf_id and reaping the next entry, replacing the break with the next MSDU processing.  Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30 Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2024-58097",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58097",
          "value": "CVE-2024-58097",
          "url": "https://scout.docker.com/v/CVE-2024-58097?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58097?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "49c3556cf6be850f83e8bd29e875fd5b17249bb2c17320600fdc41ee2996cbbe",
      "category": "container_scanning",
      "message": "CVE-2025-21629 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: reenable NETIF_F_IPV6_CSUM offload for BIG TCP packets  The blamed commit disabled hardware offoad of IPv6 packets with extension headers on devices that advertise NETIF_F_IPV6_CSUM, based on the definition of that feature in skbuff.h:  *   * - %NETIF_F_IPV6_CSUM *     - Driver (device) is only able to checksum plain *       TCP or UDP packets over IPv6. These are specifically *       unencapsulated packets of the form IPv6|TCP or *       IPv6|UDP where the Next Header field in the IPv6 *       header is either TCP or UDP. IPv6 extension headers *       are not supported with this feature. This feature *       cannot be set in features for a device with *       NETIF_F_HW_CSUM also set. This feature is being *       DEPRECATED (see below).  The change causes skb_warn_bad_offload to fire for BIG TCP packets.  [  496.310233] WARNING: CPU: 13 PID: 23472 at net/core/dev.c:3129 skb_warn_bad_offload+0xc4/0xe0  [  496.310297]  ? skb_warn_bad_offload+0xc4/0xe0 [  496.310300]  skb_checksum_help+0x129/0x1f0 [  496.310303]  skb_csum_hwoffload_help+0x150/0x1b0 [  496.310306]  validate_xmit_skb+0x159/0x270 [  496.310309]  validate_xmit_skb_list+0x41/0x70 [  496.310312]  sch_direct_xmit+0x5c/0x250 [  496.310317]  __qdisc_run+0x388/0x620  BIG TCP introduced an IPV6_TLV_JUMBO IPv6 extension header to communicate packet length, as this is an IPv6 jumbogram. But, the feature is only enabled on devices that support BIG TCP TSO. The header is only present for PF_PACKET taps like tcpdump, and not transmitted by physical devices.  For this specific case of extension headers that are not transmitted, return to the situation before the blamed commit and support hardware offload.  ipv6_has_hopopt_jumbo() tests not only whether this header is present, but also that it is the only extension header before a terminal (L4) header.",
      "cve": "CVE-2025-21629",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21629",
          "value": "CVE-2025-21629",
          "url": "https://scout.docker.com/v/CVE-2025-21629?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21629?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7713e20e6197e859f9d02939453e2e46c5baa1a7a39b801f679687335eb3b81f",
      "category": "container_scanning",
      "message": "CVE-2025-21634 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cgroup/cpuset: remove kernfs active break  A warning was found:  WARNING: CPU: 10 PID: 3486953 at fs/kernfs/file.c:828 CPU: 10 PID: 3486953 Comm: rmdir Kdump: loaded Tainted: G RIP: 0010:kernfs_should_drain_open_files+0x1a1/0x1b0 RSP: 0018:ffff8881107ef9e0 EFLAGS: 00010202 RAX: 0000000080000002 RBX: ffff888154738c00 RCX: dffffc0000000000 RDX: 0000000000000007 RSI: 0000000000000004 RDI: ffff888154738c04 RBP: ffff888154738c04 R08: ffffffffaf27fa15 R09: ffffed102a8e7180 R10: ffff888154738c07 R11: 0000000000000000 R12: ffff888154738c08 R13: ffff888750f8c000 R14: ffff888750f8c0e8 R15: ffff888154738ca0 FS:  00007f84cd0be740(0000) GS:ffff8887ddc00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000555f9fbe00c8 CR3: 0000000153eec001 CR4: 0000000000370ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: kernfs_drain+0x15e/0x2f0 __kernfs_remove+0x165/0x300 kernfs_remove_by_name_ns+0x7b/0xc0 cgroup_rm_file+0x154/0x1c0 cgroup_addrm_files+0x1c2/0x1f0 css_clear_dir+0x77/0x110 kill_css+0x4c/0x1b0 cgroup_destroy_locked+0x194/0x380 cgroup_rmdir+0x2a/0x140  It can be explained by: rmdir \t\t\t\techo 1 > cpuset.cpus kernfs_fop_write_iter // active=0 cgroup_rm_file kernfs_remove_by_name_ns\tkernfs_get_active // active=1 __kernfs_remove\t\t\t\t\t  // active=0x80000002 kernfs_drain\t\t\tcpuset_write_resmask wait_event //waiting (active == 0x80000001) kernfs_break_active_protection // active = 0x80000001 // continue kernfs_unbreak_active_protection // active = 0x80000002 ... kernfs_should_drain_open_files // warning occurs kernfs_put_active  This warning is caused by 'kernfs_break_active_protection' when it is writing to cpuset.cpus, and the cgroup is removed concurrently.  The commit 3a5a6d0c2b03 (\"cpuset: don't nest cgroup_mutex inside get_online_cpus()\") made cpuset_hotplug_workfn asynchronous, This change involves calling flush_work(), which can create a multiple processes circular locking dependency that involve cgroup_mutex, potentially leading to a deadlock. To avoid deadlock. the commit 76bb5ab8f6e3 (\"cpuset: break kernfs active protection in cpuset_write_resmask()\") added 'kernfs_break_active_protection' in the cpuset_write_resmask. This could lead to this warning.  After the commit 2125c0034c5d (\"cgroup/cpuset: Make cpuset hotplug processing synchronous\"), the cpuset_write_resmask no longer needs to wait the hotplug to finish, which means that concurrent hotplug and cpuset operations are no longer possible. Therefore, the deadlock doesn't exist anymore and it does not have to 'break active protection' now. To fix this warning, just remove kernfs_break_active_protection operation in the 'cpuset_write_resmask'.",
      "cve": "CVE-2025-21634",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21634",
          "value": "CVE-2025-21634",
          "url": "https://scout.docker.com/v/CVE-2025-21634?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21634?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b571bf2cf868fd191f705e5f86f1a5a400528de918a96ba2cb27f0ec09a1f8c8",
      "category": "container_scanning",
      "message": "CVE-2025-21635 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rds: sysctl: rds_tcp_{rcv,snd}buf: avoid using current->nsproxy  As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons:  - Inconsistency: getting info from the reader's/writer's netns vs only from the opener's netns.  - current->nsproxy can be NULL in some cases, resulting in an 'Oops' (null-ptr-deref), e.g. when the current task is exiting, as spotted by syzbot [1] using acct(2).  The per-netns structure can be obtained from the table->data using container_of(), then the 'net' one can be retrieved from the listen socket (if available).",
      "cve": "CVE-2025-21635",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21635",
          "value": "CVE-2025-21635",
          "url": "https://scout.docker.com/v/CVE-2025-21635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4d21f39af455f9256d7eb0127aea07c3d2cb19e097a60970287890aa203d7bea",
      "category": "container_scanning",
      "message": "CVE-2025-21649 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hns3: fix kernel crash when 1588 is sent on HIP08 devices  Currently, HIP08 devices does not register the ptp devices, so the hdev->ptp is NULL. But the tx process would still try to set hardware time stamp info with SKBTX_HW_TSTAMP flag and cause a kernel crash.  [  128.087798] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000018 ... [  128.280251] pc : hclge_ptp_set_tx_info+0x2c/0x140 [hclge] [  128.286600] lr : hclge_ptp_set_tx_info+0x20/0x140 [hclge] [  128.292938] sp : ffff800059b93140 [  128.297200] x29: ffff800059b93140 x28: 0000000000003280 [  128.303455] x27: ffff800020d48280 x26: ffff0cb9dc814080 [  128.309715] x25: ffff0cb9cde93fa0 x24: 0000000000000001 [  128.315969] x23: 0000000000000000 x22: 0000000000000194 [  128.322219] x21: ffff0cd94f986000 x20: 0000000000000000 [  128.328462] x19: ffff0cb9d2a166c0 x18: 0000000000000000 [  128.334698] x17: 0000000000000000 x16: ffffcf1fc523ed24 [  128.340934] x15: 0000ffffd530a518 x14: 0000000000000000 [  128.347162] x13: ffff0cd6bdb31310 x12: 0000000000000368 [  128.353388] x11: ffff0cb9cfbc7070 x10: ffff2cf55dd11e02 [  128.359606] x9 : ffffcf1f85a212b4 x8 : ffff0cd7cf27dab0 [  128.365831] x7 : 0000000000000a20 x6 : ffff0cd7cf27d000 [  128.372040] x5 : 0000000000000000 x4 : 000000000000ffff [  128.378243] x3 : 0000000000000400 x2 : ffffcf1f85a21294 [  128.384437] x1 : ffff0cb9db520080 x0 : ffff0cb9db500080 [  128.390626] Call trace: [  128.393964]  hclge_ptp_set_tx_info+0x2c/0x140 [hclge] [  128.399893]  hns3_nic_net_xmit+0x39c/0x4c4 [hns3] [  128.405468]  xmit_one.constprop.0+0xc4/0x200 [  128.410600]  dev_hard_start_xmit+0x54/0xf0 [  128.415556]  sch_direct_xmit+0xe8/0x634 [  128.420246]  __dev_queue_xmit+0x224/0xc70 [  128.425101]  dev_queue_xmit+0x1c/0x40 [  128.429608]  ovs_vport_send+0xac/0x1a0 [openvswitch] [  128.435409]  do_output+0x60/0x17c [openvswitch] [  128.440770]  do_execute_actions+0x898/0x8c4 [openvswitch] [  128.446993]  ovs_execute_actions+0x64/0xf0 [openvswitch] [  128.453129]  ovs_dp_process_packet+0xa0/0x224 [openvswitch] [  128.459530]  ovs_vport_receive+0x7c/0xfc [openvswitch] [  128.465497]  internal_dev_xmit+0x34/0xb0 [openvswitch] [  128.471460]  xmit_one.constprop.0+0xc4/0x200 [  128.476561]  dev_hard_start_xmit+0x54/0xf0 [  128.481489]  __dev_queue_xmit+0x968/0xc70 [  128.486330]  dev_queue_xmit+0x1c/0x40 [  128.490856]  ip_finish_output2+0x250/0x570 [  128.495810]  __ip_finish_output+0x170/0x1e0 [  128.500832]  ip_finish_output+0x3c/0xf0 [  128.505504]  ip_output+0xbc/0x160 [  128.509654]  ip_send_skb+0x58/0xd4 [  128.513892]  udp_send_skb+0x12c/0x354 [  128.518387]  udp_sendmsg+0x7a8/0x9c0 [  128.522793]  inet_sendmsg+0x4c/0x8c [  128.527116]  __sock_sendmsg+0x48/0x80 [  128.531609]  __sys_sendto+0x124/0x164 [  128.536099]  __arm64_sys_sendto+0x30/0x5c [  128.540935]  invoke_syscall+0x50/0x130 [  128.545508]  el0_svc_common.constprop.0+0x10c/0x124 [  128.551205]  do_el0_svc+0x34/0xdc [  128.555347]  el0_svc+0x20/0x30 [  128.559227]  el0_sync_handler+0xb8/0xc0 [  128.563883]  el0_sync+0x160/0x180",
      "cve": "CVE-2025-21649",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21649",
          "value": "CVE-2025-21649",
          "url": "https://scout.docker.com/v/CVE-2025-21649?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21649?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b2609ca119c418944b115a6a7f484c9b645dc4eb9244343aaa961f4cb3760393",
      "category": "container_scanning",
      "message": "CVE-2025-21656 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hwmon: (drivetemp) Fix driver producing garbage data when SCSI errors occur  scsi_execute_cmd() function can return both negative (linux codes) and positive (scsi_cmnd result field) error codes.  Currently the driver just passes error codes of scsi_execute_cmd() to hwmon core, which is incorrect because hwmon only checks for negative error codes. This leads to hwmon reporting uninitialized data to userspace in case of SCSI errors (for example if the disk drive was disconnected).  This patch checks scsi_execute_cmd() output and returns -EIO if it's error code is positive.  [groeck: Avoid inline variable declaration for portability]",
      "cve": "CVE-2025-21656",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21656",
          "value": "CVE-2025-21656",
          "url": "https://scout.docker.com/v/CVE-2025-21656?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21656?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0c8e81b20f421e00f2ac6cdad9972f893285b8c1b64744ce54e09e41b8a56877",
      "category": "container_scanning",
      "message": "CVE-2025-21658 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: avoid NULL pointer dereference if no valid extent tree  [BUG] Syzbot reported a crash with the following call trace:  BTRFS info (device loop0): scrub: started on devid 1 BUG: kernel NULL pointer dereference, address: 0000000000000208 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 106e70067 P4D 106e70067 PUD 107143067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 UID: 0 PID: 689 Comm: repro Kdump: loaded Tainted: G           O 6.13.0-rc4-custom+ #206 Tainted: [O]=OOT_MODULE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022 RIP: 0010:find_first_extent_item+0x26/0x1f0 [btrfs] Call Trace: <TASK> scrub_find_fill_first_stripe+0x13d/0x3b0 [btrfs] scrub_simple_mirror+0x175/0x260 [btrfs] scrub_stripe+0x5d4/0x6c0 [btrfs] scrub_chunk+0xbb/0x170 [btrfs] scrub_enumerate_chunks+0x2f4/0x5f0 [btrfs] btrfs_scrub_dev+0x240/0x600 [btrfs] btrfs_ioctl+0x1dc8/0x2fa0 [btrfs] ? do_sys_openat2+0xa5/0xf0 __x64_sys_ioctl+0x97/0xc0 do_syscall_64+0x4f/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e </TASK>  [CAUSE] The reproducer is using a corrupted image where extent tree root is corrupted, thus forcing to use \"rescue=all,ro\" mount option to mount the image.  Then it triggered a scrub, but since scrub relies on extent tree to find where the data/metadata extents are, scrub_find_fill_first_stripe() relies on an non-empty extent root.  But unfortunately scrub_find_fill_first_stripe() doesn't really expect an NULL pointer for extent root, it use extent_root to grab fs_info and triggered a NULL pointer dereference.  [FIX] Add an extra check for a valid extent root at the beginning of scrub_find_fill_first_stripe().  The new error path is introduced by 42437a6386ff (\"btrfs: introduce mount option rescue=ignorebadroots\"), but that's pretty old, and later commit b979547513ff (\"btrfs: scrub: introduce helper to find and fill sector info for a scrub_stripe\") changed how we do scrub.  So for kernels older than 6.6, the fix will need manual backport.",
      "cve": "CVE-2025-21658",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21658",
          "value": "CVE-2025-21658",
          "url": "https://scout.docker.com/v/CVE-2025-21658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21658?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8eee4b5b53c6b0c60966fc48128f671340357cdce3716e6962ec4679524fe32b",
      "category": "container_scanning",
      "message": "CVE-2025-21667 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iomap: avoid avoid truncating 64-bit offset to 32 bits  on 32-bit kernels, iomap_write_delalloc_scan() was inadvertently using a 32-bit position due to folio_next_index() returning an unsigned long. This could lead to an infinite loop when writing to an xfs filesystem.",
      "cve": "CVE-2025-21667",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21667",
          "value": "CVE-2025-21667",
          "url": "https://scout.docker.com/v/CVE-2025-21667?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21667?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b714d1e837003b297c782f0f327ba2013d09e65fb3951e775aabc2e7e32396b5",
      "category": "container_scanning",
      "message": "CVE-2025-21672 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  afs: Fix merge preference rule failure condition  syzbot reported a lock held when returning to userspace[1].  This is because if argc is less than 0 and the function returns directly, the held inode lock is not released.  Fix this by store the error in ret and jump to done to clean up instead of returning directly.  [dh: Modified Lizhi Xu's original patch to make it honour the error code from afs_split_string()]  [1] WARNING: lock held when returning to user space! 6.13.0-rc3-syzkaller-00209-g499551201b5f #0 Not tainted ------------------------------------------------ syz-executor133/5823 is leaving the kernel with locks still held! 1 lock held by syz-executor133/5823: #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: inode_lock include/linux/fs.h:818 [inline] #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: afs_proc_addr_prefs_write+0x2bb/0x14e0 fs/afs/addr_prefs.c:388",
      "cve": "CVE-2025-21672",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21672",
          "value": "CVE-2025-21672",
          "url": "https://scout.docker.com/v/CVE-2025-21672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21672?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f711f8226a22e3a4f4ac8da8fa3d70aa8e0def9effb2fc6b5eb78bf5d597b33d",
      "category": "container_scanning",
      "message": "CVE-2025-21673 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix double free of TCP_Server_Info::hostname  When shutting down the server in cifs_put_tcp_session(), cifsd thread might be reconnecting to multiple DFS targets before it realizes it should exit the loop, so @server->hostname can't be freed as long as cifsd thread isn't done.  Otherwise the following can happen:  RIP: 0010:__slab_free+0x223/0x3c0 Code: 5e 41 5f c3 cc cc cc cc 4c 89 de 4c 89 cf 44 89 44 24 08 4c 89 1c 24 e8 fb cf 8e 00 44 8b 44 24 08 4c 8b 1c 24 e9 5f fe ff ff <0f> 0b 41 f7 45 08 00 0d 21 00 0f 85 2d ff ff ff e9 1f ff ff ff 80 RSP: 0018:ffffb26180dbfd08 EFLAGS: 00010246 RAX: ffff8ea34728e510 RBX: ffff8ea34728e500 RCX: 0000000000800068 RDX: 0000000000800068 RSI: 0000000000000000 RDI: ffff8ea340042400 RBP: ffffe112041ca380 R08: 0000000000000001 R09: 0000000000000000 R10: 6170732e31303000 R11: 70726f632e786563 R12: ffff8ea34728e500 R13: ffff8ea340042400 R14: ffff8ea34728e500 R15: 0000000000800068 FS: 0000000000000000(0000) GS:ffff8ea66fd80000(0000) 000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffc25376080 CR3: 000000012a2ba001 CR4: PKRU: 55555554 Call Trace: <TASK> ? show_trace_log_lvl+0x1c4/0x2df ? show_trace_log_lvl+0x1c4/0x2df ? __reconnect_target_unlocked+0x3e/0x160 [cifs] ? __die_body.cold+0x8/0xd ? die+0x2b/0x50 ? do_trap+0xce/0x120 ? __slab_free+0x223/0x3c0 ? do_error_trap+0x65/0x80 ? __slab_free+0x223/0x3c0 ? exc_invalid_op+0x4e/0x70 ? __slab_free+0x223/0x3c0 ? asm_exc_invalid_op+0x16/0x20 ? __slab_free+0x223/0x3c0 ? extract_hostname+0x5c/0xa0 [cifs] ? extract_hostname+0x5c/0xa0 [cifs] ? __kmalloc+0x4b/0x140 __reconnect_target_unlocked+0x3e/0x160 [cifs] reconnect_dfs_server+0x145/0x430 [cifs] cifs_handle_standard+0x1ad/0x1d0 [cifs] cifs_demultiplex_thread+0x592/0x730 [cifs] ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs] kthread+0xdd/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x29/0x50 </TASK>",
      "cve": "CVE-2025-21673",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21673",
          "value": "CVE-2025-21673",
          "url": "https://scout.docker.com/v/CVE-2025-21673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21673?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7907c9c35677b1b1051c40134c16e1e5fdbbc88375aa4fef0afd09cd621b3792",
      "category": "container_scanning",
      "message": "CVE-2025-21682 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  eth: bnxt: always recalculate features after XDP clearing, fix null-deref  Recalculate features when XDP is detached.  Before: # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw: off [requested on]  After: # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw: on  The fact that HW-GRO doesn't get re-enabled automatically is just a minor annoyance. The real issue is that the features will randomly come back during another reconfiguration which just happens to invoke netdev_update_features(). The driver doesn't handle reconfiguring two things at a time very robustly.  Starting with commit 98ba1d931f61 (\"bnxt_en: Fix RSS logic in __bnxt_reserve_rings()\") we only reconfigure the RSS hash table if the \"effective\" number of Rx rings has changed. If HW-GRO is enabled \"effective\" number of rings is 2x what user sees. So if we are in the bad state, with HW-GRO re-enablement \"pending\" after XDP off, and we lower the rings by / 2 - the HW-GRO rings doing 2x and the ethtool -L doing / 2 may cancel each other out, and the:  if (old_rx_rings != bp->hw_resc.resv_rx_rings &&  condition in __bnxt_reserve_rings() will be false. The RSS map won't get updated, and we'll crash with:  BUG: kernel NULL pointer dereference, address: 0000000000000168 RIP: 0010:__bnxt_hwrm_vnic_set_rss+0x13a/0x1a0 bnxt_hwrm_vnic_rss_cfg_p5+0x47/0x180 __bnxt_setup_vnic_p5+0x58/0x110 bnxt_init_nic+0xb72/0xf50 __bnxt_open_nic+0x40d/0xab0 bnxt_open_nic+0x2b/0x60 ethtool_set_channels+0x18c/0x1d0  As we try to access a freed ring.  The issue is present since XDP support was added, really, but prior to commit 98ba1d931f61 (\"bnxt_en: Fix RSS logic in __bnxt_reserve_rings()\") it wasn't causing major issues.",
      "cve": "CVE-2025-21682",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21682",
          "value": "CVE-2025-21682",
          "url": "https://scout.docker.com/v/CVE-2025-21682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "94449a4ab00175d09596a8bdcf0371f0bf92360c98795525907324c3d52cc33d",
      "category": "container_scanning",
      "message": "CVE-2025-21696 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: clear uffd-wp PTE/PMD state on mremap()  When mremap()ing a memory region previously registered with userfaultfd as write-protected but without UFFD_FEATURE_EVENT_REMAP, an inconsistency in flag clearing leads to a mismatch between the vma flags (which have uffd-wp cleared) and the pte/pmd flags (which do not have uffd-wp cleared).  This mismatch causes a subsequent mprotect(PROT_WRITE) to trigger a warning in page_table_check_pte_flags() due to setting the pte to writable while uffd-wp is still set.  Fix this by always explicitly clearing the uffd-wp pte/pmd flags on any such mremap() so that the values are consistent with the existing clearing of VM_UFFD_WP.  Be careful to clear the logical flag regardless of its physical form; a PTE bit, a swap PTE bit, or a PTE marker.  Cover PTE, huge PMD and hugetlb paths.",
      "cve": "CVE-2025-21696",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21696",
          "value": "CVE-2025-21696",
          "url": "https://scout.docker.com/v/CVE-2025-21696?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21696?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "44b055bcc0b5b20f0c371f051fd8af8e811039bfa2868bda4b9de02ececbc061",
      "category": "container_scanning",
      "message": "CVE-2025-21712 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  md/md-bitmap: Synchronize bitmap_get_stats() with bitmap lifetime  After commit ec6bb299c7c3 (\"md/md-bitmap: add 'sync_size' into struct md_bitmap_stats\"), following panic is reported:  Oops: general protection fault, probably for non-canonical address RIP: 0010:bitmap_get_stats+0x2b/0xa0 Call Trace: <TASK> md_seq_show+0x2d2/0x5b0 seq_read_iter+0x2b9/0x470 seq_read+0x12f/0x180 proc_reg_read+0x57/0xb0 vfs_read+0xf6/0x380 ksys_read+0x6c/0xf0 do_syscall_64+0x82/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e  Root cause is that bitmap_get_stats() can be called at anytime if mddev is still there, even if bitmap is destroyed, or not fully initialized. Deferenceing bitmap in this case can crash the kernel. Meanwhile, the above commit start to deferencing bitmap->storage, make the problem easier to trigger.  Fix the problem by protecting bitmap_get_stats() with bitmap_info.mutex.",
      "cve": "CVE-2025-21712",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21712",
          "value": "CVE-2025-21712",
          "url": "https://scout.docker.com/v/CVE-2025-21712?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21712?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d38dfc2b558ab26173a760570602669e3001ccb4f485f30fbdda294bb954ef4b",
      "category": "container_scanning",
      "message": "CVE-2025-21723 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: mpi3mr: Fix possible crash when setting up bsg fails  If bsg_setup_queue() fails, the bsg_queue is assigned a non-NULL value. Consequently, in mpi3mr_bsg_exit(), the condition \"if(!mrioc->bsg_queue)\" will not be satisfied, preventing execution from entering bsg_remove_queue(), which could lead to the following crash:  BUG: kernel NULL pointer dereference, address: 000000000000041c Call Trace: <TASK> mpi3mr_bsg_exit+0x1f/0x50 [mpi3mr] mpi3mr_remove+0x6f/0x340 [mpi3mr] pci_device_remove+0x3f/0xb0 device_release_driver_internal+0x19d/0x220 unbind_store+0xa4/0xb0 kernfs_fop_write_iter+0x11f/0x200 vfs_write+0x1fc/0x3e0 ksys_write+0x67/0xe0 do_syscall_64+0x38/0x80 entry_SYSCALL_64_after_hwframe+0x78/0xe2",
      "cve": "CVE-2025-21723",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21723",
          "value": "CVE-2025-21723",
          "url": "https://scout.docker.com/v/CVE-2025-21723?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21723?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "430f1dccf1370ca23719ae0494af99e05bf897655b956c5a1d27740f92cdd338",
      "category": "container_scanning",
      "message": "CVE-2025-21730 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: avoid to init mgnt_entry list twice when WoWLAN failed  If WoWLAN failed in resume flow, the rtw89_ops_add_interface() triggered without removing the interface first. Then the mgnt_entry list init again, causing the list_empty() check in rtw89_chanctx_ops_assign_vif() useless, and list_add_tail() again. Therefore, we have added a check to prevent double adding of the list.  rtw89_8852ce 0000:01:00.0: failed to check wow status disabled rtw89_8852ce 0000:01:00.0: wow: failed to check disable fw ready rtw89_8852ce 0000:01:00.0: wow: failed to swap to normal fw rtw89_8852ce 0000:01:00.0: failed to disable wow rtw89_8852ce 0000:01:00.0: failed to resume for wow -110 rtw89_8852ce 0000:01:00.0: MAC has already powered on i2c_hid_acpi i2c-ILTK0001:00: PM: acpi_subsys_resume+0x0/0x60 returned 0 after 284705 usecs list_add corruption. prev->next should be next (ffff9d9719d82228), but was ffff9d9719f96030. (prev=ffff9d9719f96030). ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:34! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 2 PID: 6918 Comm: kworker/u8:19 Tainted: G     U     O Hardware name: Google Anraggar/Anraggar, BIOS Google_Anraggar.15217.514.0 03/25/2024 Workqueue: events_unbound async_run_entry_fn RIP: 0010:__list_add_valid_or_report+0x9f/0xb0 Code: e8 56 89 ff ff 0f 0b 48 c7 c7 3e fc e0 96 48 89 c6 e8 45 89 ff ... RSP: 0018:ffffa51b42bbbaf0 EFLAGS: 00010246 RAX: 0000000000000075 RBX: ffff9d9719d82ab0 RCX: 13acb86e047a4400 RDX: 3fffffffffffffff RSI: 0000000000000000 RDI: 00000000ffffdfff RBP: ffffa51b42bbbb28 R08: ffffffff9768e250 R09: 0000000000001fff R10: ffffffff9765e250 R11: 0000000000005ffd R12: ffff9d9719f95c40 R13: ffff9d9719f95be8 R14: ffff9d97081bfd78 R15: ffff9d9719d82060 FS:  0000000000000000(0000) GS:ffff9d9a6fb00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007e7d029a4060 CR3: 0000000345e38000 CR4: 0000000000750ee0 PKRU: 55555554 Call Trace: <TASK> ? __die_body+0x68/0xb0 ? die+0xaa/0xd0 ? do_trap+0x9f/0x170 ? __list_add_valid_or_report+0x9f/0xb0 ? __list_add_valid_or_report+0x9f/0xb0 ? handle_invalid_op+0x69/0x90 ? __list_add_valid_or_report+0x9f/0xb0 ? exc_invalid_op+0x3c/0x50 ? asm_exc_invalid_op+0x16/0x20 ? __list_add_valid_or_report+0x9f/0xb0 rtw89_chanctx_ops_assign_vif+0x1f9/0x210 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1] ? __mutex_unlock_slowpath+0xa0/0xf0 rtw89_ops_assign_vif_chanctx+0x4b/0x90 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1] drv_assign_vif_chanctx+0xa7/0x1f0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6] ieee80211_reconfig+0x9cb/0x17b0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6] ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed] ? dev_printk_emit+0x51/0x70 ? _dev_info+0x6e/0x90 wiphy_resume+0x89/0x180 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed] ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed] dpm_run_callback+0x37/0x1e0 device_resume+0x26d/0x4b0 ? __pfx_dpm_watchdog_handler+0x10/0x10 async_resume+0x1d/0x30 async_run_entry_fn+0x29/0xd0 worker_thread+0x397/0x970 kthread+0xed/0x110 ? __pfx_worker_thread+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x38/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK>",
      "cve": "CVE-2025-21730",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21730",
          "value": "CVE-2025-21730",
          "url": "https://scout.docker.com/v/CVE-2025-21730?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21730?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c99e1a7b7cb9d8618d3a001bce78e941bf181c4934154d312a027fc673a21f71",
      "category": "container_scanning",
      "message": "CVE-2025-21792 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ax25: Fix refcount leak caused by setting SO_BINDTODEVICE sockopt  If an AX25 device is bound to a socket by setting the SO_BINDTODEVICE socket option, a refcount leak will occur in ax25_release().  Commit 9fd75b66b8f6 (\"ax25: Fix refcount leaks caused by ax25_cb_del()\") added decrement of device refcounts in ax25_release(). In order for that to work correctly the refcounts must already be incremented when the device is bound to the socket. An AX25 device can be bound to a socket by either calling ax25_bind() or setting SO_BINDTODEVICE socket option. In both cases the refcounts should be incremented, but in fact it is done only in ax25_bind().  This bug leads to the following issue reported by Syzkaller:  ================================================================ refcount_t: decrement hit 0; leaking memory. WARNING: CPU: 1 PID: 5932 at lib/refcount.c:31 refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31 Modules linked in: CPU: 1 UID: 0 PID: 5932 Comm: syz-executor424 Not tainted 6.13.0-rc4-syzkaller-00110-g4099a71718b0 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31 Call Trace: <TASK> __refcount_dec include/linux/refcount.h:336 [inline] refcount_dec include/linux/refcount.h:351 [inline] ref_tracker_free+0x710/0x820 lib/ref_tracker.c:236 netdev_tracker_free include/linux/netdevice.h:4156 [inline] netdev_put include/linux/netdevice.h:4173 [inline] netdev_put include/linux/netdevice.h:4169 [inline] ax25_release+0x33f/0xa10 net/ax25/af_ax25.c:1069 __sock_release+0xb0/0x270 net/socket.c:640 sock_close+0x1c/0x30 net/socket.c:1408 ... do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... </TASK> ================================================================  Fix the implementation of ax25_setsockopt() by adding increment of refcounts for the new device bound, and decrement of refcounts for the old unbound device.",
      "cve": "CVE-2025-21792",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21792",
          "value": "CVE-2025-21792",
          "url": "https://scout.docker.com/v/CVE-2025-21792?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21792?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e8f6894b2caeb2f1a1463b16395c83ce0352c51acb537f77ab4e254b92c6eef6",
      "category": "container_scanning",
      "message": "CVE-2025-21816 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  hrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYING  hrtimers are migrated away from the dying CPU to any online target at the CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timers handling tasks involved in the CPU hotplug forward progress.  However wakeups can still be performed by the outgoing CPU after CPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers being armed. Depending on several considerations (crystal ball power management based election, earliest timer already enqueued, timer migration enabled or not), the target may eventually be the current CPU even if offline. If that happens, the timer is eventually ignored.  The most notable example is RCU which had to deal with each and every of those wake-ups by deferring them to an online CPU, along with related workarounds:  _ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying) _ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU) _ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)  The problem isn't confined to RCU though as the stop machine kthread (which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the end of its work through cpu_stop_signal_done() and performs a wake up that eventually arms the deadline server timer:  WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0 CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not tainted Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0 RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0 Call Trace: <TASK> start_dl_timer enqueue_dl_entity dl_server_start enqueue_task_fair enqueue_task ttwu_do_activate try_to_wake_up complete cpu_stopper_thread  Instead of providing yet another bandaid to work around the situation, fix it in the hrtimers infrastructure instead: always migrate away a timer to an online target whenever it is enqueued from an offline CPU.  This will also allow to revert all the above RCU disgraceful hacks.",
      "cve": "CVE-2025-21816",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21816",
          "value": "CVE-2025-21816",
          "url": "https://scout.docker.com/v/CVE-2025-21816?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21816?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2610ca23c5b3e33f1a967b1cd7e3a55b0dd50ef354ae7217743934d01e297011",
      "category": "container_scanning",
      "message": "CVE-2025-21817 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  block: mark GFP_NOIO around sysfs ->store()  sysfs ->store is called with queue freezed, meantime we have several ->store() callbacks(update_nr_requests, wbt, scheduler) to allocate memory with GFP_KERNEL which may run into direct reclaim code path, then potential deadlock can be caused.  Fix the issue by marking NOIO around sysfs ->store()",
      "cve": "CVE-2025-21817",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21817",
          "value": "CVE-2025-21817",
          "url": "https://scout.docker.com/v/CVE-2025-21817?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21817?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0f5d2bee6d3ead127c0693a8d2cb44ce8562c58aad9f8daaca26100c92b5472f",
      "category": "container_scanning",
      "message": "CVE-2025-21819 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Revert \"drm/amd/display: Use HW lock mgr for PSR1\"  This reverts commit a2b5a9956269 (\"drm/amd/display: Use HW lock mgr for PSR1\")  Because it may cause system hang while connect with two edp panel.",
      "cve": "CVE-2025-21819",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21819",
          "value": "CVE-2025-21819",
          "url": "https://scout.docker.com/v/CVE-2025-21819?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21819?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "deae9f6ea844ffe586ec1238de183f974fd2cd077b114f131421c6a5551cd559",
      "category": "container_scanning",
      "message": "CVE-2025-21821 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fbdev: omap: use threaded IRQ for LCD DMA  When using touchscreen and framebuffer, Nokia 770 crashes easily with:  BUG: scheduling while atomic: irq/144-ads7846/82/0x00010000 Modules linked in: usb_f_ecm g_ether usb_f_rndis u_ether libcomposite configfs omap_udc ohci_omap ohci_hcd CPU: 0 UID: 0 PID: 82 Comm: irq/144-ads7846 Not tainted 6.12.7-770 #2 Hardware name: Nokia 770 Call trace: unwind_backtrace from show_stack+0x10/0x14 show_stack from dump_stack_lvl+0x54/0x5c dump_stack_lvl from __schedule_bug+0x50/0x70 __schedule_bug from __schedule+0x4d4/0x5bc __schedule from schedule+0x34/0xa0 schedule from schedule_preempt_disabled+0xc/0x10 schedule_preempt_disabled from __mutex_lock.constprop.0+0x218/0x3b4 __mutex_lock.constprop.0 from clk_prepare_lock+0x38/0xe4 clk_prepare_lock from clk_set_rate+0x18/0x154 clk_set_rate from sossi_read_data+0x4c/0x168 sossi_read_data from hwa742_read_reg+0x5c/0x8c hwa742_read_reg from send_frame_handler+0xfc/0x300 send_frame_handler from process_pending_requests+0x74/0xd0 process_pending_requests from lcd_dma_irq_handler+0x50/0x74 lcd_dma_irq_handler from __handle_irq_event_percpu+0x44/0x130 __handle_irq_event_percpu from handle_irq_event+0x28/0x68 handle_irq_event from handle_level_irq+0x9c/0x170 handle_level_irq from generic_handle_domain_irq+0x2c/0x3c generic_handle_domain_irq from omap1_handle_irq+0x40/0x8c omap1_handle_irq from generic_handle_arch_irq+0x28/0x3c generic_handle_arch_irq from call_with_stack+0x1c/0x24 call_with_stack from __irq_svc+0x94/0xa8 Exception stack(0xc5255da0 to 0xc5255de8) 5da0: 00000001 c22fc620 00000000 00000000 c08384a8 c106fc00 00000000 c240c248 5dc0: c113a600 c3f6ec30 00000001 00000000 c22fc620 c5255df0 c22fc620 c0279a94 5de0: 60000013 ffffffff __irq_svc from clk_prepare_lock+0x4c/0xe4 clk_prepare_lock from clk_get_rate+0x10/0x74 clk_get_rate from uwire_setup_transfer+0x40/0x180 uwire_setup_transfer from spi_bitbang_transfer_one+0x2c/0x9c spi_bitbang_transfer_one from spi_transfer_one_message+0x2d0/0x664 spi_transfer_one_message from __spi_pump_transfer_message+0x29c/0x498 __spi_pump_transfer_message from __spi_sync+0x1f8/0x2e8 __spi_sync from spi_sync+0x24/0x40 spi_sync from ads7846_halfd_read_state+0x5c/0x1c0 ads7846_halfd_read_state from ads7846_irq+0x58/0x348 ads7846_irq from irq_thread_fn+0x1c/0x78 irq_thread_fn from irq_thread+0x120/0x228 irq_thread from kthread+0xc8/0xe8 kthread from ret_from_fork+0x14/0x28  As a quick fix, switch to a threaded IRQ which provides a stable system.",
      "cve": "CVE-2025-21821",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21821",
          "value": "CVE-2025-21821",
          "url": "https://scout.docker.com/v/CVE-2025-21821?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21821?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fd435aa9f8213d39ac0541d4a1d43f1e3bafebba048388b0cc187da995f5bfde",
      "category": "container_scanning",
      "message": "CVE-2025-21833 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  iommu/vt-d: Avoid use of NULL after WARN_ON_ONCE  There is a WARN_ON_ONCE to catch an unlikely situation when domain_remove_dev_pasid can't find the `pasid`. In case it nevertheless happens we must avoid using a NULL pointer.",
      "cve": "CVE-2025-21833",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21833",
          "value": "CVE-2025-21833",
          "url": "https://scout.docker.com/v/CVE-2025-21833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ae947f45f0631d569a96d5c8ab6912300b82d8af6061e19e41db16a278cd8169",
      "category": "container_scanning",
      "message": "CVE-2025-21891 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ipvlan: ensure network headers are in skb linear part  syzbot found that ipvlan_process_v6_outbound() was assuming the IPv6 network header isis present in skb->head [1]  Add the needed pskb_network_may_pull() calls for both IPv4 and IPv6 handlers.  [1] BUG: KMSAN: uninit-value in __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47 __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47 ipv6_addr_type include/net/ipv6.h:555 [inline] ip6_route_output_flags_noref net/ipv6/route.c:2616 [inline] ip6_route_output_flags+0x51/0x720 net/ipv6/route.c:2651 ip6_route_output include/net/ip6_route.h:93 [inline] ipvlan_route_v6_outbound+0x24e/0x520 drivers/net/ipvlan/ipvlan_core.c:476 ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:491 [inline] ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:541 [inline] ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:605 [inline] ipvlan_queue_xmit+0xd72/0x1780 drivers/net/ipvlan/ipvlan_core.c:671 ipvlan_start_xmit+0x5b/0x210 drivers/net/ipvlan/ipvlan_main.c:223 __netdev_start_xmit include/linux/netdevice.h:5150 [inline] netdev_start_xmit include/linux/netdevice.h:5159 [inline] xmit_one net/core/dev.c:3735 [inline] dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3751 sch_direct_xmit+0x399/0xd40 net/sched/sch_generic.c:343 qdisc_restart net/sched/sch_generic.c:408 [inline] __qdisc_run+0x14da/0x35d0 net/sched/sch_generic.c:416 qdisc_run+0x141/0x4d0 include/net/pkt_sched.h:127 net_tx_action+0x78b/0x940 net/core/dev.c:5484 handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561 __do_softirq+0x14/0x1a kernel/softirq.c:595 do_softirq+0x9a/0x100 kernel/softirq.c:462 __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389 local_bh_enable include/linux/bottom_half.h:33 [inline] rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline] __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4611 dev_queue_xmit include/linux/netdevice.h:3311 [inline] packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276 packet_snd net/packet/af_packet.c:3132 [inline] packet_sendmsg+0x93e0/0xa7e0 net/packet/af_packet.c:3164 sock_sendmsg_nosec net/socket.c:718 [inline]",
      "cve": "CVE-2025-21891",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21891",
          "value": "CVE-2025-21891",
          "url": "https://scout.docker.com/v/CVE-2025-21891?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21891?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec03e1a7229227658736ca840c240683efc4d9e097555727a7a5221c60992ac1",
      "category": "container_scanning",
      "message": "CVE-2025-21908 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  NFS: fix nfs_release_folio() to not deadlock via kcompactd writeback  Add PF_KCOMPACTD flag and current_is_kcompactd() helper to check for it so nfs_release_folio() can skip calling nfs_wb_folio() from kcompactd.  Otherwise NFS can deadlock waiting for kcompactd enduced writeback which recurses back to NFS (which triggers writeback to NFSD via NFS loopback mount on the same host, NFSD blocks waiting for XFS's call to __filemap_get_folio):  6070.550357] INFO: task kcompactd0:58 blocked for more than 4435 seconds.  {--- [58] \"kcompactd0\" [<0>] folio_wait_bit+0xe8/0x200 [<0>] folio_wait_writeback+0x2b/0x80 [<0>] nfs_wb_folio+0x80/0x1b0 [nfs] [<0>] nfs_release_folio+0x68/0x130 [nfs] [<0>] split_huge_page_to_list_to_order+0x362/0x840 [<0>] migrate_pages_batch+0x43d/0xb90 [<0>] migrate_pages_sync+0x9a/0x240 [<0>] migrate_pages+0x93c/0x9f0 [<0>] compact_zone+0x8e2/0x1030 [<0>] compact_node+0xdb/0x120 [<0>] kcompactd+0x121/0x2e0 [<0>] kthread+0xcf/0x100 [<0>] ret_from_fork+0x31/0x40 [<0>] ret_from_fork_asm+0x1a/0x30 ---}  [akpm@linux-foundation.org: fix build]",
      "cve": "CVE-2025-21908",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21908",
          "value": "CVE-2025-21908",
          "url": "https://scout.docker.com/v/CVE-2025-21908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21908?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3135ea79be8705b17305d67aa5f6cf95ceb1003369fec437ad954789de01322d",
      "category": "container_scanning",
      "message": "CVE-2025-21918 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: typec: ucsi: Fix NULL pointer access  Resources should be released only after all threads that utilize them have been destroyed. This commit ensures that resources are not released prematurely by waiting for the associated workqueue to complete before deallocating them.",
      "cve": "CVE-2025-21918",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21918",
          "value": "CVE-2025-21918",
          "url": "https://scout.docker.com/v/CVE-2025-21918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ad1f94ce5a18a60290678e7d61b90ff763e13bfa26673ce0e3d3a1a531dff39d",
      "category": "container_scanning",
      "message": "CVE-2025-21949 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  LoongArch: Set hugetlb mmap base address aligned with pmd size  With ltp test case \"testcases/bin/hugefork02\", there is a dmesg error report message such as:  kernel BUG at mm/hugetlb.c:5550! Oops - BUG[#1]: CPU: 0 UID: 0 PID: 1517 Comm: hugefork02 Not tainted 6.14.0-rc2+ #241 Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022 pc 90000000004eaf1c ra 9000000000485538 tp 900000010edbc000 sp 900000010edbf940 a0 900000010edbfb00 a1 9000000108d20280 a2 00007fffe9474000 a3 00007ffff3474000 a4 0000000000000000 a5 0000000000000003 a6 00000000003cadd3 a7 0000000000000000 t0 0000000001ffffff t1 0000000001474000 t2 900000010ecd7900 t3 00007fffe9474000 t4 00007fffe9474000 t5 0000000000000040 t6 900000010edbfb00 t7 0000000000000001 t8 0000000000000005 u0 90000000004849d0 s9 900000010edbfa00 s0 9000000108d20280 s1 00007fffe9474000 s2 0000000002000000 s3 9000000108d20280 s4 9000000002b38b10 s5 900000010edbfb00 s6 00007ffff3474000 s7 0000000000000406 s8 900000010edbfa08 ra: 9000000000485538 unmap_vmas+0x130/0x218 ERA: 90000000004eaf1c __unmap_hugepage_range+0x6f4/0x7d0 PRMD: 00000004 (PPLV0 +PIE -PWE) EUEN: 00000007 (+FPE +SXE +ASXE -BTE) ECFG: 00071c1d (LIE=0,2-4,10-12 VS=7) ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0) PRID: 0014c010 (Loongson-64bit, Loongson-3A5000) Process hugefork02 (pid: 1517, threadinfo=00000000a670eaf4, task=000000007a95fc64) Call Trace: [<90000000004eaf1c>] __unmap_hugepage_range+0x6f4/0x7d0 [<9000000000485534>] unmap_vmas+0x12c/0x218 [<9000000000494068>] exit_mmap+0xe0/0x308 [<900000000025fdc4>] mmput+0x74/0x180 [<900000000026a284>] do_exit+0x294/0x898 [<900000000026aa30>] do_group_exit+0x30/0x98 [<900000000027bed4>] get_signal+0x83c/0x868 [<90000000002457b4>] arch_do_signal_or_restart+0x54/0xfa0 [<90000000015795e8>] irqentry_exit_to_user_mode+0xb8/0x138 [<90000000002572d0>] tlb_do_page_fault_1+0x114/0x1b4  The problem is that base address allocated from hugetlbfs is not aligned with pmd size. Here add a checking for hugetlbfs and align base address with pmd size. After this patch the test case \"testcases/bin/hugefork02\" passes to run.  This is similar to the commit 7f24cbc9c4d42db8a3c8484d1 (\"mm/mmap: teach generic_get_unmapped_area{_topdown} to handle hugetlb mappings\").",
      "cve": "CVE-2025-21949",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21949",
          "value": "CVE-2025-21949",
          "url": "https://scout.docker.com/v/CVE-2025-21949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21949?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d55c5545a7ec48ab045a757d2ffb71c4a715708e7f746498e589c44bf873a587",
      "category": "container_scanning",
      "message": "CVE-2025-22037 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix null pointer dereference in alloc_preauth_hash()  The Client send malformed smb2 negotiate request. ksmbd return error response. Subsequently, the client can send smb2 session setup even thought conn->preauth_info is not allocated. This patch add KSMBD_SESS_NEED_SETUP status of connection to ignore session setup request if smb2 negotiate phase is not complete.",
      "cve": "CVE-2025-22037",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22037",
          "value": "CVE-2025-22037",
          "url": "https://scout.docker.com/v/CVE-2025-22037?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22037?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1739affb33a120df5837a59983a7190b451083ef09e3bfb0419d9c60943b20a3",
      "category": "container_scanning",
      "message": "CVE-2025-3198 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.",
      "cve": "CVE-2025-3198",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-3198",
          "value": "CVE-2025-3198",
          "url": "https://scout.docker.com/v/CVE-2025-3198?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-3198?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dd965a2df22ebc97fb20aac644a2290263580e9958681e2f422add2f97128cc3",
      "category": "container_scanning",
      "message": "CVE-2025-37800 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  driver core: fix potential NULL pointer dereference in dev_uevent()  If userspace reads \"uevent\" device attribute at the same time as another threads unbinds the device from its driver, change to dev->driver from a valid pointer to NULL may result in crash. Fix this by using READ_ONCE() when fetching the pointer, and take bus' drivers klist lock to make sure driver instance will not disappear while we access it.  Use WRITE_ONCE() when setting the driver pointer to ensure there is no tearing.",
      "cve": "CVE-2025-37800",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-37800",
          "value": "CVE-2025-37800",
          "url": "https://scout.docker.com/v/CVE-2025-37800?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-37800?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0f7931f4d7523e8f572e0e972e620450f03a5d235937c47044823ec68b2c2db7",
      "category": "container_scanning",
      "message": "CVE-2022-49138 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: hci_event: Ignore multiple conn complete events  When one of the three connection complete events is received multiple times for the same handle, the device is registered multiple times which leads to memory corruptions. Therefore, consequent events for a single connection are ignored.  The conn->state can hold different values, therefore HCI_CONN_HANDLE_UNSET is introduced to identify new connections. To make sure the events do not contain this or another invalid handle HCI_CONN_HANDLE_MAX and checks are introduced.  Buglink: https://bugzilla.kernel.org/show_bug.cgi?id=215497",
      "cve": "CVE-2022-49138",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49138",
          "value": "CVE-2022-49138",
          "url": "https://scout.docker.com/v/CVE-2022-49138?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49138?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4453fce279192cfda56881d815b94fa14612e754bddff3512e998ed7e0a2b7e8",
      "category": "container_scanning",
      "message": "CVE-2024-49569 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-rdma: unquiesce admin_q before destroy it  Kernel will hang on destroy admin_q while we create ctrl failed, such as following calltrace:  PID: 23644    TASK: ff2d52b40f439fc0  CPU: 2    COMMAND: \"nvme\" #0 [ff61d23de260fb78] __schedule at ffffffff8323bc15 #1 [ff61d23de260fc08] schedule at ffffffff8323c014 #2 [ff61d23de260fc28] blk_mq_freeze_queue_wait at ffffffff82a3dba1 #3 [ff61d23de260fc78] blk_freeze_queue at ffffffff82a4113a #4 [ff61d23de260fc90] blk_cleanup_queue at ffffffff82a33006 #5 [ff61d23de260fcb0] nvme_rdma_destroy_admin_queue at ffffffffc12686ce #6 [ff61d23de260fcc8] nvme_rdma_setup_ctrl at ffffffffc1268ced #7 [ff61d23de260fd28] nvme_rdma_create_ctrl at ffffffffc126919b #8 [ff61d23de260fd68] nvmf_dev_write at ffffffffc024f362 #9 [ff61d23de260fe38] vfs_write at ffffffff827d5f25 RIP: 00007fda7891d574  RSP: 00007ffe2ef06958  RFLAGS: 00000202 RAX: ffffffffffffffda  RBX: 000055e8122a4d90  RCX: 00007fda7891d574 RDX: 000000000000012b  RSI: 000055e8122a4d90  RDI: 0000000000000004 RBP: 00007ffe2ef079c0   R8: 000000000000012b   R9: 000055e8122a4d90 R10: 0000000000000000  R11: 0000000000000202  R12: 0000000000000004 R13: 000055e8122923c0  R14: 000000000000012b  R15: 00007fda78a54500 ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b  This due to we have quiesced admi_q before cancel requests, but forgot to unquiesce before destroy it, as a result we fail to drain the pending requests, and hang on blk_mq_freeze_queue_wait() forever. Here try to reuse nvme_rdma_teardown_admin_queue() to fix this issue and simplify the code.",
      "cve": "CVE-2024-49569",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49569",
          "value": "CVE-2024-49569",
          "url": "https://scout.docker.com/v/CVE-2024-49569?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49569?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6558700b6b1dbc5243b6cd2357a4e2ab8490e6b501318c3ddd73119aac1e8341",
      "category": "container_scanning",
      "message": "CVE-2021-3714 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.",
      "cve": "CVE-2021-3714",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3714",
          "value": "CVE-2021-3714",
          "url": "https://scout.docker.com/v/CVE-2021-3714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3714?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b3cc909e18af910f828093a9c8bafd44edb0de78190a27b52687e051e8ddc359",
      "category": "container_scanning",
      "message": "CVE-2025-8869 on pip@22.0.2",
      "description": "### Summary\n\nIn the fallback extraction path for source distributions, `pip` used Pythons `tarfile` module without verifying that symbolic/hard link targets resolve inside the intended extraction directory. A malicious sdist can include links that escape the target directory and overwrite arbitrary files on the invoking host during `pip install`.\n\n### Impact\n\nSuccessful exploitation enables arbitrary file overwrite outside the build/extraction directory on the machine running `pip`. This can be leveraged to tamper with configuration or startup files and may lead to further code execution depending on the environment, but the direct, guaranteed impact is integrity compromise on the vulnerable system.\n\n### Conditions\n\nThe issue is triggered when installing an attacker-controlled sdist (e.g., from an index or URL) and the fallback extraction code path is used. No special privileges are required beyond running `pip install`; active user action is necessary.\n\n### Remediation\n\nThe [fix](https://github.com/pypa/pip/pull/13550) is available starting in pip `25.3`. Using a Python interpreter that implements the safe-extraction behavior described by **PEP 706** provides additional defense in depth for other `tarfile` issues but is not a substitute for upgrading pip for this specific flaw.",
      "cve": "CVE-2025-8869",
      "severity": "Medium",
      "confidence": "Unknown",
      "solution": "Upgrade pip@22.0.2 to 25.3",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/pip@22.0.2"
          },
          "version": "22.0.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-8869",
          "value": "CVE-2025-8869",
          "url": "https://scout.docker.com/v/CVE-2025-8869?s=github&n=pip&t=pypi&vr=%3C%3D25.2"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-8869?s=github&n=pip&t=pypi&vr=%3C%3D25.2"
        }
      ]
    },
    {
      "id": "8d518965c2c901b18db3945ed4042123d9546b4dd6c5b0b57b10085c707f18be",
      "category": "container_scanning",
      "message": "CVE-2020-25664 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "In WriteOnePNGImage() of the PNG coder at coders/png.c, an improper call to AcquireVirtualMemory() and memset() allows for an out-of-bounds write later when PopShortPixel() from MagickCore/quantum-private.h is called. The patch fixes the calls by adding 256 to rowbytes. An attacker who is able to supply a specially crafted image could affect availability with a low impact to data integrity. This flaw affects ImageMagick versions prior to 6.9.10-68 and 7.0.8-68.",
      "cve": "CVE-2020-25664",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2020-25664",
          "value": "CVE-2020-25664",
          "url": "https://scout.docker.com/v/CVE-2020-25664?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2020-25664?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "480b3bb14f8446a088f829a4169a1b8271cd5493d21f230f73007e0e55387857",
      "category": "container_scanning",
      "message": "CVE-2024-40918 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Try to fix random segmentation faults in package builds  PA-RISC systems with PA8800 and PA8900 processors have had problems with random segmentation faults for many years.  Systems with earlier processors are much more stable.  Systems with PA8800 and PA8900 processors have a large L2 cache which needs per page flushing for decent performance when a large range is flushed. The combined cache in these systems is also more sensitive to non-equivalent aliases than the caches in earlier systems.  The majority of random segmentation faults that I have looked at appear to be memory corruption in memory allocated using mmap and malloc.  My first attempt at fixing the random faults didn't work. On reviewing the cache code, I realized that there were two issues which the existing code didn't handle correctly. Both relate to cache move-in. Another issue is that the present bit in PTEs is racy.  1) PA-RISC caches have a mind of their own and they can speculatively load data and instructions for a page as long as there is a entry in the TLB for the page which allows move-in. TLBs are local to each CPU. Thus, the TLB entry for a page must be purged before flushing the page. This is particularly important on SMP systems.  In some of the flush routines, the flush routine would be called and then the TLB entry would be purged. This was because the flush routine needed the TLB entry to do the flush.  2) My initial approach to trying the fix the random faults was to try and use flush_cache_page_if_present for all flush operations. This actually made things worse and led to a couple of hardware lockups. It finally dawned on me that some lines weren't being flushed because the pte check code was racy. This resulted in random inequivalent mappings to physical pages.  The __flush_cache_page tmpalias flush sets up its own TLB entry and it doesn't need the existing TLB entry. As long as we can find the pte pointer for the vm page, we can get the pfn and physical address of the page. We can also purge the TLB entry for the page before doing the flush. Further, __flush_cache_page uses a special TLB entry that inhibits cache move-in.  When switching page mappings, we need to ensure that lines are removed from the cache.  It is not sufficient to just flush the lines to memory as they may come back.  This made it clear that we needed to implement all the required flush operations using tmpalias routines. This includes flushes for user and kernel pages.  After modifying the code to use tmpalias flushes, it became clear that the random segmentation faults were not fully resolved. The frequency of faults was worse on systems with a 64 MB L2 (PA8900) and systems with more CPUs (rp4440).  The warning that I added to flush_cache_page_if_present to detect pages that couldn't be flushed triggered frequently on some systems.  Helge and I looked at the pages that couldn't be flushed and found that the PTE was either cleared or for a swap page. Ignoring pages that were swapped out seemed okay but pages with cleared PTEs seemed problematic.  I looked at routines related to pte_clear and noticed ptep_clear_flush. The default implementation just flushes the TLB entry. However, it was obvious that on parisc we need to flush the cache page as well. If we don't flush the cache page, stale lines will be left in the cache and cause random corruption. Once a PTE is cleared, there is no way to find the physical address associated with the PTE and flush the associated page at a later time.  I implemented an updated change with a parisc specific version of ptep_clear_flush. It fixed the random data corruption on Helge's rp4440 and rp3440, as well as on my c8000.  At this point, I realized that I could restore the code where we only flush in flush_cache_page_if_present if the page has been accessed. However, for this, we also need to flush the cache when the accessed bit is cleared in ---truncated---",
      "cve": "CVE-2024-40918",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40918",
          "value": "CVE-2024-40918",
          "url": "https://scout.docker.com/v/CVE-2024-40918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40918?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "79e585b23dc3ca2fed0b26a0b261b912de129d7148ca41740b26dd694ccb4e06",
      "category": "container_scanning",
      "message": "CVE-2024-57893 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ALSA: seq: oss: Fix races at processing SysEx messages  OSS sequencer handles the SysEx messages split in 6 bytes packets, and ALSA sequencer OSS layer tries to combine those.  It stores the data in the internal buffer and this access is racy as of now, which may lead to the out-of-bounds access.  As a temporary band-aid fix, introduce a mutex for serializing the process of the SysEx message packets.",
      "cve": "CVE-2024-57893",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57893",
          "value": "CVE-2024-57893",
          "url": "https://scout.docker.com/v/CVE-2024-57893?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57893?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a0bf80535ba024c36b5cc025c55aa545564113fb95145cf2f7254f1062c7036c",
      "category": "container_scanning",
      "message": "CVE-2015-8553 on ubuntu/linux@5.15.0-161.171",
      "description": "Xen allows guest OS users to obtain sensitive information from uninitialized locations in host OS kernel memory by not enabling memory and I/O decoding control bits.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-0777.",
      "cve": "CVE-2015-8553",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2015-8553",
          "value": "CVE-2015-8553",
          "url": "https://scout.docker.com/v/CVE-2015-8553?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2015-8553?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f508d94f559eeecb480423129095cb36cc9e043b66d52504944a5285f369d665",
      "category": "container_scanning",
      "message": "CVE-2023-1193 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free flaw was found in setup_async_work in the KSMBD implementation of the in-kernel samba server and CIFS in the Linux kernel. This issue could allow an attacker to crash the system by accessing freed work.",
      "cve": "CVE-2023-1193",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-1193",
          "value": "CVE-2023-1193",
          "url": "https://scout.docker.com/v/CVE-2023-1193?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-1193?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a58fe6e61c055f30999b9450edae49b0cbf12161d97ea93ece33468ffed71d42",
      "category": "container_scanning",
      "message": "CVE-2023-29659 on ubuntu/libheif@1.12.0-2build1",
      "description": "A Segmentation fault caused by a floating point exception exists in libheif 1.15.1 using crafted heif images via the heif::Fraction::round() function in box.cc, which causes a denial of service.",
      "cve": "CVE-2023-29659",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libheif@1.12.0-2build1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.12.0-2build1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-29659",
          "value": "CVE-2023-29659",
          "url": "https://scout.docker.com/v/CVE-2023-29659?s=ubuntu&n=libheif&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-29659?s=ubuntu&n=libheif&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e4018f8b04cc07818516db4ea99310373d2d77343821762287877d061f85f684",
      "category": "container_scanning",
      "message": "CVE-2023-37769 on ubuntu/pixman@0.40.0-1ubuntu0.22.04.1",
      "description": "stress-test master commit e4c878 was discovered to contain a FPE vulnerability via the component combine_inner at /pixman-combine-float.c.",
      "cve": "CVE-2023-37769",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/pixman@0.40.0-1ubuntu0.22.04.1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "0.40.0-1ubuntu0.22.04.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-37769",
          "value": "CVE-2023-37769",
          "url": "https://scout.docker.com/v/CVE-2023-37769?s=ubuntu&n=pixman&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-37769?s=ubuntu&n=pixman&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "04298dbe2106c4a7f4094c94d4a98f21b070903f3c548bc9d2db952d608fcd04",
      "category": "container_scanning",
      "message": "CVE-2019-15794 on ubuntu/linux@5.15.0-161.171",
      "description": "Overlayfs in the Linux kernel and shiftfs, a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series, both replace vma->vm_file in their mmap handlers. On error the original value is not restored, and the reference is put for the file to which vm_file points. On upstream kernels this is not an issue, as no callers dereference vm_file following after call_mmap() returns an error. However, the aufs patchs change mmap_region() to replace the fput() using a local variable with vma_fput(), which will fput() vm_file, leading to a refcount underflow.",
      "cve": "CVE-2019-15794",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2019-15794",
          "value": "CVE-2019-15794",
          "url": "https://scout.docker.com/v/CVE-2019-15794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2019-15794?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0cb1071bbca75a90890a9593f24b2677db7a6c2dc51d6dea8e1f1471e2514da3",
      "category": "container_scanning",
      "message": "CVE-2023-5752 on pip@22.0.2",
      "description": "When installing a package from a Mercurial VCS URL, e.g. `pip install hg+...`, with pip prior to v23.3, the specified Mercurial revision could be used to inject arbitrary configuration options to the `hg clone` call (e.g. `--config`). Controlling the Mercurial configuration can modify how and which repository is installed. This vulnerability does not affect users who aren't installing from Mercurial.",
      "cve": "CVE-2023-5752",
      "severity": "Medium",
      "confidence": "Unknown",
      "solution": "Upgrade pip@22.0.2 to 23.3",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/pip@22.0.2"
          },
          "version": "22.0.2"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-5752",
          "value": "CVE-2023-5752",
          "url": "https://scout.docker.com/v/CVE-2023-5752?s=github&n=pip&t=pypi&vr=%3C23.3"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-5752?s=github&n=pip&t=pypi&vr=%3C23.3"
        }
      ]
    },
    {
      "id": "059bb2d9a08b7c0411e66d89e1ee1f0362ad43289c42959c1631a48ee6ec860d",
      "category": "container_scanning",
      "message": "CVE-2021-3864 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.",
      "cve": "CVE-2021-3864",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3864",
          "value": "CVE-2021-3864",
          "url": "https://scout.docker.com/v/CVE-2021-3864?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3864?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c069bc68b2f261e30a8d9c0b6822d85e6090cbfb72188d1c405f9ebbbb60dafb",
      "category": "container_scanning",
      "message": "CVE-2022-1247 on ubuntu/linux@5.15.0-161.171",
      "description": "An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh->use to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their count and use are zero.",
      "cve": "CVE-2022-1247",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-1247",
          "value": "CVE-2022-1247",
          "url": "https://scout.docker.com/v/CVE-2022-1247?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-1247?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d0599d259382a67694551b3daf2eb31835d772db8c4ea8c5af6db2c41e5ff7ed",
      "category": "container_scanning",
      "message": "CVE-2022-2961 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free flaw was found in the Linux kernels PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "cve": "CVE-2022-2961",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-2961",
          "value": "CVE-2022-2961",
          "url": "https://scout.docker.com/v/CVE-2022-2961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-2961?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9c87ff4405ae756c0ed1128c0786332b0b2bdd471dab745a927c397e81fc043c",
      "category": "container_scanning",
      "message": "CVE-2023-52586 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/msm/dpu: Add mutex lock in control vblank irq  Add a mutex lock to control vblank irq to synchronize vblank enable/disable operations happening from different threads to prevent race conditions while registering/unregistering the vblank irq callback.  v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a parameter of dpu_encoder_phys. -Switch from atomic refcnt to a simple int counter as mutex has now been added v3: Mistakenly did not change wording in last version. It is done now. v2: Slightly changed wording of commit message  Patchwork: https://patchwork.freedesktop.org/patch/571854/",
      "cve": "CVE-2023-52586",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52586",
          "value": "CVE-2023-52586",
          "url": "https://scout.docker.com/v/CVE-2023-52586?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52586?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "416dd7e6a6aeb50a42bacec159002d9981d40d8a71cc7793f91a48fe35b1527a",
      "category": "container_scanning",
      "message": "CVE-2024-49855 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nbd: fix race between timeout and normal completion  If request timetout is handled by nbd_requeue_cmd(), normal completion has to be stopped for avoiding to complete this requeued request, other use-after-free can be triggered.  Fix the race by clearing NBD_CMD_INFLIGHT in nbd_requeue_cmd(), meantime make sure that cmd->lock is grabbed for clearing the flag and the requeue.",
      "cve": "CVE-2024-49855",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49855",
          "value": "CVE-2024-49855",
          "url": "https://scout.docker.com/v/CVE-2024-49855?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49855?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "aab8beb12cf976894ed20cf9c0a0920c20e3caead96f2708734f38b6ff5445d2",
      "category": "container_scanning",
      "message": "CVE-2024-50106 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nfsd: fix race between laundromat and free_stateid  There is a race between laundromat handling of revoked delegations and a client sending free_stateid operation. Laundromat thread finds that delegation has expired and needs to be revoked so it marks the delegation stid revoked and it puts it on a reaper list but then it unlock the state lock and the actual delegation revocation happens without the lock. Once the stid is marked revoked a racing free_stateid processing thread does the following (1) it calls list_del_init() which removes it from the reaper list and (2) frees the delegation stid structure. The laundromat thread ends up not calling the revoke_delegation() function for this particular delegation but that means it will no release the lock lease that exists on the file.  Now, a new open for this file comes in and ends up finding that lease list isn't empty and calls nfsd_breaker_owns_lease() which ends up trying to derefence a freed delegation stateid. Leading to the followint use-after-free KASAN warning:  kernel: ================================================================== kernel: BUG: KASAN: slab-use-after-free in nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205 kernel: kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9 kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024 kernel: Call trace: kernel: dump_backtrace+0x98/0x120 kernel: show_stack+0x1c/0x30 kernel: dump_stack_lvl+0x80/0xe8 kernel: print_address_description.constprop.0+0x84/0x390 kernel: print_report+0xa4/0x268 kernel: kasan_report+0xb4/0xf8 kernel: __asan_report_load8_noabort+0x1c/0x28 kernel: nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: nfsd_file_do_acquire+0xb3c/0x11d0 [nfsd] kernel: nfsd_file_acquire_opened+0x84/0x110 [nfsd] kernel: nfs4_get_vfs_file+0x634/0x958 [nfsd] kernel: nfsd4_process_open2+0xa40/0x1a40 [nfsd] kernel: nfsd4_open+0xa08/0xe80 [nfsd] kernel: nfsd4_proc_compound+0xb8c/0x2130 [nfsd] kernel: nfsd_dispatch+0x22c/0x718 [nfsd] kernel: svc_process_common+0x8e8/0x1960 [sunrpc] kernel: svc_process+0x3d4/0x7e0 [sunrpc] kernel: svc_handle_xprt+0x828/0xe10 [sunrpc] kernel: svc_recv+0x2cc/0x6a8 [sunrpc] kernel: nfsd+0x270/0x400 [nfsd] kernel: kthread+0x288/0x310 kernel: ret_from_fork+0x10/0x20  This patch proposes a fixed that's based on adding 2 new additional stid's sc_status values that help coordinate between the laundromat and other operations (nfsd4_free_stateid() and nfsd4_delegreturn()).  First to make sure, that once the stid is marked revoked, it is not removed by the nfsd4_free_stateid(), the laundromat take a reference on the stateid. Then, coordinating whether the stid has been put on the cl_revoked list or we are processing FREE_STATEID and need to make sure to remove it from the list, each check that state and act accordingly. If laundromat has added to the cl_revoke list before the arrival of FREE_STATEID, then nfsd4_free_stateid() knows to remove it from the list. If nfsd4_free_stateid() finds that operations arrived before laundromat has placed it on cl_revoke list, it marks the state freed and then laundromat will no longer add it to the list.  Also, for nfsd4_delegreturn() when looking for the specified stid, we need to access stid that are marked removed or freeable, it means the laundromat has started processing it but hasn't finished and this delegreturn needs to return nfserr_deleg_revoked and not nfserr_bad_stateid. The latter will not trigger a FREE_STATEID and the lack of it will leave this stid on the cl_revoked list indefinitely.",
      "cve": "CVE-2024-50106",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50106",
          "value": "CVE-2024-50106",
          "url": "https://scout.docker.com/v/CVE-2024-50106?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50106?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "17e64d9bee3a56b7f2639fa70252f18f7e63ab7c51fc92577135a235b9eb0424",
      "category": "container_scanning",
      "message": "CVE-2024-50286 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix slab-use-after-free in ksmbd_smb2_session_create  There is a race condition between ksmbd_smb2_session_create and ksmbd_expire_session. This patch add missing sessions_table_lock while adding/deleting session from global session table.",
      "cve": "CVE-2024-50286",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50286",
          "value": "CVE-2024-50286",
          "url": "https://scout.docker.com/v/CVE-2024-50286?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50286?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "41790132a7a2987c18274ee2825a103cb8bea167b7462cd33c7d6b0ebcc0d5d5",
      "category": "container_scanning",
      "message": "CVE-2024-57876 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/dp_mst: Fix resetting msg rx state after topology removal  If the MST topology is removed during the reception of an MST down reply or MST up request sideband message, the drm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be reset from one thread via drm_dp_mst_topology_mgr_set_mst(false), racing with the reading/parsing of the message from another thread via drm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race is possible since the reader/parser doesn't hold any lock while accessing the reception state. This in turn can lead to a memory corruption in the reader/parser as described by commit bd2fccac61b4 (\"drm/dp_mst: Fix MST sideband message body length check\").  Fix the above by resetting the message reception state if needed before reading/parsing a message. Another solution would be to hold the drm_dp_mst_topology_mgr::lock for the whole duration of the message reception/parsing in drm_dp_mst_handle_down_rep() and drm_dp_mst_handle_up_req(), however this would require a bigger change. Since the fix is also needed for stable, opting for the simpler solution in this patch.",
      "cve": "CVE-2024-57876",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57876",
          "value": "CVE-2024-57876",
          "url": "https://scout.docker.com/v/CVE-2024-57876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57876?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e17f2043c47402b042c89a77fb2ac031207abc08176eee3bac64db2a3a1bf900",
      "category": "container_scanning",
      "message": "CVE-2022-1114 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A heap-use-after-free flaw was found in ImageMagick's RelinquishDCMInfo() function of dcm.c file. This vulnerability is triggered when an attacker passes a specially crafted DICOM image file to ImageMagick for conversion, potentially leading to information disclosure and a denial of service.",
      "cve": "CVE-2022-1114",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-1114",
          "value": "CVE-2022-1114",
          "url": "https://scout.docker.com/v/CVE-2022-1114?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-1114?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0c87a17afbd998bcf7ea609ca066c47cf658683e40ae20913116a235245ac25d",
      "category": "container_scanning",
      "message": "CVE-2022-49172 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  parisc: Fix non-access data TLB cache flush faults  When a page is not present, we get non-access data TLB faults from the fdc and fic instructions in flush_user_dcache_range_asm and flush_user_icache_range_asm. When these occur, the cache line is not invalidated and potentially we get memory corruption. The problem was hidden by the nullification of the flush instructions.  These faults also affect performance. With pa8800/pa8900 processors, there will be 32 faults per 4 KB page since the cache line is 128 bytes.  There will be more faults with earlier processors.  The problem is fixed by using flush_cache_pages(). It does the flush using a tmp alias mapping.  The flush_cache_pages() call in flush_cache_range() flushed too large a range.  V2: Remove unnecessary preempt_disable() and preempt_enable() calls.",
      "cve": "CVE-2022-49172",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49172",
          "value": "CVE-2022-49172",
          "url": "https://scout.docker.com/v/CVE-2022-49172?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49172?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7a0b04cad94867a596a1b180f089f595137e403803d9a5436ca9f623dcf3d349",
      "category": "container_scanning",
      "message": "CVE-2022-49218 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/dp: Fix OOB read when handling Post Cursor2 register  The link_status array was not large enough to read the Adjust Request Post Cursor2 register, so remove the common helper function to avoid an OOB read, found with a -Warray-bounds build:  drivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_get_adjust_request_post_cursor': drivers/gpu/drm/drm_dp_helper.c:59:27: error: array subscript 10 is outside array bounds of 'const u8[6]' {aka 'const unsigned char[6]'} [-Werror=array-bounds] 59 |         return link_status[r - DP_LANE0_1_STATUS]; |                ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~ drivers/gpu/drm/drm_dp_helper.c:147:51: note: while referencing 'link_status' 147 | u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE], | ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Replace the only user of the helper with an open-coded fetch and decode, similar to drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c.",
      "cve": "CVE-2022-49218",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49218",
          "value": "CVE-2022-49218",
          "url": "https://scout.docker.com/v/CVE-2022-49218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49218?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "08a8b083206cd0b46c6d1689f7e66264825f083496997ba894429a3db854914e",
      "category": "container_scanning",
      "message": "CVE-2022-49234 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: dsa: Avoid cross-chip syncing of VLAN filtering  Changes to VLAN filtering are not applicable to cross-chip notifications.  On a system like this:  .-----.   .-----.   .-----. | sw1 +---+ sw2 +---+ sw3 | '-1-2-'   '-1-2-'   '-1-2-'  Before this change, upon sw1p1 leaving a bridge, a call to dsa_port_vlan_filtering would also be made to sw2p1 and sw3p1.  In this scenario:  .---------.   .-----.   .-----. |   sw1   +---+ sw2 +---+ sw3 | '-1-2-3-4-'   '-1-2-'   '-1-2-'  When sw1p4 would leave a bridge, dsa_port_vlan_filtering would be called for sw2 and sw3 with a non-existing port - leading to array out-of-bounds accesses and crashes on mv88e6xxx.",
      "cve": "CVE-2022-49234",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49234",
          "value": "CVE-2022-49234",
          "url": "https://scout.docker.com/v/CVE-2022-49234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49234?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "245b6f4d1bb17991ec1b7f7c7b66161cf044f3c8953c2e837f7a3668e79aa56b",
      "category": "container_scanning",
      "message": "CVE-2022-49401 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm/page_owner: use strscpy() instead of strlcpy()  current->comm[] is not a string (no guarantee for a zero byte in it).  strlcpy(s1, s2, l) is calling strlen(s2), potentially causing out-of-bound access, as reported by syzbot:  detected buffer overflow in __fortify_strlen ------------[ cut here ]------------ kernel BUG at lib/string_helpers.c:980! invalid opcode: 0000 [#1] PREEMPT SMP KASAN CPU: 0 PID: 4087 Comm: dhcpcd-run-hooks Not tainted 5.18.0-rc3-syzkaller-01537-g20b87e7c29df #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 RIP: 0010:fortify_panic+0x18/0x1a lib/string_helpers.c:980 Code: 8c e8 c5 ba e1 fa e9 23 0f bf fa e8 0b 5d 8c f8 eb db 55 48 89 fd e8 e0 49 40 f8 48 89 ee 48 c7 c7 80 f5 26 8a e8 99 09 f1 ff <0f> 0b e8 ca 49 40 f8 48 8b 54 24 18 4c 89 f1 48 c7 c7 00 00 27 8a RSP: 0018:ffffc900000074a8 EFLAGS: 00010286  RAX: 000000000000002c RBX: ffff88801226b728 RCX: 0000000000000000 RDX: ffff8880198e0000 RSI: ffffffff81600458 RDI: fffff52000000e87 RBP: ffffffff89da2aa0 R08: 000000000000002c R09: 0000000000000000 R10: ffffffff815fae2e R11: 0000000000000000 R12: ffff88801226b700 R13: ffff8880198e0830 R14: 0000000000000000 R15: 0000000000000000 FS:  0000000000000000(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5876ad6ff8 CR3: 000000001a48c000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600 Call Trace: <IRQ> __fortify_strlen include/linux/fortify-string.h:128 [inline] strlcpy include/linux/fortify-string.h:143 [inline] __set_page_owner_handle+0x2b1/0x3e0 mm/page_owner.c:171 __set_page_owner+0x3e/0x50 mm/page_owner.c:190 prep_new_page mm/page_alloc.c:2441 [inline] get_page_from_freelist+0xba2/0x3e00 mm/page_alloc.c:4182 __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5408 alloc_pages+0x1aa/0x310 mm/mempolicy.c:2272 alloc_slab_page mm/slub.c:1799 [inline] allocate_slab+0x26c/0x3c0 mm/slub.c:1944 new_slab mm/slub.c:2004 [inline] ___slab_alloc+0x8df/0xf20 mm/slub.c:3005 __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3092 slab_alloc_node mm/slub.c:3183 [inline] slab_alloc mm/slub.c:3225 [inline] __kmem_cache_alloc_lru mm/slub.c:3232 [inline] kmem_cache_alloc+0x360/0x3b0 mm/slub.c:3242 dst_alloc+0x146/0x1f0 net/core/dst.c:92",
      "cve": "CVE-2022-49401",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49401",
          "value": "CVE-2022-49401",
          "url": "https://scout.docker.com/v/CVE-2022-49401?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49401?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1856c4bee4ae551340138dad569d010ec8fd6b7d709afe34411ad390a7d77db6",
      "category": "container_scanning",
      "message": "CVE-2022-49518 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: SOF: ipc3-topology: Correct get_control_data for non bytes payload  It is possible to craft a topology where sof_get_control_data() would do out of bounds access because it expects that it is only called when the payload is bytes type. Confusingly it also handles other types of controls, but the payload parsing implementation is only valid for bytes.  Fix the code to count the non bytes controls and instead of storing a pointer to sof_abi_hdr in sof_widget_data (which is only valid for bytes), store the pointer to the data itself and add a new member to save the size of the data.  In case of non bytes controls we store the pointer to the chanv itself, which is just an array of values at the end.  In case of bytes control, drop the wrong cdata->data (wdata[i].pdata) check against NULL since it is incorrect and invalid in this context. The data is pointing to the end of cdata struct, so it should never be null.",
      "cve": "CVE-2022-49518",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49518",
          "value": "CVE-2022-49518",
          "url": "https://scout.docker.com/v/CVE-2022-49518?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49518?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "503a4ef2c229614f154d020ff2f68cdfdd62d386f6e181601fa61f0b6a68b859",
      "category": "container_scanning",
      "message": "CVE-2023-52682 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to wait on block writeback for post_read case  If inode is compressed, but not encrypted, it missed to call f2fs_wait_on_block_writeback() to wait for GCed page writeback in IPU write path.  Thread A\t\t\t\tGC-Thread - f2fs_gc - do_garbage_collect - gc_data_segment - move_data_block - f2fs_submit_page_write migrate normal cluster's block via meta_inode's page cache - f2fs_write_single_data_page - f2fs_do_write_data_page - f2fs_inplace_write_data - f2fs_submit_page_bio  IRQ - f2fs_read_end_io IRQ old data overrides new data due to out-of-order GC and common IO. - f2fs_read_end_io",
      "cve": "CVE-2023-52682",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52682",
          "value": "CVE-2023-52682",
          "url": "https://scout.docker.com/v/CVE-2023-52682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52682?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eb2af885acb8c7225bfacaa024152d206f0a9f24478e10f61c3b486c8fc96dc5",
      "category": "container_scanning",
      "message": "CVE-2023-52701 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: use a bounce buffer for copying skb->mark  syzbot found arm64 builds would crash in sock_recv_mark() when CONFIG_HARDENED_USERCOPY=y  x86 and powerpc are not detecting the issue because they define user_access_begin. This will be handled in a different patch, because a check_object_size() is missing.  Only data from skb->cb[] can be copied directly to/from user space, as explained in commit 79a8a642bf05 (\"net: Whitelist the skbuff_head_cache \"cb\" field\")  syzbot report was: usercopy: Kernel memory exposure attempt detected from SLUB object 'skbuff_head_cache' (offset 168, size 4)! ------------[ cut here ]------------ kernel BUG at mm/usercopy.c:102 ! Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP Modules linked in: CPU: 0 PID: 4410 Comm: syz-executor533 Not tainted 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : usercopy_abort+0x90/0x94 mm/usercopy.c:90 lr : usercopy_abort+0x90/0x94 mm/usercopy.c:90 sp : ffff80000fb9b9a0 x29: ffff80000fb9b9b0 x28: ffff0000c6073400 x27: 0000000020001a00 x26: 0000000000000014 x25: ffff80000cf52000 x24: fffffc0000000000 x23: 05ffc00000000200 x22: fffffc000324bf80 x21: ffff0000c92fe1a8 x20: 0000000000000001 x19: 0000000000000004 x18: 0000000000000000 x17: 656a626f2042554c x16: ffff0000c6073dd0 x15: ffff80000dbd2118 x14: ffff0000c6073400 x13: 00000000ffffffff x12: ffff0000c6073400 x11: ff808000081bbb4c x10: 0000000000000000 x9 : 7b0572d7cc0ccf00 x8 : 7b0572d7cc0ccf00 x7 : ffff80000bf650d4 x6 : 0000000000000000 x5 : 0000000000000001 x4 : 0000000000000001 x3 : 0000000000000000 x2 : ffff0001fefbff08 x1 : 0000000100000000 x0 : 000000000000006c Call trace: usercopy_abort+0x90/0x94 mm/usercopy.c:90 __check_heap_object+0xa8/0x100 mm/slub.c:4761 check_heap_object mm/usercopy.c:196 [inline] __check_object_size+0x208/0x6b8 mm/usercopy.c:251 check_object_size include/linux/thread_info.h:199 [inline] __copy_to_user include/linux/uaccess.h:115 [inline] put_cmsg+0x408/0x464 net/core/scm.c:238 sock_recv_mark net/socket.c:975 [inline] __sock_recv_cmsgs+0x1fc/0x248 net/socket.c:984 sock_recv_cmsgs include/net/sock.h:2728 [inline] packet_recvmsg+0x2d8/0x678 net/packet/af_packet.c:3482 ____sys_recvmsg+0x110/0x3a0 ___sys_recvmsg net/socket.c:2737 [inline] __sys_recvmsg+0x194/0x210 net/socket.c:2767 __do_sys_recvmsg net/socket.c:2777 [inline] __se_sys_recvmsg net/socket.c:2774 [inline] __arm64_sys_recvmsg+0x2c/0x3c net/socket.c:2774 __invoke_syscall arch/arm64/kernel/syscall.c:38 [inline] invoke_syscall+0x64/0x178 arch/arm64/kernel/syscall.c:52 el0_svc_common+0xbc/0x180 arch/arm64/kernel/syscall.c:142 do_el0_svc+0x48/0x110 arch/arm64/kernel/syscall.c:193 el0_svc+0x58/0x14c arch/arm64/kernel/entry-common.c:637 el0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591 Code: 91388800 aa0903e1 f90003e8 94e6d752 (d4210000)",
      "cve": "CVE-2023-52701",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52701",
          "value": "CVE-2023-52701",
          "url": "https://scout.docker.com/v/CVE-2023-52701?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52701?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "52f4e3d40ef71875a26455747a379e3d67eb5251588b3cc7fa0292eebcffd1a5",
      "category": "container_scanning",
      "message": "CVE-2023-6610 on ubuntu/linux@5.15.0-161.171",
      "description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
      "cve": "CVE-2023-6610",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-6610",
          "value": "CVE-2023-6610",
          "url": "https://scout.docker.com/v/CVE-2023-6610?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-6610?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "195343325792be035bbc0d10972fa8cbd5aab7d89d833a0e439c9062a94cf67b",
      "category": "container_scanning",
      "message": "CVE-2024-26954 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix slab-out-of-bounds in smb_strndup_from_utf16()  If ->NameOffset of smb2_create_req is smaller than Buffer offset of smb2_create_req, slab-out-of-bounds read can happen from smb2_open. This patch set the minimum value of the name offset to the buffer offset to validate name length of smb2_create_req().",
      "cve": "CVE-2024-26954",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26954",
          "value": "CVE-2024-26954",
          "url": "https://scout.docker.com/v/CVE-2024-26954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7f6e5bdfb2f78048c5f3067c01fcc7fe47ecf223c6bb8b1a448a6569ab1e44d8",
      "category": "container_scanning",
      "message": "CVE-2024-35937 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: cfg80211: check A-MSDU format more carefully  If it looks like there's another subframe in the A-MSDU but the header isn't fully there, we can end up reading data out of bounds, only to discard later. Make this a bit more careful and check if the subframe header can even be present.",
      "cve": "CVE-2024-35937",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35937",
          "value": "CVE-2024-35937",
          "url": "https://scout.docker.com/v/CVE-2024-35937?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35937?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1444be3d20a7281c7b2766fd7b093ef29fb05897236c725bad89ef7f6ff9658a",
      "category": "container_scanning",
      "message": "CVE-2024-35939 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  dma-direct: Leak pages on dma_set_decrypted() failure  On TDX it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues.  DMA could free decrypted/shared pages if dma_set_decrypted() fails. This should be a rare case. Just leak the pages in this case instead of freeing them.",
      "cve": "CVE-2024-35939",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35939",
          "value": "CVE-2024-35939",
          "url": "https://scout.docker.com/v/CVE-2024-35939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35939?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9f84786ca4ec01823c5f9f58c26a628b3378c5d7224c211e3ed788771f2c5786",
      "category": "container_scanning",
      "message": "CVE-2024-36915 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nfc: llcp: fix nfc_llcp_setsockopt() unsafe copies  syzbot reported unsafe calls to copy_from_sockptr() [1]  Use copy_safe_from_sockptr() instead.  [1]  BUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline] BUG: KASAN: slab-out-of-bounds in nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255 Read of size 4 at addr ffff88801caa1ec3 by task syz-executor459/5078  CPU: 0 PID: 5078 Comm: syz-executor459 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 copy_from_sockptr_offset include/linux/sockptr.h:49 [inline] copy_from_sockptr include/linux/sockptr.h:55 [inline] nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255 do_sock_setsockopt+0x3b1/0x720 net/socket.c:2311 __sys_setsockopt+0x1ae/0x250 net/socket.c:2334 __do_sys_setsockopt net/socket.c:2343 [inline] __se_sys_setsockopt net/socket.c:2340 [inline] __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340 do_syscall_64+0xfd/0x240 entry_SYSCALL_64_after_hwframe+0x6d/0x75 RIP: 0033:0x7f7fac07fd89 Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 91 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007fff660eb788 EFLAGS: 00000246 ORIG_RAX: 0000000000000036 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f7fac07fd89 RDX: 0000000000000000 RSI: 0000000000000118 RDI: 0000000000000004 RBP: 0000000000000000 R08: 0000000000000002 R09: 0000000000000000 R10: 0000000020000a80 R11: 0000000000000246 R12: 0000000000000000 R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000",
      "cve": "CVE-2024-36915",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36915",
          "value": "CVE-2024-36915",
          "url": "https://scout.docker.com/v/CVE-2024-36915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6c024b0120c59acef6c66a66510e02523329b362bb49f76c3b0d54208c2347c0",
      "category": "container_scanning",
      "message": "CVE-2024-41013 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xfs: don't walk off the end of a directory data block  This adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entry to make sure don't stray beyond valid memory region. Before patching, the loop simply checks that the start offset of the dup and dep is within the range. So in a crafted image, if last entry is xfs_dir2_data_unused, we can change dup->length to dup->length-1 and leave 1 byte of space. In the next traversal, this space will be considered as dup or dep. We may encounter an out of bound read when accessing the fixed members.  In the patch, we make sure that the remaining bytes large enough to hold an unused entry before accessing xfs_dir2_data_unused and xfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also make sure that the remaining bytes large enough to hold a dirent with a single-byte name before accessing xfs_dir2_data_entry.",
      "cve": "CVE-2024-41013",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41013",
          "value": "CVE-2024-41013",
          "url": "https://scout.docker.com/v/CVE-2024-41013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41013?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc695da19145edaecf48c57f133e4801e1b3f1aeb1f9f0bcd41f0ade076f709a",
      "category": "container_scanning",
      "message": "CVE-2024-41014 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xfs: add bounds checking to xlog_recover_process_data  There is a lack of verification of the space occupied by fixed members of xlog_op_header in the xlog_recover_process_data.  We can create a crafted image to trigger an out of bounds read by following these steps: 1) Mount an image of xfs, and do some file operations to leave records 2) Before umounting, copy the image for subsequent steps to simulate abnormal exit. Because umount will ensure that tail_blk and head_blk are the same, which will result in the inability to enter xlog_recover_process_data 3) Write a tool to parse and modify the copied image in step 2 4) Make the end of the xlog_op_header entries only 1 byte away from xlog_rec_header->h_size 5) xlog_rec_header->h_num_logops++ 6) Modify xlog_rec_header->h_crc  Fix: Add a check to make sure there is sufficient space to access fixed members of xlog_op_header.",
      "cve": "CVE-2024-41014",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41014",
          "value": "CVE-2024-41014",
          "url": "https://scout.docker.com/v/CVE-2024-41014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41014?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3c7439731b57bf5477578e4a53c25d58e5a589f0b96cfc7e88a09d3f7fdf2aa3",
      "category": "container_scanning",
      "message": "CVE-2024-41935 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  f2fs: fix to shrink read extent node in batches  We use rwlock to protect core structure data of extent tree during its shrink, however, if there is a huge number of extent nodes in extent tree, during shrink of extent tree, it may hold rwlock for a very long time, which may trigger kernel hang issue.  This patch fixes to shrink read extent node in batches, so that, critical region of the rwlock can be shrunk to avoid its extreme long time hold.",
      "cve": "CVE-2024-41935",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41935",
          "value": "CVE-2024-41935",
          "url": "https://scout.docker.com/v/CVE-2024-41935?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41935?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6f596964f1eb397c1ddb5b3586c9ef8acda48ba75a302624a0bab43bf16573e3",
      "category": "container_scanning",
      "message": "CVE-2024-49861 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix helper writes to read-only maps  Lonial found an issue that despite user- and BPF-side frozen BPF map (like in case of .rodata), it was still possible to write into it from a BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT} as arguments.  In check_func_arg() when the argument is as mentioned, the meta->raw_mode is never set. Later, check_helper_mem_access(), under the case of PTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the subsequent call to check_map_access_type() and given the BPF map is read-only it succeeds.  The helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT when results are written into them as opposed to read out of them. The latter indicates that it's okay to pass a pointer to uninitialized memory as the memory is written to anyway.  However, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM just with additional alignment requirement. So it is better to just get rid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the fixed size memory types. For this, add MEM_ALIGNED to additionally ensure alignment given these helpers write directly into the args via *<ptr> = val. The .arg*_size has been initialized reflecting the actual sizeof(*<ptr>).  MEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated argument types, since in !MEM_FIXED_SIZE cases the verifier does not know the buffer size a priori and therefore cannot blindly write *<ptr> = val.",
      "cve": "CVE-2024-49861",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49861",
          "value": "CVE-2024-49861",
          "url": "https://scout.docker.com/v/CVE-2024-49861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "953cfe12b62746d309e01ad83968bc64189a6624aca552de4342093992ceeef3",
      "category": "container_scanning",
      "message": "CVE-2024-49928 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: avoid reading out of bounds when loading TX power FW elements  Because the loop-expression will do one more time before getting false from cond-expression, the original code copied one more entry size beyond valid region.  Fix it by moving the entry copy to loop-body.",
      "cve": "CVE-2024-49928",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49928",
          "value": "CVE-2024-49928",
          "url": "https://scout.docker.com/v/CVE-2024-49928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49928?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "776bf563828a1838a5516f94462b0561c694774ff06d713baa66ff6c69d2f808",
      "category": "container_scanning",
      "message": "CVE-2024-50164 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix overloading of MEM_UNINIT's meaning  Lonial reported an issue in the BPF verifier where check_mem_size_reg() has the following code:  if (!tnum_is_const(reg->var_off)) /* For unprivileged variable accesses, disable raw * mode so that the program is required to * initialize all the memory that the helper could * just partially fill up. */ meta = NULL;  This means that writes are not checked when the register containing the size of the passed buffer has not a fixed size. Through this bug, a BPF program can write to a map which is marked as read-only, for example, .rodata global maps.  The problem is that MEM_UNINIT's initial meaning that \"the passed buffer to the BPF helper does not need to be initialized\" which was added back in commit 435faee1aae9 (\"bpf, verifier: add ARG_PTR_TO_RAW_STACK type\") got overloaded over time with \"the passed buffer is being written to\".  The problem however is that checks such as the above which were added later via 06c1c049721a (\"bpf: allow helpers access to variable memory\") set meta to NULL in order force the user to always initialize the passed buffer to the helper. Due to the current double meaning of MEM_UNINIT, this bypasses verifier write checks to the memory (not boundary checks though) and only assumes the latter memory is read instead.  Fix this by reverting MEM_UNINIT back to its original meaning, and having MEM_WRITE as an annotation to BPF helpers in order to then trigger the BPF verifier checks for writing to memory.  Some notes: check_arg_pair_ok() ensures that for ARG_CONST_SIZE{,_OR_ZERO} we can access fn->arg_type[arg - 1] since it must contain a preceding ARG_PTR_TO_MEM. For check_mem_reg() the meta argument can be removed altogether since we do check both BPF_READ and BPF_WRITE. Same for the equivalent check_kfunc_mem_size_reg().",
      "cve": "CVE-2024-50164",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50164",
          "value": "CVE-2024-50164",
          "url": "https://scout.docker.com/v/CVE-2024-50164?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50164?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bdc74ff6898b88eb51f54190eee1d284acc23669cd8cdf1257c9b71729a25103",
      "category": "container_scanning",
      "message": "CVE-2024-53147 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  exfat: fix out-of-bounds access of directory entries  In the case of the directory size is greater than or equal to the cluster size, if start_clu becomes an EOF cluster(an invalid cluster) due to file system corruption, then the directory entry where ei->hint_femp.eidx hint is outside the directory, resulting in an out-of-bounds access, which may cause further file system corruption.  This commit adds a check for start_clu, if it is an invalid cluster, the file or directory will be treated as empty.",
      "cve": "CVE-2024-53147",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53147",
          "value": "CVE-2024-53147",
          "url": "https://scout.docker.com/v/CVE-2024-53147?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53147?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fb45b667604401dabfc8fb43956926e9f1ad7ac59324f6208bc3fb431be0fcb0",
      "category": "container_scanning",
      "message": "CVE-2024-57945 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  riscv: mm: Fix the out of bound issue of vmemmap address  In sparse vmemmap model, the virtual address of vmemmap is calculated as: ((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT)). And the struct page's va can be calculated with an offset: (vmemmap + (pfn)).  However, when initializing struct pages, kernel actually starts from the first page from the same section that phys_ram_base belongs to. If the first page's physical address is not (phys_ram_base >> PAGE_SHIFT), then we get an va below VMEMMAP_START when calculating va for it's struct page.  For example, if phys_ram_base starts from 0x82000000 with pfn 0x82000, the first page in the same section is actually pfn 0x80000. During init_unavailable_range(), we will initialize struct page for pfn 0x80000 with virtual address ((struct page *)VMEMMAP_START - 0x2000), which is below VMEMMAP_START as well as PCI_IO_END.  This commit fixes this bug by introducing a new variable 'vmemmap_start_pfn' which is aligned with memory section size and using it to calculate vmemmap address instead of phys_ram_base.",
      "cve": "CVE-2024-57945",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57945",
          "value": "CVE-2024-57945",
          "url": "https://scout.docker.com/v/CVE-2024-57945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "717e4952ec24e391d281047c2afe6435f76aaa3b985c9db09d7c9dc97da4d433",
      "category": "container_scanning",
      "message": "CVE-2024-57982 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  xfrm: state: fix out-of-bounds read during lookup  lookup and resize can run in parallel.  The xfrm_state_hash_generation seqlock ensures a retry, but the hash functions can observe a hmask value that is too large for the new hlist array.  rehash does: rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..] net->xfrm.state_hmask = nhashmask;  While state lookup does: h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family); hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) {  This is only safe in case the update to state_bydst is larger than net->xfrm.xfrm_state_hmask (or if the lookup function gets serialized via state spinlock again).  Fix this by prefetching state_hmask and the associated pointers. The xfrm_state_hash_generation seqlock retry will ensure that the pointer and the hmask will be consistent.  The existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side, add lockdep assertions to document that they are only safe for insert side.  xfrm_state_lookup_byaddr() uses the spinlock rather than RCU. AFAICS this is an oversight from back when state lookup was converted to RCU, this lock should be replaced with RCU in a future patch.",
      "cve": "CVE-2024-57982",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57982",
          "value": "CVE-2024-57982",
          "url": "https://scout.docker.com/v/CVE-2024-57982?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57982?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fd3bc1c416ea41642ad8535318220dc9653f68d0aab0dfe7d803f3776902c39a",
      "category": "container_scanning",
      "message": "CVE-2024-58015 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: Fix for out-of bound access error  Selfgen stats are placed in a buffer using print_array_to_buf_index() function. Array length parameter passed to the function is too big, resulting in possible out-of bound memory error. Decreasing buffer size by one fixes faulty upper bound of passed array.  Discovered in coverity scan, CID 1600742 and CID 1600758",
      "cve": "CVE-2024-58015",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-58015",
          "value": "CVE-2024-58015",
          "url": "https://scout.docker.com/v/CVE-2024-58015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-58015?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "61efdc1e6580e8706ec22170a82e945223f4d51ed114cdb4e992baf1e0ab81bd",
      "category": "container_scanning",
      "message": "CVE-2025-22038 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: validate zero num_subauth before sub_auth is accessed  Access psid->sub_auth[psid->num_subauth - 1] without checking if num_subauth is non-zero leads to an out-of-bounds read. This patch adds a validation step to ensure num_subauth != 0 before sub_auth is accessed.",
      "cve": "CVE-2025-22038",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-22038",
          "value": "CVE-2025-22038",
          "url": "https://scout.docker.com/v/CVE-2025-22038?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-22038?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e61e60e7eaac85ea0cd201e1307cc5ef7b6eea5374f4c9fb9b2f90b5ee49aad6",
      "category": "container_scanning",
      "message": "CVE-2021-3610 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A heap-based buffer overflow vulnerability was found in ImageMagick in versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an incorrect setting of the pixel array size, which can lead to a crash and segmentation fault.",
      "cve": "CVE-2021-3610",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-3610",
          "value": "CVE-2021-3610",
          "url": "https://scout.docker.com/v/CVE-2021-3610?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-3610?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d8afd15aaed56dcb5dd0e0f657da1e474d69c26eb19ffba56986a936aad60fd8",
      "category": "container_scanning",
      "message": "CVE-2021-40211 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "An issue was discovered with ImageMagick 7.1.0-4 via Division by zero in function ReadEnhMetaFile of coders/emf.c.",
      "cve": "CVE-2021-40211",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2021-40211",
          "value": "CVE-2021-40211",
          "url": "https://scout.docker.com/v/CVE-2021-40211?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2021-40211?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4613067995fdf04dd4f87045f05917127fc64af1c9bcbc9fffc416bac61d7625",
      "category": "container_scanning",
      "message": "CVE-2022-0400 on ubuntu/linux@5.15.0-161.171",
      "description": "An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.",
      "cve": "CVE-2022-0400",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-0400",
          "value": "CVE-2022-0400",
          "url": "https://scout.docker.com/v/CVE-2022-0400?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-0400?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ebeb45046f3f5155801dbbd88bfa87bd205c29e59c66eb9464428d9f78d32e90",
      "category": "container_scanning",
      "message": "CVE-2022-25836 on ubuntu/linux@5.15.0-161.171",
      "description": "Bluetooth Low Energy Pairing in Bluetooth Core Specification v4.0 through v5.3 may permit an unauthenticated MITM to acquire credentials with two pairing devices via adjacent access when the MITM negotiates Legacy Passkey Pairing with the pairing Initiator and Secure Connections Passkey Pairing with the pairing Responder and brute forces the Passkey entered by the user into the Initiator. The MITM attacker can use the identified Passkey value to complete authentication with the Responder via Bluetooth pairing method confusion.",
      "cve": "CVE-2022-25836",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-25836",
          "value": "CVE-2022-25836",
          "url": "https://scout.docker.com/v/CVE-2022-25836?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-25836?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "827bfc8dce50f0dfa568eb0cd0d1cad9b40dc62be42074157042d249f00c49ab",
      "category": "container_scanning",
      "message": "CVE-2022-45061 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue was discovered in Python before 3.11.1. An unnecessary quadratic algorithm exists in one path when processing some inputs to the IDNA (RFC 3490) decoder, such that a crafted, unreasonably long name being presented to the decoder could lead to a CPU denial of service. Hostnames are often supplied by remote servers that could be controlled by a malicious actor; in such a scenario, they could trigger excessive CPU consumption on the client attempting to make use of an attacker-supplied supposed hostname. For example, the attack payload could be placed in the Location header of an HTTP response with status code 302. A fix is planned in 3.11.1, 3.10.9, 3.9.16, 3.8.16, and 3.7.16.",
      "cve": "CVE-2022-45061",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-45061",
          "value": "CVE-2022-45061",
          "url": "https://scout.docker.com/v/CVE-2022-45061?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-45061?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a82487a0ef1d42bf7b47540ee3492c7c975adeb3277394e98449767f10e13065",
      "category": "container_scanning",
      "message": "CVE-2023-24329 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue in the urllib.parse component of Python before 3.11.4 allows attackers to bypass blocklisting methods by supplying a URL that starts with blank characters.",
      "cve": "CVE-2023-24329",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-24329",
          "value": "CVE-2023-24329",
          "url": "https://scout.docker.com/v/CVE-2023-24329?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-24329?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "17eb00471d3843abc103c70c7884d1f9bf5d4c92300a1f4fc8a2946f02f2bc64",
      "category": "container_scanning",
      "message": "CVE-2023-41105 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "An issue was discovered in Python 3.11 through 3.11.4. If a path containing '\\0' bytes is passed to os.path.normpath(), the path will be truncated unexpectedly at the first '\\0' byte. There are plausible cases in which an application would have rejected a filename for security reasons in Python 3.10.x or earlier, but that filename is no longer rejected in Python 3.11.x.",
      "cve": "CVE-2023-41105",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-41105",
          "value": "CVE-2023-41105",
          "url": "https://scout.docker.com/v/CVE-2023-41105?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-41105?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c21149756e596b816cc627711cc91a67260e841dbdc4168339a218735aa9ee23",
      "category": "container_scanning",
      "message": "CVE-2024-6232 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "There is a MEDIUM severity vulnerability affecting CPython.      Regular expressions that allowed excessive backtracking during tarfile.TarFile header parsing are vulnerable to ReDoS via specifically-crafted tar archives.",
      "cve": "CVE-2024-6232",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-6232",
          "value": "CVE-2024-6232",
          "url": "https://scout.docker.com/v/CVE-2024-6232?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-6232?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a75cf9974c0e8cbfc675cbe7adaa7681108e2e02890360daf19f4083bc4b87f1",
      "category": "container_scanning",
      "message": "CVE-2025-53019 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. In versions prior to 7.1.2-0 and 6.9.13-26, in ImageMagick's `magick stream` command, specifying multiple consecutive `%d` format specifiers in a filename template causes a memory leak. Versions 7.1.2-0 and 6.9.13-26 fix the issue.",
      "cve": "CVE-2025-53019",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-53019",
          "value": "CVE-2025-53019",
          "url": "https://scout.docker.com/v/CVE-2025-53019?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-53019?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bd404511bf695457165a16624428f1dcf2b1288e55d31e8b41d576bdfb15de88",
      "category": "container_scanning",
      "message": "CVE-2020-14356 on ubuntu/linux@5.15.0-161.171",
      "description": "A flaw null pointer dereference in the Linux kernel cgroupv2 subsystem in versions before 5.7.10 was found in the way when reboot the system. A local user could use this flaw to crash the system or escalate their privileges on the system.",
      "cve": "CVE-2020-14356",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2020-14356",
          "value": "CVE-2020-14356",
          "url": "https://scout.docker.com/v/CVE-2020-14356?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2020-14356?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5ddc1b43a53ebec828a4773ea38a0573e6343ae2d236dfa796b973ee68b1c231",
      "category": "container_scanning",
      "message": "CVE-2022-28463 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick 7.1.0-27 is vulnerable to Buffer Overflow.",
      "cve": "CVE-2022-28463",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-28463",
          "value": "CVE-2022-28463",
          "url": "https://scout.docker.com/v/CVE-2022-28463?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-28463?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2c34c2ecf143ae16235286d490700320d75eba8c09b9b7cb91d2a7c6dd2c6385",
      "category": "container_scanning",
      "message": "CVE-2022-3238 on ubuntu/linux@5.15.0-161.171",
      "description": "A double-free flaw was found in the Linux kernels NTFS3 subsystem in how a user triggers remount and umount simultaneously. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "cve": "CVE-2022-3238",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-3238",
          "value": "CVE-2022-3238",
          "url": "https://scout.docker.com/v/CVE-2022-3238?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-3238?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4c5be9a7d21bdde5d269fe1f27ead7c94903366d95d841bef5dd3ad7b2e73226",
      "category": "container_scanning",
      "message": "CVE-2022-32545 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.",
      "cve": "CVE-2022-32545",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-32545",
          "value": "CVE-2022-32545",
          "url": "https://scout.docker.com/v/CVE-2022-32545?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-32545?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e635715203e81f656b645b30c658500ccb5a215b4b4e8307cd570137d92c223e",
      "category": "container_scanning",
      "message": "CVE-2022-32546 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.",
      "cve": "CVE-2022-32546",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-32546",
          "value": "CVE-2022-32546",
          "url": "https://scout.docker.com/v/CVE-2022-32546?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-32546?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1f4ef63338d3486af4b3bda3ee8b762dd7744c49d889c75dabd3cf386539b6bb",
      "category": "container_scanning",
      "message": "CVE-2022-32547 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "In ImageMagick, there is load of misaligned address for type 'double', which requires 8 byte alignment and for type 'float', which requires 4 byte alignment at MagickCore/property.c. Whenever crafted or untrusted input is processed by ImageMagick, this causes a negative impact to application availability or other problems related to undefined behavior.",
      "cve": "CVE-2022-32547",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-32547",
          "value": "CVE-2022-32547",
          "url": "https://scout.docker.com/v/CVE-2022-32547?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-32547?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "6ebdebd0a6280a543f44d3a5bb485d5799409dcc612ea9e61d9d2cf0a25e237f",
      "category": "container_scanning",
      "message": "CVE-2022-48744 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5e: Avoid field-overflowing memcpy()  In preparation for FORTIFY_SOURCE performing compile-time and run-time field bounds checking for memcpy(), memmove(), and memset(), avoid intentionally writing across neighboring fields.  Use flexible arrays instead of zero-element arrays (which look like they are always overflowing) and split the cross-field memcpy() into two halves that can be appropriately bounds-checked by the compiler.  We were doing:  #define ETH_HLEN  14 #define VLAN_HLEN  4 ... #define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN) ... struct mlx5e_tx_wqe      *wqe  = mlx5_wq_cyc_get_wqe(wq, pi); ... struct mlx5_wqe_eth_seg  *eseg = &wqe->eth; struct mlx5_wqe_data_seg *dseg = wqe->data; ... memcpy(eseg->inline_hdr.start, xdptxd->data, MLX5E_XDP_MIN_INLINE);  target is wqe->eth.inline_hdr.start (which the compiler sees as being 2 bytes in size), but copying 18, intending to write across start (really vlan_tci, 2 bytes). The remaining 16 bytes get written into wqe->data[0], covering byte_count (4 bytes), lkey (4 bytes), and addr (8 bytes).  struct mlx5e_tx_wqe { struct mlx5_wqe_ctrl_seg   ctrl;                 /*     0    16 */ struct mlx5_wqe_eth_seg    eth;                  /*    16    16 */ struct mlx5_wqe_data_seg   data[];               /*    32     0 */  /* size: 32, cachelines: 1, members: 3 */ /* last cacheline: 32 bytes */ };  struct mlx5_wqe_eth_seg { u8                         swp_outer_l4_offset;  /*     0     1 */ u8                         swp_outer_l3_offset;  /*     1     1 */ u8                         swp_inner_l4_offset;  /*     2     1 */ u8                         swp_inner_l3_offset;  /*     3     1 */ u8                         cs_flags;             /*     4     1 */ u8                         swp_flags;            /*     5     1 */ __be16                     mss;                  /*     6     2 */ __be32                     flow_table_metadata;  /*     8     4 */ union { struct { __be16     sz;                   /*    12     2 */ u8         start[2];             /*    14     2 */ } inline_hdr;                            /*    12     4 */ struct { __be16     type;                 /*    12     2 */ __be16     vlan_tci;             /*    14     2 */ } insert;                                /*    12     4 */ __be32             trailer;              /*    12     4 */ };                                               /*    12     4 */  /* size: 16, cachelines: 1, members: 9 */ /* last cacheline: 16 bytes */ };  struct mlx5_wqe_data_seg { __be32                     byte_count;           /*     0     4 */ __be32                     lkey;                 /*     4     4 */ __be64                     addr;                 /*     8     8 */  /* size: 16, cachelines: 1, members: 3 */ /* last cacheline: 16 bytes */ };  So, split the memcpy() so the compiler can reason about the buffer sizes.  \"pahole\" shows no size nor member offset changes to struct mlx5e_tx_wqe nor struct mlx5e_umr_wqe. \"objdump -d\" shows no meaningful object code changes (i.e. only source line number induced differences and optimizations).",
      "cve": "CVE-2022-48744",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48744",
          "value": "CVE-2022-48744",
          "url": "https://scout.docker.com/v/CVE-2022-48744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48744?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ebfdda71cc5788e159972c0341949091d35f5bfe2dc5d337e2f967d5d52396ce",
      "category": "container_scanning",
      "message": "CVE-2022-48771 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/vmwgfx: Fix stale file descriptors on failed usercopy  A failing usercopy of the fence_rep object will lead to a stale entry in the file descriptor table as put_unused_fd() won't release it. This enables userland to refer to a dangling 'file' object through that still valid file descriptor, leading to all kinds of use-after-free exploitation scenarios.  Fix this by deferring the call to fd_install() until after the usercopy has succeeded.",
      "cve": "CVE-2022-48771",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48771",
          "value": "CVE-2022-48771",
          "url": "https://scout.docker.com/v/CVE-2022-48771?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48771?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "641d51abe332df85a6c3e6a630e2f594463ec044577ae7d1f6477936b92536a9",
      "category": "container_scanning",
      "message": "CVE-2022-48990 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix use-after-free during gpu recovery  [Why] [  754.862560] refcount_t: underflow; use-after-free. [  754.862898] Call Trace: [  754.862903]  <TASK> [  754.862913]  amdgpu_job_free_cb+0xc2/0xe1 [amdgpu] [  754.863543]  drm_sched_main.cold+0x34/0x39 [amd_sched]  [How] The fw_fence may be not init, check whether dma_fence_init is performed before job free",
      "cve": "CVE-2022-48990",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48990",
          "value": "CVE-2022-48990",
          "url": "https://scout.docker.com/v/CVE-2022-48990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48990?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "72ba219fe52cc5a6ad68f305cd28923578698605e809277a89f9d8cd06e07614",
      "category": "container_scanning",
      "message": "CVE-2022-48998 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  powerpc/bpf/32: Fix Oops on tail call tests  test_bpf tail call tests end up as:  test_bpf: #0 Tail call leaf jited:1 85 PASS test_bpf: #1 Tail call 2 jited:1 111 PASS test_bpf: #2 Tail call 3 jited:1 145 PASS test_bpf: #3 Tail call 4 jited:1 170 PASS test_bpf: #4 Tail call load/store leaf jited:1 190 PASS test_bpf: #5 Tail call load/store jited:1 BUG: Unable to handle kernel data access on write at 0xf1b4e000 Faulting instruction address: 0xbe86b710 Oops: Kernel access of bad area, sig: 11 [#1] BE PAGE_SIZE=4K MMU=Hash PowerMac Modules linked in: test_bpf(+) CPU: 0 PID: 97 Comm: insmod Not tainted 6.1.0-rc4+ #195 Hardware name: PowerMac3,1 750CL 0x87210 PowerMac NIP:  be86b710 LR: be857e88 CTR: be86b704 REGS: f1b4df20 TRAP: 0300   Not tainted  (6.1.0-rc4+) MSR:  00009032 <EE,ME,IR,DR,RI>  CR: 28008242  XER: 00000000 DAR: f1b4e000 DSISR: 42000000 GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000 GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8 GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000 GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00 NIP [be86b710] 0xbe86b710 LR [be857e88] __run_one+0xec/0x264 [test_bpf] Call Trace: [f1b4dfe0] [00000002] 0x2 (unreliable) Instruction dump: XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ---[ end trace 0000000000000000 ]---  This is a tentative to write above the stack. The problem is encoutered with tests added by commit 38608ee7b690 (\"bpf, tests: Add load store test case for tail call\")  This happens because tail call is done to a BPF prog with a different stack_depth. At the time being, the stack is kept as is when the caller tail calls its callee. But at exit, the callee restores the stack based on its own properties. Therefore here, at each run, r1 is erroneously increased by 32 - 16 = 16 bytes.  This was done that way in order to pass the tail call count from caller to callee through the stack. As powerpc32 doesn't have a red zone in the stack, it was necessary the maintain the stack as is for the tail call. But it was not anticipated that the BPF frame size could be different.  Let's take a new approach. Use register r4 to carry the tail call count during the tail call, and save it into the stack at function entry if required. This means the input parameter must be in r3, which is more correct as it is a 32 bits parameter, then tail call better match with normal BPF function entry, the down side being that we move that input parameter back and forth between r3 and r4. That can be optimised later.  Doing that also has the advantage of maximising the common parts between tail calls and a normal function exit.  With the fix, tail call tests are now successfull:  test_bpf: #0 Tail call leaf jited:1 53 PASS test_bpf: #1 Tail call 2 jited:1 115 PASS test_bpf: #2 Tail call 3 jited:1 154 PASS test_bpf: #3 Tail call 4 jited:1 165 PASS test_bpf: #4 Tail call load/store leaf jited:1 101 PASS test_bpf: #5 Tail call load/store jited:1 141 PASS test_bpf: #6 Tail call error path, max count reached jited:1 994 PASS test_bpf: #7 Tail call count preserved across function calls jited:1 140975 PASS test_bpf: #8 Tail call error path, NULL target jited:1 110 PASS test_bpf: #9 Tail call error path, index out of range jited:1 69 PASS test_bpf: test_tail_calls: Summary: 10 PASSED, 0 FAILED, [10/10 JIT'ed]",
      "cve": "CVE-2022-48998",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-48998",
          "value": "CVE-2022-48998",
          "url": "https://scout.docker.com/v/CVE-2022-48998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-48998?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0df57ae56fd7771d1002991c22619c615ac8da80564a5306a2743adfa89ab56c",
      "category": "container_scanning",
      "message": "CVE-2022-49267 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mmc: core: use sysfs_emit() instead of sprintf()  sprintf() (still used in the MMC core for the sysfs output) is vulnerable to the buffer overflow.  Use the new-fangled sysfs_emit() instead.  Found by Linux Verification Center (linuxtesting.org) with the SVACE static analysis tool.",
      "cve": "CVE-2022-49267",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49267",
          "value": "CVE-2022-49267",
          "url": "https://scout.docker.com/v/CVE-2022-49267?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49267?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "39893f80d1223e2b6e08bfa886b11c7cbef1b47c601b026387e1893530a0fc63",
      "category": "container_scanning",
      "message": "CVE-2022-49471 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rtw89: cfo: check mac_id to avoid out-of-bounds  Somehow, hardware reports incorrect mac_id and pollute memory. Check index before we access the array.  UBSAN: array-index-out-of-bounds in rtw89/phy.c:2517:23 index 188 is out of range for type 's32 [64]' CPU: 1 PID: 51550 Comm: irq/35-rtw89_pc Tainted: G           OE Call Trace: <IRQ> show_stack+0x52/0x58 dump_stack_lvl+0x4c/0x63 dump_stack+0x10/0x12 ubsan_epilogue+0x9/0x45 __ubsan_handle_out_of_bounds.cold+0x44/0x49 ? __alloc_skb+0x92/0x1d0 rtw89_phy_cfo_parse+0x44/0x7f [rtw89_core] rtw89_core_rx+0x261/0x871 [rtw89_core] ? __alloc_skb+0xee/0x1d0 rtw89_pci_napi_poll+0x3fa/0x4ea [rtw89_pci] __napi_poll+0x33/0x1a0 net_rx_action+0x126/0x260 ? __queue_work+0x217/0x4c0 __do_softirq+0xd9/0x315 ? disable_irq_nosync+0x10/0x10 do_softirq.part.0+0x6d/0x90 </IRQ> <TASK> __local_bh_enable_ip+0x62/0x70 rtw89_pci_interrupt_threadfn+0x182/0x1a6 [rtw89_pci] irq_thread_fn+0x28/0x60 irq_thread+0xc8/0x190 ? irq_thread_fn+0x60/0x60 kthread+0x16b/0x190 ? irq_thread_check_affinity+0xe0/0xe0 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 </TASK>",
      "cve": "CVE-2022-49471",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49471",
          "value": "CVE-2022-49471",
          "url": "https://scout.docker.com/v/CVE-2022-49471?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49471?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2fc25e81cba7015e5f888e490e866369f42adc395986c67fd406e12b373032f4",
      "category": "container_scanning",
      "message": "CVE-2022-49635 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/i915/selftests: fix subtraction overflow bug  On some machines hole_end can be small enough to cause subtraction overflow. On the other side (addr + 2 * min_alignment) can overflow in case of mock tests. This patch should handle both cases.  (cherry picked from commit ab3edc679c552a466e4bf0b11af3666008bd65a2)",
      "cve": "CVE-2022-49635",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49635",
          "value": "CVE-2022-49635",
          "url": "https://scout.docker.com/v/CVE-2022-49635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49635?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "406348761455e569ac3d4706ab5445568f6462bf59cdca1bcefc43c952784c62",
      "category": "container_scanning",
      "message": "CVE-2022-49722 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ice: Fix memory corruption in VF driver  Disable VF's RX/TX queues, when it's disabled. VF can have queues enabled, when it requests a reset. If PF driver assumes that VF is disabled, while VF still has queues configured, VF may unmap DMA resources. In such scenario device still can map packets to memory, which ends up silently corrupting it. Previously, VF driver could experience memory corruption, which lead to crash: [ 5119.170157] BUG: unable to handle kernel paging request at 00001b9780003237 [ 5119.170166] PGD 0 P4D 0 [ 5119.170173] Oops: 0002 [#1] PREEMPT_RT SMP PTI [ 5119.170181] CPU: 30 PID: 427592 Comm: kworker/u96:2 Kdump: loaded Tainted: G        W I      --------- -  - 4.18.0-372.9.1.rt7.166.el8.x86_64 #1 [ 5119.170189] Hardware name: Dell Inc. PowerEdge R740/014X06, BIOS 2.3.10 08/15/2019 [ 5119.170193] Workqueue: iavf iavf_adminq_task [iavf] [ 5119.170219] RIP: 0010:__page_frag_cache_drain+0x5/0x30 [ 5119.170238] Code: 0f 0f b6 77 51 85 f6 74 07 31 d2 e9 05 df ff ff e9 90 fe ff ff 48 8b 05 49 db 33 01 eb b4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 <f0> 29 77 34 74 01 c3 48 8b 07 f6 c4 80 74 0f 0f b6 77 51 85 f6 74 [ 5119.170244] RSP: 0018:ffffa43b0bdcfd78 EFLAGS: 00010282 [ 5119.170250] RAX: ffffffff896b3e40 RBX: ffff8fb282524000 RCX: 0000000000000002 [ 5119.170254] RDX: 0000000049000000 RSI: 0000000000000000 RDI: 00001b9780003203 [ 5119.170259] RBP: ffff8fb248217b00 R08: 0000000000000022 R09: 0000000000000009 [ 5119.170262] R10: 2b849d6300000000 R11: 0000000000000020 R12: 0000000000000000 [ 5119.170265] R13: 0000000000001000 R14: 0000000000000009 R15: 0000000000000000 [ 5119.170269] FS:  0000000000000000(0000) GS:ffff8fb1201c0000(0000) knlGS:0000000000000000 [ 5119.170274] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 5119.170279] CR2: 00001b9780003237 CR3: 00000008f3e1a003 CR4: 00000000007726e0 [ 5119.170283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 5119.170286] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 5119.170290] PKRU: 55555554 [ 5119.170292] Call Trace: [ 5119.170298]  iavf_clean_rx_ring+0xad/0x110 [iavf] [ 5119.170324]  iavf_free_rx_resources+0xe/0x50 [iavf] [ 5119.170342]  iavf_free_all_rx_resources.part.51+0x30/0x40 [iavf] [ 5119.170358]  iavf_virtchnl_completion+0xd8a/0x15b0 [iavf] [ 5119.170377]  ? iavf_clean_arq_element+0x210/0x280 [iavf] [ 5119.170397]  iavf_adminq_task+0x126/0x2e0 [iavf] [ 5119.170416]  process_one_work+0x18f/0x420 [ 5119.170429]  worker_thread+0x30/0x370 [ 5119.170437]  ? process_one_work+0x420/0x420 [ 5119.170445]  kthread+0x151/0x170 [ 5119.170452]  ? set_kthread_struct+0x40/0x40 [ 5119.170460]  ret_from_fork+0x35/0x40 [ 5119.170477] Modules linked in: iavf sctp ip6_udp_tunnel udp_tunnel mlx4_en mlx4_core nfp tls vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache sunrpc intel_rapl_msr iTCO_wdt iTCO_vendor_support dell_smbios wmi_bmof dell_wmi_descriptor dcdbas kvm_intel kvm irqbypass intel_rapl_common isst_if_common skx_edac irdma nfit libnvdimm x86_pkg_temp_thermal i40e intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ib_uverbs rapl ipmi_ssif intel_cstate intel_uncore mei_me pcspkr acpi_ipmi ib_core mei lpc_ich i2c_i801 ipmi_si ipmi_devintf wmi ipmi_msghandler acpi_power_meter xfs libcrc32c sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ice ahci drm libahci crc32c_intel libata tg3 megaraid_sas [ 5119.170613]  i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: iavf] [ 5119.170627] CR2: 00001b9780003237",
      "cve": "CVE-2022-49722",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-49722",
          "value": "CVE-2022-49722",
          "url": "https://scout.docker.com/v/CVE-2022-49722?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-49722?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b8f93064d1d436d0a25ad4c635fa5a670f935e74679e239cb02ffde43a62d1d0",
      "category": "container_scanning",
      "message": "CVE-2023-0030 on ubuntu/linux@5.15.0-161.171",
      "description": "A use-after-free flaw was found in the Linux kernels nouveau driver in how a user triggers a memory overflow that causes the nvkm_vma_tail function to fail. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "cve": "CVE-2023-0030",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-0030",
          "value": "CVE-2023-0030",
          "url": "https://scout.docker.com/v/CVE-2023-0030?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-0030?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "338d12a1d67b9800e4f957e0d9deaaab8d291ea8ffef5ab564fd66287ee3f332",
      "category": "container_scanning",
      "message": "CVE-2023-0996 on ubuntu/libheif@1.12.0-2build1",
      "description": "There is a vulnerability in the strided image data parsing code in the emscripten wrapper for libheif. An attacker could exploit this through a crafted image file to cause a buffer overflow in linear memory during a memcpy call.",
      "cve": "CVE-2023-0996",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/libheif@1.12.0-2build1?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "1.12.0-2build1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-0996",
          "value": "CVE-2023-0996",
          "url": "https://scout.docker.com/v/CVE-2023-0996?s=ubuntu&n=libheif&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-0996?s=ubuntu&n=libheif&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a36bcab0d7c44810ad8ca31287c2284403f6e915df782546543cad51530f241c",
      "category": "container_scanning",
      "message": "CVE-2023-2007 on ubuntu/linux@5.15.0-161.171",
      "description": "The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.",
      "cve": "CVE-2023-2007",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-2007",
          "value": "CVE-2023-2007",
          "url": "https://scout.docker.com/v/CVE-2023-2007?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-2007?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "c1230dcd64c4f1182f0d736b2cb15f7a51dd20a2818754e6c0a1438769001f48",
      "category": "container_scanning",
      "message": "CVE-2023-26242 on ubuntu/linux@5.15.0-161.171",
      "description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
      "cve": "CVE-2023-26242",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-26242",
          "value": "CVE-2023-26242",
          "url": "https://scout.docker.com/v/CVE-2023-26242?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-26242?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "494f4a0d48ec0f08640fcfc7ed98cfc64f51e9b2f404365c995a2385e8b67cab",
      "category": "container_scanning",
      "message": "CVE-2023-52452 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix accesses to uninit stack slots  Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
      "cve": "CVE-2023-52452",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52452",
          "value": "CVE-2023-52452",
          "url": "https://scout.docker.com/v/CVE-2023-52452?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52452?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "39150aceb4e7c1c96563cddba1b406bc0e23fdc5728689077d9301cbb01d0b33",
      "category": "container_scanning",
      "message": "CVE-2023-52624 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Wake DMCUB before executing GPINT commands  [Why] DMCUB can be in idle when we attempt to interface with the HW through the GPINT mailbox resulting in a system hang.  [How] Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep sequence.  If the GPINT executes successfully then DMCUB will be put back into sleep after the optional response is returned.  It functions similar to the inbox command interface.",
      "cve": "CVE-2023-52624",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52624",
          "value": "CVE-2023-52624",
          "url": "https://scout.docker.com/v/CVE-2023-52624?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52624?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b7d47dcc4b4b82f233c67f1021b2dde7f1335714c97f6656fb84b100f230b253",
      "category": "container_scanning",
      "message": "CVE-2023-52751 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix use-after-free in smb2_query_info_compound()  The following UAF was triggered when running fstests generic/072 with KASAN enabled against Windows Server 2022 and mount options 'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm'  BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs] Read of size 8 at addr ffff888014941048 by task xfs_io/27534  CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 Call Trace: dump_stack_lvl+0x4a/0x80 print_report+0xcf/0x650 ? srso_alias_return_thunk+0x5/0x7f ? srso_alias_return_thunk+0x5/0x7f ? __phys_addr+0x46/0x90 kasan_report+0xda/0x110 ? smb2_query_info_compound+0x423/0x6d0 [cifs] ? smb2_query_info_compound+0x423/0x6d0 [cifs] smb2_query_info_compound+0x423/0x6d0 [cifs] ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __stack_depot_save+0x39/0x480 ? kasan_save_stack+0x33/0x60 ? kasan_set_track+0x25/0x30 ? ____kasan_slab_free+0x126/0x170 smb2_queryfs+0xc2/0x2c0 [cifs] ? __pfx_smb2_queryfs+0x10/0x10 [cifs] ? __pfx___lock_acquire+0x10/0x10 smb311_queryfs+0x210/0x220 [cifs] ? __pfx_smb311_queryfs+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __lock_acquire+0x480/0x26c0 ? lock_release+0x1ed/0x640 ? srso_alias_return_thunk+0x5/0x7f ? do_raw_spin_unlock+0x9b/0x100 cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 ? __pfx___do_sys_fstatfs+0x10/0x10 ? srso_alias_return_thunk+0x5/0x7f ? lockdep_hardirqs_on_prepare+0x136/0x200 ? srso_alias_return_thunk+0x5/0x7f do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8  Allocated by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 __kasan_kmalloc+0x8f/0xa0 open_cached_dir+0x71b/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs] smb311_queryfs+0x210/0x220 [cifs] cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8  Freed by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 kasan_save_free_info+0x2b/0x50 ____kasan_slab_free+0x126/0x170 slab_free_freelist_hook+0xd0/0x1e0 __kmem_cache_free+0x9d/0x1b0 open_cached_dir+0xff5/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs]  This is a race between open_cached_dir() and cached_dir_lease_break() where the cache entry for the open directory handle receives a lease break while creating it.  And before returning from open_cached_dir(), we put the last reference of the new @cfid because of !@cfid->has_lease.  Besides the UAF, while running xfstests a lot of missed lease breaks have been noticed in tests that run several concurrent statfs(2) calls on those cached fids  CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108 CIFS: VFS: Dump pending requests: CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108 ...  To fix both, in open_cached_dir() ensure that @cfid->has_lease is set right before sending out compounded request so that any potential lease break will be get processed by demultiplex thread while we're still caching @cfid.  And, if open failed for some reason, re-check @cfid->has_lease to decide whether or not put lease reference.",
      "cve": "CVE-2023-52751",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52751",
          "value": "CVE-2023-52751",
          "url": "https://scout.docker.com/v/CVE-2023-52751?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52751?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d017f9433cd07b7cecc00bee6e5545af873c759ccfb5f9bcfeb887d007a782c",
      "category": "container_scanning",
      "message": "CVE-2023-52837 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nbd: fix uaf in nbd_open  Commit 4af5f2e03013 (\"nbd: use blk_mq_alloc_disk and blk_cleanup_disk\") cleans up disk by blk_cleanup_disk() and it won't set disk->private_data as NULL as before. UAF may be triggered in nbd_open() if someone tries to open nbd device right after nbd_put() since nbd has been free in nbd_dev_remove().  Fix this by implementing ->free_disk and free private data in it.",
      "cve": "CVE-2023-52837",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52837",
          "value": "CVE-2023-52837",
          "url": "https://scout.docker.com/v/CVE-2023-52837?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52837?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "31cb577df962a181599c8810dce78f0d2f55d910a8333d014c7d0cb7201e451a",
      "category": "container_scanning",
      "message": "CVE-2023-52916 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  media: aspeed: Fix memory overwrite if timing is 1600x900  When capturing 1600x900, system could crash when system memory usage is tight.  The way to reproduce this issue: 1. Use 1600x900 to display on host 2. Mount ISO through 'Virtual media' on OpenBMC's web 3. Run script as below on host to do sha continuously #!/bin/bash while [ [1] ]; do find /media -type f -printf '\"%h/%f\"\\n' | xargs sha256sum done 4. Open KVM on OpenBMC's web  The size of macro block captured is 8x8. Therefore, we should make sure the height of src-buf is 8 aligned to fix this issue.",
      "cve": "CVE-2023-52916",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52916",
          "value": "CVE-2023-52916",
          "url": "https://scout.docker.com/v/CVE-2023-52916?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52916?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "5bf8c2bd28bb20687f902269a89dc822539ebe504d09aab31d349e289b1624cd",
      "category": "container_scanning",
      "message": "CVE-2023-52921 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: fix possible UAF in amdgpu_cs_pass1()  Since the gang_size check is outside of chunk parsing loop, we need to reset i before we free the chunk data.  Suggested by Ye Zhang (@VAR10CK) of Baidu Security.",
      "cve": "CVE-2023-52921",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2023-52921",
          "value": "CVE-2023-52921",
          "url": "https://scout.docker.com/v/CVE-2023-52921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2023-52921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9503b8975c716c80bf8c20e4a94baa409b46744eb4d6cf840757466c20533e4d",
      "category": "container_scanning",
      "message": "CVE-2024-26699 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix array-index-out-of-bounds in dcn35_clkmgr  [Why] There is a potential memory access violation while iterating through array of dcn35 clks.  [How] Limit iteration per array size.",
      "cve": "CVE-2024-26699",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26699",
          "value": "CVE-2024-26699",
          "url": "https://scout.docker.com/v/CVE-2024-26699?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26699?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e1818a4f48c33e3ad3adf1565a205af6d675804de899cc496a2787dbf9b680f8",
      "category": "container_scanning",
      "message": "CVE-2024-26742 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: smartpqi: Fix disable_managed_interrupts  Correct blk-mq registration issue with module parameter disable_managed_interrupts enabled.  When we turn off the default PCI_IRQ_AFFINITY flag, the driver needs to register with blk-mq using blk_mq_map_queues(). The driver is currently calling blk_mq_pci_map_queues() which results in a stack trace and possibly undefined behavior.  Stack Trace: [    7.860089] scsi host2: smartpqi [    7.871934] WARNING: CPU: 0 PID: 238 at block/blk-mq-pci.c:52 blk_mq_pci_map_queues+0xca/0xd0 [    7.889231] Modules linked in: sd_mod t10_pi sg uas smartpqi(+) crc32c_intel scsi_transport_sas usb_storage dm_mirror dm_region_hash dm_log dm_mod ipmi_devintf ipmi_msghandler fuse [    7.924755] CPU: 0 PID: 238 Comm: kworker/0:3 Not tainted 4.18.0-372.88.1.el8_6_smartpqi_test.x86_64 #1 [    7.944336] Hardware name: HPE ProLiant DL380 Gen10/ProLiant DL380 Gen10, BIOS U30 03/08/2022 [    7.963026] Workqueue: events work_for_cpu_fn [    7.978275] RIP: 0010:blk_mq_pci_map_queues+0xca/0xd0 [    7.978278] Code: 48 89 de 89 c7 e8 f6 0f 4f 00 3b 05 c4 b7 8e 01 72 e1 5b 31 c0 5d 41 5c 41 5d 41 5e 41 5f e9 7d df 73 00 31 c0 e9 76 df 73 00 <0f> 0b eb bc 90 90 0f 1f 44 00 00 41 57 49 89 ff 41 56 41 55 41 54 [    7.978280] RSP: 0018:ffffa95fc3707d50 EFLAGS: 00010216 [    7.978283] RAX: 00000000ffffffff RBX: 0000000000000000 RCX: 0000000000000010 [    7.978284] RDX: 0000000000000004 RSI: 0000000000000000 RDI: ffff9190c32d4310 [    7.978286] RBP: 0000000000000000 R08: ffffa95fc3707d38 R09: ffff91929b81ac00 [    7.978287] R10: 0000000000000001 R11: ffffa95fc3707ac0 R12: 0000000000000000 [    7.978288] R13: ffff9190c32d4000 R14: 00000000ffffffff R15: ffff9190c4c950a8 [    7.978290] FS:  0000000000000000(0000) GS:ffff9193efc00000(0000) knlGS:0000000000000000 [    7.978292] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [    8.172814] CR2: 000055d11166c000 CR3: 00000002dae10002 CR4: 00000000007706f0 [    8.172816] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [    8.172817] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [    8.172818] PKRU: 55555554 [    8.172819] Call Trace: [    8.172823]  blk_mq_alloc_tag_set+0x12e/0x310 [    8.264339]  scsi_add_host_with_dma.cold.9+0x30/0x245 [    8.279302]  pqi_ctrl_init+0xacf/0xc8e [smartpqi] [    8.294085]  ? pqi_pci_probe+0x480/0x4c8 [smartpqi] [    8.309015]  pqi_pci_probe+0x480/0x4c8 [smartpqi] [    8.323286]  local_pci_probe+0x42/0x80 [    8.337855]  work_for_cpu_fn+0x16/0x20 [    8.351193]  process_one_work+0x1a7/0x360 [    8.364462]  ? create_worker+0x1a0/0x1a0 [    8.379252]  worker_thread+0x1ce/0x390 [    8.392623]  ? create_worker+0x1a0/0x1a0 [    8.406295]  kthread+0x10a/0x120 [    8.418428]  ? set_kthread_struct+0x50/0x50 [    8.431532]  ret_from_fork+0x1f/0x40 [    8.444137] ---[ end trace 1bf0173d39354506 ]---",
      "cve": "CVE-2024-26742",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26742",
          "value": "CVE-2024-26742",
          "url": "https://scout.docker.com/v/CVE-2024-26742?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26742?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "fb5930f0a742fa4da40ddf88bd66fa944dacb825d497d4ce569e5565f3a900b2",
      "category": "container_scanning",
      "message": "CVE-2024-26842 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  scsi: ufs: core: Fix shift issue in ufshcd_clear_cmd()  When task_tag >= 32 (in MCQ mode) and sizeof(unsigned int) == 4, 1U << task_tag will out of bounds for a u32 mask. Fix this up to prevent SHIFT_ISSUE (bitwise shifts that are out of bounds for their data type).  [name:debug_monitors&]Unexpected kernel BRK exception at EL1 [name:traps&]Internal error: BRK handler: 00000000f2005514 [#1] PREEMPT SMP [name:mediatek_cpufreq_hw&]cpufreq stop DVFS log done [name:mrdump&]Kernel Offset: 0x1ba5800000 from 0xffffffc008000000 [name:mrdump&]PHYS_OFFSET: 0x80000000 [name:mrdump&]pstate: 22400005 (nzCv daif +PAN -UAO) [name:mrdump&]pc : [0xffffffdbaf52bb2c] ufshcd_clear_cmd+0x280/0x288 [name:mrdump&]lr : [0xffffffdbaf52a774] ufshcd_wait_for_dev_cmd+0x3e4/0x82c [name:mrdump&]sp : ffffffc0081471b0 <snip> Workqueue: ufs_eh_wq_0 ufshcd_err_handler Call trace: dump_backtrace+0xf8/0x144 show_stack+0x18/0x24 dump_stack_lvl+0x78/0x9c dump_stack+0x18/0x44 mrdump_common_die+0x254/0x480 [mrdump] ipanic_die+0x20/0x30 [mrdump] notify_die+0x15c/0x204 die+0x10c/0x5f8 arm64_notify_die+0x74/0x13c do_debug_exception+0x164/0x26c el1_dbg+0x64/0x80 el1h_64_sync_handler+0x3c/0x90 el1h_64_sync+0x68/0x6c ufshcd_clear_cmd+0x280/0x288 ufshcd_wait_for_dev_cmd+0x3e4/0x82c ufshcd_exec_dev_cmd+0x5bc/0x9ac ufshcd_verify_dev_init+0x84/0x1c8 ufshcd_probe_hba+0x724/0x1ce0 ufshcd_host_reset_and_restore+0x260/0x574 ufshcd_reset_and_restore+0x138/0xbd0 ufshcd_err_handler+0x1218/0x2f28 process_one_work+0x5fc/0x1140 worker_thread+0x7d8/0xe20 kthread+0x25c/0x468 ret_from_fork+0x10/0x20",
      "cve": "CVE-2024-26842",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-26842",
          "value": "CVE-2024-26842",
          "url": "https://scout.docker.com/v/CVE-2024-26842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-26842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0ef6824665e24556a5bbd9832eae57d0d6a104a795f4f1736f9b52776cc65bb5",
      "category": "container_scanning",
      "message": "CVE-2024-35861 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect()  Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "cve": "CVE-2024-35861",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35861",
          "value": "CVE-2024-35861",
          "url": "https://scout.docker.com/v/CVE-2024-35861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35861?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a7b9ad96faa241d569e10f9ba9a792830770c2c2bf2bbe685ef05ab1132f60a0",
      "category": "container_scanning",
      "message": "CVE-2024-35862 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential UAF in smb2_is_network_name_deleted()  Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "cve": "CVE-2024-35862",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35862",
          "value": "CVE-2024-35862",
          "url": "https://scout.docker.com/v/CVE-2024-35862?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35862?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ed39abc5c4385dfd4e96ea7e8845a23babc33016f89d7696537acdeb28666cc6",
      "category": "container_scanning",
      "message": "CVE-2024-35863 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential UAF in is_valid_oplock_break()  Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "cve": "CVE-2024-35863",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35863",
          "value": "CVE-2024-35863",
          "url": "https://scout.docker.com/v/CVE-2024-35863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1dd79fb069a804e3255ef80b76d3128662de96c4a9c127c47f0d86c252cf630c",
      "category": "container_scanning",
      "message": "CVE-2024-35868 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix potential UAF in cifs_stats_proc_write()  Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "cve": "CVE-2024-35868",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35868",
          "value": "CVE-2024-35868",
          "url": "https://scout.docker.com/v/CVE-2024-35868?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35868?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ebdec0879657a0c7e10091ca93c118b757549a6a798d01cf7cfe8d4ab3f917d2",
      "category": "container_scanning",
      "message": "CVE-2024-35929 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  rcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()  For the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and CONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE() in the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions:  CPU2                                               CPU11 kthread rcu_nocb_cb_kthread                                       ksys_write rcu_do_batch                                              vfs_write rcu_torture_timer_cb                                      proc_sys_write __kmem_cache_free proc_sys_call_handler kmemleak_free drop_caches_sysctl_handler delete_object_full                                        drop_slab __delete_object                                           shrink_slab put_object lazy_rcu_shrink_scan call_rcu rcu_nocb_flush_bypass __call_rcu_commn rcu_nocb_bypass_lock  raw_spin_trylock(&rdp->nocb_bypass_lock) fail  atomic_inc(&rdp->nocb_lock_contended); rcu_nocb_wait_contended WARN_ON_ONCE(smp_processor_id() != rdp->cpu); WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)) | |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __|  Reproduce this bug with \"echo 3 > /proc/sys/vm/drop_caches\".  This commit therefore uses rcu_nocb_try_flush_bypass() instead of rcu_nocb_flush_bypass() in lazy_rcu_shrink_scan().  If the nocb_bypass queue is being flushed, then rcu_nocb_try_flush_bypass will return directly.",
      "cve": "CVE-2024-35929",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35929",
          "value": "CVE-2024-35929",
          "url": "https://scout.docker.com/v/CVE-2024-35929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35929?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2d738754548f8f7c11ef8f4b934601a157f2d73e6b77688038a2c8a48e496819",
      "category": "container_scanning",
      "message": "CVE-2024-35932 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/vc4: don't check if plane->state->fb == state->fb  Currently, when using non-blocking commits, we can see the following kernel warning:  [  110.908514] ------------[ cut here ]------------ [  110.908529] refcount_t: underflow; use-after-free. [  110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0 [  110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [  110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G         C 6.1.66-v8+ #32 [  110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT) [  110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [  110.909132] pc : refcount_dec_not_one+0xb8/0xc0 [  110.909152] lr : refcount_dec_not_one+0xb4/0xc0 [  110.909170] sp : ffffffc00913b9c0 [  110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60 [  110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480 [  110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78 [  110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000 [  110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004 [  110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003 [  110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00 [  110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572 [  110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000 [  110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001 [  110.909434] Call trace: [  110.909441]  refcount_dec_not_one+0xb8/0xc0 [  110.909461]  vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4] [  110.909903]  vc4_cleanup_fb+0x44/0x50 [vc4] [  110.910315]  drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper] [  110.910669]  vc4_atomic_commit_tail+0x390/0x9dc [vc4] [  110.911079]  commit_tail+0xb0/0x164 [drm_kms_helper] [  110.911397]  drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper] [  110.911716]  drm_atomic_commit+0xb0/0xdc [drm] [  110.912569]  drm_mode_atomic_ioctl+0x348/0x4b8 [drm] [  110.913330]  drm_ioctl_kernel+0xec/0x15c [drm] [  110.914091]  drm_ioctl+0x24c/0x3b0 [drm] [  110.914850]  __arm64_sys_ioctl+0x9c/0xd4 [  110.914873]  invoke_syscall+0x4c/0x114 [  110.914897]  el0_svc_common+0xd0/0x118 [  110.914917]  do_el0_svc+0x38/0xd0 [  110.914936]  el0_svc+0x30/0x8c [  110.914958]  el0t_64_sync_handler+0x84/0xf0 [  110.914979]  el0t_64_sync+0x18c/0x190 [  110.914996] ---[ end trace 0000000000000000 ]---  This happens because, although `prepare_fb` and `cleanup_fb` are perfectly balanced, we cannot guarantee consistency in the check plane->state->fb == state->fb. This means that sometimes we can increase the refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The opposite can also be true.  In fact, the struct drm_plane .state shouldn't be accessed directly but instead, the `drm_atomic_get_new_plane_state()` helper function should be used. So, we could stick to this check, but using `drm_atomic_get_new_plane_state()`. But actually, this check is not re ---truncated---",
      "cve": "CVE-2024-35932",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35932",
          "value": "CVE-2024-35932",
          "url": "https://scout.docker.com/v/CVE-2024-35932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35932?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "4a6b1973c8e5be8a0b24bad24f7c166114983bd796c1a7907939e22ec95a67a9",
      "category": "container_scanning",
      "message": "CVE-2024-36012 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: msft: fix slab-use-after-free in msft_do_close()  Tying the msft->data lifetime to hdev by freeing it in hci_release_dev() to fix the following case:  [use] msft_do_close() msft = hdev->msft_data; if (!msft)                      ...(1) <- passed. return; mutex_lock(&msft->filter_lock); ...(4) <- used after freed.  [free] msft_unregister() msft = hdev->msft_data; hdev->msft_data = NULL;         ...(2) kfree(msft);                    ...(3) <- msft is freed.  ================================================================== BUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline] BUG: KASAN: slab-use-after-free in __mutex_lock+0x8f/0xc30 kernel/locking/mutex.c:752 Read of size 8 at addr ffff888106cbbca8 by task kworker/u5:2/309",
      "cve": "CVE-2024-36012",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36012",
          "value": "CVE-2024-36012",
          "url": "https://scout.docker.com/v/CVE-2024-36012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36012?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "234d60896470b662b6a2aadf19113520e48ba23b819c3369572317cb3c652ab9",
      "category": "container_scanning",
      "message": "CVE-2024-36898 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  gpiolib: cdev: fix uninitialised kfifo  If a line is requested with debounce, and that results in debouncing in software, and the line is subsequently reconfigured to enable edge detection then the allocation of the kfifo to contain edge events is overlooked.  This results in events being written to and read from an uninitialised kfifo.  Read events are returned to userspace.  Initialise the kfifo in the case where the software debounce is already active.",
      "cve": "CVE-2024-36898",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36898",
          "value": "CVE-2024-36898",
          "url": "https://scout.docker.com/v/CVE-2024-36898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36898?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec44ce4bcfe9b2a4e9d5eaefacf23d4c3a5cd51aaeb6d1317929a281ee334177",
      "category": "container_scanning",
      "message": "CVE-2024-36914 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Skip on writeback when it's not applicable  [WHY] dynamic memory safety error detector (KASAN) catches and generates error messages \"BUG: KASAN: slab-out-of-bounds\" as writeback connector does not support certain features which are not initialized.  [HOW] Skip them when connector type is DRM_MODE_CONNECTOR_WRITEBACK.",
      "cve": "CVE-2024-36914",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36914",
          "value": "CVE-2024-36914",
          "url": "https://scout.docker.com/v/CVE-2024-36914?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36914?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2c46c401d0e363761f096ab03dc115a888da93063b6ee1f93f4080487b330825",
      "category": "container_scanning",
      "message": "CVE-2024-36921 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: guard against invalid STA ID on removal  Guard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that would result in out-of-bounds array accesses. This prevents issues should the driver get into a bad state during error handling.",
      "cve": "CVE-2024-36921",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-36921",
          "value": "CVE-2024-36921",
          "url": "https://scout.docker.com/v/CVE-2024-36921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-36921?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7cbcf3d086b198cbf4062464b77e88c6f4a131882d3a2e25aa660c08ef60d037",
      "category": "container_scanning",
      "message": "CVE-2024-38556 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Add a timeout to acquire the command queue semaphore  Prevent forced completion handling on an entry that has not yet been assigned an index, causing an out of bounds access on idx = -22. Instead of waiting indefinitely for the sem, blocking flow now waits for index to be allocated or a sem acquisition timeout before beginning the timer for FW completion.  Kernel log example: mlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion",
      "cve": "CVE-2024-38556",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-38556",
          "value": "CVE-2024-38556",
          "url": "https://scout.docker.com/v/CVE-2024-38556?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-38556?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e94bf4d9594b00b16a62f452675100d27dc262e0bd09b8b18cded4711c283415",
      "category": "container_scanning",
      "message": "CVE-2024-40900 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: remove requests from xarray during flushing requests  Even with CACHEFILES_DEAD set, we can still read the requests, so in the following concurrency the request may be used after it has been freed:  mount  |   daemon_thread1    |    daemon_thread2 ------------------------------------------------------------ cachefiles_ondemand_init_object cachefiles_ondemand_send_req REQ_A = kzalloc(sizeof(*req) + data_len) wait_for_completion(&REQ_A->done) cachefiles_daemon_read cachefiles_ondemand_daemon_read // close dev fd cachefiles_flush_reqs complete(&REQ_A->done) kfree(REQ_A) xa_lock(&cache->reqs); cachefiles_ondemand_select_req req->msg.opcode != CACHEFILES_OP_READ // req use-after-free !!! xa_unlock(&cache->reqs); xa_destroy(&cache->reqs)  Hence remove requests from cache->reqs when flushing them to avoid accessing freed requests.",
      "cve": "CVE-2024-40900",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40900",
          "value": "CVE-2024-40900",
          "url": "https://scout.docker.com/v/CVE-2024-40900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40900?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "777fe7454f9d9ac4f399d2b98cb749b66c9c4d5d4ec502fcbd08191380f80035",
      "category": "container_scanning",
      "message": "CVE-2024-40954 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: do not leave a dangling sk pointer, when socket creation fails  It is possible to trigger a use-after-free by: * attaching an fentry probe to __sock_release() and the probe calling the bpf_get_socket_cookie() helper * running traceroute -I 1.1.1.1 on a freshly booted VM  A KASAN enabled kernel will log something like below (decoded and stripped): ================================================================== BUG: KASAN: slab-use-after-free in __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) Read of size 8 at addr ffff888007110dd8 by task traceroute/299  CPU: 2 PID: 299 Comm: traceroute Tainted: G            E      6.10.0-rc2+ #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014 Call Trace: <TASK> dump_stack_lvl (lib/dump_stack.c:117 (discriminator 1)) print_report (mm/kasan/report.c:378 mm/kasan/report.c:488) ? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) kasan_report (mm/kasan/report.c:603) ? __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) kasan_check_range (mm/kasan/generic.c:183 mm/kasan/generic.c:189) __sock_gen_cookie (./arch/x86/include/asm/atomic64_64.h:15 ./include/linux/atomic/atomic-arch-fallback.h:2583 ./include/linux/atomic/atomic-instrumented.h:1611 net/core/sock_diag.c:29) bpf_get_socket_ptr_cookie (./arch/x86/include/asm/preempt.h:94 ./include/linux/sock_diag.h:42 net/core/filter.c:5094 net/core/filter.c:5092) bpf_prog_875642cf11f1d139___sock_release+0x6e/0x8e bpf_trampoline_6442506592+0x47/0xaf __sock_release (net/socket.c:652) __sock_create (net/socket.c:1601) ... Allocated by task 299 on cpu 2 at 78.328492s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) __kasan_slab_alloc (mm/kasan/common.c:312 mm/kasan/common.c:338) kmem_cache_alloc_noprof (mm/slub.c:3941 mm/slub.c:4000 mm/slub.c:4007) sk_prot_alloc (net/core/sock.c:2075) sk_alloc (net/core/sock.c:2134) inet_create (net/ipv4/af_inet.c:327 net/ipv4/af_inet.c:252) __sock_create (net/socket.c:1572) __sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706) __x64_sys_socket (net/socket.c:1718) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)  Freed by task 299 on cpu 2 at 78.328502s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) kasan_save_free_info (mm/kasan/generic.c:582) poison_slab_object (mm/kasan/common.c:242) __kasan_slab_free (mm/kasan/common.c:256) kmem_cache_free (mm/slub.c:4437 mm/slub.c:4511) __sk_destruct (net/core/sock.c:2117 net/core/sock.c:2208) inet_create (net/ipv4/af_inet.c:397 net/ipv4/af_inet.c:252) __sock_create (net/socket.c:1572) __sys_socket (net/socket.c:1660 net/socket.c:1644 net/socket.c:1706) __x64_sys_socket (net/socket.c:1718) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)  Fix this by clearing the struct socket reference in sk_common_release() to cover all protocol families create functions, which may already attached the reference to the sk object with sock_init_data().",
      "cve": "CVE-2024-40954",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40954",
          "value": "CVE-2024-40954",
          "url": "https://scout.docker.com/v/CVE-2024-40954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40954?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "46bbe717749c3078a4bef59a3f917759e2396413cdc3bf66f681ec24ad726666",
      "category": "container_scanning",
      "message": "CVE-2024-40989 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Disassociate vcpus from redistributor region on teardown  When tearing down a redistributor region, make sure we don't have any dangling pointer to that region stored in a vcpu.",
      "cve": "CVE-2024-40989",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-40989",
          "value": "CVE-2024-40989",
          "url": "https://scout.docker.com/v/CVE-2024-40989?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-40989?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "148e1e1c51cc1d1472589463dd9094c838cb142f5b550102aa058c76640cc625",
      "category": "container_scanning",
      "message": "CVE-2024-41045 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Defer work in bpf_timer_cancel_and_free  Currently, the same case as previous patch (two timer callbacks trying to cancel each other) can be invoked through bpf_map_update_elem as well, or more precisely, freeing map elements containing timers. Since this relies on hrtimer_cancel as well, it is prone to the same deadlock situation as the previous patch.  It would be sufficient to use hrtimer_try_to_cancel to fix this problem, as the timer cannot be enqueued after async_cancel_and_free. Once async_cancel_and_free has been done, the timer must be reinitialized before it can be armed again. The callback running in parallel trying to arm the timer will fail, and freeing bpf_hrtimer without waiting is sufficient (given kfree_rcu), and bpf_timer_cb will return HRTIMER_NORESTART, preventing the timer from being rearmed again.  However, there exists a UAF scenario where the callback arms the timer before entering this function, such that if cancellation fails (due to timer callback invoking this routine, or the target timer callback running concurrently). In such a case, if the timer expiration is significantly far in the future, the RCU grace period expiration happening before it will free the bpf_hrtimer state and along with it the struct hrtimer, that is enqueued.  Hence, it is clear cancellation needs to occur after async_cancel_and_free, and yet it cannot be done inline due to deadlock issues. We thus modify bpf_timer_cancel_and_free to defer work to the global workqueue, adding a work_struct alongside rcu_head (both used at _different_ points of time, so can share space).  Update existing code comments to reflect the new state of affairs.",
      "cve": "CVE-2024-41045",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41045",
          "value": "CVE-2024-41045",
          "url": "https://scout.docker.com/v/CVE-2024-41045?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41045?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "98047ed941d9c73dc0ad131fed56a840919b7f5c85d04d082f6220720d01b007",
      "category": "container_scanning",
      "message": "CVE-2024-41050 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: cyclic allocation of msg_id to avoid reuse  Reusing the msg_id after a maliciously completed reopen request may cause a read request to remain unprocessed and result in a hung, as shown below:  t1       |      t2       |      t3 ------------------------------------------------- cachefiles_ondemand_select_req cachefiles_ondemand_object_is_close(A) cachefiles_ondemand_set_object_reopening(A) queue_work(fscache_object_wq, &info->work) ondemand_object_worker cachefiles_ondemand_init_object(A) cachefiles_ondemand_send_req(OPEN) // get msg_id 6 wait_for_completion(&req_A->done) cachefiles_ondemand_daemon_read // read msg_id 6 req_A cachefiles_ondemand_get_fd copy_to_user // Malicious completion msg_id 6 copen 6,-1 cachefiles_ondemand_copen complete(&req_A->done) // will not set the object to close // because ondemand_id && fd is valid.  // ondemand_object_worker() is done // but the object is still reopening.  // new open req_B cachefiles_ondemand_init_object(B) cachefiles_ondemand_send_req(OPEN) // reuse msg_id 6 process_open_req copen 6,A.size // The expected failed copen was executed successfully  Expect copen to fail, and when it does, it closes fd, which sets the object to close, and then close triggers reopen again. However, due to msg_id reuse resulting in a successful copen, the anonymous fd is not closed until the daemon exits. Therefore read requests waiting for reopen to complete may trigger hung task.  To avoid this issue, allocate the msg_id cyclically to avoid reusing the msg_id for a very short duration of time.",
      "cve": "CVE-2024-41050",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41050",
          "value": "CVE-2024-41050",
          "url": "https://scout.docker.com/v/CVE-2024-41050?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41050?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "971e0004ceed03c57da4d2d55884ff0b5b8d6a1e403fff1a00673ade1a1cd9c2",
      "category": "container_scanning",
      "message": "CVE-2024-41069 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ASoC: topology: Fix references to freed memory  Most users after parsing a topology file, release memory used by it, so having pointer references directly into topology file contents is wrong. Use devm_kmemdup(), to allocate memory as needed.",
      "cve": "CVE-2024-41069",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41069",
          "value": "CVE-2024-41069",
          "url": "https://scout.docker.com/v/CVE-2024-41069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41069?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e67e20d28a5656336eefe1c7066a3f6ac1bd2fac21532e8356ecf4342216d85",
      "category": "container_scanning",
      "message": "CVE-2024-41074 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cachefiles: Set object to close if ondemand_id < 0 in copen  If copen is maliciously called in the user mode, it may delete the request corresponding to the random id. And the request may have not been read yet.  Note that when the object is set to reopen, the open request will be done with the still reopen state in above case. As a result, the request corresponding to this object is always skipped in select_req function, so the read request is never completed and blocks other process.  Fix this issue by simply set object to close if its id < 0 in copen.",
      "cve": "CVE-2024-41074",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-41074",
          "value": "CVE-2024-41074",
          "url": "https://scout.docker.com/v/CVE-2024-41074?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-41074?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "72b943131fceeb26127dd886f15a6d99ad29d8fce04e798fd8eed01b13b4159a",
      "category": "container_scanning",
      "message": "CVE-2024-42117 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: ASSERT when failing to find index by plane/stream id  [WHY] find_disp_cfg_idx_by_plane_id and find_disp_cfg_idx_by_stream_id returns an array index and they return -1 when not found; however, -1 is not a valid index number.  [HOW] When this happens, call ASSERT(), and return a positive number (which is fewer than callers' array size) instead.  This fixes 4 OVERRUN and 2 NEGATIVE_RETURNS issues reported by Coverity.",
      "cve": "CVE-2024-42117",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42117",
          "value": "CVE-2024-42117",
          "url": "https://scout.docker.com/v/CVE-2024-42117?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42117?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8de26e3549613afdb65cd6ea821d09053e09ef2fd8159d5f561ff95373dccbe3",
      "category": "container_scanning",
      "message": "CVE-2024-42118 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Do not return negative stream id for array  [WHY] resource_stream_to_stream_idx returns an array index and it return -1 when not found; however, -1 is not a valid array index number.  [HOW] When this happens, call ASSERT(), and return a zero instead.  This fixes an OVERRUN and an NEGATIVE_RETURNS issues reported by Coverity.",
      "cve": "CVE-2024-42118",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42118",
          "value": "CVE-2024-42118",
          "url": "https://scout.docker.com/v/CVE-2024-42118?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42118?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1116b80289d1455a2b679e065ddbdbeee0538e6ad558bf7b35dd46b1b96d2d16",
      "category": "container_scanning",
      "message": "CVE-2024-42147 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  crypto: hisilicon/debugfs - Fix debugfs uninit process issue  During the zip probe process, the debugfs failure does not stop the probe. When debugfs initialization fails, jumping to the error branch will also release regs, in addition to its own rollback operation.  As a result, it may be released repeatedly during the regs uninit process. Therefore, the null check needs to be added to the regs uninit process.",
      "cve": "CVE-2024-42147",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-42147",
          "value": "CVE-2024-42147",
          "url": "https://scout.docker.com/v/CVE-2024-42147?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-42147?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ae1fc1c88449aa9913a99f55d05df9eecbde24743db794b61c62b432ceca8867",
      "category": "container_scanning",
      "message": "CVE-2024-43842 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw89: Fix array index mistake in rtw89_sta_info_get_iter()  In rtw89_sta_info_get_iter() 'status->he_gi' is compared to array size. But then 'rate->he_gi' is used as array index instead of 'status->he_gi'. This can lead to go beyond array boundaries in case of 'rate->he_gi' is not equal to 'status->he_gi' and is bigger than array size. Looks like \"copy-paste\" mistake.  Fix this mistake by replacing 'rate->he_gi' with 'status->he_gi'.  Found by Linux Verification Center (linuxtesting.org) with SVACE.",
      "cve": "CVE-2024-43842",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-43842",
          "value": "CVE-2024-43842",
          "url": "https://scout.docker.com/v/CVE-2024-43842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-43842?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e9b8c4046ba748fd2ca7f4524aa50d326789bfdd57812fc7adbd0742917cd98f",
      "category": "container_scanning",
      "message": "CVE-2024-46729 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix incorrect size calculation for loop  [WHY] fe_clk_en has size of 5 but sizeof(fe_clk_en) has byte size 20 which is lager than the array size.  [HOW] Divide byte size 20 by its element size.  This fixes 2 OVERRUN issues reported by Coverity.",
      "cve": "CVE-2024-46729",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46729",
          "value": "CVE-2024-46729",
          "url": "https://scout.docker.com/v/CVE-2024-46729?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46729?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "23589399986cf3d6d9ad290eb9ed64c8b6dfb771e4812410fe09f4d38f8b5318",
      "category": "container_scanning",
      "message": "CVE-2024-46811 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box  [Why] Coverity reports OVERRUN warning. soc.num_states could be 40. But array range of bw_params->clk_table.entries is 8.  [How] Assert if soc.num_states greater than 8.",
      "cve": "CVE-2024-46811",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46811",
          "value": "CVE-2024-46811",
          "url": "https://scout.docker.com/v/CVE-2024-46811?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46811?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ad8fdca3ff6243bc12ea8db2f280045727b9a6550e10220d6447b5f056840326",
      "category": "container_scanning",
      "message": "CVE-2024-46813 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check link_index before accessing dc->links[]  [WHY & HOW] dc->links[] has max size of MAX_LINKS and NULL is return when trying to access with out-of-bound index.  This fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.",
      "cve": "CVE-2024-46813",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46813",
          "value": "CVE-2024-46813",
          "url": "https://scout.docker.com/v/CVE-2024-46813?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46813?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "921c11bb2abfafccd56ef989394530deb16433f45958367db99463921ccb7fa8",
      "category": "container_scanning",
      "message": "CVE-2024-46820 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu/vcn: remove irq disabling in vcn 5 suspend  We do not directly enable/disable VCN IRQ in vcn 5.0.0. And we do not handle the IRQ state as well. So the calls to disable IRQ and set state are removed. This effectively gets rid of the warining of \"WARN_ON(!amdgpu_irq_enabled(adev, src, type))\" in amdgpu_irq_put().",
      "cve": "CVE-2024-46820",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46820",
          "value": "CVE-2024-46820",
          "url": "https://scout.docker.com/v/CVE-2024-46820?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46820?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "198e80b757fb65544adeecdafb47a04ed97f408c8ca6dd40bf81bb44342bbec5",
      "category": "container_scanning",
      "message": "CVE-2024-46830 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  KVM: x86: Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTS  Grab kvm->srcu when processing KVM_SET_VCPU_EVENTS, as KVM will forcibly leave nested VMX/SVM if SMM mode is being toggled, and leaving nested VMX reads guest memory.  Note, kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUN via sync_regs(), which already holds SRCU.  I.e. trying to precisely use kvm_vcpu_srcu_read_lock() around the problematic SMM code would cause problems.  Acquiring SRCU isn't all that expensive, so for simplicity, grab it unconditionally for KVM_SET_VCPU_EVENTS.  ============================= WARNING: suspicious RCU usage 6.10.0-rc7-332d2c1d713e-next-vm #552 Not tainted ----------------------------- include/linux/kvm_host.h:1027 suspicious rcu_dereference_check() usage!  other info that might help us debug this:  rcu_scheduler_active = 2, debug_locks = 1 1 lock held by repro/1071: #0: ffff88811e424430 (&vcpu->mutex){+.+.}-{3:3}, at: kvm_vcpu_ioctl+0x7d/0x970 [kvm]  stack backtrace: CPU: 15 PID: 1071 Comm: repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015 Call Trace: <TASK> dump_stack_lvl+0x7f/0x90 lockdep_rcu_suspicious+0x13f/0x1a0 kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm] kvm_vcpu_read_guest+0x3e/0x90 [kvm] nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel] load_vmcs12_host_state+0x432/0xb40 [kvm_intel] vmx_leave_nested+0x30/0x40 [kvm_intel] kvm_vcpu_ioctl_x86_set_vcpu_events+0x15d/0x2b0 [kvm] kvm_arch_vcpu_ioctl+0x1107/0x1750 [kvm] ? mark_held_locks+0x49/0x70 ? kvm_vcpu_ioctl+0x7d/0x970 [kvm] ? kvm_vcpu_ioctl+0x497/0x970 [kvm] kvm_vcpu_ioctl+0x497/0x970 [kvm] ? lock_acquire+0xba/0x2d0 ? find_held_lock+0x2b/0x80 ? do_user_addr_fault+0x40c/0x6f0 ? lock_release+0xb7/0x270 __x64_sys_ioctl+0x82/0xb0 do_syscall_64+0x6c/0x170 entry_SYSCALL_64_after_hwframe+0x4b/0x53 RIP: 0033:0x7ff11eb1b539 </TASK>",
      "cve": "CVE-2024-46830",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46830",
          "value": "CVE-2024-46830",
          "url": "https://scout.docker.com/v/CVE-2024-46830?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46830?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1d2239bd2bb5106eac81c00a46b2ba1b5fa6c34beed3add896c9bccc0fdd338d",
      "category": "container_scanning",
      "message": "CVE-2024-46833 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  net: hns3: void array out of bound when loop tnl_num  When query reg inf of SSU, it loops tnl_num times. However, tnl_num comes from hardware and the length of array is a fixed value. To void array out of bound, make sure the loop time is not greater than the length of array",
      "cve": "CVE-2024-46833",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46833",
          "value": "CVE-2024-46833",
          "url": "https://scout.docker.com/v/CVE-2024-46833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46833?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec270d328e5e3258ad72712885ea5f3c1963472ae0feaca8402d97d3f19889b7",
      "category": "container_scanning",
      "message": "CVE-2024-46836 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  usb: gadget: aspeed_udc: validate endpoint index for ast udc  We should verify the bound of the array to assure that host may not manipulate the index to point past endpoint array.  Found by static analysis.",
      "cve": "CVE-2024-46836",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-46836",
          "value": "CVE-2024-46836",
          "url": "https://scout.docker.com/v/CVE-2024-46836?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-46836?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f6ce5179a940c7da25f644d1af433eff6f3f1f531b34ed7d4f184df8c9914949",
      "category": "container_scanning",
      "message": "CVE-2024-47745 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  mm: call the security_mmap_file() LSM hook in remap_file_pages()  The remap_file_pages syscall handler calls do_mmap() directly, which doesn't contain the LSM security check. And if the process has called personality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for RW pages, this will actually result in remapping the pages to RWX, bypassing a W^X policy enforced by SELinux.  So we should check prot by security_mmap_file LSM hook in the remap_file_pages syscall handler before do_mmap() is called. Otherwise, it potentially permits an attacker to bypass a W^X policy enforced by SELinux.  The bypass is similar to CVE-2016-10044, which bypass the same thing via AIO and can be found in [1].  The PoC:  $ cat > test.c  int main(void) { size_t pagesz = sysconf(_SC_PAGE_SIZE); int mfd = syscall(SYS_memfd_create, \"test\", 0); const char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE, MAP_SHARED, mfd, 0); unsigned int old = syscall(SYS_personality, 0xffffffff); syscall(SYS_personality, READ_IMPLIES_EXEC | old); syscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0); syscall(SYS_personality, old); // show the RWX page exists even if W^X policy is enforced int fd = open(\"/proc/self/maps\", O_RDONLY); unsigned char buf2[1024]; while (1) { int ret = read(fd, buf2, 1024); if (ret <= 0) break; write(1, buf2, ret); } close(fd); }  $ gcc test.c -o test $ ./test | grep rwx 7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted)  [PM: subject line tweaks]",
      "cve": "CVE-2024-47745",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-47745",
          "value": "CVE-2024-47745",
          "url": "https://scout.docker.com/v/CVE-2024-47745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-47745?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "0a04482a747eba5983047a52a4ad082ebb9a34e83c3aed3fd07018f392581756",
      "category": "container_scanning",
      "message": "CVE-2024-49880 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ext4: fix off by one issue in alloc_flex_gd()  Wesley reported an issue:  ================================================================== EXT4-fs (dm-5): resizing filesystem from 7168 to 786432 blocks ------------[ cut here ]------------ kernel BUG at fs/ext4/resize.c:324! CPU: 9 UID: 0 PID: 3576 Comm: resize2fs Not tainted 6.11.0+ #27 RIP: 0010:ext4_resize_fs+0x1212/0x12d0 Call Trace: __ext4_ioctl+0x4e0/0x1800 ext4_ioctl+0x12/0x20 __x64_sys_ioctl+0x99/0xd0 x64_sys_call+0x1206/0x20d0 do_syscall_64+0x72/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e ==================================================================  While reviewing the patch, Honza found that when adjusting resize_bg in alloc_flex_gd(), it was possible for flex_gd->resize_bg to be bigger than flexbg_size.  The reproduction of the problem requires the following:  o_group = flexbg_size * 2 * n; o_size = (o_group + 1) * group_size; n_group: [o_group + flexbg_size, o_group + flexbg_size * 2) o_size = (n_group + 1) * group_size;  Take n=0,flexbg_size=16 as an example:  last:15 |o---------------|--------------n-| o_group:0    resize to      n_group:30  The corresponding reproducer is:  img=test.img rm -f $img truncate -s 600M $img mkfs.ext4 -F $img -b 1024 -G 16 8M dev=`losetup -f --show $img` mkdir -p /tmp/test mount $dev /tmp/test resize2fs $dev 248M  Delete the problematic plus 1 to fix the issue, and add a WARN_ON_ONCE() to prevent the issue from happening again.  [ Note: another reproucer which this commit fixes is:  img=test.img rm -f $img truncate -s 25MiB $img mkfs.ext4 -b 4096 -E nodiscard,lazy_itable_init=0,lazy_journal_init=0 $img truncate -s 3GiB $img dev=`losetup -f --show $img` mkdir -p /tmp/test mount $dev /tmp/test resize2fs $dev 3G umount $dev losetup -d $dev  -- TYT ]",
      "cve": "CVE-2024-49880",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49880",
          "value": "CVE-2024-49880",
          "url": "https://scout.docker.com/v/CVE-2024-49880?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49880?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "62460936fb3415291ee4e217ae398bf8905f67c19a4d2afe9535a69046d743fa",
      "category": "container_scanning",
      "message": "CVE-2024-49931 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: ath12k: fix array out-of-bound access in SoC stats  Currently, the ath12k_soc_dp_stats::hal_reo_error array is defined with a maximum size of DP_REO_DST_RING_MAX. However, the ath12k_dp_rx_process() function access ath12k_soc_dp_stats::hal_reo_error using the REO destination SRNG ring ID, which is incorrect. SRNG ring ID differ from normal ring ID, and this usage leads to out-of-bounds array access. To fix this issue, modify ath12k_dp_rx_process() to use the normal ring ID directly instead of the SRNG ring ID to avoid out-of-bounds array access.  Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
      "cve": "CVE-2024-49931",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49931",
          "value": "CVE-2024-49931",
          "url": "https://scout.docker.com/v/CVE-2024-49931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49931?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b1758f9ee2c2cab27d87ba1e3213a925d6c1b6d760fcc5a68a95b7f062de77ab",
      "category": "container_scanning",
      "message": "CVE-2024-49991 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer  Pass pointer reference to amdgpu_bo_unref to clear the correct pointer, otherwise amdgpu_bo_unref clear the local variable, the original pointer not set to NULL, this could cause use-after-free bug.",
      "cve": "CVE-2024-49991",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49991",
          "value": "CVE-2024-49991",
          "url": "https://scout.docker.com/v/CVE-2024-49991?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49991?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2f233cfa97268d63c3eab9b903ff657ddb502b6b7b01ccc3ce1e4cb178f72cc8",
      "category": "container_scanning",
      "message": "CVE-2024-49992 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/stm: Avoid use-after-free issues with crtc and plane  ltdc_load() calls functions drm_crtc_init_with_planes(), drm_universal_plane_init() and drm_encoder_init(). These functions should not be called with parameters allocated with devm_kzalloc() to avoid use-after-free issues [1].  Use allocations managed by the DRM framework.  Found by Linux Verification Center (linuxtesting.org).  [1] https://lore.kernel.org/lkml/u366i76e3qhh3ra5oxrtngjtm2u5lterkekcz6y2jkndhuxzli@diujon4h7qwb/",
      "cve": "CVE-2024-49992",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-49992",
          "value": "CVE-2024-49992",
          "url": "https://scout.docker.com/v/CVE-2024-49992?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-49992?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7b292dc082f9dd481a39804755aa4667577f08facbd6ede162bacf3b6934eebe",
      "category": "container_scanning",
      "message": "CVE-2024-50063 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Prevent tail call between progs attached to different hooks  bpf progs can be attached to kernel functions, and the attached functions can take different parameters or return different return values. If prog attached to one kernel function tail calls prog attached to another kernel function, the ctx access or return value verification could be bypassed.  For example, if prog1 is attached to func1 which takes only 1 parameter and prog2 is attached to func2 which takes two parameters. Since verifier assumes the bpf ctx passed to prog2 is constructed based on func2's prototype, verifier allows prog2 to access the second parameter from the bpf ctx passed to it. The problem is that verifier does not prevent prog1 from passing its bpf ctx to prog2 via tail call. In this case, the bpf ctx passed to prog2 is constructed from func1 instead of func2, that is, the assumption for ctx access verification is bypassed.  Another example, if BPF LSM prog1 is attached to hook file_alloc_security, and BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier knows the return value rules for these two hooks, e.g. it is legal for bpf_lsm_audit_rule_known to return positive number 1, and it is illegal for file_alloc_security to return positive number. So verifier allows prog2 to return positive number 1, but does not allow prog1 to return positive number. The problem is that verifier does not prevent prog1 from calling prog2 via tail call. In this case, prog2's return value 1 will be used as the return value for prog1's hook file_alloc_security. That is, the return value rule is bypassed.  This patch adds restriction for tail call to prevent such bypasses.",
      "cve": "CVE-2024-50063",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50063",
          "value": "CVE-2024-50063",
          "url": "https://scout.docker.com/v/CVE-2024-50063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50063?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8955b055de2b811b00d3b6fd0d69d22e92a8768559317f3891e267dd1a068dd1",
      "category": "container_scanning",
      "message": "CVE-2024-50112 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  x86/lam: Disable ADDRESS_MASKING in most cases  Linear Address Masking (LAM) has a weakness related to transient execution as described in the SLAM paper[1]. Unless Linear Address Space Separation (LASS) is enabled this weakness may be exploitable.  Until kernel adds support for LASS[2], only allow LAM for COMPILE_TEST, or when speculation mitigations have been disabled at compile time, otherwise keep LAM disabled.  There are no processors in market that support LAM yet, so currently nobody is affected by this issue.  [1] SLAM: https://download.vusec.net/papers/slam_sp24.pdf [2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/  [ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ]",
      "cve": "CVE-2024-50112",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50112",
          "value": "CVE-2024-50112",
          "url": "https://scout.docker.com/v/CVE-2024-50112?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50112?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1bf958f484dc47bf72eb4b256f919856d16304775eb831acc188f6c058a65a71",
      "category": "container_scanning",
      "message": "CVE-2024-50246 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  fs/ntfs3: Add rough attr alloc_size check",
      "cve": "CVE-2024-50246",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-50246",
          "value": "CVE-2024-50246",
          "url": "https://scout.docker.com/v/CVE-2024-50246?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-50246?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8eb21e5049266353a4b95119f2dca6821e5b0bcbfc99555709aa16d89314679b",
      "category": "container_scanning",
      "message": "CVE-2024-53098 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/xe/ufence: Prefetch ufence addr to catch bogus address  access_ok() only checks for addr overflow so also try to read the addr to catch invalid addr sent from userspace.  (cherry picked from commit 9408c4508483ffc60811e910a93d6425b8e63928)",
      "cve": "CVE-2024-53098",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53098",
          "value": "CVE-2024-53098",
          "url": "https://scout.docker.com/v/CVE-2024-53098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53098?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "8639924f29406b60f0a2d861bdaa7c20b25732e69f4fef9bd5a5e8940e6dac59",
      "category": "container_scanning",
      "message": "CVE-2024-53133 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Handle dml allocation failure to avoid crash  [Why] In the case where a dml allocation fails for any reason, the current state's dml contexts would no longer be valid. Then subsequent calls dc_state_copy_internal would shallow copy invalid memory and if the new state was released, a double free would occur.  [How] Reset dml pointers in new_state to NULL and avoid invalid pointer  (cherry picked from commit bcafdc61529a48f6f06355d78eb41b3aeda5296c)",
      "cve": "CVE-2024-53133",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53133",
          "value": "CVE-2024-53133",
          "url": "https://scout.docker.com/v/CVE-2024-53133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53133?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "1393633a326209c8b903ddd8aa4604d110fb90ae7ee57d3156cff01700f7da9b",
      "category": "container_scanning",
      "message": "CVE-2024-54456 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  NFS: Fix potential buffer overflowin nfs_sysfs_link_rpc_client()  name is char[64] where the size of clnt->cl_program->name remains unknown. Invoking strcat() directly will also lead to potential buffer overflow. Change them to strscpy() and strncat() to fix potential issues.",
      "cve": "CVE-2024-54456",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-54456",
          "value": "CVE-2024-54456",
          "url": "https://scout.docker.com/v/CVE-2024-54456?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-54456?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "a5f62972587c059d69deeb3e768031572ec23c95e597ac0554cb2b6932d4648d",
      "category": "container_scanning",
      "message": "CVE-2024-56538 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm: zynqmp_kms: Unplug DRM device before removal  Prevent userspace accesses to the DRM device from causing use-after-frees by unplugging the device before we remove it. This causes any further userspace accesses to result in an error without further calls into this driver's internals.",
      "cve": "CVE-2024-56538",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56538",
          "value": "CVE-2024-56538",
          "url": "https://scout.docker.com/v/CVE-2024-56538?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56538?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "13441b4a0be0ce6efc1e6799c36be683159d58016a1e8ff933825e31f4f8af97",
      "category": "container_scanning",
      "message": "CVE-2024-56604 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc()  bt_sock_alloc() attaches allocated sk object to the provided sock object. If rfcomm_dlc_alloc() fails, we release the sk object, but leave the dangling pointer in the sock object, which may cause use-after-free.  Fix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().",
      "cve": "CVE-2024-56604",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56604",
          "value": "CVE-2024-56604",
          "url": "https://scout.docker.com/v/CVE-2024-56604?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56604?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "eeb870ee882077c47b560eaed8ba130a0573d0b4f8704a67d439500b3ad0748c",
      "category": "container_scanning",
      "message": "CVE-2024-56609 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skb  When removing kernel modules by: rmmod rtw88_8723cs rtw88_8703b rtw88_8723x rtw88_sdio rtw88_core  Driver uses skb_queue_purge() to purge TX skb, but not report tx status causing \"Have pending ack frames!\" warning. Use ieee80211_purge_tx_queue() to correct this.  Since ieee80211_purge_tx_queue() doesn't take locks, to prevent racing between TX work and purge TX queue, flush and destroy TX work in advance.  wlan0: deauthenticating from aa:f5:fd:60:4c:a8 by local choice (Reason: 3=DEAUTH_LEAVING) ------------[ cut here ]------------ Have pending ack frames! WARNING: CPU: 3 PID: 9232 at net/mac80211/main.c:1691 ieee80211_free_ack_frame+0x5c/0x90 [mac80211] CPU: 3 PID: 9232 Comm: rmmod Tainted: G         C 6.10.1-200.fc40.aarch64 #1 Hardware name: pine64 Pine64 PinePhone Braveheart (1.1)/Pine64 PinePhone Braveheart (1.1), BIOS 2024.01 01/01/2024 pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : ieee80211_free_ack_frame+0x5c/0x90 [mac80211] lr : ieee80211_free_ack_frame+0x5c/0x90 [mac80211] sp : ffff80008c1b37b0 x29: ffff80008c1b37b0 x28: ffff000003be8000 x27: 0000000000000000 x26: 0000000000000000 x25: ffff000003dc14b8 x24: ffff80008c1b37d0 x23: ffff000000ff9f80 x22: 0000000000000000 x21: 000000007fffffff x20: ffff80007c7e93d8 x19: ffff00006e66f400 x18: 0000000000000000 x17: ffff7ffffd2b3000 x16: ffff800083fc0000 x15: 0000000000000000 x14: 0000000000000000 x13: 2173656d61726620 x12: 6b636120676e6964 x11: 0000000000000000 x10: 000000000000005d x9 : ffff8000802af2b0 x8 : ffff80008c1b3430 x7 : 0000000000000001 x6 : 0000000000000001 x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000 x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000003be8000 Call trace: ieee80211_free_ack_frame+0x5c/0x90 [mac80211] idr_for_each+0x74/0x110 ieee80211_free_hw+0x44/0xe8 [mac80211] rtw_sdio_remove+0x9c/0xc0 [rtw88_sdio] sdio_bus_remove+0x44/0x180 device_remove+0x54/0x90 device_release_driver_internal+0x1d4/0x238 driver_detach+0x54/0xc0 bus_remove_driver+0x78/0x108 driver_unregister+0x38/0x78 sdio_unregister_driver+0x2c/0x40 rtw_8723cs_driver_exit+0x18/0x1000 [rtw88_8723cs] __do_sys_delete_module.isra.0+0x190/0x338 __arm64_sys_delete_module+0x1c/0x30 invoke_syscall+0x74/0x100 el0_svc_common.constprop.0+0x48/0xf0 do_el0_svc+0x24/0x38 el0_svc+0x3c/0x158 el0t_64_sync_handler+0x120/0x138 el0t_64_sync+0x194/0x198 ---[ end trace 0000000000000000 ]---",
      "cve": "CVE-2024-56609",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56609",
          "value": "CVE-2024-56609",
          "url": "https://scout.docker.com/v/CVE-2024-56609?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56609?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "84df4de210ab5de3bfdd2da5e53972f4c4430f44fe91b0e9f346f9d0ae03e91e",
      "category": "container_scanning",
      "message": "CVE-2024-56775 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Fix handling of plane refcount  [Why] The mechanism to backup and restore plane states doesn't maintain refcount, which can cause issues if the refcount of the plane changes in between backup and restore operations, such as memory leaks if the refcount was supposed to go down, or double frees / invalid memory accesses if the refcount was supposed to go up.  [How] Cache and re-apply current refcount when restoring plane states.",
      "cve": "CVE-2024-56775",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56775",
          "value": "CVE-2024-56775",
          "url": "https://scout.docker.com/v/CVE-2024-56775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56775?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ea01382c956a294ddad2259ab93f9c01e3dd340f780221b765fb10322fc3ba7c",
      "category": "container_scanning",
      "message": "CVE-2024-56784 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Adding array index check to prevent memory corruption  [Why & How] Array indices out of bound caused memory corruption. Adding checks to ensure that array index stays in bound.",
      "cve": "CVE-2024-56784",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-56784",
          "value": "CVE-2024-56784",
          "url": "https://scout.docker.com/v/CVE-2024-56784?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-56784?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f3c3b13723b69dab4d7d05c07a92dca88fd4a94a7f0dfdf8aba3b3f3770bee28",
      "category": "container_scanning",
      "message": "CVE-2024-57887 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm: adv7511: Fix use-after-free in adv7533_attach_dsi()  The host_node pointer was assigned and freed in adv7533_parse_dt(), and later, adv7533_attach_dsi() uses the same. Fix this use-after-free issue bydropping of_node_put() in adv7533_parse_dt() and calling of_node_put() in error path of probe() and also in the remove().",
      "cve": "CVE-2024-57887",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57887",
          "value": "CVE-2024-57887",
          "url": "https://scout.docker.com/v/CVE-2024-57887?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57887?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "f6971f974b3ee20837460356b30992efa34845227b3adb0e15fcaaeecd25ee54",
      "category": "container_scanning",
      "message": "CVE-2024-57899 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  wifi: mac80211: fix mbss changed flags corruption on 32 bit systems  On 32-bit systems, the size of an unsigned long is 4 bytes, while a u64 is 8 bytes. Therefore, when using or_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE), the code is incorrectly searching for a bit in a 32-bit variable that is expected to be 64 bits in size, leading to incorrect bit finding.  Solution: Ensure that the size of the bits variable is correctly adjusted for each architecture.  Call Trace: ? show_regs+0x54/0x58 ? __warn+0x6b/0xd4 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? report_bug+0x113/0x150 ? exc_overflow+0x30/0x30 ? handle_bug+0x27/0x44 ? exc_invalid_op+0x18/0x50 ? handle_exception+0xf6/0xf6 ? exc_overflow+0x30/0x30 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? exc_overflow+0x30/0x30 ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211] ? ieee80211_mesh_work+0xff/0x260 [mac80211] ? cfg80211_wiphy_work+0x72/0x98 [cfg80211] ? process_one_work+0xf1/0x1fc ? worker_thread+0x2c0/0x3b4 ? kthread+0xc7/0xf0 ? mod_delayed_work_on+0x4c/0x4c ? kthread_complete_and_exit+0x14/0x14 ? ret_from_fork+0x24/0x38 ? kthread_complete_and_exit+0x14/0x14 ? ret_from_fork_asm+0xf/0x14 ? entry_INT80_32+0xf0/0xf0  [restore no-op path for no changes]",
      "cve": "CVE-2024-57899",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-57899",
          "value": "CVE-2024-57899",
          "url": "https://scout.docker.com/v/CVE-2024-57899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-57899?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2475ec3002d231ee0714fbdc3173015ab63e5b01a9b9e90db7890a92e6fbdc6a",
      "category": "container_scanning",
      "message": "CVE-2024-9287 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment \"activation\" scripts (ie \"source venv/bin/activate\"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie \"./venv/bin/python\") are not affected.",
      "cve": "CVE-2024-9287",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-9287",
          "value": "CVE-2024-9287",
          "url": "https://scout.docker.com/v/CVE-2024-9287?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-9287?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "9b5e4fb867f2d89403a183d7850949aed7edd8d6220ed6b1f3a14c2d334461fd",
      "category": "container_scanning",
      "message": "CVE-2025-21780 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table()  It malicious user provides a small pptable through sysfs and then a bigger pptable, it may cause buffer overflow attack in function smu_sys_set_pp_table().",
      "cve": "CVE-2025-21780",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21780",
          "value": "CVE-2025-21780",
          "url": "https://scout.docker.com/v/CVE-2025-21780?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21780?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "30de277d923653fd0df5d5d7c0c0f058f34e6dc414c31d10e8a2deb8787f0f94",
      "category": "container_scanning",
      "message": "CVE-2025-21863 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  io_uring: prevent opcode speculation  sqe->opcode is used for different tables, make sure we santitise it against speculations.",
      "cve": "CVE-2025-21863",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21863",
          "value": "CVE-2025-21863",
          "url": "https://scout.docker.com/v/CVE-2025-21863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21863?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "159575866420c934f53ed32b0a2b2f44f8226773e999f46c69839a8200dcb7e4",
      "category": "container_scanning",
      "message": "CVE-2025-21915 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  cdx: Fix possible UAF error in driver_override_show()  Fixed a possible UAF problem in driver_override_show() in drivers/cdx/cdx.c  This function driver_override_show() is part of DEVICE_ATTR_RW, which includes both driver_override_show() and driver_override_store(). These functions can be executed concurrently in sysfs.  The driver_override_store() function uses driver_set_override() to update the driver_override value, and driver_set_override() internally locks the device (device_lock(dev)). If driver_override_show() reads cdx_dev->driver_override without locking, it could potentially access a freed pointer if driver_override_store() frees the string concurrently. This could lead to printing a kernel address, which is a security risk since DEVICE_ATTR can be read by all users.  Additionally, a similar pattern is used in drivers/amba/bus.c, as well as many other bus drivers, where device_lock() is taken in the show function, and it has been working without issues.  This potential bug was detected by our experimental static analysis tool, which analyzes locking APIs and paired functions to identify data races and atomicity violations.",
      "cve": "CVE-2025-21915",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21915",
          "value": "CVE-2025-21915",
          "url": "https://scout.docker.com/v/CVE-2025-21915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21915?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2464f1638c87bc898d8300a4ce03627c2e8f02d417c99565a03860c0004ca916",
      "category": "container_scanning",
      "message": "CVE-2025-21927 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  nvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()  nvme_tcp_recv_pdu() doesn't check the validity of the header length. When header digests are enabled, a target might send a packet with an invalid header length (e.g. 255), causing nvme_tcp_verify_hdgst() to access memory outside the allocated area and cause memory corruptions by overwriting it with the calculated digest.  Fix this by rejecting packets with an unexpected header length.",
      "cve": "CVE-2025-21927",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21927",
          "value": "CVE-2025-21927",
          "url": "https://scout.docker.com/v/CVE-2025-21927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21927?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "7e1439108148fc943dc7cd73060cdebc862f75a9806586253925b7c94ab93233",
      "category": "container_scanning",
      "message": "CVE-2025-21945 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in smb2_lock  If smb_lock->zero_len has value, ->llist of smb_lock is not delete and flock is old one. It will cause use-after-free on error handling routine.",
      "cve": "CVE-2025-21945",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21945",
          "value": "CVE-2025-21945",
          "url": "https://scout.docker.com/v/CVE-2025-21945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21945?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b8a3c1a87609cb064359a6c9f92bfca535b80b75b2e91c45c0e831a2afe3d0a1",
      "category": "container_scanning",
      "message": "CVE-2025-21967 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix use-after-free in ksmbd_free_work_struct  ->interim_entry of ksmbd_work could be deleted after oplock is freed. We don't need to manage it with linked list. The interim request could be immediately sent whenever a oplock break wait is needed.",
      "cve": "CVE-2025-21967",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21967",
          "value": "CVE-2025-21967",
          "url": "https://scout.docker.com/v/CVE-2025-21967?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21967?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bf57df4a84b9b159acd0be6895158ca96d9364bfe4ab37a3458818b34bcf8e66",
      "category": "container_scanning",
      "message": "CVE-2025-21969 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd  After the hci sync command releases l2cap_conn, the hci receive data work queue references the released l2cap_conn when sending to the upper layer. Add hci dev lock to the hci receive data work queue to synchronize the two.  [1] BUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 Read of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837  CPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci1 hci_rx_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline] l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline] l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline] l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817 hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline] hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK>  Allocated by task 5837: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860 l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726 hci_event_func net/bluetooth/hci_event.c:7473 [inline] hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525 hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  Freed by task 54: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2353 [inline] slab_free mm/slub.c:4613 [inline] kfree+0x196/0x430 mm/slub.c:4761 l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266 hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr ---truncated---",
      "cve": "CVE-2025-21969",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-21969",
          "value": "CVE-2025-21969",
          "url": "https://scout.docker.com/v/CVE-2025-21969?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-21969?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "54b226dd388da16a3ab6c96ccddc6cfc3d5d76a1b4cce53015511ead7a19c2cb",
      "category": "container_scanning",
      "message": "CVE-2025-5244 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability was found in GNU Binutils up to 2.44. It has been rated as critical. Affected by this issue is the function elf_gc_sweep of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. Upgrading to version 2.45 is able to address this issue. It is recommended to upgrade the affected component.",
      "cve": "CVE-2025-5244",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-5244",
          "value": "CVE-2025-5244",
          "url": "https://scout.docker.com/v/CVE-2025-5244?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-5244?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "61e2de573a18ef01fa452bea9116e95802a089c8cffaf459cf5128fc7a32418e",
      "category": "container_scanning",
      "message": "CVE-2025-5245 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability classified as critical has been found in GNU Binutils up to 2.44. This affects the function debug_type_samep of the file /binutils/debug.c of the component objdump. The manipulation leads to memory corruption. Local access is required to approach this attack. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.",
      "cve": "CVE-2025-5245",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-5245",
          "value": "CVE-2025-5245",
          "url": "https://scout.docker.com/v/CVE-2025-5245?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-5245?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ec35cdf2d16d92704375636b17531056e91485edb70ab972f4545dfec46be5cf",
      "category": "container_scanning",
      "message": "CVE-2025-55154 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to versions 6.9.13-27 and 7.1.2-1, the magnified size calculations in ReadOneMNGIMage (in coders/png.c) are unsafe and can overflow, leading to memory corruption. This issue has been patched in versions 6.9.13-27 and 7.1.2-1.",
      "cve": "CVE-2025-55154",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-55154",
          "value": "CVE-2025-55154",
          "url": "https://scout.docker.com/v/CVE-2025-55154?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-55154?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "27b2baa981fdb988ea96433a1270f5fffff9974c53751a361cfd669a37f4c1d0",
      "category": "container_scanning",
      "message": "CVE-2025-7545 on ubuntu/binutils@2.38-4ubuntu2.10",
      "description": "A vulnerability classified as problematic was found in GNU Binutils 2.45. Affected by this vulnerability is the function copy_section of the file binutils/objcopy.c. The manipulation leads to heap-based buffer overflow. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. The patch is named 08c3cbe5926e4d355b5cb70bbec2b1eeb40c2944. It is recommended to apply a patch to fix this issue.",
      "cve": "CVE-2025-7545",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/binutils@2.38-4ubuntu2.10?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "2.38-4ubuntu2.10"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-7545",
          "value": "CVE-2025-7545",
          "url": "https://scout.docker.com/v/CVE-2025-7545?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-7545?s=ubuntu&n=binutils&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dfd6382bf17a09713741c8d490c97a5de055874d3d27c854ca38e40d5ad10fbb",
      "category": "container_scanning",
      "message": "CVE-2025-47273 on ubuntu/python-pip@22.0.2+dfsg-1ubuntu0.7",
      "description": "setuptools is a package that allows users to download, build, install, upgrade, and uninstall Python packages. A path traversal vulnerability in `PackageIndex` is present in setuptools prior to version 78.1.1. An attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to remote code execution depending on the context. Version 78.1.1 fixes the issue.",
      "cve": "CVE-2025-47273",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python-pip@22.0.2%2Bdfsg-1ubuntu0.7?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "22.0.2+dfsg-1ubuntu0.7"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-47273",
          "value": "CVE-2025-47273",
          "url": "https://scout.docker.com/v/CVE-2025-47273?s=ubuntu&n=python-pip&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-47273?s=ubuntu&n=python-pip&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "2b4b580d558fb7990c0c5fa457790a006f2a947937cbead9754f2a7e1328da28",
      "category": "container_scanning",
      "message": "CVE-2025-55298 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to ImageMagick versions 6.9.13-28 and 7.1.2-2, a format string bug vulnerability exists in InterpretImageFilename function where user input is directly passed to FormatLocaleString without proper sanitization. An attacker can overwrite arbitrary memory regions, enabling a wide range of attacks from heap overflow to remote code execution. This issue has been patched in versions 6.9.13-28 and 7.1.2-2.",
      "cve": "CVE-2025-55298",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-55298",
          "value": "CVE-2025-55298",
          "url": "https://scout.docker.com/v/CVE-2025-55298?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-55298?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "bc5b038bc932eefebd9f4615cd58f97f074d069a7e019e8236c5ef529127cda9",
      "category": "container_scanning",
      "message": "CVE-2025-57803 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Prior to versions 6.9.13-28 and 7.1.2-2 for ImageMagick's 32-bit build, a 32-bit integer overflow in the BMP encoders scanline-stride computation collapses bytes_per_line (stride) to a tiny value while the per-row writer still emits 3  width bytes for 24-bpp images. The row base pointer advances using the (overflowed) stride, so the first row immediately writes past its slot and into adjacent heap memory with attacker-controlled bytes. This is a classic, powerful primitive for heap corruption in common auto-convert pipelines. This issue has been patched in versions 6.9.13-28 and 7.1.2-2.",
      "cve": "CVE-2025-57803",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-57803",
          "value": "CVE-2025-57803",
          "url": "https://scout.docker.com/v/CVE-2025-57803?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-57803?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "ee39cc359ce02ce82d54aaa6459b5a1dd72295a5d9f9b490950727224af9bd6a",
      "category": "container_scanning",
      "message": "CVE-2025-53014 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. Versions prior to 7.1.2-0 and 6.9.13-26 have a heap buffer overflow in the `InterpretImageFilename` function. The issue stems from an off-by-one error that causes out-of-bounds memory access when processing format strings containing consecutive percent signs (`%%`). Versions 7.1.2-0 and 6.9.13-26 fix the issue.",
      "cve": "CVE-2025-53014",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-53014",
          "value": "CVE-2025-53014",
          "url": "https://scout.docker.com/v/CVE-2025-53014?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-53014?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "d6aa7877e4d9cecb611c6bbf84596631cc5152f35415f61631263e7fcbef4fef",
      "category": "container_scanning",
      "message": "CVE-2025-53101 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. In versions prior to 7.1.2-0 and 6.9.13-26, in ImageMagick's `magick mogrify` command, specifying multiple consecutive `%d` format specifiers in a filename template causes internal pointer arithmetic to generate an address below the beginning of the stack buffer, resulting in a stack overflow through `vsnprintf()`. Versions 7.1.2-0 and 6.9.13-26 fix the issue.",
      "cve": "CVE-2025-53101",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-53101",
          "value": "CVE-2025-53101",
          "url": "https://scout.docker.com/v/CVE-2025-53101?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-53101?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "71878b553be60e8fb0c00c087a4889a0536c1db8064f868d479a676c310ac347",
      "category": "container_scanning",
      "message": "CVE-2025-57807 on ubuntu/imagemagick@8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5",
      "description": "ImageMagick is free and open-source software used for editing and manipulating digital images. ImageMagick versions lower than 14.8.2 include insecure functions: SeekBlob(), which permits advancing the stream offset beyond the current end without increasing capacity, and WriteBlob(), which then expands by quantum + length (amortized) instead of offset + length, and copies to data + offset. When offset  extent, the copy targets memory beyond the allocation, producing a deterministic heap write on 64-bit builds. No 2 arithmetic wrap, external delegates, or policy settings are required. This is fixed in version 14.8.2.",
      "cve": "CVE-2025-57807",
      "severity": "Medium",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/imagemagick@8%3A6.9.11.60%2Bdfsg-1.3ubuntu0.22.04.5?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "8:6.9.11.60+dfsg-1.3ubuntu0.22.04.5"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-57807",
          "value": "CVE-2025-57807",
          "url": "https://scout.docker.com/v/CVE-2025-57807?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-57807?s=ubuntu&n=imagemagick&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "3b849ee6fca9c6917a32be06a2e485439f977c92ec0097230a0ab249af0e3c7b",
      "category": "container_scanning",
      "message": "CVE-2024-35870 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix UAF in smb2_reconnect_server()  The UAF bug is due to smb2_reconnect_server() accessing a session that is already being teared down by another thread that is executing __cifs_put_smb_ses().  This can happen when (a) the client has connection to the server but no session or (b) another thread ends up setting @ses->ses_status again to something different than SES_EXITING.  To fix this, we need to make sure to unconditionally set @ses->ses_status to SES_EXITING and prevent any other threads from setting a new status while we're still tearing it down.  The following can be reproduced by adding some delay to right after the ipc is freed in __cifs_put_smb_ses() - which will give smb2_reconnect_server() worker a chance to run and then accessing @ses->ipc:  kinit ... mount.cifs //srv/share /mnt/1 -o sec=krb5,nohandlecache,echo_interval=10 [disconnect srv] ls /mnt/1 &>/dev/null sleep 30 kdestroy [reconnect srv] sleep 10 umount /mnt/1 ... CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed CIFS: VFS: \\\\srv Send error in SessSetup = -126 CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed CIFS: VFS: \\\\srv Send error in SessSetup = -126 general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI CPU: 3 PID: 50 Comm: kworker/3:1 Not tainted 6.9.0-rc2 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/01/2014 Workqueue: cifsiod smb2_reconnect_server [cifs] RIP: 0010:__list_del_entry_valid_or_report+0x33/0xf0 Code: 4f 08 48 85 d2 74 42 48 85 c9 74 59 48 b8 00 01 00 00 00 00 ad de 48 39 c2 74 61 48 b8 22 01 00 00 00 00 74 69 <48> 8b 01 48 39 f8 75 7b 48 8b 72 08 48 39 c6 0f 85 88 00 00 00 b8 RSP: 0018:ffffc900001bfd70 EFLAGS: 00010a83 RAX: dead000000000122 RBX: ffff88810da53838 RCX: 6b6b6b6b6b6b6b6b RDX: 6b6b6b6b6b6b6b6b RSI: ffffffffc02f6878 RDI: ffff88810da53800 RBP: ffff88810da53800 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000001 R12: ffff88810c064000 R13: 0000000000000001 R14: ffff88810c064000 R15: ffff8881039cc000 FS: 0000000000000000(0000) GS:ffff888157c00000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fe3728b1000 CR3: 000000010caa4000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? die_addr+0x36/0x90 ? exc_general_protection+0x1c1/0x3f0 ? asm_exc_general_protection+0x26/0x30 ? __list_del_entry_valid_or_report+0x33/0xf0 __cifs_put_smb_ses+0x1ae/0x500 [cifs] smb2_reconnect_server+0x4ed/0x710 [cifs] process_one_work+0x205/0x6b0 worker_thread+0x191/0x360 ? __pfx_worker_thread+0x10/0x10 kthread+0xe2/0x110 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",
      "cve": "CVE-2024-35870",
      "severity": "High",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-35870",
          "value": "CVE-2024-35870",
          "url": "https://scout.docker.com/v/CVE-2024-35870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-35870?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "b323cc36e8cb958d4f832a87096adc03e1bfe897d5aa35f12de337b2a5a696e7",
      "category": "container_scanning",
      "message": "CVE-2025-38118 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: MGMT: Fix UAF on mgmt_remove_adv_monitor_complete  This reworks MGMT_OP_REMOVE_ADV_MONITOR to not use mgmt_pending_add to avoid crashes like bellow:  ================================================================== BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406 Read of size 8 at addr ffff88801c53f318 by task kworker/u5:5/5341  CPU: 0 UID: 0 PID: 5341 Comm: kworker/u5:5 Not tainted 6.15.0-syzkaller-10402-g4cb6c8af8591 #0 PREEMPT(full) Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xd2/0x2b0 mm/kasan/report.c:521 kasan_report+0x118/0x150 mm/kasan/report.c:634 mgmt_remove_adv_monitor_complete+0xe5/0x540 net/bluetooth/mgmt.c:5406 hci_cmd_sync_work+0x261/0x3a0 net/bluetooth/hci_sync.c:334 process_one_work kernel/workqueue.c:3238 [inline] process_scheduled_works+0xade/0x17b0 kernel/workqueue.c:3321 worker_thread+0x8a0/0xda0 kernel/workqueue.c:3402 kthread+0x711/0x8a0 kernel/kthread.c:464 ret_from_fork+0x3fc/0x770 arch/x86/kernel/process.c:148 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245 </TASK>  Allocated by task 5987: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4358 kmalloc_noprof include/linux/slab.h:905 [inline] kzalloc_noprof include/linux/slab.h:1039 [inline] mgmt_pending_new+0x65/0x240 net/bluetooth/mgmt_util.c:252 mgmt_pending_add+0x34/0x120 net/bluetooth/mgmt_util.c:279 remove_adv_monitor+0x103/0x1b0 net/bluetooth/mgmt.c:5454 hci_mgmt_cmd+0x9c9/0xef0 net/bluetooth/hci_sock.c:1719 hci_sock_sendmsg+0x6ca/0xef0 net/bluetooth/hci_sock.c:1839 sock_sendmsg_nosec net/socket.c:712 [inline] __sock_sendmsg+0x219/0x270 net/socket.c:727 sock_write_iter+0x258/0x330 net/socket.c:1131 new_sync_write fs/read_write.c:593 [inline] vfs_write+0x548/0xa90 fs/read_write.c:686 ksys_write+0x145/0x250 fs/read_write.c:738 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f  Freed by task 5989: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3e/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x62/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2380 [inline] slab_free mm/slub.c:4642 [inline] kfree+0x18e/0x440 mm/slub.c:4841 mgmt_pending_foreach+0xc9/0x120 net/bluetooth/mgmt_util.c:242 mgmt_index_removed+0x10d/0x2f0 net/bluetooth/mgmt.c:9366 hci_sock_bind+0xbe9/0x1000 net/bluetooth/hci_sock.c:1314 __sys_bind_socket net/socket.c:1810 [inline] __sys_bind+0x2c3/0x3e0 net/socket.c:1841 __do_sys_bind net/socket.c:1846 [inline] __se_sys_bind net/socket.c:1844 [inline] __x64_sys_bind+0x7a/0x90 net/socket.c:1844 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "cve": "CVE-2025-38118",
      "severity": "High",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-38118",
          "value": "CVE-2025-38118",
          "url": "https://scout.docker.com/v/CVE-2025-38118?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-38118?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "dd74e98390e176fc041be3d3848462cf3893bc692b7b5cc9ad8bbc1a62c45bc4",
      "category": "container_scanning",
      "message": "CVE-2022-40898 on wheel@0.37.1",
      "description": "Python Packaging Authority (PyPA) Wheel is a reference implementation of the Python wheel packaging standard. Wheel 0.37.1 and earlier are vulnerable to a Regular Expression denial of service via attacker controlled input to the wheel cli. The vulnerable regex is used to verify the validity of Wheel file names. This has been patched in version 0.38.1.",
      "cve": "CVE-2022-40898",
      "severity": "High",
      "confidence": "Unknown",
      "solution": "Upgrade wheel@0.37.1 to 0.38.1",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/wheel@0.37.1"
          },
          "version": "0.37.1"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-40898",
          "value": "CVE-2022-40898",
          "url": "https://scout.docker.com/v/CVE-2022-40898?s=github&n=wheel&t=pypi&vr=%3C0.38.1"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-40898?s=github&n=wheel&t=pypi&vr=%3C0.38.1"
        }
      ]
    },
    {
      "id": "798a3b9bb4570a9e6383e1766c61192f2fe42e131f0f2aa87d6bb1e40f2be33e",
      "category": "container_scanning",
      "message": "CVE-2024-6345 on setuptools@59.6.0",
      "description": "A vulnerability in the `package_index` module of pypa/setuptools versions up to 69.1.1 allows for remote code execution via its download functions. These functions, which are used to download packages from URLs provided by users or retrieved from package index servers, are susceptible to code injection. If these functions are exposed to user-controlled inputs, such as package URLs, they can execute arbitrary commands on the system. The issue is fixed in version 70.0.",
      "cve": "CVE-2024-6345",
      "severity": "High",
      "confidence": "Unknown",
      "solution": "Upgrade setuptools@59.6.0 to 70.0.0",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/setuptools@59.6.0"
          },
          "version": "59.6.0"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-6345",
          "value": "CVE-2024-6345",
          "url": "https://scout.docker.com/v/CVE-2024-6345?s=github&n=setuptools&t=pypi&vr=%3C70.0.0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-6345?s=github&n=setuptools&t=pypi&vr=%3C70.0.0"
        }
      ]
    },
    {
      "id": "bfd4d7e2aea2540455c4356b6d258556eca5ed11ab67aab97e112c6f6b9aff76",
      "category": "container_scanning",
      "message": "CVE-2025-47273 on setuptools@59.6.0",
      "description": "### Summary \nA path traversal vulnerability in `PackageIndex` was fixed in setuptools version 78.1.1\n\n### Details\n```\n    def _download_url(self, url, tmpdir):\n        # Determine download filename\n        #\n        name, _fragment = egg_info_for_url(url)\n        if name:\n            while '..' in name:\n                name = name.replace('..', '.').replace('\\\\', '_')\n        else:\n            name = \"__downloaded__\"  # default if URL has no path contents\n\n        if name.endswith('.[egg.zip](http://egg.zip/)'):\n            name = name[:-4]  # strip the extra .zip before download\n\n -->       filename = os.path.join(tmpdir, name)\n```\n\nHere: https://github.com/pypa/setuptools/blob/6ead555c5fb29bc57fe6105b1bffc163f56fd558/setuptools/package_index.py#L810C1-L825C88\n\n`os.path.join()` discards the first argument `tmpdir` if the second begins with a slash or drive letter.\n`name` is derived from a URL without sufficient sanitization. While there is some attempt to sanitize by replacing instances of '..' with '.', it is insufficient.\n\n### Risk Assessment\nAs easy_install and package_index are deprecated, the exploitation surface is reduced.\nHowever, it seems this could be exploited in a similar fashion like https://github.com/advisories/GHSA-r9hx-vwmv-q579, and as described by POC 4 in https://github.com/advisories/GHSA-cx63-2mw6-8hw5 report: via malicious URLs present on the pages of a package index.\n\n### Impact\nAn attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to RCE depending on the context.\n\n### References\nhttps://huntr.com/bounties/d6362117-ad57-4e83-951f-b8141c6e7ca5\nhttps://github.com/pypa/setuptools/issues/4946",
      "cve": "CVE-2025-47273",
      "severity": "High",
      "confidence": "Unknown",
      "solution": "Upgrade setuptools@59.6.0 to 78.1.1",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/setuptools@59.6.0"
          },
          "version": "59.6.0"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2025-47273",
          "value": "CVE-2025-47273",
          "url": "https://scout.docker.com/v/CVE-2025-47273?s=github&n=setuptools&t=pypi&vr=%3C78.1.1"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2025-47273?s=github&n=setuptools&t=pypi&vr=%3C78.1.1"
        }
      ]
    },
    {
      "id": "6ff4fd1079fa89d5f139c659294ebb456f087a83c7efefa10b485cb3c3d95b6f",
      "category": "container_scanning",
      "message": "CVE-2022-42919 on ubuntu/python3.11@3.11.0~rc1-1~22.04",
      "description": "Python 3.9.x before 3.9.16 and 3.10.x before 3.10.9 on Linux allows local privilege escalation in a non-default configuration. The Python multiprocessing library, when used with the forkserver start method on Linux, allows pickles to be deserialized from any user in the same machine local network namespace, which in many system configurations means any user on the same machine. Pickles can execute arbitrary code. Thus, this allows for local user privilege escalation to the user that any forkserver process is running as. Setting multiprocessing.util.abstract_sockets_supported to False is a workaround. The forkserver start method for multiprocessing is not the default start method. This issue is Linux specific because only Linux supports abstract namespace sockets. CPython before 3.9 does not make use of Linux abstract namespace sockets by default. Support for users manually specifying an abstract namespace socket was added as a bugfix in 3.7.8 and 3.8.3, but users would need to make specific uncommon API calls in order to do that in CPython before 3.9.",
      "cve": "CVE-2022-42919",
      "severity": "High",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/python3.11@3.11.0~rc1-1~22.04?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "3.11.0~rc1-1~22.04"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-42919",
          "value": "CVE-2022-42919",
          "url": "https://scout.docker.com/v/CVE-2022-42919?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-42919?s=ubuntu&n=python3.11&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "e2c7adc19d9d6c766584897029f5209d3ccd00ba8071aaaa1952fe1ad787ee4b",
      "category": "container_scanning",
      "message": "CVE-2024-53179 on ubuntu/linux@5.15.0-161.171",
      "description": "In the Linux kernel, the following vulnerability has been resolved:  smb: client: fix use-after-free of signing key  Customers have reported use-after-free in @ses->auth_key.response with SMB2.1 + sign mounts which occurs due to following race:  task A                         task B cifs_mount() dfs_mount_share() get_session() cifs_mount_get_session()    cifs_send_recv() cifs_get_smb_ses()          compound_send_recv() cifs_setup_session()        smb2_setup_request() kfree_sensitive()           smb2_calc_signature() crypto_shash_setkey() *UAF*  Fix this by ensuring that we have a valid @ses->auth_key.response by checking whether @ses->ses_status is SES_GOOD or SES_EXITING with @ses->ses_lock held.  After commit 24a9799aa8ef (\"smb: client: fix UAF in smb2_reconnect_server()\"), we made sure to call ->logoff() only when @ses was known to be good (e.g. valid ->auth_key.response), so it's safe to access signing key when @ses->ses_status == SES_EXITING.",
      "cve": "CVE-2024-53179",
      "severity": "High",
      "confidence": "Unknown",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:deb/ubuntu/linux@5.15.0-161.171?os_distro=jammy&os_name=ubuntu&os_version=22.04"
          },
          "version": "5.15.0-161.171"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2024-53179",
          "value": "CVE-2024-53179",
          "url": "https://scout.docker.com/v/CVE-2024-53179?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2024-53179?s=ubuntu&n=linux&ns=ubuntu&t=deb&osn=ubuntu&osv=22.04&vr=%3E%3D0"
        }
      ]
    },
    {
      "id": "711b8e9ad799fc53ab026750c589757f013a9e0db51fc785521ed32041ba5a38",
      "category": "container_scanning",
      "message": "CVE-2022-40897 on setuptools@59.6.0",
      "description": "Python Packaging Authority (PyPA)'s setuptools is a library designed to facilitate packaging Python projects. Setuptools version 65.5.0 and earlier could allow remote attackers to cause a denial of service by fetching malicious HTML from a PyPI package or custom PackageIndex page due to a vulnerable Regular Expression in `package_index`. This has been patched in version 65.5.1.",
      "cve": "CVE-2022-40897",
      "severity": "High",
      "confidence": "Unknown",
      "solution": "Upgrade setuptools@59.6.0 to 65.5.1",
      "scanner": {
        "id": "docker-scout",
        "name": "Docker Scout"
      },
      "location": {
        "dependency": {
          "package": {
            "name": "pkg:pypi/setuptools@59.6.0"
          },
          "version": "59.6.0"
        },
        "operating_system": "ubuntu 22.04",
        "image": "custom_no_tool-webapp:latest"
      },
      "identifiers": [
        {
          "type": "cve",
          "name": "CVE-2022-40897",
          "value": "CVE-2022-40897",
          "url": "https://scout.docker.com/v/CVE-2022-40897?s=github&n=setuptools&t=pypi&vr=%3C65.5.1"
        }
      ],
      "links": [
        {
          "url": "https://scout.docker.com/v/CVE-2022-40897?s=github&n=setuptools&t=pypi&vr=%3C65.5.1"
        }
      ]
    }
  ],
  "remediations": [],
  "scan": {
    "start_time": "2025-10-30T05:36:00",
    "end_time": "2025-10-30T05:36:00",
    "status": "success",
    "type": "container_scanning",
    "scanner": {
      "id": "docker-scout",
      "name": "Docker Scout",
      "version": "1.18.3",
      "vendor": {
        "name": "Docker"
      }
    },
    "analyzer": {
      "id": "docker-scout",
      "name": "Docker Scout",
      "version": "1.18.3",
      "vendor": {
        "name": "Docker"
      }
    }
  }
}
