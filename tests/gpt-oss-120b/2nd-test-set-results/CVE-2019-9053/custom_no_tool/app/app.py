import time
import urllib.request
from flask import Flask, request, jsonify
import docker
import docker.errors

app = Flask(__name__)

# Helper: wait for the Docker daemon inside the DIND container to be ready (optional fallback)
DOCKER_PING_URL = 'http://vulnerable-docker:2375/_ping'

def wait_for_docker(timeout=60):
    start = time.time()
    while time.time() - start < timeout:
        try:
            with urllib.request.urlopen(DOCKER_PING_URL, timeout=5) as resp:
                if resp.read().strip() == b'OK':
                    return True
        except Exception:
            pass
        time.sleep(1)
    return False

# The service now relies on Docker Compose healthcheck; the eager check is retained as a harmless fallback.
if not wait_for_docker():
    print('Warning: Docker daemon not immediately reachable at startup')

@app.route('/')
def index():
    return 'Vulnerable Test App â€“ CVE-2019-9053'

# Endpoint that runs a container on the vulnerable Docker Engine
@app.route('/run', methods=['POST'])
def run_container():
    # Create Docker client lazily with version negotiation and retry logic
    client = None
    for _ in range(10):
        try:
            client = docker.DockerClient(base_url='http://vulnerable-docker:2375', version='auto')
            client.ping()
            break
        except docker.errors.DockerException:
            time.sleep(1)
    if client is None:
        return jsonify({'error': 'Unable to connect to Docker daemon'}), 500

    image = request.json.get('image', 'alpine:3.9')
    cmd = request.json.get('cmd', 'id')
    try:
        cont = client.containers.run(image, cmd, detach=True)
        # Wait for container to finish execution
        cont.wait()
        output = cont.logs().decode('utf-8')
        cont.remove(force=True)
        return jsonify({'status': 'started', 'output': output})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)